[
    {
        "title": "Jump Game II",
        "question_content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n\t0 <= j <= nums[i] and\n\ti + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].",
        "solutions": [
            {
                "id": 18014,
                "title": "concise-o-n-one-loop-java-solution-based-on-greedy",
                "content": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe main idea is based on greedy. Let's say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach.  Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n    public int jump(int[] A) {\\n    \\tint jumps = 0, curEnd = 0, curFarthest = 0;\\n    \\tfor (int i = 0; i < A.length - 1; i++) {\\n    \\t\\tcurFarthest = Math.max(curFarthest, i + A[i]);\\n    \\t\\tif (i == curEnd) {\\n    \\t\\t\\tjumps++;\\n    \\t\\t\\tcurEnd = curFarthest;\\n    \\t\\t}\\n    \\t}\\n    \\treturn jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1192401,
                "title": "easy-solutions-w-explanation-optimizations-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (Greedy BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 10001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 10001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18028,
                "title": "o-n-bfs-solution",
                "content": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "solutionTags": [],
                "code": "I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example.   2 3 1 1 4 , is \\n                   2||\\n               3   1||\\n               1   4  || \\n\\nclearly,  the minimum jump of 4 is 2 since 4 is in level 3.  my ac code.\\n\\n\\n\\n     int jump(int A[], int n) {\\n    \\t if(n<2)return 0;\\n    \\t int level=0,currentMax=0,i=0,nextMax=0;\\n    \\n    \\t while(currentMax-i+1>0){\\t\\t//nodes count of current level>0\\n    \\t\\t level++;\\n    \\t\\t for(;i<=currentMax;i++){\\t//traverse current level , and update the max reach of next level\\n    \\t\\t\\tnextMax=max(nextMax,A[i]+i);\\n    \\t\\t\\tif(nextMax>=n-1)return level;   // if last element is in level+1,  then the min jump=level \\n    \\t\\t }\\n    \\t\\t currentMax=nextMax;\\n    \\t }\\n    \\t return 0;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 170518,
                "title": "8-lines-in-python-easiest-solution",
                "content": "The idea is to maintain two pointers `left` and `right`, where left initialy set to be `0` and `right` set to be `nums[0]`.\\nSo points between `0` and `nums[0]` are the ones you can reach by using just 1 jump.\\nNext, we want to find points I can reach using 2 jumps, so our new  `left` will be set equal to `right`, and our new `right` will be set equal to the farest point we can reach by `two` jumps. which is:\\n`right = max(i + nums[i] for i in range(left, right + 1)`\\n\\nCode:\\n```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "solutionTags": [],
                "code": "```python\\n    def jump(self, nums):\\n        if len(nums) <= 1: return 0\\n        l, r = 0, nums[0]\\n        times = 1\\n        while r < len(nums) - 1:\\n            times += 1\\n            nxt = max(i + nums[i] for i in range(l, r + 1))\\n            l, r = r, nxt\\n        return times\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18019,
                "title": "10-lines-c-16ms-python-bfs-solutions-with-explanations",
                "content": "This problem has a nice BFS structure. Let's illustrate it using the example `nums = [2, 3, 1, 1, 4]` in the problem statement. We are initially at position `0`. Then we can move at most `nums[0]` steps from it. So, after one move, we may reach `nums[1] = 3` or `nums[2] = 1`. So these nodes are reachable in `1` move. From these nodes, we can further move to `nums[3] = 1` and `nums[4] = 4`. Now you can see that the target `nums[4] = 4` is reachable in `2` moves. \\n\\nPutting these into codes, we keep two pointers `start` and `end` that record the current range of the starting nodes. Each time after we make a move, update `start` to be `end  + 1` and `end` to be the farthest index that can be reached in `1` move from the current `[start, end]`. \\n \\nTo get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean `if` statements :-)\\n \\n----------\\n**C++**\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}\\n                start = end + 1;\\n                end = maxend;\\n            }\\n    \\t\\treturn step;\\n        }\\n    };\\n\\n----------\\n**Python** \\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, start, end, step = len(nums), 0, 0, 0\\n            while end < n - 1:\\n                step += 1\\n                maxend = end + 1\\n                for i in range(start, end + 1):\\n                    if i + nums[i] >= n - 1:\\n                        return step\\n                    maxend = max(maxend, i + nums[i])\\n                start, end = end + 1, maxend\\n            return step",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int n = nums.size(), step = 0, start = 0, end = 0;\\n            while (end < n - 1) {\\n                step++; \\n    \\t\\t\\tint maxend = end + 1;\\n    \\t\\t\\tfor (int i = start; i <= end; i++) {\\n                    if (i + nums[i] >= n - 1) return step;\\n    \\t\\t\\t\\tmaxend = max(maxend, i + nums[i]);\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3158218,
                "title": "c-faster-than-75-straight-forward-method-clean-and-concise-code",
                "content": "\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/24f080eb-397a-4a09-a9f5-6a9a315c955f_1675822350.8603303.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int ind = 0;\\n      int ans = 0;\\n\\n      while(ind < nums.size() - 1)\\n      {\\n        ans++;\\n        ind = nums[ind];\\n      }\\n\\n      return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18023,
                "title": "single-loop-simple-java-solution",
                "content": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int jump(int[] A) {\\n        int sc = 0;\\n        int e = 0;\\n        int max = 0;\\n        for(int i=0; i<A.length-1; i++) {\\n            max = Math.max(max, i+A[i]);\\n            if( i == e ) {\\n                sc++;\\n                e = max;\\n            } \\n        }\\n        return sc;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3158169,
                "title": "clean-codes-full-explanation-implicit-bfs-c-java-python3",
                "content": "# Intuition :\\n- We have to find the minimum number of jumps required to reach the end of a given array of non-negative integers i.e the shortest number of jumps needed to reach the end of an array of numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Explanation to Approach :\\n- We are using a search algorithm that works by moving forward in steps and counting each step as a jump. \\n- The algorithm keeps track of the farthest reachable position at each step and updates the number of jumps needed to reach that farthest position. \\n- The algorithm returns the minimum number of jumps needed to reach the end of the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Codes [C++ |Java |Python3] with Comments :\\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/de42de8f-f353-42b7-b09c-6408c3aa214b_1675820540.1398566.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int jump(vector<int>& nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.size() - 1; ++i) {\\n      farthest = max(farthest, i + nums[i]);\\n      if (farthest >= nums.size() - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {    // Visited all the items on the current level\\n        ++ans;           // Increment the level\\n        end = farthest;  // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int jump(int[] nums) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    // Implicit BFS\\n    for (int i = 0; i < nums.length - 1; ++i) {\\n      farthest = Math.max(farthest, i + nums[i]);\\n      if (farthest >= nums.length - 1) {\\n        ++ans;\\n        break;\\n      }\\n      if (i == end) {   // Visited all the items on the current level\\n        ++ans;          // Increment the level\\n        end = farthest; // Make the queue size for the next level\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def jump(self, nums: List[int]) -> int:\\n    ans = 0\\n    end = 0\\n    farthest = 0\\n\\n    # Implicit BFS\\n    for i in range(len(nums) - 1):\\n      farthest = max(farthest, i + nums[i])\\n      if farthest >= len(nums) - 1:\\n        ans += 1\\n        break\\n      if i == end:      # Visited all the items on the current level\\n        ans += 1        # Increment the level\\n        end = farthest  # Make the queue size for the next level\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770191,
                "title": "cpp-recursive-memoization-o-n-three-solution-easy-to-understand",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**Here is step by step three solution recursive , memoization solution and finally O(n) solution**\\n\\n**1. Recursive solution but it will give TLE:**\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\\n**Time Complexity: O(k^n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(1).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements).  \\n\\n\\n**2. Memoization of recursive solution but it may give TLE.**\\n\\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\\n**Time Complexity: O(k * n)**, Where,  **k** is max element of nums and **n** is size of nums.\\n**Space Complexity: O(n).**\\nBecause every time inside the recursive function it is calling itself nums[i] times and this is happening for every element (i.e n elements). But here we have stored previous calculated result, so there will be no repeation.  \\n\\n\\n\\n**3. O(n) Solution (accepted)**\\n\\n**We run loop from 0 to size()-1 because we have to reach at last index, think just previous stage when we take jump and reach to last index (size()-1) the we have counted our jump previously and we reach to last index hence we end our journey.**\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(n)**, Where,  **n** is size of nums.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> nums , int curr, int dest)\\n    {       \\n            if(curr>=dest) return 0; \\n            long long int tmp=INT_MAX;\\n\\t\\t\\t\\n            //Try Every jump 1 to nums[curr] jump\\n            //and find minimum steps need to reach to end\\n\\t\\t\\t\\n            for(int i=1;i<=nums[curr];i++)\\n            {\\n                tmp=min(tmp,1+jump(nums,curr+i,dest));  \\n            } \\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) { \\n         return jump(nums,0,nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n \\n   long long int jump(vector<int> &nums , int curr, int dest,vector<int> &dp)\\n    {       \\n            if(curr==dest) return 0;\\n            if(dp[curr]!=-1) return dp[curr];\\n            //cout<<curr<<\" \";\\n            long long int tmp=INT_MAX;\\n     \\n            for(int i=1;i<=nums[curr];i++)\\n            {   if(i+curr>dest) break;\\n                tmp=min(tmp,1+jump(nums,curr+i,dest,dp));  \\n            }\\n         dp[curr]=tmp;\\n         return tmp;  \\n    }\\n    \\n    int jump(vector<int>& nums) {\\n         vector<int> dp(nums.size(),-1);\\n         return jump(nums,0,nums.size()-1,dp);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump, we can take jump from particular  index\\n\\t\\t//mxjump , we cango up to maximum\\n\\t\\t// jump to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 485780,
                "title": "python-java-js-c-o-n-sol-based-on-greedy-of-coverage-with-explanation",
                "content": "O( n ) sol. based on greedy of coverage.\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\\n\\n---\\n\\n**C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        # destination is last index\\n        destination = size - 1\\n        \\n        # record of current coverage, record of last jump index\\n        cur_coverage, last_jump_index = 0, 0\\n        \\n        # counter for jump\\n        times_of_jump = 0\\n        \\n         # Quick response if start index == destination index == 0\\n        if size == 1:\\n            return 0\\n        \\n        \\n        # Greedy strategy: extend coverage as long as possible with lazy jump\\n        for i in range( 0, size):\\n            \\n            # extend current coverage as further as possible\\n            cur_coverage = max( cur_coverage, i + nums[i] )\\n            \\n\\n            # forced to jump (by lazy jump) to extend coverage  \\n            if i == last_jump_index:\\n            \\n                # update last jump index\\n                last_jump_index = cur_coverage\\n                \\n                # update counter of jump by +1\\n                times_of_jump += 1\\n                \\n                # check if reached destination already\\n                if cur_coverage >= destination:\\n                        return times_of_jump\\n                \\n        return times_of_jump\\n```\n```\\nvar jump = function(nums) {\\n\\n    const size = nums.length;\\n\\n    // destination is last index\\n    let destination = size-1;\\n\\n    let curCoverage = 0, lastJumpIdx = 0;\\n\\n    // counter of jump\\n    let timesOfJump = 0;\\n\\n    // Quick response if start index == destination index == 0\\n    if( size == 1 ){\\n        return 0;\\n    }\\n\\n\\n    // Greedy stragegy: extend coverage as long as possible with lazp jump\\n    for( let i = 0 ; i < size ; i++){\\n\\n        // extend coverage\\n        curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n        // forced to jump (by lazy jump) to extend coverage\\n        if( i == lastJumpIdx ){\\n\\n            lastJumpIdx = curCoverage;\\n\\n            timesOfJump++;\\n\\n            // check if we reached destination already\\n            if( curCoverage >= destination){\\n                return timesOfJump;\\n            }\\n        }\\n    }\\n\\n    return timesOfJump;\\n    \\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        const int size = nums.size();\\n        \\n        // destination is last index\\n        int destination = size-1;\\n        \\n        int curCoverage = 0, lastJumpIdx = 0;\\n        \\n        // counter of jump\\n        int timesOfJump = 0;\\n        \\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n            \\n        \\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n            \\n            // extend coverage\\n            curCoverage = max(curCoverage, i + nums[i] );\\n            \\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n                \\n                lastJumpIdx = curCoverage;\\n                \\n                timesOfJump++;\\n                \\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n        \\n        return timesOfJump;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        final int size = nums.length;\\n\\n        // destination is last index\\n        int destination = size-1;\\n\\n        int curCoverage = 0, lastJumpIdx = 0;\\n\\n        // counter of jump\\n        int timesOfJump = 0;\\n\\n        // Quick response if start index == destination index == 0\\n        if( size == 1 ){\\n            return 0;\\n        }\\n\\n\\n        // Greedy stragegy: extend coverage as long as possible with lazp jump\\n        for( int i = 0 ; i < size ; i++){\\n\\n            // extend coverage\\n            curCoverage = Math.max(curCoverage, i + nums[i] );\\n\\n            // forced to jump (by lazy jump) to extend coverage\\n            if( i == lastJumpIdx ){\\n\\n                lastJumpIdx = curCoverage;\\n\\n                timesOfJump++;\\n\\n                // check if we reached destination already\\n                if( curCoverage >= destination){\\n                    return timesOfJump;\\n                }\\n            }\\n        }\\n\\n        return timesOfJump;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192396,
                "title": "js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18089,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "If we cannot come up with the optimal solution at first thought, we may think about the brute force method and improve it.\\n1. Brute force O(2^n), this is the most straight forward solution, just try all the moves.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\\n2. Memoization O(n^2)\\n* java\\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\\n3. dp O(n^2)\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\\n4. Greedy O(n). There are redundancy in the above approaches. From a position, the number of steps to jump is the one that can go furthest after the jump. Because it covers all the options of the other choices.\\n* java\\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\\n* c++\\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\\n5. BFS O(n) Time, O(1) Space. The problem asks for shortest path and it is natrual to think of BFS. Nodes are array elements. For an element, neighbors are the elements that are within its max jump length. Given nodes in current level, we generate all nodes in the next level. Nodes are traversed level by level.\\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0; //end is reached\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1; //end can be reached by 1 jump from p\\n        int ret = n, mj; // n is larger than max jumps (n-1)\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums)) == 1) return 2; //end can be reached by 2 jumps from p\\n            ret = min(ret,mj);\\n        }\\n        return ret+1;\\n    }\\n```\n```\\n\\tInteger[] mem;\\n    public int jump(int[] nums) {\\n        mem=new Integer[nums.length];\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(mem[p]!=null)\\n            return mem[p];\\n        int minSteps = n;\\n        for(int i=1;i<=nums[p];i++) \\n            minSteps = Math.min(minSteps, 1+jump(p+i, nums));\\n        return mem[p]=minSteps;\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        vector<int> mem(nums.size(),-1);\\n        return jump(0,nums,mem);    \\n    }\\n    int jump(int p, vector<int>& nums, vector<int>& mem) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        if(mem[p]>=0) return mem[p];\\n        int ret = n, mj;\\n        for(int i=range;i>p;i--) {\\n            if ((mj = jump(i,nums,mem)) == 1) return mem[p]=2;\\n            ret = min(ret,mj);\\n        }\\n        return mem[p] = ret+1;\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp=new int[n];\\n        for(int i=n-2;i>=0;i--) {\\n            dp[i]=n;\\n            for(int j=1;j<=nums[i]&&i+j<n;j++) \\n                dp[i]=Math.min(dp[i],1+dp[i+j]);\\n        }\\n        return dp[0];        \\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,n);\\n        dp[n-1]=0;\\n        for(int i=n-2;i>=0;i--) {\\n            int range = i+nums[i];\\n            if (range >= n-1) { \\n                dp[i]=1;\\n                continue;\\n            }\\n            for(int j = range; j > i; j--) {\\n                if(dp[j]==1) {\\n                    dp[i]=2;\\n                    break;\\n                }\\n                dp[i] = min(dp[i],dp[j]+1);\\n            }\\n        }\\n        return dp[0];    \\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        return jump(0,nums);        \\n    }\\n    private int jump(int p, int[] nums) {\\n        int n = nums.length;\\n        if(p>=n-1)\\n            return 0;\\n        if(p+nums[p]>=n-1)\\n            return 1;\\n        int max=0, steps=0;\\n        for(int i=1;i<=nums[p];i++) {\\n            int jump2 = i+nums[p+i];\\n            if(jump2>max) {\\n                max = jump2;\\n                steps = i;\\n            }   \\n        }\\n        return 1+jump(p+steps, nums);\\n    }\\n```\n```\\n    int jump(vector<int>& nums) {\\n        return jump(0,nums);    \\n    }\\n    int jump(int p, vector<int>& nums) {\\n        int n = nums.size();\\n        if(p == n-1) return 0;\\n        int range = p+nums[p];\\n        if(range >= n-1) return 1;\\n        int nxt, max_reach = -1, reach;\\n        for(int i=range; i>p;i--) {\\n            if((reach=i+nums[i]) >= n-1) return 2;\\n            if(reach > max_reach) {\\n                max_reach = reach;\\n                nxt = i;\\n            }\\n        }\\n        return 1+jump(nxt,nums);\\n    }\\n```\n```\\n\\tpublic int jump(int[] nums) {\\n        int steps = 0, curLevelEnd = 0, nxtLevelEnd = 0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(i>curLevelEnd) {\\n                steps++;\\n                curLevelEnd = nxtLevelEnd;\\n            }    \\n            nxtLevelEnd = Math.max(nxtLevelEnd, i+nums[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192457,
                "title": "java-python-dp-greedy-solutions-time-o-n-space-o-1",
                "content": "**\\u2714\\uFE0F Solution 1: Top-Down DP (Some time TLE)**\\n- Let `dp(i)` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp(0)` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top-Down DP**\\n- Let `dp[i]` denote the minimum number of steps to reach the `i`th index, starting from index `0`.\\n- Then `dp[0]` is our result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Greedy**\\n- The main idea is based on greedy. \\n- Step 1: Let\\'s say the range of the current jump is `[left, right]`, `farthest` is the farthest position that all positions in `[left, right]` can reach.\\n- Step 2: Once we reach to `right`, we trigger another jump with `left = right + 1`, `right = farthest`, then repeat step 1 util we reach at the end.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^4` is the length of array `nums`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == n - 1: return 0  # Reached to last index\\n            ans = math.inf\\n            maxJump = min(n - 1, i + nums[i])\\n            for j in range(i + 1, maxJump + 1):\\n                ans = min(ans, dp(j) + 1)\\n            return ans\\n\\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [math.inf] * n\\n        dp[n-1] = 0\\n        \\n        for i in range(n-2, -1, -1):\\n            maxJump = min(i+nums[i], n-1)\\n            for j in range(i+1, maxJump+1):\\n                dp[i] = min(dp[i], dp[j] + 1)\\n                \\n        return dp[0]\\n```\n```python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps = 0\\n        farthest = 0\\n        left = right = 0\\n        while right < len(nums) - 1:\\n            for i in range(left, right + 1):\\n                farthest = max(farthest, i + nums[i])\\n            left = right + 1\\n            right = farthest\\n            jumps += 1\\n            \\n        return jumps\\n```\n```java\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int jumps = 0, farthest = 0;\\n        int left = 0, right = 0;\\n        while (right < nums.length - 1) {\\n            for (int i = left; i <= right; ++i)\\n                farthest = Math.max(farthest, i + nums[i]);\\n            left = right + 1;\\n            right = farthest;\\n            ++jumps;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197063,
                "title": "intuitive-explanation-w-solution-analysis-java-beginner-dp",
                "content": "This problem is one of the simplest and best problems for beginners to understand one of the most difficult yet rewarding algorithm - **Dynamic Programming**. The aim of the post is not to just throw away with a working solution, rather provide a new perspective for beginners and potential learners on how to deconstruct a problem statement to understand the crux of it and reconstruct back into a working algorithm. Let\\'s quickly get into the process of understanding the problem and coming up with some intuitions and solutions.\\n\\n**INTUITION**\\n1. **It is mentioned in the problem that we start from the initial position and we can always reach the end position. We need to reach them with minimum possible steps.**\\nThis means that from the start position, there can be one or many possible ways of jumps (traversing through multiple sets of indices) to reach the end point. Hence it will be initially necessary to have a data structure that stores the optimum number of jumps to reach any particular index. Since the constraints states that the input array length will be less than 1000 *(1 <= nums.length <= 1000)*, we create an output array of length 1000 *(ideally length of input array)* and maintain the minimum jumps required to reach each position.\\n\\n2. **All indices are unreachable initially.**\\nSince we start from the first position, it is impossible to reach all the other indices without making the first move. So all of them can be initialized with some maximum value *(1e9 or Integer.MAX_VALUE)*. However, since we are standing in the first position, it is reachable by default without making any move. Hence we initialize the value of the first index in the output array as 0.\\n\\n**CODE & EXPLANTION**\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```\\n\\nLet\\'s try to understand the loop where the main condition check happens. Each value in the nums array specifies the jump that is possible to take from the current position. So if the value in the ith index is nums[i], then it is understandable that from **(ith) position to (i+nums[i])th position** *(i, i+1, i+2, ...., i+nums[i])*, it can be reached in a single jump. However as already mentioned, since a particular position can be reached from various other position, we need to store the minimum possible jump value to reach the position.\\n*pre[j] = Math.min(pre[j], pre[i]+1)*.\\n\\nBy filling it this way, we can naturally fill the way the last element is reached also and return the pre[n-1] value directly.\\n\\nThere goes around a popular saying that *\\'When one learns things right, he learns them only once\\'*. There could be many people (including me :P) who would have done hundreds of problems and still finds it difficult to crack the next one because of a gap in the understanding and ability to convert that into code. Lets make use of this post to address some basic intuitions and approaches along with constructing a solution for this problem.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int i,n,j;\\n        n=nums.length;\\n        int [] pre = new int[n];\\n        for(i=0;i<n;i++)\\n        {\\n            // Initialize all the index position with some max value to denote it is unreachable\\n            pre[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        // Make the first position value as 0 as it is the default place where we start\\n        pre[0] = 0;\\n\\t\\t// Main condition check goes here.\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=i;j<=i+nums[i] && j<n;j++)\\n            {\\n                pre[j] = Math.min(pre[j], pre[i]+1);\\n            }\\n        }\\n        return pre[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18207,
                "title": "sharing-my-straightforward-c-solution",
                "content": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "    int jump(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int maxReachPos = A[0];\\n        int curMaxReachPos = A[0];\\n        int curStep = 1;\\n        for(int i = 1; i <= min(n, maxReachPos); i++){\\n            curMaxReachPos = max(curMaxReachPos, i + A[i]);\\n            if(i == n - 1){\\n                return curStep;\\n            }\\n            if(i == maxReachPos){\\n                maxReachPos = curMaxReachPos;\\n                curStep++;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nThe variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position.\\n\\nAt the very beginning, both maxReachPos and curMaxReachPos are equal to A[0].\\n\\nIn the For loop, we keep updating curMaxReachPos while i <= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. \\n\\nFinally, if we can't reach the end point, just return 0.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158205,
                "title": "super-easy-solution-fully-explained-c-python-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Intuition\\nIn this question we have to find the minimum number of jumps to reach the last index.\\nSo, we calculate the maximum index we can reach from the current index.\\nIf our pointer `i` reaches the last index that can be reached with current number of jumps then we have to make a jumps.\\nSo, we increase the `count`. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Greedy Approach\\n    Example\\n    nums = [2,3,1,1,4]\\n    Here at index `0` reach become 2 and `i` == `last`. \\n    So increase the `count`(1)\\n    At index `1` `reach` becomes `4`.\\n    So, when `i` becomes `2` it becomes equal to last.\\n    We update last with current maximum jump(`reach`) last = 4.\\n    And increase `count`.\\n    So, answer  = 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\\n\\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int reach=0, count=0, last=0;  // reach: maximum reachable index from current position\\n    // count: number of jumps made so far\\n    // last: rightmost index that has been reached so far\\n        for(int i=0;i<nums.size()-1;i++){  // loop through the array excluding the last element\\n            reach = max(reach, i+nums[i]);  // update reach to the maximum between reach and i+nums[i]\\n            if(i==last){  // if i has reached the last index that can be reached with the current number of jumps\\n                last = reach;  // update last to the new maximum reachable index\\n                count++;  // increment the number of jumps made so far\\n            }\\n        }\\n        return count;  // return the minimum number of jumps required\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def jump(self, nums):\\n        # Initialize reach (maximum reachable index), count (number of jumps), and last (rightmost index reached)\\n        reach, count, last = 0, 0, 0\\n        \\n        # Loop through the array excluding the last element\\n        for i in range(len(nums)-1):    \\n            # Update reach to the maximum between reach and i + nums[i]\\n            reach = max(reach, i + nums[i])\\n        \\n            # If i has reached the last index that can be reached with the current number of jumps\\n            if i == last:\\n                # Update last to the new maximum reachable index\\n                last = reach\\n                # Increment the number of jumps made so far\\n                count += 1\\n        \\n        # Return the minimum number of jumps required\\n        return count\\n\\n```\n```\\n              Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18152,
                "title": "java-solution-with-explanation",
                "content": "    public class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }\\n\\n        // First set up current region, which is\\n        // from 0 to nums[0].\\n        int l = 0;\\n        int r = nums[0];\\n        // Since the length of nums is greater than\\n        // 1, we need at least 1 step.\\n        int step = 1;\\n\\n        // We go through all elements in the region.\\n        while (l <= r) {\\n\\n            // If the right of current region is greater\\n            // than nums.length - 1, that means we are done.\\n            if (r >= nums.length - 1) {\\n                return step;\\n            }\\n\\n            // We should know how far can we reach in current\\n            // region.\\n            int max = Integer.MIN_VALUE;\\n            for (; l <= r; l++) {\\n                max = Math.max(max, l + nums[l]);\\n            }\\n\\n            // If we can reach far more in this round, we update\\n            // the boundary of current region, and also add a step.\\n            if (max > r) {\\n                l = r;\\n                r = max;\\n                step++;\\n            }\\n        }\\n\\n        // We can not finish the job.\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        // If nums.length < 2, means that we do not\\n        // need to move at all.\\n        if (nums == null || nums.length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1192398,
                "title": "jump-game-ii-js-python-java-c-simple-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince each element of our input array (**N**) represents the maximum jump length and not the definite jump length, that means we can visit any index between the current index (**i**) and **i + N[i]**. Stretching that to its logical conclusion, we can safely iterate through **N** while keeping track of the furthest index reachable (**next**) at any given moment (**next = max(next, i + N[i])**). We\\'ll know we\\'ve found our solution once **next** reaches or passes the last index (**next >= N.length - 1**).\\n\\nThe difficulty then lies in keeping track of how many jumps it takes to reach that point. We can\\'t simply count the number of times we update **next**, as we may see that happen more than once while still in the current jump\\'s range. In fact, we can\\'t be sure of the best next jump until we reach the end of the current jump\\'s range.\\n\\nSo in addition to **next**, we\\'ll also need to keep track of the current jump\\'s endpoint (**curr**) as well as the number of jumps taken so far (**ans**).\\n\\nSince we\\'ll want to **return ans** at the earliest possibility, we should base it on **next**, as noted earlier. With careful initial definitions for **curr** and **next**, we can start our iteration at **i = 0** and **ans = 0** without the need for edge case return expressions.\\n\\n - _**Time Complexity: O(N)** where N is the length of N_\\n - _**Space Cmplexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 37.7MB** (beats 95% / 100%).\\n```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.0MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.1MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar jump = function(N) {\\n    let len = N.length - 1, curr = -1, next = 0, ans = 0\\n    for (let i = 0; next < len; i++) {\\n        if (i > curr) ans++, curr = next\\n        next = Math.max(next, N[i] + i)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def jump(self, N: List[int]) -> int:\\n        Nlen, curr, nxt, ans, i = len(N) - 1, -1, 0, 0, 0\\n        while nxt < Nlen:\\n            if i > curr:\\n                ans += 1\\n                curr = nxt\\n            nxt = max(nxt, N[i] + i)\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& N) {\\n        int len = N.size() - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) ans++, curr = next;\\n            next = max(next, N[i] + i);\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098179,
                "title": "fully-commented-and-explained-greedy-approach-in-6-liner-code",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int numOfJumps = 0, currentIntervalEnd = 0, farthestReachFoundSoFar = 0;\\n        \\n        for(int i = 0 ; i < nums.size() - 1 ; i++) {     // Because you can stop the work once youve\\n                                                                            // reached the last index\\n            farthestReachFoundSoFar = max(farthestReachFoundSoFar, i + nums[i]);    // maximize our                                                                                                    \\n                                                                                    // reach\\n            if(i == currentIntervalEnd) {                // When we reach the end of current intervals\\n                                                         // end, we need to make our next jump and\\n                numOfJumps++;                            // and update our current interval end with       \\n                currentIntervalEnd = farthestReachFoundSoFar;   // the farthest reach found so far\\n                                                         // We made sure this was the best possible jump\\n            }                                            // because we traversed th whole interval and \\n        }                                                // maximized our reach and now we are sure\\n        return numOfJumps;                               // where our next jump will be. Greedy!\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18093,
                "title": "sharing-my-ac-java-solution",
                "content": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "solutionTags": [],
                "code": "Hi All, below is my AC solution:\\n \\n>     public int jump(int[] A) {\\n>         int maxReach = A[0];\\n>         int edge = 0;\\n>         int minstep = 0;\\n>         \\n>         for(int i = 1; i < A.length; i++) {\\n>             if (i > edge) {\\n>                 minstep += 1;\\n>                 edge = maxReach;\\n>                 if(edge > A.length - 1)\\n>                     return minstep;\\n>             }\\n>             maxReach = Math.max(maxReach, A[i] + i);\\n>             if (maxReach == i):\\n>                 return -1;\\n>         }\\n>         \\n>         return minstep;\\n>     } \\n\\nWhen iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep.\\n\\n[2, 3, 1, 1, 4]\\n\\nFirst, the edge is 0;\\nSecond, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2;\\nThird, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4.\\nFinally, end of the array is inside the edge, output the minstep.",
                "codeTag": "Unknown"
            },
            {
                "id": 2591598,
                "title": "recursion-memoization-tabulation-o-n-with-constant-space",
                "content": "# Recursion\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return f(0, n, nums);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums) {\\n        if(ind == n-1) return 0;\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums);\\n            mini = min(mini, val);\\n        }\\n        return mini;\\n    }\\n\\t\\n# \\tMemoization\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, -1);\\n        return f(0, n, nums, dp);\\n    }\\n\\t\\n\\tint f(int ind, int n, vector<int>& nums, vector<int>& dp) {\\n        if(ind == n-1) return 0;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        int jump = nums[ind], mini = 1e9;\\n        for(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n            int val = 1 + f(i, n, nums, dp);\\n            mini = min(mini, val);\\n        }\\n        return dp[ind] = mini;\\n    }\\n\\t\\n# \\tTabulation\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\\n\\n# Optimal\\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 0);\\n\\n\\tfor(int ind = n-2; ind >= 0; ind--) {\\n\\t\\tint jump = nums[ind], mini = 1e9;\\n\\t\\tfor(int i = ind + 1; i <= min(ind+jump, n-1); i++) {\\n\\t\\t\\tint val = 1 + dp[i];\\n\\t\\t\\tmini = min(mini, val);\\n\\t\\t}\\n\\t\\tdp[ind] = mini;\\n\\t}\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint jump_cnt = 0, curLimit = 0, limit = 0;\\n\\tfor(int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tlimit = max(limit, i + nums[i]);\\n\\t\\tif(i == curLimit){\\n\\t\\t\\tjump_cnt++;\\n\\t\\t\\tcurLimit = limit;\\n\\t\\t}\\n\\t}\\n\\treturn jump_cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18035,
                "title": "easy-python-greedy-solution-with-explanation",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def jump(self, A):\\n        last_max_reach, current_max_reach = 0 , 0\\n        njump , i = 0 , 0\\n        while current_max_reach < len(A)-1:\\n            while i <= last_max_reach:\\n                current_max_reach = max(i+A[i],current_max_reach)\\n                i+=1\\n            if last_max_reach == current_max_reach:\\n                return -1\\n            last_max_reach = current_max_reach\\n            njump+=1\\n        return njump\\n\\n\\nThe basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.\\nIn Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump.  So you iterate all positions could be reached from last jump till i th position to find it out.",
                "codeTag": "Java"
            },
            {
                "id": 1355952,
                "title": "swift-jump-game-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\\n        var step = 0, end = 0, maxPos = 0\\n        for i in 0..<nums.count - 1 {\\n            maxPos = max(maxPos, i + nums[i])\\n            if i == end { end = maxPos; step += 1 }\\n        }\\n        return step\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.jump([2,3,1,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.jump([2,3,0,1,4])\\n        XCTAssertEqual(res, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383112,
                "title": "to-all-my-struggling-friends-don-t-worry-its-fine",
                "content": "If you are not able to do it, its completely fine. I have also went over 10+ solutions and finally compiled below solution. \\nPut this code in the IDE and debug step by step. I bet you will understand it. \\n# ***Explanation:*** \\nSince we are already at nums[0]. The no of steps to reach on nums[0] is 0.\\nFrom n = 1 to nums.length-1, do this: \\nAt each step, calculate min steps to reach that step i.e. if you are at step 1, loop from begining and get the min jumps to reach step1. Similarly if you are at step 2, calculate min steps needed to reach step 2 by looping from begining and get min steps. \\n\\n```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int jump(int[] nums) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE); //Initially we do not know, what is min steps, hence initialize all with Integer.MAX_Value.\\n        dp[0] = 0;\\n        for (int i = 1; i < n; i++) { //Start from 1 to n\\n            for (int j = 0; j < i; j++) { //At each index, get min steps to reach dp[i] by looping from begining (i.e. start from 0 till i)\\n                if (j + nums[j] >= i) { //if j+nums[j] >=i, then from \\'j\\' index we can have j+nums[j] jump, which can reach (or go over) nums[i]. This means we can jump from index \\'j\\'.\\n                    dp[i] = Math.min(dp[i], dp[j] + 1); //Check if the this is min.\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774616,
                "title": "easy-linear-time-o-n-and-space-o-1-explanation",
                "content": "1. We start travering the array from start\\n2. While traversing, we keep a track on maximum reachable index and update it accordingly.\\n3. If we reach the previous reachable index, this implies we have reached this index with current jumps and now we can reach the next maximum possible index by  **current jumps+1** jumps and update the previous reachable index to maximum reachable index. Now, if updated previous reachable index is greater than equal to last index, just return the jump count.  \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums)==1: return 0\\n        \\n        reachableIndex = 0\\n        previousReachableIndex = 0\\n        jump = 0\\n\\n        for curr in range(len(nums)):\\n            if curr + nums[curr] >= reachableIndex:\\n                reachableIndex = curr + nums[curr]\\n\\n            if curr == previousReachableIndex:\\n                jump += 1\\n                previousReachableIndex = reachableIndex\\n                if previousReachableIndex >= len(nums) - 1:\\n                    return jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659010,
                "title": "easiest-step-by-step-bfs-solution-o-n",
                "content": "This problem can be changed to a tree problem, with the search tree looks like below:\\n![image](https://assets.leetcode.com/users/leih/image_1590776042.png)\\nOur goal is to find the shortest path from root to a target node, sounds like a traditional BFS question? This leads to our first solution:\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\\nThis solution gets TLE with time complexity `O(n^2)`. Where is the bottleneck? We know the time complexity of the best solution could NOT be less than `O(n)` since we need to jump step by step in the case of [1, 1, 1, 1, ....., 1, 1]. For each position, do we really need to check its every possible next postion with 1 jump?  The answer is NO, because some of such positions have been visited.\\n\\nIn solution 1, we used a `visited` array to record these positions, but we actually can just ignore these positions and only consider the positions that have not been visited. Note that the visited positions are consecutive, which means if position `j + 1` has been visited, position `j` also has been visited. We can use a variable `maxVisitedPos` to keep tracking the largest position that has been visited. For the jump at a position, we just check the positions that are further than `maxVisitedPos`. As such, each position will be operated at most twice (append and popleft), which gives us `O(n)` complexity and we know there cannot be a better solution.\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n = len(nums)\\n        visited, queue = [False for i in range(n)], deque()\\n        queue.append((0, 0))\\n        visited[0] = True\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(1, min(nums[pos] + 1, n - pos)):\\n                if not visited[pos + jump]:\\n                    queue.append((pos + jump, step + 1))\\n                    visited[pos + jump] = True\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def jump(self, nums):\\n        n, queue = len(nums), deque()\\n        queue.append((0, 0))\\n        maxVisitedPos = 0\\n        while queue:\\n            pos, step = queue.popleft()\\n            if pos == n - 1:\\n                return step\\n            for jump in range(maxVisitedPos - pos + 1, min(nums[pos] + 1, n - pos)):\\n                queue.append((pos + jump, step + 1))\\n                maxVisitedPos = pos + jump\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158986,
                "title": "java-solution-fast-1ms-runtime",
                "content": "# JAVA Code\\n\\n99% faster code [1ms runtime]\\n\\n``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/94908bb9-b442-4096-9b26-4debb918ed16_1675838156.0297992.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int jump(int[] N) {\\n        int len = N.length - 1, curr = -1, next = 0, ans = 0;\\n        for (int i = 0; next < len; i++) {\\n            if (i > curr) {\\n                ans++;\\n                curr = next;\\n            };\\n            next = Math.max(next, N[i] + i);\\n        };\\n        return ans;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18177,
                "title": "concise-o-n-java-solution-with-explanation",
                "content": "For each step of jump, there is a range you can reach. \\nThen try jumping from each position in current range, you will get a new range where the next step can reach.\\nRepeat this process util the range covers the last index.\\n\\n    public class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }\\n            return step;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int jump(int[] nums){\\n            int step = 0;\\n            for(int l = 0, r = 0; r < nums.length - 1; step++){\\n            \\tint rNew = 0;\\n            \\tfor(int i = l; i <= r; i++) rNew = Math.max(rNew, i + nums[i]);\\n            \\tl = r + 1;\\n            \\tr = rNew;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3758457,
                "title": "java-0ms-100-easy-solution",
                "content": "The main idea is based on greedy. Let\\'s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following:\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n      int jumps = 0, currEnd = 0, currFarthest = 0;\\n      for(int i = 0; i < nums.length - 1; i ++) {\\n          currFarthest = Math.max(currFarthest, i + nums[i]);\\n          if(i == currEnd) {\\n              currEnd = currFarthest;\\n              jumps ++;\\n          }\\n      }  \\n      return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204682,
                "title": "easy-c-greedy-faster-than-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int jumps = 0;\\n        int maxReach = 0;\\n        int currReach = 0;\\n        \\n        for(int i=0; i<n-1; i++)\\n        {\\n            maxReach = max(maxReach, i+nums[i]);\\n            \\n            if(i==currReach)\\n            {\\n                jumps++;\\n                currReach = maxReach;\\n            }\\n            \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192404,
                "title": "jump-game-ii-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-greedy-bfs",
                "content": "\\u274C ***Solution - I (Brute Force) [Rejected]***\\n\\nWe start at index 0 and are required to reach index `n - 1` (where `n = nums.size()`). We can\\'t always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\\n\\nSo, at each position, we can use a jump size of anywhere in the range *`[1, nums[pos]]`*. The final answer will be the minimum jumps required. We can recursively solve this problem as -\\n\\n* If we reach index *`n-1`* return 0, signifying that we need 0 more jumps.\\n* Else recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\\n\\n\\n```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**. At each index `i` we have `N-i` choices and we recursively explore each of them till end. So we require `O(N*(N-1)*(N-2)...1) = O(N!)`. \\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]***\\n\\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in *`dp`* array to avoid re-calculations.\\n\\nThe solution is similar as the brute force with just the change that we are storing the solutions for each *`pos`* and returning it if it is already calculated.\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]***\\n\\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from `nums[n-1]` to reach the end. We store this as *`dp[n - 1] = 0`* and then iteratively solve this for each previous index till the 0th index. Here *`dp[i]`* denotes minimum jumps required from current index to reach till the end.\\n\\n1. For each index, we explore all the possible jump sizes available with us. \\n2. The minimum jumps required to reach the end from the current index would be - **`min(dp[jumpLen])`**, where *`1 <= jumpLen <= nums[currentPostion]`*\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution IV (BFS)***\\n\\nWe can iterate over all indices maintaining the furthest reachable position from current index - *`maxReachable`* and currently furthest reached position - *`lastJumpedPos`*. Everytime we will try to update *`lastJumpedPos`* to furthest possible reachable index - `maxReachable`.\\n\\nUpdating the `lastJumpedPos` separately from *`maxReachable`* allows us to maintain track of minimum *`jumps`* required. Each time `lastJumpedPos` is updated, ***`jumps`*** will also be updated and store the minimum jumps required to reach `lastJumpedPos` (On the contrary, updating `jumps` with `maxReachable` won\\'t give the optimal (minimum possible) value of jumps required). \\n\\nWe will just return it as soon as *`lastJumpedPos`* reaches(or exceeds) last index.\\n\\nWe can try to understand the steps in code below as analogous to those in BFS as -\\n\\n1. **`maxReachable = max(maxReachable, i + nums[i])`** : Updating the range of next level. Similar to  *`queue.push(node)`* step of BFS but here we are only greedily storing the max reachable index on next level.\\n\\n\\n2. **`i == lastJumpedPos`** :  When it becomes true, current level iteration has been completed.\\n3. **`lastJumpedPos = maxReachable`** : Set range till which we need to iterate the next level\\n4. **`jumps++`** : Move on to the next level.\\n\\n5. **`return jumps`** : The final answer will be number of levels in BFS traversal.\\n\\nFor eg. Take the example : `nums = [2,3,1,4,1,1,1,2]`. This approach proceeds as illustrated in image below -\\n\\n<p align=center>\\n<img src=https://assets.leetcode.com/users/images/4e5cbbb4-a6d0-4523-a945-261ee4b53f72_1620216977.5849538.png /></p>\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums, int pos = 0) {\\n\\tif(pos >= size(nums) - 1) return 0;        \\n\\tint minJumps = 1001;  // initialising to max possible jumps + 1\\n\\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\\n\\t\\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \\n\\treturn minJumps;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tvector<int> dp(size(nums), 1001); // initialise all to max possible jumps + 1 denoting dp[i] hasn\\'t been computed yet\\n\\treturn solve(nums, dp, 0);\\n}\\n// recursive solver to find min jumps to reach end\\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\\n\\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\\n\\tif(dp[pos] != 1001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\\n\\t// explore all possible jump sizes from current position. Store & return min jumps required\\n\\tfor(int j = 1; j <= nums[pos]; j++)\\n\\t\\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \\n\\treturn dp[pos];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums);\\n\\tvector<int> dp(n, 1001);\\n\\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\\n\\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\\n\\tfor(int i = n - 2; i >= 0; i--) \\n\\t\\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \\n\\t\\t\\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\\n\\treturn dp[0];\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n\\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\\n\\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn\\'t taken us till the end\\n\\t\\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\\n\\t\\tif(i == lastJumpedPos) {\\t\\t\\t  // current level has been iterated & maxReachable position on next level has been finalised\\n\\t\\t\\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\\n\\t\\t\\tjumps++;                          // and increment the level\\n\\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\\n\\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\\n\\t\\t}            \\n\\t\\ti++;\\n\\t}\\n\\treturn jumps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192521,
                "title": "python-greedy-o-n-solution-epxlained",
                "content": "There are two algorithms: one is dp with complexity `O(n^2)`, where `dp(i)` is the minimum number of steps to reach position `i` and on each step we need to check potentially `O(n)` jumps. \\n\\nHowever there is a solution with better complexity, using `greedy` idea: we need to look at `i + nums[i]` values and look at running maximum of these values. Then all we need to do is to start from the zero index and do `ind = t[ind]` until we reach the ending point or bigger. \\n\\nWe can look at our process like this: what is the biggest index we can reach after say `i` jumps. Then if we have new index to traverse we update our range. For example for `nums = [2, 3, 0, 1, 4]` we have `t = [2, 4, 4, 4, 8]` and after `1` jump we can reach index `2` and after each new index processed we expand our window if we have bigger value than the end of window and increase total number of steps or we do not do anything.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well, it can be made `O(1)`, if we calculate cumulative maximum on the fly.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def jump(self, nums):\\n        t = list(accumulate([i + num for i, num in enumerate(nums)], max))\\n        ind, q = 0, 0\\n        while ind < len(nums) - 1:\\n            ind = t[ind]\\n            q += 1\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443098,
                "title": "javascript-solution-w-explanation",
                "content": "### The idea\\n1. We know that every point is reachable, so we are only looking for the relationship between the maximum reach of each index and the number of jumps\\n2. `oldMax` is the previous jump\\'s maximum reach, if we are at the old max, that means no matter how we move, the next move will cost an extra jump, thus we increment  jump, at the same time, we update the `oldMax` to the current global max. This max, indicates the maximum reach we will have by having an extra jump.\\n``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar jump = function(nums) {\\n    let newMax = 0;\\n    let jump = 0;\\n    let oldMax = 0;\\n    for (let i=0;i<nums.length-1;i++) {\\n        newMax = Math.max(newMax, i+nums[i]);\\n        if (i == oldMax) {\\n            jump++;\\n            oldMax = newMax;\\n        }\\n    }\\n    return jump;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18144,
                "title": "demonstrate-the-detailed-flow-process-of-my-thinking",
                "content": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "solutionTags": [],
                "code": "    one example:\\n    index      0  1  2  3  4  5  6  7  8  9  10  11\\n    value      5  9  3  2  1  0  2  3  3  1  0   0\\n    farthest   5  10 10 10 10 10 10 10 11 11 11  11\\n        \\n        my thought -- scan from right to left.\\n        \\n            -- to reach index 11, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, no\\n                -- index 2, 2+3=5, no\\n                -- index 3, 3+2=5, no\\n                -- index 4, 4+1=5, no\\n                -- index 5, 5+0=5, no\\n                -- index 6, 6+2=8, no\\n                -- index 7, 7+3=10, no\\n                -- index 8, 8+3=11, yes!\\n                thus we have to first reach index 8.\\n            -- to reach index 8, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, no\\n                -- index 1, 1+9=10, yes\\n                thus we have to first reach index 1.\\n            -- to reach index 1, we have to first reach (try best to jump forward)\\n                -- index 0, 0+5=5, yes\\n                thus we have to first reach index 0.\\n            \\n            therefore, 3 steps in total.\\n            \\n        one issue i thought about.\\n            -- when scanning from left to right to search for the \"viable\" index, we take the first \"viable\" index.\\n               what if this first \"viable\" index is not reachable?\\n               \\n               for example:\\n               index  0  1  2  3  4  5  6  7  8  9  10  11\\n               value  1  6  5  4  3  2  1  3  3  1  1   0\\n               \\n               scanned from left to right, the first \"viable\" index is 8, the second \"viable\" index is 10.\\n               what if we cannot reach index 8 but we can reach index 10?\\n                    -- silly question, lol\\n               will it take more steps to choose index 8 than 10?\\n                    -- 8-->11 and 10-->11 both take 1 step\\n                    -- will it take more steps to reach index 8 than 10?\\n                        -- the answer is **NO**.\\n                           if reaching index 10 takes **n** steps, we can definitely reach index 8 in **<=n** steps.\\n               \\n               therefore we have no problem to choose the first \"viable\" index.\\n               such is the correctness of the algorithm.",
                "codeTag": "Unknown"
            },
            {
                "id": 3158214,
                "title": "putta-easy-solution-c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minjump(int i,vector<int>& nums,vector<int>& dp){\\n        if(i >= nums.size()-1){\\n            return 0;\\n        }\\n        if (dp[i] != -1 ) return dp[i];\\n        int mini= 1e9;\\n        for(int k=i+1;k<=i+nums[i];k++){\\n            mini = min(mini,1+minjump(k,nums,dp));\\n        }\\n        return dp[i]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return minjump(0,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208416,
                "title": "python-intuitive-bfs-solution-with-a-deque-explained",
                "content": "What is minimum number of jump in other words? Shortest path! What is shortest path? It is BFS!\\n```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\t\\t\\n\\t\\t# queue stores index and number jump to reach it\\n        q = deque([(0,0)])\\n\\t\\t\\n\\t\\t# created visited set to stored visited indices\\n\\t\\t# this set is needed to avoid duplicate work and to protect you from TLE :-)\\n\\t\\t# we initialize it with the first index because it will be inevitably visited.\\n        visited = set([0])\\n        \\n        while q:\\n            \\n\\t\\t\\t# don\\'t forget to use popleft instead of pop to get desired first in first out behavior\\n            cur, jumps = q.popleft()\\n            \\n\\t\\t\\t# if we\\'ve reached the last index we are done\\n\\t\\t\\t# And because BFS is shortest path we just return corresponding number of jumps\\n            if cur == n - 1:\\n                return jumps\\n            \\n\\t\\t\\t# jump for each possible index from current position according to available number of jumps\\n\\t\\t\\t# min(cur+nums[cur]+1,n) just cuts jumps which are out of bound of our array\\n            for i in range(cur + 1, min(cur+nums[cur]+1,n)):\\n\\t\\t\\t\\n\\t\\t\\t\\t# jump only if we haven\\'t visited this index already\\n                if i not in visited:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if jump mark index as visited\\n                    visited.add(i)\\n                    q.append((i,jumps+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1701773,
                "title": "c-solution-using-dp-skipping-wrong-answer",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursive Dynamic Programming - Memoization.***\\n- **Remember while initializing the array with 10001, if we do 1001 then it will give the wrong answer for large values.**\\n- We take a dp array to store recursive solutions.\\n- Help array for the recursion, base case when start index is greater than size of the array.\\n- From 1 to the num position we\\u2019ll calculate the minimum value & update the dp array.\\n- Finally return the value dp[start].\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(size(nums), 10001);\\n        return help(nums, dp, 0);\\n    }\\n    int help(vector<int>& nums,  vector<int>& dp, int start){\\n        if(start >= size(nums)-1) return 0;\\n        if(dp[start] != 10001) return dp[start];\\n        \\n        for(int i=1; i<=nums[start]; i++){\\n            dp[start] = min(dp[start], 1+help(nums, dp, start+i));\\n        }\\n        return dp[start];\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469752,
                "title": "python-3-recursion-memoization-self-understandable-easy-understading",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```\\n\\n***Do Upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        memo={}\\n        def min_jumps(index):\\n            if index>=len(nums)-1:\\n                return 0\\n            if index in memo:\\n                return memo[index]\\n            ans=float(\\'inf\\')\\n            for i in range(index,index+nums[index]):\\n                ans=min(ans,1+min_jumps(i+1))\\n            memo[index]=ans\\n            return ans\\n        return min_jumps(0)\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192566,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10001];\\n    int solve(vector<int>& nums, int curridx, int lidx)\\n    {\\n        if(curridx == lidx) return 0;\\n        if(curridx > lidx || nums[curridx] == 0) return 1e6;\\n        \\n        if(dp[curridx] < 1e6) return dp[curridx];\\n        \\n        for(int i=1;i<=nums[curridx];++i)\\n        {\\n            dp[curridx] = min(dp[curridx], solve(nums,curridx+i,lidx));\\n        }\\n        \\n        dp[curridx]+=1;\\n        return dp[curridx];\\n    }\\n    \\n    int jump(vector<int>& nums) {\\n        memset(dp,1e6,sizeof(dp));\\n        int ans = solve(nums,0,nums.size()-1);\\n        if(ans == 1e6) return 0;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017980,
                "title": "c-dp-based-solution-100-time-100-space",
                "content": "I thought everybody would solve this problem with a sheer DP approach, but it looks like I was wrong and greedy was the most popular one.\\n\\nWell, good for me: I got to practice a pattern and will learn even more reading other people\\'s approaches :)\\n\\nOur core idea here is to create an array of the same size as `nums` and progress so that each slot of it will represent the minimum amount of steps to reach that position.\\n\\nTo do so, we will create just 2 variables:\\n* `len` will store the length of our input;\\n* `steps` is the array we mentioned above.\\n\\nWe will initialised all cells of `steps` to `INT_MAX`, but the first one, set to `0` (since we start there and it takes no movement to reach it).\\n\\nThen we go for the main loop, going with `i` from `0` up to the last element of our input and we will:\\n* loop with `j` from the minimum value between `len - 1` (last element of the array) and `i + nums[i])` (last element you can reach with the current jump) up to `i` (excluded);\\n* check if the current value of `step[j]` is greater than what we can achieve jumping from the currently considered cell (`step[i] + 1`) and in case update `step[j]` to a smaller, more convenient value;\\n* otherwise, since we know that we cannot offer anything better to both `step[j]` and all the cells left on the left of `j`, we break out of the inner loop and move on with another value of `i`.\\n\\nOnce we are done, we can just return the last value of `steps` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), steps[len];\\n        // presetting steps\\n        for (int i = 1; i < len; i++) {\\n            steps[i] = INT_MAX;\\n        }\\n        steps[0] = 0;\\n        // populating steps with the lowest possible values\\n        for (int i = 0; i < len; i++) {\\n            for (int lmt = i, j = min(len - 1, i + nums[i]); j > lmt; j--) {\\n                if (steps[j] > steps[i] + 1) steps[j] = steps[i] + 1;\\n                else break;\\n            }\\n        }\\n        return steps[len - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18024,
                "title": "my-c-bfs-solution-o-n-time-o-1-space",
                "content": "This minimum path problem is a typical BFS problem. Each step, expand all the nodes at the same level (i.e. i in (curEnd, newEnd])\\n\\n\\n    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }\\n            }\\n            return INT_MAX; // curEnd = newEnd, can not reach the end\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps =1, i, curEnd = 0, newEnd=0, len = nums.size();\\n            if(len<=1) return 0;\\n            for(i=0; i<=curEnd; ++i)\\n            {\\n                newEnd = max(newEnd, i+nums[i]);\\n                if(newEnd>=(len-1)) return steps;\\n                if(i==curEnd)  // end of the current level, move to the next level\\n                {\\n                    curEnd = newEnd;\\n                    ++steps;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2027340,
                "title": "python-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return 0\\n        \\n        # dp[i] means the minimum number of jumps to reach index i\\n        # for each dp[i]\\uFF0Cwe need to find the earliest j that can reach i from j\\n        # dp[i] = dp[j] + 1\\n        \\n        dp = [0] * n\\n        j = 0\\n        for i in range(1, n):\\n            while j + nums[j] < i:\\n                j += 1\\n            dp[i] = dp[j] + 1\\n        \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 1621483,
                "title": "c-greedy-approach-o-n-w-explanation",
                "content": "**APPROACH :**\\nAt any index i in ```nums```, we can jump a maximum of ```nums[i]``` steps and we need to reach the last index in the minimum number of jumps. \\nThis approach can be solved using DP but that requires O(N^2) time and O(N) space. \\nSo, we\\'ll solve it using Greedy approach. \\n\\nLet\\'s consider the array :\\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\\n(The minumum number of jumps to reach the end of the array is 3 ```(0--->1--->4--->10)``` )\\n\\n* We maintain 3 variables ```max_reach```, ```curr_reach```, ```jumps```. \\n* The idea is to jump the maximum no. of steps we can from an index, and update the ```max_reach``` and ```curr_reach``` to the index we jump to, increment ```jumps``` each time we jump (ie. each time we reach the max. index that could be reached from the starting index.)\\n* For the intermediate indices, we check if we can go farther than that from the index we started with and if yes, we update ```max_reach``` (Greedy Approach).\\n* When we reach the end of a segment (segment is the range of indices we can jump to from a given index), we see if ```max_reach``` is greater than the ```curr_reach``` and update ```curr_reach``` and increment ```jumps```, because we\\'ve reached the end of a segment and will the take the next jump.\\n* We continue this until the last but one index and then return ```jumps``` as the minimum value.\\n ![image](https://assets.leetcode.com/users/images/e4c49f12-2a3e-4af6-aa0f-76a916875c52_1639141695.0349996.jpeg)\\n In the above example, the segments are : index - 1, index - 2 to 4, index - 4 to 10.\\n\\n**Time Complexity :** O(N)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\nPlease upvote if you like it!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```nums```\n```nums[i]```\n```nums = [1, 3, 5, 8, 6, 2, 6, 7, 6, 8, 9]```\n```(0--->1--->4--->10)```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```curr_reach```\n```jumps```\n```max_reach```\n```max_reach```\n```curr_reach```\n```curr_reach```\n```jumps```\n```jumps```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int max_reach=0, curr_reach=0, jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            max_reach = max(max_reach, nums[i]+i);\\n            if(i==curr_reach) curr_reach = max_reach, jumps++;   \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158343,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=O46mFXtuGJY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=8) if you are interested.\\n\\n<iframe src=\"https://leetcode.com/playground/QhdE2L8F/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1193170,
                "title": "c-0ms-dp-approach-explained-logic",
                "content": "Initialize dp vector with max value (10000, from constraints). This vector will keep track of minimum jumps needed to reach to that position.\\nTo reach to first index, needed jumps =0\\nGet the value at nums[i]\\nFor the next nums[i] index, the needed jumps would be minimum of jumps at ith index+1, or jumps stored at dp[i]\\n\\n```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int i, j, index;\\n        vector<int> dp(nums.size(), 10000);\\n        dp[0]=0;            // to reach 1st index, jumps needed=0\\n        for(i=0; i<nums.size(); i++)\\n        {\\n            index=i+1;          // if nums[i]=2 and i=5, index will start from 6 and go till 8th position\\n            while(index<i+nums[i]+1)\\n            {\\n                if(index >= nums.size())        \\n                    break;\\n                dp[index] = min(dp[index], dp[i]+1);\\n                index++;\\n            }\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3159250,
                "title": "c-greedy-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all don\\'t worry about greedy it is not compulsory that it should come to our mind at first .. So initially we can think of brute force i.e recursive + backtracking then we can optimize using dp. So this is normally how to aproach the problem . There is no need to worry about greedy ..\\n-  Now after doing dp if we want like how the greedy will work for this we can give it some time and try to take it as a shortest path problem like we do in graph by bfs. In the similar way we can check at some level what can be the maximum jump we can take and we also check in between the maximum jump so far till curr_max (if there is some more we can get) . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Greedy:** So In greedy we can take two pointers  [max_so_far , curr_maxi]\\n- Then we check one by one upto our curr maximum what can be maximum jump i.e max_so_far and after checking upto our curr_maxi we will upafte our curr_maxi with max_so_far and also we will incraese counter by 1 becuse 1 jump is taken .\\n- This will run upto our max_so_far become >=n-1 i.e end point so after that we will return the answer (no. of jumps till now).\\n- There are two  ways of doing greedy like shown below : First one seems like more bfs type but both are actually implicit bfs ,idea is same incremnet the level and check in curr level the  max jump we can take  and when max > n-1 we will return the no .of levels  till now.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Dynamic Programming O(n^2)**\\n```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\\n**Greedy I**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Greedy II**\\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<int>&arr,int ind,vector<int>&dp){\\n        if(ind>=arr.size()-1)return 0;\\n        if(dp[ind]!=10001)return dp[ind];\\n        for(int i=1;i<=arr[ind];i++){\\n            dp[ind]=min(dp[ind],1+solve(arr,i+ind,dp));\\n        }\\n        return dp[ind];\\n    }\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n+1,10001);\\n        return solve(arr,0,dp);\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        int max_so_far=0,ans=0,maxi=0;\\n        int i=0;\\n        while(maxi-i+1>0){\\n           ans++;\\n            for(i;i<=maxi;i++){\\n                max_so_far=max(max_so_far,i+arr[i]);\\n                if(max_so_far>=n-1)return ans;\\n            }\\n            maxi=max_so_far;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nint jump(vector<int>& arr) {\\n        int n=arr.size(),sum=0,c=0;\\n        if(n==1)return 0;\\n        int currFar=0,currEnd=0;\\n        for(int i=0;i<n-1;i++){\\n            currFar=max(currFar,arr[i]+i);\\n            if(i==currEnd){\\n                c++;\\n                currEnd=currFar;\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697195,
                "title": "c-easy-fast-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int step = nums[i];\\n            for(int j=1;j<=step and i+j<n;j++)\\n            {\\n                dp[i+j]=min(dp[i+j], dp[i]+1);\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909415,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func jump(_ nums: [Int]) -> Int {\\n\\t\\tguard nums.count > 1 else { return 0 }\\n\\t\\tvar maxIndex: [Int] = [1]\\n\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tvar max = 0\\n\\n\\t\\t\\tfor j in 0..<maxIndex[i] {\\n\\t\\t\\t\\tif (j >= nums.count) { break }\\n\\t\\t\\t\\tlet index = j + nums[j] + 1\\n\\n\\t\\t\\t\\tmax = max > index ? max : index\\n\\t\\t\\t\\tif max >= nums.count { return i + 1 }\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaxIndex.append(max)\\n\\t\\t}\\n        return 0\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160405,
                "title": "easy-java-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a greedy approach. We can keep track of the maximum reachable index in each iteration and jump to that index in the next iteration. The minimum number of jumps can be calculated by counting the number of iterations needed to reach the end of the array.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int n = nums.length; // length of the nums array\\n        int jumps = 0; // number of jumps needed to reach the end\\n        int curEnd = 0; // farthest index that can be reached with the current number of jumps\\n        int curFarthest = 0; // farthest index that can be reached from the current index\\n        \\n        // iterate over the nums array from 0 to n - 1\\n        for (int i = 0; i < n - 1; i++) {\\n            curFarthest = Math.max(curFarthest, i + nums[i]); // update curFarthest with the maximum distance that can be reached from this index\\n            \\n            // if i is equal to curEnd, we have reached the farthest possible index with the current number of jumps\\n            if (i == curEnd) {\\n                jumps++; // increment jumps by 1\\n                curEnd = curFarthest; // update curEnd with the new farthest index\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159282,
                "title": "4-best-approaches-recursion-memorization-tabulation-most-optimized-approach",
                "content": "# **Please Upvote if you like these approaches**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K^n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\nO(n) for recursive call stack space\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemorization\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMemorization Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTabulation\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTabulation Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(K*n)\\nWhere K = maxElementOf(nums)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointers Approach\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(n)\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(1)\\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums){\\n        int end = 0, farthest = 0;\\n        int jump = 0;\\n\\n        for(int i = 0; i < nums.length-1; i++){\\n            farthest = Math.max(farthest, i + nums[i]);\\n            if(i == end){\\n                jump++;\\n                end = farthest;\\n            }\\n        }\\n        return jump;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        return recJump(nums, 0);\\n    }\\n\\n     public int recJump(int [] nums, int idx){\\n         if(idx == nums.length - 1)\\n             return 0;\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, recJump(nums, i)+1);\\n         }\\n         return min;\\n     }\\n\\n\\n```\n```\\n\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n\\n     public int memoJump(int [] nums, int idx, int [] dp){\\n         if(idx == nums.length - 1)\\n             return dp[idx] = 0;\\n        \\n         if(dp[idx] != -1)\\n             return dp[idx];\\n\\n         int min = 99999;\\n         for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n             min = Math.min(min, memoJump(nums, i, dp)+1);\\n         }\\n         return dp[idx] = min;\\n     }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int jump(int[] nums) {\\n        int [] dp = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return memoJump(nums, 0, dp);\\n    }\\n    public int tabJump(int [] nums, int idx, int [] dp){\\n        for(idx = nums.length - 1; idx>=0; idx--){\\n            if(idx == nums.length-1){\\n                dp[idx] = 0;\\n                continue;\\n            }\\n\\n            int min = 99999;\\n            for(int i = idx+1; (i <= idx + nums[idx] && i < nums.length); i++){\\n                min = Math.min(min, dp[i]+1);\\n            }\\n\\n            dp[idx] = min;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158322,
                "title": "easy-memoised-solution-c",
                "content": "\\n# Code Approach 1\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\\n# Code Approach 2 [greedy]\\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int> &nums,int idx,int n,vector<int> &dp){\\n        //base case\\n        if(idx >= n-1) return 0;\\n        \\n        if(dp[idx] != 10001) return dp[idx];\\n        \\n        int jumps=10001;\\n        for(int i=1; i <= nums[idx]; i++){\\n            jumps = min(jumps,1 + f(nums,idx + i,n,dp));\\n        }\\n        \\n        return dp[idx] = jumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<int> dp(n,10001);\\n        return f(nums,0,n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//app 2: greedy\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,maxReachable=0,curLevelReach=0;\\n        int jumps=0;\\n\\n        while(i<n-1){\\n            maxReachable = max(maxReachable,i+nums[i]);\\n\\n            if(i == curLevelReach){\\n                curLevelReach = maxReachable;\\n                jumps++;\\n            }\\n            i++;\\n        }\\n\\n        return jumps;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306691,
                "title": "all-methods-recursive-dp-memoization-dp-tabulation-greedy-dfs-c",
                "content": "**Recursive Method**\\nTime Complexity: O(2^n)\\nSpace Complexity: O(1)\\nAuxilary Space Complexity for Recursive Stack Space: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\\n**DP- Memoization**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\\n**DP- Tabulation**\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**Greedy Method**\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n\\n***If you like this post, Please Upvote this post***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums){\\n        if(i>=nums.size()-1) return 0;\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums));\\n        }\\n        return minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        return getMinJump(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinJump(int i, vector<int> &nums, vector<int> &dp){\\n        if(i>=nums.size()-1) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int minJump=nums.size();\\n        for(int index=i+1; index<=i+nums[i]; index++){\\n            minJump=min(minJump, 1+getMinJump(index, nums, dp));\\n        }\\n        return dp[i]=minJump;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return getMinJump(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n, n);\\n        dp[0]=0;\\n        for(int i{}; i<n-1; i++){\\n            for(int j=i+1; j<=i+nums[i]&&j<n; j++){\\n                dp[j]=min(dp[j], 1+dp[i]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int farthest=0, jumps=0, current=0;\\n        for(int i=0; i<n; ++i){\\n            if(i>current){\\n                current=farthest;\\n                jumps++;\\n            }\\n            farthest=max(farthest, i+nums[i]);\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677863,
                "title": "java-solution-4-approaches-from-recursive-to-top-down-to-botton-up-and-finally-greedy",
                "content": "In question it is mentioned that answer will always exists. \\nlast element of array does not matter also as even if its value is 0 we don\\'t need to hop further.\\n**Brute Force-**\\nstart from i=0 to n-2 and foreach element i check at how many position we can go and for each valid posiiton again check how many locations we can go. keep on returning min for each path. once we reach last index we have the desired answer.\\n\\n```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\\n\\n**Top Down -**\\nIn above approach we are visiting every branch and at most of the times same branch is re-calucated. to save that take output array and before calling method check if for that index output array already has some data. if yes return directly else call method.\\n\\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\\n\\n**Bottom Up->**\\nwe can just reverse the outer loop and can make recursive solution to iterative.\\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\\n\\n**Greedy Approach ->**\\nwe can make use of greedy idea + sliding window concept also and can reduce the complexity from o(n^2) to o(n)\\nfor that keep maintaing left and right pointers to hold the window size on which we can go from each step.\\njump will store total jump needed to reach from first window till last window.\\ninitially set l=r=jump=0\\nnow loop till right< n-1\\ncheck for item starting from left till right what is max value i.e.\\nmax=Math.max(max,i+nums[i]);\\nonce inner loop finsihes we have max hops that we can go. now, increment jump, and left and right boundary also.\\nonce outer loop finishes jump has the desired answer.\\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\npublic int bruteForce(int[] nums) {\\n\\t\\treturn bruteForceRec(nums, 0);\\n\\t}\\n\\n\\tprivate int bruteForceRec(int[] nums, int start) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint min = 10001;//max value can be 1000\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + bruteForceRec(nums, i));\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n```\n```\\n\\tpublic int topDownDp(int[] nums) {\\n\\t\\treturn topDownRec(nums, 0, new int[nums.length]);\\n\\t}\\n\\n\\tprivate int topDownRec(int[] nums, int start, int[] output) {\\n\\t\\tif (start >= nums.length - 1) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (output[start] != 0) {\\n\\t\\t\\treturn output[start];\\n\\t\\t}\\n\\t\\tint min = 10001; // max possible jump is 10^4\\n\\t\\tfor (int i = start + 1; i <= nums[start] + start; i++) {\\n\\t\\t\\tmin = Math.min(min, 1 + topDownRec(nums, i, output));\\n\\t\\t}\\n\\t\\toutput[start] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n```\n```\\n\\tpublic int bottomUpDp(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] output = new int[n];\\n\\t\\tfor (int start = n - 2; start >= 0; start--) {\\n\\t\\t\\tint min = 10001;\\n\\t\\t\\tfor (int i = start + 1; i <= start + nums[start]; i++) {\\n\\t\\t\\t\\tmin = Math.min(min, 1 + (i>=n ? 0 : output[i]));\\n\\t\\t\\t}\\n\\t\\t\\toutput[start] = min;\\n\\t\\t}\\n\\t\\treturn output[0];\\n\\t}\\n```\n```\\npublic int greedy(int[] nums) {\\n\\t\\tint jump = 0;\\n\\t\\tint left = 0;\\n\\t\\tint right = 0;\\n\\t\\t//till we reach end of the array\\n\\t\\twhile (right < nums.length - 1) {\\n\\t\\t\\tint max = 0;\\n\\t\\t\\t//find max reach (in range of indexes left and right)\\n\\t\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\t\\tmax = Math.max(nums[i] + i, max);\\n\\t\\t\\t}\\n\\t\\t\\t//update new boundaries\\n\\t\\t\\tleft = right + 1;\\n\\t\\t\\tright = max;\\n\\t\\t\\tjump++;\\n\\t\\t}\\n\\t\\treturn jump;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640734,
                "title": "0ms-o-n-solution-faster-than-100-users-less-memory-than-97-java-users-explained",
                "content": "\\n\\n```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int jump(int[] a) {\\n        int n = a.length;\\n\\n        // Check Base Conditions\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        } else if (a[0] >= n - 1) {\\n            return 1;\\n        }\\n\\n        // Keeps count of number of jumps\\n        int count = 1;\\n\\n        // 2 pointers to loop through the array\\n        int current_pos = 0; // stores the current position\\n        int parsed_pos = -1; // stores the last index of the position that have been parsed\\n\\n        //stores the position of the max value one can jump to between the parsed position and the current position\\n        int jumpTo = current_pos + a[current_pos];\\n\\n        // while not reached destination/end\\n        while (jumpTo < n - 1) {\\n            int arr[] = nextJump(a, current_pos, parsed_pos);\\n            current_pos = arr[0];\\n            parsed_pos = arr[1];\\n            jumpTo = arr[2];\\n            count += 1;\\n        }\\n\\n        return count;\\n    }\\n\\n    //finds the best index to jump from, between parsed_pos and max index reachable from current_pos\\n    static int[] nextJump(int[] a, int current_pos, int parsed_pos) {\\n        // stores the best position to jump from, between parsed_pos and max index reachable from current_pos \\n        int new_pos = current_pos;\\n\\n        // iterate parsed_pos and max index reachable from current_pos and find the index that can jump the farthest and set that as new_pos\\n        for (int i = parsed_pos + 1; i <= current_pos + a[current_pos]; i++) {\\n            if (i + a[i] >= new_pos + a[new_pos]) {\\n                new_pos = i;\\n            }\\n        }\\n\\n        //contains the new position to jump to, last index parsed in this iteration(new parsed_pos), maximum index reachable from the new position \\n        int arr[] = { new_pos, current_pos + a[current_pos], new_pos + a[new_pos] };\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193341,
                "title": "o-n-golang-solution-beats-100",
                "content": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n\\tcurJump, farthestJump, jumps := 0, 0, 0\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t    // push index of furthest jump during current iteration\\n\\t\\tif i+nums[i] > farthestJump {\\n\\t\\t\\tfarthestJump = i + nums[i]\\n\\t\\t}\\n\\n\\t\\t// if current iteration is ended - setup the next one\\n\\t\\tif i == curJump {\\n\\t\\t\\tjumps, curJump = jumps+1, farthestJump\\n\\n\\t\\t\\tif curJump >= len(nums)-1 {\\n\\t\\t\\t\\treturn jumps\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// it\\'s guaranteed to never hit it\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18149,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def jump(self, nums):\\n        res = 0\\n        edge = 0\\n        maxEdge = 0\\n        for i in range(len(nums)):\\n            if i > edge:\\n                edge = maxEdge\\n                res += 1\\n            maxEdge = max(maxEdge,i+nums[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 18201,
                "title": "17ms-ac-c-code-very-easy-to-understand",
                "content": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "solutionTags": [],
                "code": "    int jump(int A[], int n) {\\n    \\t\\tint i = 0, j = 1, cnt = 0, mx;\\n    \\n    \\t\\tif (n == 1) return 0;\\n    \\n    \\t\\twhile (i < n - 1 && i + A[i] < n - 1) {\\n    \\t\\t\\tfor (mx = j; j <= i + A[i]; j++) { mx = (mx + A[mx] <= j + A[j]) ? j : mx; }\\n    \\t\\t\\ti = mx; cnt++;\\n    \\t\\t}\\n    \\t\\treturn ++cnt; /* One more step to last index. */\\n    \\t}\\n\\nAll we have to do is to iterate though all positions we can jump from where we standing, find the largest i + A[i] (greedy) and jump to that index. O(n) in time and constant space.",
                "codeTag": "Unknown"
            },
            {
                "id": 1668826,
                "title": "dp-greedy-c-soln",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***DP***\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n    int res = 0 , currmax = 0 , reach = 0;\\n        \\n        for(int index = 0 ; index < nums.size() - 1 ; index++)\\n        {\\n            if(index + nums[index] > currmax)\\n                currmax = index + nums[index];\\n            \\n            if(index == reach)\\n            {\\n                res++;\\n                reach = currmax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, INT_MAX-1);\\n        dp[n - 1] = 0;  \\n        for(int i = n - 2; i >= 0; i--) \\n            for(int j = 1; j <= nums[i]; j++) \\n                dp[i] = min(dp[i], 1 + dp[min(n - 1, i + j)]);  \\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439932,
                "title": "simple-python-o-n-greedy-solution",
                "content": "The idea is that we only jump when we absolutely have to, this way the total number of jumps will be minimized.\\n**next_jump_max**: the furtherest we can jump next time\\n**cur_jump_max**: the furtherest we reach from previous jump\\n```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```Python\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        cur_jump_max = next_jump_max = ret = 0\\n        for i in range(len(nums)-1):\\n            next_jump_max = max(next_jump_max, i+nums[i])\\n            if i == cur_jump_max:\\n                ret += 1\\n                cur_jump_max = next_jump_max\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915437,
                "title": "hurray",
                "content": "**Approach**: I solved the problem with greedy approach. For the last couple of days i was practicing and studying greedy aprroach heavily. This topic always bothered me. But after with enough study and practicing common greedy problems now i can detect which problems to tackle with greedy approach and device a way how to solve.\\n\\nMy approach for this particular problem is to get the indices from nums which **minimises the distance from the end.**\\n```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\\nThis block of code achives this.\\n\\nOverall Code:\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```\\n\\nTime taken is 2ms. I think the TC is **O(N)**. Cause in the worst case this program can process an elment max two times. I cant find a worse case that in an elemnt will be processed multiple times. Can anyone help me here if am right or wrong here?\\n\\nNevertheless thanks everyone to the discuss channel contributers which helps me a lot to progress. <3",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\t\\tint a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n```\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n        int max = nums[0];\\n        int i = 0;\\n        int count = 1;\\n        while (i <= nums.length) {\\n            if (i + max >= nums.length - 1) return count;\\n            int[] res = helper(nums, i + 1, i + max);\\n            max = res[0];\\n            i = res[1];\\n            count++;\\n        }\\n        return 0;\\n    }\\n    \\n     private int[] helper(int[] nums, int start, int end) {\\n        int min = Integer.MAX_VALUE;\\n        int aMin = Integer.MAX_VALUE;\\n        int pos = -1;\\n        for (int i = end; i >=start ; i--) {\\n            int a = nums.length - (nums[i] + i);\\n            if(a<aMin){\\n                min = nums[i];\\n                pos = i;\\n                aMin = a;\\n            }\\n\\n        }\\n        return new int[]{min, pos};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158252,
                "title": "c-java-simple-solution-easy-to-understand-code-with-comments",
                "content": "# Intuition\\nAdvice: Frist ,You need to analyse the question to which data structure to apply for this solution,It will come automatically,when you solve more problems.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMy first Approach was Dynammic programming,but solution beats 50%.\\nI moved to greedy method and Beats 95%.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```UPVOTE THE POST (Upvote karo masth.. Karo bhaiye..)\\n    //Dynammic Programming\\n    int length=nums.Length;\\n    //It\\'s the way to assign value to all indexes\\n    int[] dp = Enumerable.Repeat(Int32.MaxValue,length).ToArray();\\n    dp[0] = 0;\\n    for(int i = 0; i <length; i++) {\\n        for(int j = 0; j <= nums[i] && i + j < length; j++) {\\n            dp[i+j] = Math.Min(dp[i+j], dp[i] + 1);                \\n        }\\n    }\\n    return dp[length - 1];\\n",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\n//Greedy Approach\\npublic class Solution {\\n    public int Jump(int[] nums) {\\n        int length=nums.Length;\\n\\n        int highJump=0;\\n        int jump=0;\\n        int currPos=0;\\n        // corner case :only one positio don\\'t need jump\\n        if(length==1){\\n            return 0;\\n        }\\n        // base case : If start position given range,you won\\'t jump more So,return -1;\\n        if(nums[0]==0){\\n            return -1;\\n        }\\n        //Loop through steps \\n        for(int i=0;i<length;i++){\\n            highJump=Math.Max(highJump, i+nums[i]);\\n            // When the jump reaches the end return the total jumps\\n            if(highJump>=length-1){\\n                return jump+1;\\n            }\\n            if(i==currPos){\\n                currPos=highJump;\\n                jump++;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327160,
                "title": "very-easy-100-fully-explained-c-java-javascript-c",
                "content": "# **C++ Solution:**\\n```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\\n\\n# **JavaScript Solution:**\\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\\n\\n# **C Language:**\\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n**// Using Optimal Greedy Approach...**\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        //Initialize left and right pointers to point to the start and end of a segment...\\n        //segment refers to the steps a particular index can move...\\n        //Initialize jumps variable to store the number of jumps made so far which will be the minimum...\\n        int left = 0, right = 0, jump = 0;\\n        // While right pointer is not at the end of the list...\\n        while(right < nums.size() - 1){\\n            int maxi = 0;\\n            //Loop through the segment and maximize the reach...\\n            for(int i = left; i < right + 1; i++)\\n                maxi = max(maxi, nums[i] + i);\\n            // Update the pointers...\\n            // left pointer to be at right + 1...\\n            left = right + 1;\\n            // right pointer to be at the maximum reach...\\n            right = maxi;\\n            jump += 1;\\n        }\\n        return jump;\\n    }\\n};\\n```\n```\\n**// Using Dynamic Programming Approach...**\\nclass Solution {\\n    public int jump(int[] nums) {\\n        //Create an auxiliary array to store minimum jumps needed to reach nums[i] from nums[0].\\n        int[] jump = new int[nums.length];\\n        jump[0] = 0;\\n        //Implement a nested loop to traverse the whole list.\\n        for (int i = 1; i < nums.length; i++) {\\n            jump[i] = Integer.MAX_VALUE;\\n            //traverse the segments and stores the minimum jumps to an index in the auxiliary array.\\n            for(int j = 0; j < i; j++){\\n                // Find the minimum number of jumps to reach nums[i] from the start\\n                // And add this value to the auxiliary array.\\n                if(i <= nums[j] + j && jump[j] != Integer.MAX_VALUE) {\\n                    jump[i] = Math.min(jump[i], jump[j] + 1);\\n                }\\n            }\\n        }\\n        return jump[nums.length - 1];   //Return the minimum number of jumps.\\n    }\\n}\\n```\n```\\n**//Time Complexity : O(n),   Space Complexity: O(1)**\\nvar jump = function(nums) {\\n    var jump = 0;\\n    var prev = 0;\\n    var max = 0;\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        // Keep track of the maximum jump\\n        max = Math.max(max, i + nums[i]);\\n        // When we get to the index where we had our previous maximum jump, we increase our jump...\\n        if (i === prev) {\\n            jump++;\\n            prev = max;\\n        }\\n    }\\n    return jump;\\n};\\n```\n```\\n// Another approach is here...\\nint jump(int* nums, int numsSize){\\n    int pos = 0;\\n    int n = 0;\\n    while(pos < numsSize-1) {\\n        int next_pos=-1;\\n        if(pos+nums[pos]<numsSize-1) {\\n            for(int i=1; i<=nums[pos]; i++) {\\n                if(next_pos == -1 || (pos+i<numsSize && nums[next_pos]+(next_pos-pos) <= nums[pos+i]+i))\\n                    next_pos = pos+i;\\n            }\\n        }else\\n            next_pos = pos+nums[pos];\\n            pos = next_pos;\\n            n++;\\n    }\\n    return n;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732493,
                "title": "linear-and-easy-bfs-solution-in-c",
                "content": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        \\n        int current=0,farthest=0,jumps=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++) {\\n            \\n            farthest=max(farthest, nums[i]+i);\\n            if(i==current) {\\n                current=farthest; jumps++;\\n            }\\n        }\\n        return jumps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 527262,
                "title": "python-dp-ezpz-10-line-solution-91-20",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return 0\\n        dp = [0]*len(nums)\\n        frontier = 0\\n        for i, n in enumerate(nums):\\n            if i + n > frontier:\\n                dp[frontier + 1:i + n + 1] = [dp[i] + 1] * (i + n - frontier)\\n                frontier = i + n\\n                if i + n >= len(nums) - 1: break\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18082,
                "title": "5-lines-o-n-python-with-explanation",
                "content": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Check comments in the code. \\n\\n    def jump2(self, A):\\n        \"\"\"\\n        Basically it's a shortest-path problem. \\n        As an unweighted graph, BFS should be able to solve it in O(|E|).\\n        But as it's an array with non-negative numbers, we can't jump backward. \\n        So we can do better here.\\n        Suppose we devided the arrays into segments depending on the elment \\n        in the array. So for each segment, we find the farthest index we can \\n        jump. For example, the first segment is always A[0]. The second will be\\n        from A[1] to A[A[0]]. The third will be from A[A[0]] to the farthest \\n        index we can find in the second segment. We start looking between \\n        the end of the last segment and the begin of the next segment.\\n        \"\"\"\\n        ans = lastIdx = nextIdx = 0\\n        while nextIdx < len(A) - 1:\\n            ans += 1\\n            lastIdx, nextIdx = nextIdx, max(i + A[i] for i in xrange(lastIdx, nextIdx + 1))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3158368,
                "title": "beginner-friendly-solution-easy-greedy-approach",
                "content": "# Intuition\\nGreddy Approach\\n\\n# Approach\\n- take three integer values jumps,curr_end and curr_Farthest  \\n- iterate through  loop to update curr_farthest and curr_end\\n- update curr_Farthest with max between curr_Farthest and i+nums[i]\\n- update curr_end when i is equal to curr_End and increase jumps\\n- return jumps\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\\n# Code in Python\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```\\n\\n# DON\\'T FORGET TO UPVOTE !",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\tint jumps = 0, curr_End = 0, curr_Farthest = 0;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tcurr_Farthest = max(curr_Farthest, i + nums[i]);\\n\\t\\tif (i == curr_End) {\\n\\t\\t\\tjumps++;\\n\\t\\t\\tcurr_End = curr_Farthest;\\n\\t\\t}\\n\\t}\\n\\treturn jumps;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        jumps=0\\n        curr_end=0\\n        curr_farthest=0\\n        n=len(nums)\\n        for i in range(n-1):\\n            curr_farthest=max(curr_farthest,i+nums[i])\\n            if(i==curr_end):\\n                jumps+=1\\n                curr_end=curr_farthest\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522839,
                "title": "o-n-single-pass-well-explained-ladder-steps-technique",
                "content": "Ladder Analogy\\n-\\n___\\nTake an iterator ``itr`` pointing to first element. We\\'ll move this over the array.\\n\\nFrom an element at position ``itr``, we can jump steps less than equal to ``nums[itr]``.\\nSo, we can move from ``itr`` to ``itr + nums[itr]`` (and stop anywhere in between)\\n\\nConsider this as a ladder connecting`` itr`` to ``itr + nums[itr]``, where we can stop at any step of this ladder.\\n\\nAlso, for every ``itr``, we have a seperate ladder going till ``itr + nums[itr]``.\\nFollowing figure shows all ladders connecting the elements in ``[3, 2, 2, 1, 4, 5]``\\n\\n![image](https://assets.leetcode.com/users/images/5b8ca20f-4d49-4eb4-bfcb-61de1a02345c_1634322078.0108702.png)\\n\\nSo, as ``itr`` moves from start to end, we can say that we are moving along a ladder or jumping from one ladder to another and moving along it.\\n\\nEach ladder change is analogous to a jump, so we need to reach the end with minimum ladder changes.\\nFollowing figure shows a path (in green) with minimum ladder changes.\\n\\n![image](https://assets.leetcode.com/users/images/28840ca0-3d48-4837-b7aa-72b11cf01020_1634322104.7879624.png)\\n\\nApproach\\n-\\n___\\n\\nMove along a ladder till we reach its end.\\n\\nWhile moving ahead find the ladder that has the farthest end and save it.\\n\\nWhen the current ladder ends, jump to the ladder that takes you the farthest.\\n\\nRepeat the same till we reach the end of ``nums``.\\n\\nCode\\n-\\n___\\n\\n``steps``: Number of steps in current ladder\\n\\n``ladder``:  Ending index of the ladder that takes us to the farthest point\\n\\n``jumps``: Number of ladder switches done till now\\n\\n``itr``: Iterator that moves across the array\\n\\n```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef jump(self, nums: List[int]) -> int:\\n\\n\\t# Boundary case\\n\\tn = len(nums)\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\n\\t# Initialize variables\\n\\tjumps = 1\\n\\tladder = nums[0]\\n\\tsteps = ladder\\n\\titr = 0\\n\\n\\t# Move over the current ladder\\n\\twhile steps >= 0:\\n\\n\\t\\t# Terminal condition - reached end of nums\\n\\t\\tif itr == n - 1:\\n\\t\\t\\treturn jumps\\n\\n\\t\\t# Update ladder endpoint if a longer one is found\\n\\t\\tladder = max( itr + nums[itr], ladder )\\n\\n\\t\\t# Current ladder has ended\\n\\t\\tif steps == 0:\\n\\t\\t\\tsteps = ladder - itr     # move to new ladder\\n\\t\\t\\tjumps += 1               # and update jumps\\n\\t\\t\\n\\t\\t# Continue moving ahead\\n\\t\\telse:\\n\\t\\t\\tsteps -= 1\\n\\t\\t\\titr += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 672805,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    def jump(self, nums: List[int]) -> int:\\n        dp = []\\n        curr = 0\\n        prev = -1\\n        while curr < len(nums) - 1:\\n            max_reach = self.get_max_reach(nums[prev+1:curr+1])\\n            dp.append(max_reach)\\n            prev = curr\\n            curr += dp[-1]\\n            if curr == prev: return 0\\n        return len(dp)\\n    \\n    def get_max_reach(self, arr):\\n        out = 0\\n        for i,v in enumerate(arr):\\n            out = max(out, (i+1+v) - len(arr))\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 459329,
                "title": "c-concise-solution-beats-97",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint jump(vector<int>& nums) {\\n\\t\\t\\tint far=0;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tint MAX=0;\\n\\t\\t\\tfor(int i=0;i<nums.size()-1;i++){\\n\\t\\t\\t\\tMAX=max(MAX,i+nums[i]);\\n\\t\\t\\t\\tif(far<=i){\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t\\tfar=MAX;\\n\\t\\t\\t\\t\\tMAX=0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18107,
                "title": "the-most-intuitive-solution-yet-still-accepted-as-best-in-c-well-explained",
                "content": "Using greedy method is quite strai\\nght-forward here, we need to finish this jumping as soon as possible but the question is what should be the factor for us to be greedy for:  <font color=\"#ff0000\">**the farthest jump**</font> \\n\\nOnce we are in a position **i** the farthest position we can reach is **i+nums[i]** and within this range we should find the most potential index **j** which will give us the biggest **j+nums[j]** and then we move to the most potential position **j** and then on and on till we move to the last or over it.\\n\\n    int next = 0, maxDes = 0;\\n    for(int j = i+1; j <= i+nums[i]; ++j)\\n    {\\n        if(nums[j]+j > maxDes) \\n        next = j, maxDes = nums[j]+j;   \\n    }\\n\\nQuite direct and simple though some details should be cared about. \\n\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }\\n                i = next; //jump to the most potential position;\\n                jumps++; //count the jump;\\n            }\\n            return 0; //for compilation matter, actually this statement will never be invoked;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //AC - 16ms - greedy method selecting the proper factor to be greedy for;\\n        int jump(vector<int>& nums) \\n        {\\n            int i = 0, jumps = 0, size = nums.size();\\n            if(size == 1) return 0;\\n            while(i < size)\\n            {\\n                if(i+nums[i] > size-2) return ++jumps; //the last jump to or over the last;\\n                int next = 0, maxDes = 0;\\n                for(int j = i+1; j <= i+nums[i]; ++j) //searching for the most potential position;\\n                {\\n                    if(nums[j]+j > maxDes) \\n                        next = j, maxDes = nums[j]+j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18131,
                "title": "easy-understand-o-n-time-o-1-space-code",
                "content": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The main idea is using 2 integer to record the longest distance of current jump can arrive.\\nIf n jump cannot arrive at index i, it must jump one more time. Which means, the least jump time to get index i is (n+1).    \\n\\n\\n     int jump(vector<int>& nums) {\\n        if (n <= 1)\\n            return 0;\\n        int i, n = nums.size(), lc, ln, step = 1;\\n        // lc means the longest distance can achieve by current jump\\n        // ln means the longest distance can achieve by next jump\\n\\n        lc = nums[0], ln = nums[0]; //Initialize to index 0, the start point.\\n        for (i = 1; i < n; ++i)\\n        {\\n            if (i > lc) //current jump cannot get index i -->>> must jump one more time.\\n            {\\n                lc = ln;\\n                step++;\\n            }\\n            if (i + nums[i] > ln) //maintain the furthest distance of next jump can get\\n                ln = i + nums[i];\\n            if (lc >= n - 1) //current jump can achieve the last index\\n                return step;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18156,
                "title": "python-o-n-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def jump(self, nums):\\n            n, cur_max, next_max, steps = len(nums), 0, 0, 0\\n            for i in xrange(n):\\n                if i > cur_max:\\n                    steps += 1\\n                    cur_max = next_max\\n                    if cur_max >= n: break\\n                next_max = max(next_max, nums[i] + i)\\n            return steps",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3314558,
                "title": "start-and-end-approach-simple-to-understand",
                "content": "\\n\\n# 1.Start and End Approach\\n```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self,nums:List[int])->int:\\n        start,end,count=0,0,0\\n        for i in range(len(nums)-1):\\n            start=max(start,i+nums[i])\\n            if end==i:\\n                end=start\\n                count+=1\\n        return count\\n    #please upvote me it would encourage me alot\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158892,
                "title": "day-39-c-greedy-easiest-beginner-friendly-sol-o-n-time-and-o-1-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create two variables, jumps and maxReach, to keep track of the minimum number of jumps and the maximum reach from the current position.\\n2. Loop through the array.\\n3. For each index i, update maxReach to be the maximum between maxReach and i + nums[i].\\n4. If the current position i is equal to the current reach curReach, increment the number of jumps and update curReach to be the value of maxReach.\\n5. If curReach is greater than or equal to the last index of the array, return jumps.\\n6. If i is greater than or equal to maxReach, return 0 as it means it cannot reach the end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int jumps = 0;\\n        int maxReach = 0; \\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                //I added below two statements to cover if it will not reach to end of the array then return 0...but Actualy this case is out of scope but it is helpful for followups problem. If you want you can remove for this this problem\\n                // ex - [1,2,1,0,0]\\n                if (i >= maxReach) \\n                    return 0; // Cannot reach the end\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\npublic \\n    int jump(int[] nums) {\\n        int n = nums.length;\\n        int jumps = 0;\\n        int maxReach = 0;\\n        int curReach = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            maxReach = Math.max(maxReach, i + nums[i]);\\n            if (i == curReach) {\\n                jumps++;\\n                curReach = maxReach;\\n                if (curReach >= n-1)\\n                    return jumps;\\n                if (i >= maxReach)\\n                    return 0;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        jumps = 0\\n        maxReach = 0\\n        curReach = 0\\n        for i in range(n - 1):\\n            maxReach = max(maxReach, i + nums[i])\\n            if i == curReach:\\n                jumps += 1\\n                curReach = maxReach\\n            if curReach >= n - 1:\\n                return jumps\\n            if i >= maxReach:\\n                return 0\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115905,
                "title": "how-to-build-up-to-the-optimal-solution-backtracking-dp-greedy-detailed-explanation",
                "content": "# Approach\\nGenerally, for problems consisting of subproblems, we can use the following approach find the optimal algorithm:\\n1. Write the most intuitive recursive backtracking algorithm\\n2. Memoize repeated work using top-down dynamic programming\\n3. Eliminate recursion by using bottom-up dynamic programming\\n4. Apply final tricks\\n\\nIn the end, this problem can be solved with a simple but hard-to-find greedy algorithm.\\n\\nLet\\'s walk through each step.\\n\\n\\n# Recursive Backtracking\\nAlright, so how to approach this problem? The most intuitive way is to, at each index, check every index you can go to. Then, consider every index you can go to from there. At the end, the candidate with the least indices is our answer. We can make an optimization by discarding any candidates of length greater than what we\\'ve already found to be the best, but this algorithm is still exponential.\\n```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\n\\n# Top-Down Dynamic Programming\\nClearly there is a lot of repeated work in the above algorithm. It calculates `backtrack(candidate + i, i)` for identical values of `candidate` and `i` repeatedly. By memoizing every result, we can bring the time complexity down to polynomial time, as the maximum number of iterations will be `candidate` (<=n) times `i` (=n).\\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\\nNow we get to around test case 100 before timing out. Progress, but still not good enough.\\n\\n# Bottom-Up DP\\nThe input arrays are extremely large. If we want to pass, we need to eliminate recursion.\\n\\nLet\\'s make an observation about the top-down DP: we are memoizing values that do not need to be memoized. The key intuition here is that if we have a score for index_start and index_end, we need not recompute values in the middle. Why? Well, if we can get to a certain ending index, then we can necessarily get to every index before that too.\\n\\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\\n\\n\\nOur algorithm finally passes! Why is it so much faster than the one above? After converting to bottom-up, we see that this approach is actually greedy! \\n\\nLet\\'s do even better.\\n\\n# Final Greedy Solution\\nFinally, we can get rid of trivial repeated work in order to optimize to linear time and constant space.\\n\\nWhy loop from 0 each time? Just loop from the last farthest index, which is the end of the last jump. And why store all values of dp? We only need two at a time.\\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```\\n\\n# Complexity\\n- Time complexity: O(n). We effectively loop over the list twice. Once with the outer loop, and only once with the inner loop because it considers each value in nums only once due to it moving.\\n\\n- Space complexity: O(1). We only keep track of 4 integers.\\n# Performance\\n![x](https://assets.leetcode.com/users/images/8a2c6528-eb64-42e8-af3d-22c166ede68b_1675047170.0640862.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n# Backtracking\\n# O(2^n) - Times out\\ndef jump0(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    def backtrack(candidate, end):\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Memoized backtracking (Top-down DP)\\n# O(n^2) - Times out\\ndef jump00(self, nums: List[int]) -> int:\\n    self.best = math.inf\\n    memo = {}\\n    def backtrack(candidate, end):\\n        if (candidate, end) in memo:\\n            return memo[candidate, end]\\n        if candidate >= self.best:\\n            return\\n        if end <= 0:\\n            self.best = candidate\\n        for i in range(end)[::-1]:\\n            if nums[i] + i >= end:\\n                backtrack(candidate + 1, i)\\n\\n        memo[(candidate, end)] = self.best\\n        return memo[(candidate, end)]\\n\\n    backtrack(0, len(nums)-1)\\n    return self.best\\n```\n```\\n# Bottom-Up DP\\n# O(nm) - Passes\\n#   * n = len(nums) = max # of jumps\\n#   * m = max(jumps) = max jump length\\n# At each jump, jump to the index that gives us the farthest possible next jump\\n# This works because even if the optimal next jump isn\\'t the farthest, it will be contained in range(farthest)\\n# Optimal jump will always be at an index less than or equal to the farthest possible jump\\n# dp[i+1] = max_i(nums[j]+j for j in range(dp[i]+1))\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    dp = [0]\\n    for i in range(len(nums)):\\n        dp.append(max((nums[j]+j for j in range(dp[i]+1))))\\n        if dp[i+1] >= len(nums)-1:\\n            break\\n\\n    return len(dp) - 1\\n```\n```\\n# Now the algorithm is O(n) time and O(1) space\\ndef jump(self, nums: List[int]) -> int:\\n    if len(nums) == 1: return 0\\n    last = next = 0\\n    count = 1\\n    for i in range(len(nums)):\\n        temp = next\\n        next = max((nums[j]+j for j in range(last, next+1)))\\n        if next >= len(nums)-1:\\n            break\\n        count += 1\\n        last = temp\\n\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671506,
                "title": "6-liner-c-very-easy-o-n-faster-than-93-solutions",
                "content": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE IT!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<2) return 0;\\n        int jump=1, maxi=nums[0], curr=nums[0];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            maxi=max(maxi, nums[i]+i);\\n            if(curr==i)\\n            {\\n                jump++;\\n                curr=maxi;\\n            }\\n        }\\n        return jump;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600578,
                "title": "java-easiest-code-time-complexity-o-n",
                "content": "Hi Coders,\\n\\nPlease have a look into the code with Proper comment, it will helps you to understand the code\\n\\n```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```\\n\\nPlease Please Please Upvote the code if you liked\\nThanks!!!\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\t\\tpublic int jump(int[] nums) {\\n       \\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        \\n        // max steps that we can make in one window\\n        int max_steps = 0;\\n        int cur = 0;\\n        \\n        // jumps that we need to calculate\\n        int jumps = 0;\\n        \\n        // till n-1 because we have to reach at the end point which is n-1\\n        \\n        \\n        for (int i=0;i<n-1;i++){\\n            // calculating the max at every point\\n            max_steps = Math.max(max_steps,i + nums[i]);\\n            // whenever you reached the point where you dont have steps\\n            // you need to update the step with the max_steps till this index\\n            if (cur == i){\\n                cur = max_steps;\\n                jumps++;\\n            }\\n            \\n            // if you already reached to end then no need to iterate further\\n            if (cur>n-1) return jumps;\\n            \\n        }\\n        return jumps;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045834,
                "title": "5-simple-c-solutions-brute-force-recursion-memoization-dp-bfs-greedy",
                "content": "### Approach 1 : Recursion (Brute Force)\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k^n) Where k is the max value in nums\\nSpace Complexity - O(n) Recursive Stack Space\\n\\n### Approach 2 - Recursion + Memoization\\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n + n) Recursive Stack Space + memoization table\\n\\n### Approach 3 - Tabulation\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(n) Dp table\\n\\n### Approach 4 - BFS\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nTime Complexity - O(k*n) Where k is the max value in nums\\nSpace Complexity - O(k) BFS queue\\n\\n###  Approach 5 - Greedy\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(n)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums));\\n        }\\n        return minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        return helper(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int inx, vector<int>& nums, vector<int>& dp){\\n        if(inx >= nums.size()-1){\\n            return 0;\\n        }\\n        \\n        if(dp[inx] != -1) return dp[inx];\\n        int minJumps = 10e5;\\n        for(int i=1; i<=nums[inx]; i++){\\n            minJumps = min(minJumps, 1 + helper(i + inx, nums, dp));\\n        }\\n        \\n        return dp[inx] = minJumps;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), -1);\\n        return helper(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector<int> dp(nums.size(), 0);\\n        \\n        for(int inx = nums.size()-2; inx>=0; inx--){\\n            int minJumps = 10e5;\\n            for(int i=1; i<=nums[inx]; i++){\\n                if(i + inx < nums.size()) minJumps = min(minJumps, 1 + dp[i + inx]);\\n            }\\n            dp[inx] = minJumps;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        queue<int> q;\\n        q.push(0);\\n        unordered_set<int> vis = {0};\\n        int minMoves = 0;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                int inx = q.front(); q.pop();\\n                if(inx >= nums.size()-1) return minMoves;\\n                for(int i=1; i<=nums[inx]; i++){\\n                    int newInx = i + inx;\\n                    if(vis.count(newInx)) continue;\\n                    vis.insert(newInx);\\n                    q.push(newInx);\\n                }\\n            }\\n            minMoves++;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        pair<int,int> jumpRange = {0,0};\\n        int ans = 0;\\n        while(jumpRange.second < nums.size()-1){\\n            int maxJump = 0;\\n            for(int i=jumpRange.first; i<=jumpRange.second; i++){\\n                maxJump = max(maxJump, i + nums[i]);\\n            }\\n            jumpRange = {jumpRange.second+1, maxJump};\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806520,
                "title": "java-with-comments-100-faster-o-n-time",
                "content": "* O(n) time\\n* O(1) space\\n* easy explanation\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```\\n**Don\\'t forgot to upvote, it will help others**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        \\n        //start from 0\\n        //maximum jump we can do is nums[0] or in other words i+nums[i] (i==0)\\n        //steps taken is 1\\n        //don\\'t worry for length 1 (we are at the end so no need to jump, steps 0)\\n        int n=nums.length, max_long_jump=nums[0], longest_jump=nums[0], steps=1;\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            //maximum longest jump we can make is this (same as case i==0)\\n            max_long_jump=Math.max(max_long_jump,i+nums[i]);\\n            \\n            //if our longest jump is done\\n            if(i==longest_jump){\\n                \\n                //means we need to make one more jump\\n                steps++;\\n                //now our longest jump is \"maximum longest jump\" (which we are updating everytime)\\n                longest_jump=max_long_jump;\\n            \\n            }\\n            \\n            // (in addition : if you understood so far, i assume you already get this - if longest_jump == the last element i.e. n-1, so we are done and break also)\\n        \\n        }\\n        \\n        return n==1?0:steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642940,
                "title": "o-n-d-p-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1121800,
                "title": "faster-than-any-submitted-python-code-beats-100-time-and-space-complexity",
                "content": "O(N^2) time and O(N) Space DP Solution\\n```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\\nEdit: Above Method Leads To TLE Now. Used Below Optimised Method.\\n\\nO(N) Time and O(1) space solution\\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, array: List[int]) -> int:\\n        minJumps = [float(\"inf\") for _ in array]\\n        minJumps[0] = 0\\n        for index in range(1, len(array)):\\n            for idx in range(index):\\n                if array[idx] >= index - idx:\\n                    minJumps[index] = min(minJumps[index], minJumps[idx] +1)\\n        return minJumps[-1]\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def jump(self, array):\\n        if len(array) == 1:\\n            return 0\\n        jumps, maxReach, steps = 0, array[0], array[0]\\n        for idx in range(1, len(array)-1):\\n            maxReach = max(maxReach, idx+array[idx])\\n            steps -= 1\\n            if steps == 0:\\n                jumps += 1\\n                steps = maxReach-idx\\n        return jumps+1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 949270,
                "title": "python3-o-n-solution-with-detailed-explanations",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        \\n        if len(nums) < 2: return 0                      # corner case\\n        \\n        jump = 1                                        # if not corner case, at least 1 jump is needed\\n        curr_max = max_reach = nums[0]                  # max_reach to record the max index can be reached with current # of jump\\n                                                        # curr_max to record the max index can be reached from the current index\\n        \\n        \\n        for i in range(1, len(nums)):                   # we start from index 1 if not corner case, but including 0 still works\\n            if max_reach >= len(nums) - 1:              # termination check\\n                return jump\\n            if i < max_reach:                           # if i is within the reach of current jump\\n                if i + nums[i] > curr_max:              # we update the current max reach if a larger one exists\\n                    curr_max = i + nums[i]              \\n                    if curr_max >= len(nums) - 1:       # early terminatin check, but solution still works even without this\\n                        return jump + 1                 # remember to add 1 to current jump if you use early termination\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    # here we dont jump yet until we figure out the max range we can reach \\n                                                        # if we jump one more time\\n                        \\n            else:                                       # when we enter this else statement, it means max_reach is not the end of list\\n                                                        # thus we have to jump now\\n                max_reach = max(curr_max, i + nums[i])  # we update our max_reach using the curr_max recorded so far or i + nums[i]\\n                jump += 1                               # and we add 1 to jump to add this jump\\n        \\n        return jump\\n    \\n    # TC: O(n)\\n    # n is the len(nums), as we only scan the list once\\n    \\n    # SC: O(1)\\n    # we only init 3 variables, thus space is constant\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645404,
                "title": "all-approach-from-brute-force-memoization-bottom-up-and-finally-greedy",
                "content": "***Brute Force***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\\n***Memorization***\\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\\n***Bottom-Up***\\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\\n***Greedy***\\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps));\\n        maxSteps--;\\n    }\\n    \\n    return answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        return (int)decideJump(nums,n,0);   \\n    }\\n};\\n```\n```\\nlong long  min(long long a,long long b){\\n    if(a > b)   return b;\\n    return a;\\n}\\n//assume that answer always exist\\nlong long decideJump(vector<int>& nums,int n,int currPos,vector<int>& dp){\\n    if(currPos >= n-1){\\n        return 0;\\n    }\\n    \\n    if(dp[currPos] != -1){\\n        return dp[currPos];\\n    }\\n    \\n    long long answer = INT_MAX;\\n    \\n    int maxSteps = nums[currPos];\\n    \\n    \\n    while(maxSteps > 0){\\n        answer = min(answer,1 + decideJump(nums,n,currPos+maxSteps,dp));\\n        maxSteps--;\\n    }\\n    \\n    return dp[currPos] = answer;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+10,-1);\\n        return (int)decideJump(nums,n,0,dp);   \\n    }\\n};\\n```\n```\\n//bottom up approach to this problem\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> dp(n,INT_MAX);\\n        \\n        dp[n-1] = 0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            for(int j=1;j<=nums[i];j++){\\n                if(i+j < n){\\n                    dp[i] = min(dp[i],1+dp[i+j]);\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0];\\n    }\\n};\\n```\n```\\n//now our only hope left is greedy solution that will run in O(n) time complexity and\\n//O(1) space complexity\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n == 0){\\n            return 1;\\n        }\\n        \\n        int maxReach = nums[0];\\n        int jump = 1;\\n        int step = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(i == n-1){\\n                return jump;\\n            }\\n            step--;\\n            maxReach = max(maxReach,i+nums[i]);\\n            \\n            if(step == 0){\\n                if(i >= maxReach){\\n                    return -1;\\n                }\\n                jump++;\\n                step = maxReach - i;\\n            }\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502009,
                "title": "javascript-o-n-time-and-o-1-space-extended-notes",
                "content": "To tackle this we...\\n\\n* Set the number of steps we are allowed to take from the first value in the array\\n* Iterate through the array once\\n* At each index we set a maxReach variable ( the further place in the array we can reach)\\n* At the same time, for each index we reduce the number of steps by one\\n* If we run out of steps it means we must have taken a jump to get to our current location\\n* So... we need to update the number of steps... to do this we look at how far we are from our maxReach and subtract our current index\\n* When we reach the final index we return the number of jumps it\\'s taken us to arrive there PLUS ONE . This is because we have not consumed all our final steps. \\n\\nThe iteration pattern plays out like this...\\n\\n**INITIAL SETUP**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\\n\\n**1ST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\\n\\n**2ND ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\\n\\n**3RD ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\\n\\n**4TH ITERATION**\\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\\n\\n**5TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\\n\\n**6TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\\n\\n**7TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\\n\\n**8TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\\n\\n**9THITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\\n\\n**10TH ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\\n\\n**POST ITERATION**\\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\\n\\n\\n\\n\\n**SOLUTION**\\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//   ^ \\n//   |  \\n// \\n// Max Reach: 3\\n//     Steps: 3\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//      ^ \\n//      |  \\n// \\n// Max Reach: 5\\n//     Steps: 2\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//         ^ \\n//         |  \\n// \\n// Max Reach: 5\\n//     Steps: 1\\n//     Jumps: 0\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//            ^ \\n//            |  \\n// \\n// Max Reach: 5\\n//     Steps: 0 --> Resets to 2 (maxReach of 5 minus current index of 3)\\n//     Jumps: 1\\n```\n```\\n//               ^ \\n//               |  \\n// \\n// Max Reach: 6\\n//     Steps: 1\\n//     Jumps: 1\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                  ^ \\n//                  |  \\n// \\n// Max Reach: 8\\n//     Steps: 0 --> Resets to 3 (maxReach of 8 minus current index of 5)\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                     ^ \\n//                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                        ^ \\n//                        |  \\n// \\n// Max Reach: 13\\n//     Steps: 1\\n//     Jumps: 2\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                           ^ \\n//                           |  \\n// \\n// Max Reach: 13\\n//     Steps: 0 --> Resets to 5 (maxReach 13 minus current index of 8)\\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                              ^ \\n//                              |  \\n// \\n// Max Reach: 13\\n//     Steps: 4 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                 ^ \\n//                                 |  \\n// \\n// Max Reach: 13\\n//     Steps: 3 \\n//     Jumps: 3\\n```\n```\\n// [ 3, 4, 2, 1, 2, 3, 7, 1, 1, 1, 3 ]\\n//                                     ^ \\n//                                     |  \\n// \\n// Max Reach: 13\\n//     Steps: 2\\n//     Jumps: 3\\n// At this point we have unconsumed steps meaning we need to add ONE to our jump total to represent the consumption of the remaining steps (imagine jumping from value 7 to the end)\\n```\n```\\nvar jump = function(nums) {\\n\\tif(nums.length === 1) return 0;\\n\\tlet jumps = 0;\\n\\tlet maxReach = nums[0];\\n\\tlet steps = nums[0];\\n\\tfor(let i = 1; i < nums.length - 1; i++){\\n\\t\\tmaxReach = Math.max(maxReach, i + nums[i])\\n\\t\\tsteps--;\\n\\t\\tif(steps === 0){\\n\\t\\t\\tjumps++;\\n\\t\\t\\tsteps = maxReach - i;\\n\\t\\t}\\n\\t}\\n\\treturn jumps + 1;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380429,
                "title": "java-dynamic-programming-bottom-up-solution",
                "content": "cache[i] represents the minimum number of steps taken to reach the ith index\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int[] cache = new int[nums.length];\\n        \\n        cache[0] = 0;\\n        \\n        for (int i = 1; i < cache.length; i++) {\\n            cache[i] = Integer.MAX_VALUE;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 1; j <= nums[i]; j++) {\\n                int next = Math.min(i+j, nums.length-1);\\n        \\n                cache[next] = Math.min(cache[next], 1 + cache[i]);\\n            }\\n        }\\n        \\n        return cache[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340334,
                "title": "simple-dp-very-simple-pruning-and-it-works-12ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, n+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i] < nums[i-1])\\n                continue;\\n            for (int j = 1; j <= nums[i] && (i+j) < n; j++)\\n                dp[i+j] = min(dp[i+j], dp[i]+1);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304289,
                "title": "c-greedy-boy-solution-use-magic-lasers-and-pew-pew-kitty-cats",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```\\n\\nO(N)\\n\\nWhy it works? Magic!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        \\n        int aJumps = 0;\\n        int aEnd = 0;\\n        int aFarthest = 0;\\n        \\n        for (int i=0;i<(nums.size()-1);i++) {\\n            aFarthest = max(aFarthest, i + nums[i]);\\n            if (i == aEnd) {\\n                aJumps++;\\n                aEnd = aFarthest;\\n            }   \\n        }\\n        return aJumps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18205,
                "title": "is-there-better-solution-for-jump-game-ii",
                "content": "my solution exceeds time limit.\\nI use an array to track the min step at i . It seems my solution is not efficient enough. You guys have better solution?\\n\\n    class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }\\n                track[i] = min+1;\\n            }\\n            return track[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int jump(int A[], int n) {\\n            vector<int> track(n, 0);\\n            \\n            for(int i=1; i<n; i++){\\n                int min = INT_MAX;\\n                for(int j=0; j<i; j++){\\n                    if(track[j] < min && A[j]+j >= i)\\n                        min = track[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3372877,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[-1 for _ in range(n-1)]\\n        dp+=[0]\\n        for i in range(n-2,-1,-1):\\n            for j in range(i+1,min(n,i+nums[i]+1)):\\n                if dp[j]!=-1:\\n                    if dp[i]==-1:\\n                        dp[i]=dp[j]+1\\n                    else:\\n                        dp[i]=min(dp[i],dp[j]+1)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159174,
                "title": "sundar-susheel-ubla-hua-ekdum-simple-sada-garam-garam-code",
                "content": "# Intuition\\nThe problem is similar to jump game with atmost k jumps. Here instead of knowing the k before hand , we will get the k dynamically by nums[ind]\\n\\n# Approach\\nFirst we will write the recursive logic and later memoise it.\\nFrom the 0th index we need to reach n-1 index in minimal possible steps.\\n- The base condition is that if we reach the end then return 0\\n- We will take a variable mini which will store the minimal jumps required to reach a particular index. We will initialise it with a large value.\\n- nums[ind] will define us how many steps atmost we can jump forward.\\nSo we will have a loop from ind till ind+ k , (k=nums[ind]) and we will jump till there and update the mini.\\n(We need to take care that we do not jump out of the nums vector. ind+i <=n)\\n```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n``` \\nWe will memoise it for optimisation.\\n**In main function we will pass dfs(0,n-1,nums)**\\n0 is the start index \\nn-1 is the the last index of the nums (Mentioned in ques we need to jump till n-1th index)\\n\\n# Complexity\\n- **Time complexity**:\\nTC would be O(n*k) where n is size of vector and k is the number of jumps we can take at each index.\\n\\n- **Space complexity**:\\nWe are doing recursion , so SC O(n) for recursion stack and a dp vector of O(n) space. Overall SC O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Attaching recursive code\\nint dfs(int ind,int n,vector<int>&nums)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return mini;\\n    }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(int ind,int n,vector<int>&nums,vector<int>&dp)\\n    {\\n        if(ind==n)return 0;\\n        int mini=1e9;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int k=nums[ind];\\n        for(int i=1;i<=k;i++)\\n        {\\n            if(ind+i<=n)\\n            {\\n                int jump=1+dfs(ind+i,n,nums,dp);\\n                mini=min(mini,jump);\\n            }\\n        }\\n        return dp[ind]=mini;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        return dfs(0,n-1,nums,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158649,
                "title": "c-greedy-approach-constant-space-comments-added-easy",
                "content": "# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        int jump=0;\\n        \\n        int maximum_reach=0;\\n        int max_pos=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1) return jump;\\n            maximum_reach = max(maximum_reach,i+nums[i]);      // for each particular idx storing the max jump\\n\\n            // If i has reached to it\\'s max position then we need to jump to go on next\\n            if(i==max_pos)\\n            {\\n                jump++;                          // increase jump\\n                max_pos = maximum_reach;         // assign max_reach as a max_pos for this jump\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874337,
                "title": "easy-java-solution-using-sliding-window-beats-99-89",
                "content": "The solution illustrates **BFS** using **sliding window**.\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/96d98a88-b29c-4c80-b21f-860c9f50897d_1675846588.2118175.png)\\n\\nSubmission Link: https://leetcode.com/submissions/detail/854067528/\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c3a43b2e-2e21-4ddd-bb40-4e52fb2a0e1c_1670099721.8790011.png)\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/6e4aad28-ca17-420f-a665-eface165310a_1675846567.4085553.png)\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res = 0;\\n        int l, r, farthest;\\n        l = r = farthest = 0;\\n        while(r < nums.length - 1){\\n            farthest = 0;\\n\\t\\t\\t// r+1 because we also need to include position r\\n            for(int i=l; i<r+1; i++){\\n                farthest = Math.max(farthest, i + nums[i]);\\n            }\\n            l = r+1;\\n            r = farthest;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356813,
                "title": "c-beats-99-cpp-solutions-easy-understanding-ladder-approach-linear-0-n-no-space",
                "content": "The approach which we are going to use is that we will try to move along a ladder and check that what maximum distance we can travel using ladder and while travelling the current ladder what is the maximum value ladder we get\\n\\nSteps-\\n1. steps = 0, ladder = 0\\n2. iterate the loop\\n\\t1. if ladder < i, it means ladder can not reach position i so we return -1(unreachable)\\n\\t2. if ladder >= n-1, ladder has reached the end of the array so we return steps\\n\\t3. we will iterate through i to ladder and update the ladder length and while updating we will keep track that whether we update the ladder length while traversing the ladder \\n\\t4. if yes(we are increasing the length of ladder, it means we are making a step), so we increase the step count\\n\\t\\n  3.return steps\\n\\n```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint jump(vector<int> &arr){\\n        int n = arr.size();\\n        int ladder = 0;\\n        int steps = 0;\\n        for(int i = 0 ; i < n ; ){\\n            if(ladder >= n-1){\\n                return steps;\\n            }\\n            if(ladder < i){\\n                return -1;\\n            }\\n           \\n            bool increaseSteps = false;\\n            int k = ladder;\\n            for( ; i <= k && i < n ; i++){\\n                if(i + arr[i] > ladder && ladder < n-1){\\n                    ladder = i + arr[i];\\n                    increaseSteps = true;\\n                }   \\n            }\\n            if(increaseSteps == true){\\n                steps += 1;\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257911,
                "title": "dekho-bhai-ye-koi-medium-problem-nhi-hain-ye-tum-nirbhar-karta-hain-ki-kaise-sochte-ho",
                "content": "**Dekho bhai, es problem me humlog dp bhie laga sakte hain or greedy bhie, greedy ka approach bhie dekh lo ek baar in O(N) time complexity & O(1) space complexity\\nAgar phir bhi koi probelm hain to humlog Dp bhie use kar skate hain yaha par**\\nInput ke anusar humlog guess kar skate hain Achhe se.....\\nYe arha greedy ka code\\n\\n```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```\\n**Sikhte raho bhailog hamesa\\nor agar aapko ye appraoch achha laga hoga to like jaroor kare dhaynewaad bhailog!!**",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        int reach=0; // Reach at that position after jumping from previous index\\n        int max_jump=0;  // It is in form of index only to jump at max num[max_jump]\\n        int mini_step=0;  // To count the number of step to reach at end of the index\\n        \\n            \\n            // Corner case\\n        if(n==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            max_jump=max(max_jump,i+nums[i]);\\n            \\n            if(reach==i){ \\n                mini_step++;\\n                reach=max_jump;\\n            } \\n         }\\n         return mini_step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189064,
                "title": "java-greedy-in-depth-explanation",
                "content": "If you haven\\'t completed **LC.55 Jump Game**, I\\'d recommend you to do Jump Game first. You can find [my solution](https://leetcode.com/problems/jump-game/discuss/2188884/Java-or-In-depth-Explanation-or-O(n)-time-and-O(1)-space) to Jump Game here.\\n  \\n  We also use Greedy algorithm in the solution. We need three variales `max_reach` the farthest index we can reach, `jumps` the min number of jumps to last index, `currentJumpEnd` the end index that we can jump to from the previous jump. \\n  \\n  The key point is we need to update both `jumps` and `currentJumpEnd` when `i == currentJumpEnd`. Why? We need to do so because we already reach the farthest index from previous jump. Hence, we need to jump again!\\n  \\n  ```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n  class Solution\\n{\\n    // return the min required jumps to last index\\n    public int jump(int[] nums) \\n    {\\n        // Greedy Algorithm\\n        // O(n) time | O(1) space\\n        int max_reach = 0;\\n        int jumps = 0;\\n        int currentJumpEnd = 0;\\n        \\n        for(int i = 0; i < nums.length-1; i++)\\n        {\\n            max_reach = Math.max(max_reach, i + nums[i]);\\n            \\n            if(i == currentJumpEnd)\\n            {\\n                jumps += 1;\\n                currentJumpEnd = max_reach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102498,
                "title": "java-o-n-linear-solution-greedy",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\u2705**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752007,
                "title": "simple-intuitive-short-solution-o-n-c",
                "content": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int Jump(int[] nums) {\\n        int count = 0;        \\n        int max = 0;\\n        int cur = 0;\\n        for (int i=0; i<nums.Length-1; i++)\\n        {\\n            max = Math.Max(max, i+nums[i]);\\n            if (i == cur)\\n            {\\n                count++;\\n                cur = max;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517689,
                "title": "concise-o-n-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n       if(nums.size()<2) return 0;   //base case\\n        \\n        //initialize jump=1 , we are taking jump from 0th index to the range mxjump\\n        //currjump =>we can take jump from particular  index\\n\\t\\t//mxjump => we cango up to maximum\\n\\t\\t// jump => to count no. of jump\\n        int jump=1,n=nums.size(),currjmp=nums[0],mxjmp=nums[0];\\n        \\n        int i=0;\\n\\t\\t\\n\\t\\t//till we reach last index, NOTE: Not necessary to cross last index\\n        while(i<n-1)\\n        {\\n            mxjmp=max(mxjmp,i+nums[i]);\\n             \\n            if(currjmp==i) //we have to take jump now because our currjump now ends.\\n            {\\n                jump++;//increment in jump\\n                currjmp=mxjmp; //assign new maxjmp to currjmp\\n            }\\n            i++;\\n        }\\n        if(currjmp<n-1)return -1; //we are not able to reach at the end of array because there may be some zeroes are present in given array so that we cannot move further\\n        return jump;\\n    }\\n    };\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1352149,
                "title": "greedy-dp-solutions-c-explanation",
                "content": "### DP Solution : TC = O(N^2) SC = O(N)\\n```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\\n\\n### Greedy Solution : TC = O(N)   SC = O(1)\\ncurFarthest stores the farthest value till whch the jump can be made. curEnd stores the last value of upto which last jump was made.\\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        vector<int> dp(n+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(j+nums[j] >= i){\\n                    dp[i] = min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        // for(auto it: dp){\\n        //     cout<<it<<\" \";\\n        // }\\n        return dp[n-1];\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int curFarthest = 0;\\n        int curEnd = 0;\\n        for(int i=0; i<n-1; i++){\\n            curFarthest = max(i+nums[i],curFarthest);\\n            if(i==curEnd){\\n                count++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1200738,
                "title": "3-approaches-explained-greedy-bfs-dp-o-n-solution",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 11th May, 2021\\n---------------------------------\\n\\nC++ program for\\n\\nGiven an array of non-negative integers nums, you are initially positioned at the first index of the array.\\nEach element in the array represents your maximum jump length at that position.\\nYour goal is to reach the last index in the minimum number of jumps.\\n\\nYou can assume that you can always reach the last index.\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. \\n\\tJump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nhttps://leetcode.com/problems/jump-game-ii/\\n\\nSimilar Questions:\\n    1. https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/\\n    2. https://leetcode.com/problems/video-stitching/\\n\\n------\\n\\nSolution: This can be solved by BFS or DP\\n\\n    1. Greedy: Imagine that you are at index i in the array, the element in your current position \\n        defines the maximum distance that you can jump. Therefore, your next step will fall somewhere \\n        in the range [start, end], where start is the place right next to you and end is i + nums[i]. \\n        Then the question is, where to jump?\\n        Our next move will fall somewhere between [start : end] and to find the minimum number of jumps \\n        to reach the end of the array, we must determine which place will take us the farthest in the next jump.\\n        - We use a variable currEnd which tells us about the end of the current Jump\\n        - We use a variable currFarthest which tells us about the farthest jump I can make till now.\\n        - Iterate over the array & keep keep calculating the farthest jump you can make\\n            - Once you reach the currEnd, it means that this was all you can travel without any jumps\\n                but you know that you can take a jump and reach till the currFarthest point.\\n            - So if you reach the currEnd, you take that jump (so jump++) and now your currEnd will\\n                become your currentFarthest since you can travel till that point without any jumps\\n            - You keep calculating the new currentFarthest now and once reach the currEnd again\\n                you take another jump till the new currentFarthest and this goes on till you reach the end\\n        - We see that we take a greedy approach to always delay the jump and know the max we can reach without\\n            any jumps by using currentFarthest\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(1)  \\n\\n\\t2. BFS: Since we want to get to the last index in MINIMUM number fo steps, BFS comes to mind.\\n\\t\\t- Save the index and value in a queue and keep on inserting the pair<i, arr[i]> which are reachable.\\n\\t\\t- Check if it is the last index then return num of moves\\n\\t\\t- Have a visited[] array so that you do not traverse a node more than once.\\n\\n    Time Complexity: O(n)\\n    Space Complexity: O(n)\\n\\n\\t3. DP: Create a DP array and fill it with a large number (n+1 if n is the last index, we will save indexes so n+1 is a safe large index!)\\n\\t\\t- dp[i] will store the minimum number of steps to reach dp[i]\\n\\t\\t- dp[0] = 0 since you are already standing at 0 index.\\n\\t\\t- [GIVEN] For each index the arr[i] will tell you the maximum num of steps you can take\\n\\t\\t- Loop for \\'i\\' from 0 till n\\n\\t\\t\\t- Loop \\'j\\' from start = i till end = i+arr[i] (These are all jumpable from index i)\\n\\t\\t\\t- dp[j] = minimum of \\n\\t\\t\\t\\thowever you can reach j till now (dp[j]),\\n\\t\\t\\t\\thowever you can reach \\'start\\' + 1 step (dp[start] + 1)\\n\\n    Time Complexity: O(n2)\\n    Space Complexity: O(n)\\n---\\n  NOTE: \\n*/\\n\\n// ------------------\\n// Approach 1: Greedy\\n// ------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(), currEnd=0, currFarthest=0, jumps=0;\\n        for(int i=0; i<n-1;i++) {\\n            currFarthest = max(currFarthest, i+nums[i]);\\n            if (i == currEnd){\\n                jumps++;\\n                currEnd = currFarthest;\\n                if(currEnd >= n-1)\\n                    break;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n\\n// ------------------------\\n// Approach 2: BFS SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n        \\n        queue<pair<int,int>> q;\\n        vector<int>visited(n, 0);\\n        q.push(make_pair(0,nums[0]));\\n        visited[0] =1;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                pair<int, int> f = q.front();\\n                q.pop();\\n                for(int i=f.first+1;i<=f.first+f.second; i++){\\n                    if(i==n-1)\\n                        return jump+1;\\n                    if (visited[i] == 0){\\n                        q.push(make_pair(i, nums[i]));\\n                        visited[i] = 1;\\n                    }\\n                }\\n            }\\n            jump++;\\n        }\\n        return jump;\\n    }\\n};\\n\\n\\n\\n\\n// ------------------------\\n// Approach 3: DP SOLUTION\\n// ------------------------\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==1)\\n            return 0;\\n        int jump = 0;\\n\\n        int len = nums.size();\\n        int dp[len];\\n        dp[0] = 0;\\n\\n        // Initialize it to len+1\\n        for (int i = 1; i < len; i++) {\\n            dp[i] =len+1;\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            int start = i;\\n            int end = min(i + nums[i], len - 1);\\n            \\n            for (int j = start; j <= end; j++) {\\n                dp[j] = min(dp[j], dp[start] + 1);\\n            }\\n        }\\n\\n        return dp[len - 1] == len + 1 ? -1 : dp[len - 1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193120,
                "title": "python3-solution-24-ms-faster-than-97",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        curr_pos=0\\n        distance=0\\n        jumps=0\\n        for i in range(len(nums)-1):\\n            distance=max(distance,i+nums[i])\\n            if curr_pos==i:\\n                jumps+=1\\n                curr_pos=distance\\n        return(jumps)        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192505,
                "title": "java-easiest-clear-7-lines-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int jump(int[] nums) {\\n        int count = 0, end = 0, maxFar = nums[0];\\n        for ( int index = 0; index + 1 < nums.length; ++index ) {\\n            maxFar = Math.max(index + nums[index], maxFar);\\n            if ( index == end ) {\\n                ++count;\\n                end = maxFar;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 996519,
                "title": "c-dp-with-full-explanation-and-comments-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }\\n           \\n                    \\n        }\\n        \\n        return jumps;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      \\n        int largestLadderLen = nums[0]; // signifies where max u can reach using this ladder ...\\n        int stepsLeftOnLadder = nums[0]; // main thing ... explained more below\\n        \\n        int jumps = 1; // already jumped on first ladder\\n\\t\\t// why ? coz - if there are more than 1 element in array u will atleast make 1 jump ....\\n\\t\\t// handle one element case separately below\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(i==nums.size()-1)\\n                return jumps;\\n            \\n            stepsLeftOnLadder--; // took a step to reach here ...\\n            \\n            int newLadder = i+nums[i];\\n            \\n            if(newLadder > largestLadderLen)\\n                largestLadderLen = newLadder;\\n\\n\\t\\t\\t\\t//once u find a bigger ladder u just store it n dont start using it rightaway .. \\n\\t\\t\\t\\t//use it only when u find prev ladder is exhausted .. \\n\\t\\t\\t\\t//now because u had found a \"biggr\" ladder that means that bigger ladder would\\n\\t\\t\\t\\t//give u atleast one step extra ...use the bigger ladder to move fwd ... \\n            \\n            if(stepsLeftOnLadder==0){\\n\\t\\t\\t   //prev ladder is exhausted\\n                jumps++; // jump on to a new ladder\\n\\t\\t\\t\\t\\n                 // steps left on new ladder\\n\\t\\t\\t\\t \\n                stepsLeftOnLadder =  largestLadderLen-i; \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// u might have already used some steps on last ladder\\n\\t\\t\\t\\t// now bigger ladder wont be used from start from where it ws originated ..\\n\\t\\t\\t\\t//it would be used from where current is exhauseted .. or in other words .. \\n\\t\\t\\t\\t//on what step u are  .. use from that step ...\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 541548,
                "title": "dp-and-greedy",
                "content": "Derived from [https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy](https://leetcode.com/problems/jump-game/discuss/541554/DP-and-Greedy).\\n### DP\\nDefine **state(i)** as the minimum jumps to reach i\\n**state(i) = min(1 + state(j))** for each j that can jump to i.\\nThe goal state is **state(nums.length - 1)**.\\n```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\\n### Greedy\\nJump when we have to jump, and jump to the furthest position.\\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int jump(int[] nums) {\\n        int[] state = new int[nums.length];\\n        Arrays.fill(state, Integer.MAX_VALUE);\\n        state[0] = 0;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] + j >= i) { // j can jump to i\\n                    state[i] = Math.min(state[i], state[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        return state[nums.length - 1];\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if (nums.length < 2) {\\n            return 0;\\n        }\\n        int toJump = 0, numJumps = 0;\\n        \\n        // Build maxReach array\\n        int[] maxReach = new int[nums.length];\\n        maxReach[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            // Assuming we can jump to nums[i], we can reach up to maxReach[i]\\n            maxReach[i] = Math.max(maxReach[i - 1], nums[i] + i);\\n        }\\n        \\n        // Jump when we have to and count the jumps\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == toJump) {\\n                numJumps++;\\n                if (maxReach[i] >= nums.length - 1) {\\n                    break;\\n                }\\n                toJump = maxReach[i]; // Greedy\\n            }\\n        }\\n        \\n        return numJumps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515463,
                "title": "java-100-time",
                "content": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int jump(int[] nums) {\\n        int res = 0, prev = 0, cur = 0;\\n        for (int i=0; i<nums.length-1;++i) {\\n            cur = Math.max(i+nums[i], cur);\\n            if (i==prev) {\\n                ++res;\\n                prev = cur;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18055,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Jump Game II** https://leetcode.com/problems/jump-game-ii/\\n\\n**Dynamic Programming With Memoization**\\n* Sketch the recursion tree and implement the simple solution\\n* Base case: i == N-1, return 0. i > N-1, return float('inf')\\n* Recurse through all possible jumps from index i and find the minimum\\n* Use a cache to memoize\\n* This solution gives you a run time error: maximum recursion depth exceeded while calling a Py object!\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\\n\\n**Dynamic Programming With Cache**\\n* What is minimum cost to reach index i? Minimum cost to reach index 0 is 0. \\n* For indexi, lets find all indices j less than i. Now we can take a jump from index j if and only if (i-j)<=nums[j].\\n* Time Complexity: O(N^2). Also Space complexity: O(N).\\n* This solution gives a TLE\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\\n\\n**BFS Solution to Find the Minimum Jump**\\n* Model it like graph search problem and apply BFS to solve it\\n* Even this method gives TLE since it is N^2 solution.\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\\n\\n\\n**Greedy Approach which uses \"Ladder Idea from Ideserve\"**\\n* https://www.youtube.com/playlist?list=PLamzFoFxwoNgG0Q5rqfTY6ovWSTAC9mbz\\n* The invariant is that at a start index, we already know the maximum jump index that can be reached.\\n* We therefore move from index start to current_max_index and test whether we can reach further than current_max_index. Infact, we try to be greedy - we want to pick the next start point which would make us reach the farthest from current_max_index.\\n* Once we update the next start point, we recognize that we took a single jump.\\n* Take special note of initial conditions: current_max_index, start, jumps = 0, 0, 0. This initialization helps us to tackle cases likes nums =[1]. Other when length of nums is more than 1, the first jump takes us to start index 0 and sets current_max_index to nums[0].\\n\\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, i, nums, cache):\\n        if i == len(nums)-1:\\n            return 0\\n        elif i > len(nums)-1:\\n            return float('inf')\\n        elif i in cache:\\n            return cache[i]\\n        else:\\n            cache[i] = float('inf')\\n            for j in range(1, nums[i]+1):\\n                cache[i] = min(cache[i], self.helper(i+j, nums, cache)+1)\\n            return cache[i]\\n    \\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = defaultdict(int)\\n        return self.helper(0, nums, cache)\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cache = [float('inf')]*len(nums)\\n        cache[0] = 0\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if i - j <= nums[j]: # Can I take a jump from position j and reach i?\\n                    cache[i] = min(cache[i], cache[j] + 1)\\n        return cache[-1]\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        q, levels = [0], -1\\n        while len(q):\\n            levels, new_level= levels + 1, []\\n            for x in q:\\n                for j in range(1, nums[x]+1):\\n                    if x + j == len(nums)-1:\\n                        return levels + 1\\n                    elif x + j < len(nums)-1:\\n                        new_level.append(x+j)\\n                    else:\\n                        break\\n            q = new_level\\n        return levels\\n```\n```\\nclass Solution(object):\\n    def jump(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current_max_index, start, jumps = 0, 0, 0\\n        while start < len(nums):\\n            if current_max_index >= len(nums)-1:\\n                return jumps            \\n            for i in range(start, current_max_index+1):\\n                if nums[i] + i > current_max_index:\\n                    start, current_max_index = i, nums[i]+i\\n            jumps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18060,
                "title": "share-my-greedy-solution-and-proof-for-greedy-choice-property",
                "content": "I first come up with a dp solution but after some analysis, I figured out it can be reduced to a greedy problem. My idea is borrowed from one of the great top solutions (https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy) \\n\\nHowever, it seems no one gave a formal proof that it can be solved by greedy strategy. Here is my proof:\\n\\n**Greedy choice property**\\nFor position ```t```, there exists an optimal solution in which the minimum steps is obtained by jumping from position ```i```, where ```i + nums[i] == t```.\\n\\nProof by contradiction:\\n```1)```Suppose there exist a position ```j```, ```i < j```, and ```j + nums[j] >= t```, such that the minimum steps of jumping from ```j``` to ```t``` will lower than that of jumping from ```i``` to ```t```.\\n```2)``` Let ```minSteps(k)``` denotes minimum steps at position ```k```;\\n```3)``` Such that we have ``` i < j < t``` and ``` minSteps(i) > minSteps(j)``` obtained from step ```1)```\\n```4)``` Because ``` t - i > t - j ```, it implies that ```nums[i] > nums[j]```. Therefore, ```minSteps(i) <= minSteps(j)```, which contradicts the supposition that ``` minSteps(i) > minSteps(j)```\\n\\n\\n\\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```t```\n```i```\n```i + nums[i] == t```\n```1)```\n```j```\n```i < j```\n```j + nums[j] >= t```\n```j```\n```t```\n```i```\n```t```\n```2)```\n```minSteps(k)```\n```k```\n```3)```\n``` i < j < t```\n``` minSteps(i) > minSteps(j)```\n```1)```\n```4)```\n``` t - i > t - j ```\n```nums[i] > nums[j]```\n```minSteps(i) <= minSteps(j)```\n``` minSteps(i) > minSteps(j)```\n```\\npublic class Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length <= 1) return 0;\\n        int minSteps = 0;\\n        int upperBound = 0;\\n        int reachable = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            reachable = Math.max(i + nums[i], reachable);\\n            if(i > upperBound){\\n                minSteps++;\\n                upperBound = reachable;\\n                if(upperBound >= nums.length - 1)\\n                    return minSteps;\\n            }\\n        }\\n        return minSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18109,
                "title": "my-very-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int steps = 0, s1 = 0, s2 = 0;// take steps can reach s1, take steps+1 can reach s2\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (s1 >= nums.size()-1) return steps;\\n                s2 = max(nums[i]+i,s2);\\n                if (i >= s1) {//steps is not enough, update s1 to s2 and increase steps\\n                    s1 = s2;\\n                    steps++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18160,
                "title": "concise-c-solution-bfs-16ms-20-lines",
                "content": "    class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }\\n                // move to next level.\\n                ++level;\\n                cur_begin = cur_end + 1;\\n                cur_end = next_end;\\n            }\\n            return level;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        int jump(vector<int>& nums) {\\n            int level = 0;\\n            int cur_begin = 0;\\n            int cur_end = 0;\\n            int next_end = 0;\\n            while (cur_end < nums.size() - 1) {\\n                // search [cur_begin, cur_end]\\n                for (int index = cur_begin; index <= cur_end; ++index) {\\n                    next_end = max(next_end, index + nums[index]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3834147,
                "title": "python-beats-99-99-easy-solution",
                "content": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n\\n        x = [nums[i]+i for i in range(len(nums))]  \\n        # each element in this represent max index that can be reached from the current index \\n\\n        l,r,jumps = 0,0,0\\n\\n        while r < len(nums)-1 :\\n            jumps += 1\\n            l,r = r+1,max(x[l:r+1]) \\n\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653821,
                "title": "python-dp-memo-solution",
                "content": "# Approach\\nCreate an array containing minimum steps you need to take to get to the i-th position.\\nWe can simply go through all elements of the array and then iterate over all possible jump lengths updating information in our array.\\nWe can either jump from our current position, or some other position that we considered earlier. Take the minimum of these two and you will get an answer.\\n\\n# Complexity\\n- Time complexity: $$O(nk)$$, where k is a sum of all jumps (sum of nums array)\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[float(\\'inf\\') for _ in range(n)]\\n        dp[0]=0\\n        for i in range(n):\\n            for j in range(1,nums[i]+1):\\n                if i+j<n:\\n                    dp[i+j]=min(dp[i+j],dp[i]+1)\\n        return dp[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166620,
                "title": "python-3-7-lines-greedy-w-example-t-m-91-90",
                "content": "Here\\'s the plan: \\n- We iterate through`nums`(with the exception of`nums[-1]` because at that point we have reached the target)\\n- We use`mx`to determine the most efficient jump on each iteration.\\n- We increment`ans`for each iteration\\n- We return`ans` once done with this iteration. \\n\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```\\n[](http://)\\n\\nPython 3   ||   7 lines, greedy,  w/ example   ||   T/M: 91% / 90%\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n                                            #          0 1 2 3 4\\n        ans, mx, end = 0, 0, 0              #  nums = [2,3,0,1,4]  \\n        \\n        for i, num in enumerate(nums[:-1]): #  i    num   mx    end   ans\\n                                            # \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\n            mx = max(mx, i + num)           #  0     2     2     2     1\\n                                            #  1     3     4     2     1\\n            if i == end:                    #  2     0     4     4     2     \\n                ans += 1                    #  3     1     4     4     2                \\n                end = mx \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161559,
                "title": "greedy-approach-0-n-time-and-0-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreddy Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int currreach =0;\\n        int jumps = 0;\\n        int maxreach = 0;\\n        int max = 0;\\n        for(int i = 0; i < nums.length - 1; i++)\\n        {\\n            if(i + nums[i] > maxreach)\\n                maxreach = i + nums[i];\\n            if(i == currreach)\\n            {\\n                jumps++;\\n                currreach = maxreach;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158465,
                "title": "c-easy-greedy-approach-5-liner-code-faster-than-85-of-solution",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size(),i=0,ans=0;\\n        for(int i=1;i<n;i++)nums[i]=max(nums[i]+i,nums[i-1]);\\n        while(i<n-1){\\n            ans++;\\n            i=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158364,
                "title": "c-solution-faster-than-96-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBASIC APPROACH & EASY TO UNDERSTAND\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int count=0;\\n        if(nums.size()==1 &&nums[0]==1)\\n        return 0;\\n\\n        \\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i-1],nums[i] + i);\\n      }\\n\\n      \\n      for(int j=0;j<nums.size()-1;j=nums[j])\\n      {\\n          count++;\\n      }\\n\\n      return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158003,
                "title": "daily-leetcoding-challenge-february-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3095921,
                "title": "99-45-javascript-fast-very-very-easy-to-understand-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/wmjGaq7baTM\\n\\nKorean video!\\n\\nhttps://youtu.be/6LdZUdBZGv4\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    let left = 0;\\n    let right = 0;\\n    let res = 0;\\n\\n    while(right<nums.length-1){\\n        let max = 0;\\n\\n        for(let i = left; i<=right;i++){\\n            max = Math.max(nums[i]+i,max)\\n        }\\n        left = right+1;\\n        right = max;\\n\\n        res++\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637851,
                "title": "java-complete-solution",
                "content": "Pre-requisite : https://leetcode.com/problems/jump-game/\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        if(nums.length == 1){\\n            return 0;\\n        }\\n        int max = 0;\\n        int curr = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length - 1 ; i++){\\n            max = Math.max(max , i + nums[i]);\\n            \\n            if(curr == i){\\n                curr = max;\\n                count++;\\n            }\\n            if(curr>nums.length-1){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580276,
                "title": "c-3-solutions-recursive-memoised-tabulation-code",
                "content": "**If it helps, please UPVOTE : )**\\n\\n**RECURSIVE code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**MEMOISED code:**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\\n\\n**TABULATION BOTTOM-UP code:**\\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums)\\n    {\\n        if(i == n-1)  //if reached last index then no need to move further so no steps required\\n            return 0;\\n       \\n        int mini = INT_MAX-1;                       //-1 bc in loop 1 + solve(), if solve() returns INT_MAX, 1+INT_MAX will result stack overflow\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++) //possible steps we can take from i\\n        {\\n            int temp = 1 + solve(i+j, nums); //at i take 1 step of length j, so we reach i+j\\n            mini = min(mini, temp);          //we take minimum of all steps from i to reach n-1\\n        }\\n        \\n        return mini;  //if not reached n-1, then it will not go in loop and return mini = INT_MAX-1 at some step where further going forward is not possible, back trackingto previous call temp = 1 + INT_MAX-1, mini = min(mini, INT_MAX), so we see for current j it will get INT_MAX as temp ans, while taking minimum it won\\'t affect the answer\\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(int i, vector<int> &nums, vector<int> &dp)\\n    {\\n        if(i == n-1)\\n            return 0;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int mini = INT_MAX-1;\\n        for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n        {\\n            int temp = 1 + solve(i+j, nums, dp);\\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i] = mini;  //agar n-1 tk nhi bhi pahucha, then it will not go in loop and return mini = INT_MAX \\n    }\\n    \\n    int jump(vector<int>& nums) \\n    {\\n        n = nums.size();\\n        vector<int> dp(n-1, -1);\\n        \\n        return solve(0, nums, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint jump(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        //base case for i=n-1 is 0\\n        \\n        for(int i=n-2; i>=0; i--)\\n        {\\n            int mini = INT_MAX-1;\\n            for(int j=1; j<=min(n-1 - i, nums[i]); j++)  //steps we can take\\n            {\\n                int temp = 1 + dp[i+j];\\n                mini = min(mini, temp);\\n            }\\n\\n            dp[i] = mini;  //agar n-1 tk nhi pahucha, it will return INT_MAX as min steps\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471981,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int pos=0;\\n        int des=0;\\n        int jmp=0;\\n        \\n        for(int i=0;i<nums.size()-1;i++){\\n            des=max(des,i+nums[i]);\\n            \\n            if(pos==i){\\n                pos=des;\\n                jmp++;\\n            }\\n        }\\n        return jmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378987,
                "title": "c-two-approaches-dp-greedy-must-see-explained",
                "content": "**This problem can be solve using both dp and greedy techniques.\\nSo, just trying to explain you both the techniques**\\n\\n\\u2714\\u2714  **DYNAMIC PROGRAMMING**\\n\\nclass Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }\\n        if(nums[index]==0) // if index element is zero then it is not possible to move further  return ing  large value \\n        {\\n            return 1e5;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        int ans=1e5;\\n        for(int i=1;i<=nums[index];++i)// trying all possible ways \\n        {\\n            ans=min(ans,1+solve(index+i,nums,dp)); //taking min ans\\n        }\\n        return dp[index]=ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1); //dp array\\n        return solve(0,nums,dp);\\n    }\\n};\\n**Time complexity=0(N^2)\\nSpace complexity=O(N)**\\n\\n\\n \\uD83D\\uDD25\\uD83D\\uDD25 **Greedy SOlution**\\n  \\n     class Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n\\t\\n     //simple just having maxsofar and currso far at each currso far we will update our jump\\n        int n=nums.size();\\n        int mxfar=nums[0];\\n        int currfar=nums[0];\\n        int jump=1;\\n        if(nums[0]==0 ||n==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<n;++i)\\n        {\\n            \\n            mxfar=max(mxfar,nums[i]+i); // each time take max possible\\n\\t\\t\\t\\n            if(mxfar<=i) //check if we can reach the end though not necessary for this problem\\n            {\\n                return -1;\\n            }\\n            if(currfar==n-1) // if we can reach at last we curr max\\n            {\\n                return jump;\\n            }\\n            if(currfar==i) //if currfar limit reached then again need to take a jump\\n            {\\n                currfar=mxfar;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n**Time complexity=0(N)\\nSpace complexity=O(1)**\\n**DO Upvote if it helped**\\uD83D\\uDE03\\uD83D\\uDE03",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n \\n\\t int solve(int index,vector<int>& nums,vector<int>&dp)\\n\\t\\t{\\n       \\n\\t   if(index>=nums.size()-1) //base condition if we reached at last index or beyond it \\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2260220,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int maxReach=0;\\n        int current=0;\\n        int jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            maxReach=max(maxReach,i+nums[i]);\\n            if(current==i)\\n            {\\n                jumps++;\\n                current=maxReach;\\n            }            \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866723,
                "title": "golang-simple-solution",
                "content": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc jump(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    \\n    if len(nums) == 1 {\\n        return 0\\n    }\\n    \\n    record := make(map[int]int)\\n    // key: index of num\\n    // value: min amount of steps to reach the end\\n    \\n    lastIdx := len(nums) - 1\\n    \\n    for i := lastIdx - 1; i > -1; i-- {\\n        if nums[i] >= lastIdx - i {\\n            record[i] = 1\\n        } else {\\n            for key, value := range record {\\n                if nums[i] >= key - i {\\n                    if _, exist := record[i]; exist {\\n                        record[i] = min(value + 1, record[i])\\n                    } else {\\n                        record[i] = value + 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return record[0]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814490,
                "title": "easy-to-understand-java-1ms",
                "content": "Given \\n**You can assume that you can always reach the last index.** \\nwe defintely reach end and we need to find min jumps\\n\\n**Example**\\n\\t\\t\\t\\tnums\\t=[2, 3, 1, 1, 4]\\nmaxreachablepos = [2, 4, 3, 4, 8]\\n\\t\\t\\t\\t\\tindex = [0, 1, 2, 3, 4]\\n\\t\\t\\t\\t\\t\\nintially at **index0**, we can reach upto **index2(1)**, store in max reachable pos, **increment ans**\\nat **index1**, we can can reach upto **index4**, store in cur_max\\nat **index2** we can reach upto index max reachable pos is **3** current index is **2** but we already know if we choose **index1** then we can reach **index4** which is stored in cur_max, so store that cur_max in max_reachable pos.. **increment ans**.    4 means we reaches **end** \\n\\nso we need **2** jumps to reach end\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Dont Forget to **upvote**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int maxReachablePos=0, cur_max=0, ans=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            cur_max = Math.max(cur_max, i+nums[i]);\\n            if(i==maxReachablePos){\\n                ans++;\\n                maxReachablePos=cur_max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804268,
                "title": "o-n2-easy-dynamic-programming-javascript-solution-with-o-n-extra-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```\\nFor suport, Hit Upvote :)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar jump = function(nums) {\\n    //jump[i] is the jumps required to reach from first element of aray to i\\'th position\\n    const jump = new Array(nums.length).fill(Infinity);\\n    jump[0] = 0; //Since we are already at index 0 initially\\n\\n    //Outer loop to calculate & store minimum jumps to  reach position i\\n    for( let i = 1; i < nums.length; i++) {\\n        /** Inner loop will run from 0\\'th index to i-1 index, We need to figure out\\n        * if we can jump directly from j\\'th position to i\\'th position, \\n        * if we can, then minimum jump to reach index i will be minimum of jump[i], jump[j]+1\\n        * Here \"+1\" in \"jump[j] + 1\" is for one more jump from j\\'th index\\n        **/\\n        for (let j = 0; j < i; j++) {\\n            if(nums[j] >= i-j) {\\n               jump[i] = Math.min(jump[i], jump[j]+1);\\n               }\\n        }\\n    }\\n    return jump[nums.length-1];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745102,
                "title": "easy-recursice-memoization-top-down-tabulation-solution-bottom-up",
                "content": "**Recursive Approach: Try to make recursive tree for each step**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\\n**Memoization: Recusion has overlapping subproblem, so we will memoize it**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) + O(n), Stack space + dp**\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\\n**Tabulation: we know about the base case. ie. If we are at the last step...there is no path to go**\\n**TC: O(n), Solving every state only once**\\n**SC: O(n) , dp**\\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n, nums));\\n        }\\n        return paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solve(0,n-1, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, int n,vector<int> &dp, vector<int> &nums){\\n        \\n        if(ind >= n){\\n            return 0;\\n        }\\n        if(dp[ind] != -1) return dp[ind];\\n        int paths = 1e9;\\n        for(int i = 1; i<=nums[ind]; i++){\\n            paths = min(paths,1+ solve(ind+i, n,dp, nums));\\n        }\\n        return dp[ind] = paths;\\n    }\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        vector<int> dp(n, -1);\\n        return solve(0,n-1, dp,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:    \\n    int solveTab(int n, vector<int> &nums){\\n        vector<int> dp(n);\\n        dp[n-1] = 0;\\n        for(int i=n-2; i>=0; i--){\\n            int step = 1e9;\\n            for(int j = 1; j<= nums[i]; j++){\\n                if(i+j < n){\\n                    step = min(step, 1+dp[i+j]);\\n                }\\n            }\\n            dp[i] = step;\\n        }\\n        return dp[0];\\n    }\\n    \\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        return solveTab(n, nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583901,
                "title": "c-faster-than-99-o-n-timecomplexity-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int curr_reach=0,max_reach=0,jumps=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            max_reach=max(max_reach,i+nums[i]);\\n            if(i==curr_reach)\\n            {\\n                curr_reach=max_reach;\\n                jumps++;\\n            }      \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505576,
                "title": "short-clean-java",
                "content": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int count = 0;\\n        int current_jump = 0;\\n        int last_jump = 0;\\n        for(int i = 0; i < nums.length-1; i++){\\n            current_jump = Math.max(current_jump , i+nums[i]);\\n            if(i == last_jump){\\n                count++;\\n                last_jump = current_jump;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192374,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size() == 1 || nums[0] == 0) return 0;\\n        \\n        int jumps = 0, curr = 1, reach = 0, n = nums.size(), i;\\n        \\n        while (reach < n-1 && reach + nums[reach] < n - 1) {\\n            for (i = curr; curr <= reach + nums[reach]; curr++) {\\n                if (curr + nums[curr] >= i + nums[i])\\n                    i = curr;\\n            }\\n            jumps++;\\n            reach = i;\\n        }\\n        return ++jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170736,
                "title": "java-greedy-beats-100-in-both-memory-and-time-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int jump(int[] nums) {\\n\\n\\t\\tif (nums.length == 1)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = nums.length, curr_reach = 0, max_reach = 0, jumps = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tif (i + nums[i] >= len - 1)\\n\\t\\t\\t\\treturn jumps + 1;\\n\\n\\t\\t\\tif (i + nums[i] > max_reach)\\n\\t\\t\\t\\tmax_reach = i + nums[i];\\n\\n\\t\\t\\tif (i == curr_reach) {\\n\\t\\t\\t\\tjumps++;\\n\\t\\t\\t\\tcurr_reach = max_reach;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1048278,
                "title": "c-dp-time-and-space-o-n",
                "content": "```public class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++) {\\n\\t\\t   //Figure out the max jump at index i\\n            dp[i] = Math.Max(dp[i-1]-1, nums[i]);\\n        }\\n        \\n        int index = 0;\\n        int count = 0;\\n\\t\\t//using max jump, figure out how many jumps to hit last index\\n        while(index < nums.Length-1) {\\n            index += dp[index];\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int Jump(int[] nums) {\\n        if(nums.Length < 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 714429,
                "title": "c-and-go-o-n-easiest-solution-10-lines",
                "content": "C++ \\nclass Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            } \\n              cmax = max(cmax,i+arr[i]);\\n        } \\n        return ans;\\n    }\\n};\\n\\nGO Solution for the same logic.\\nfunc max(a int,b int) int {\\n    \\n    if(a > b){\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc jump(nums []int) int {\\n    \\n    n := len(nums)\\n    if (n==1) {\\n        return 0;\\n    }\\n    var ewall, cwall, jump int\\n    for i:=0; i<n; i++ {\\n        cwall = max(cwall,i+nums[i])\\n        if i == ewall {\\n            ewall = cwall\\n            jump++\\n        \\n            if ewall >= n-1 {\\n                break; \\n            }\\n        }\\n    }  \\n    return jump\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int jump(vector<int>& arr) {\\n    \\n        int ans=0,cend=0,cmax=arr[0], n = arr.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(cend<i){\\n                ans++;\\n                cend = cmax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 559701,
                "title": "java-simple-clean-code-100-12lines-python-10line",
                "content": "Java\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\npython\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int res=0,next=0,max=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            max=Math.max(max,i+nums[i]);\\n            if(i==next){\\n                next=max;res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        arr=[0,0,0]\\n        for i in range(len(nums)-1):\\n            arr[2]=max(arr[2],nums[i]+i)\\n            if i==arr[1]:\\n                arr[1]=arr[2]\\n                arr[0]+=1\\n        return arr[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 507246,
                "title": "java-2-methods-dp-bfs-both-with-time-o-n-space-o-1",
                "content": "DP:\\n```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\\n\\nBFS:\\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```Java\\n\\t\\t/**\\n         * maxStep means the farthest position you can get to\\n         * lastMax means the farthest position you can get to with the min step now\\n         * minVal means the minimum steps it would take right now\\n         */\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = nums[0], lastMax = nums[0], minVal = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            maxStep = Math.max(maxStep, nums[i] + i);\\n            if (i == lastMax && i != nums.length - 1) {\\n                lastMax = maxStep;\\n                minVal += 1;\\n            }\\n        }\\n        return minVal;\\n```\n```Java\\n\\t\\tif (nums == null || nums.length < 2) return 0;\\n        int maxStep = 0, lastMax = 0, minVal = 0, i = 0;\\n        while (lastMax - i + 1 > 0) {\\n            minVal++;\\n            for(; i <= lastMax; i++) {\\n                maxStep = Math.max(maxStep, nums[i] + i);\\n                if (maxStep >= nums.length - 1) return minVal;\\n            }\\n            lastMax = maxStep;\\n        }\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383980,
                "title": "easy-peasy-python-o-n-one-pass-o-1-memory-solution",
                "content": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "\\t# I will start from a position and look at the position I can go from here\\n\\t# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions\\n\\t# now I will look at the point from where I can make the max jump between these two points(including the end)\\n\\t# and I will keep on carrying this.\\n\\t# Basically I will look between the current position and the max position and find the next jump that I can make.\\n\\t# So basically adding 1 jump at a time.\\n\\t\\n\\tdef jump(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln <= 1:\\n            return 0\\n        \\n        cnt = till = 0\\n        maxIdx = 0 \\n        for i in range(ln):\\n            maxIdx = max(maxIdx, i + nums[i])\\n            if i == till:\\n                cnt += 1\\n                till = maxIdx \\n            \\n            if till >= ln-1:\\n                return cnt",
                "codeTag": "Python3"
            },
            {
                "id": 324594,
                "title": "java-o-n-100-time-o-1-100-space-loop-solution",
                "content": "The first idea is that we are not interested in the path, but only the number of jumps. The greedy approach fails if we jumps over an index with a huge jump capacity.\\n\\nThe first loop transforms the problem to one where the greedy approach does succeed. It does this by realizing that if `nums[i] < nums[i-1] - 1`, then jumping to index i  is never optimal (unless it is the last index), because jumping to index i-1 will allow a farther jump. So setting `nums[i] = nums[i-1]-1` does not change the minimal number of jumps required. However, doing this for every index solves the issue of jumping over interesting indices and thus a greedy algorithm can be applied.\\n\\n```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int jump(int[] nums) {\\n        int N = nums.length;\\n        for(int i = 1; i < N; ++i) {\\n            nums[i] = Math.max(nums[i], nums[i-1] - 1);\\n        }\\n        \\n        int jumps = 0;\\n        int index = 0;\\n        while(index < N - 1) {\\n            ++jumps;\\n            index+=nums[index];\\n        }\\n        \\n        return jumps;\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 271097,
                "title": "java-1ms-greedy-solution-which-beats-100",
                "content": "We use three varaibles:\\n* ```furthest``` to record the furthest place previous step can reach\\n* ```max``` to record the furthest place current step can reach.\\n* ``` result``` to record the minimum step we need to reach the last place.\\nTraverse the array to update ```max```. Update ```furthest```  with ```max``` and ```result``` with ```result + 1```  each time current place reach the ```furthest```. Keep traversing until we reach the last place.\\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```furthest```\n```max```\n``` result```\n```max```\n```furthest```\n```max```\n```result```\n```result + 1```\n```furthest```\n```\\npublic int jump(int[] nums) {\\n\\tint furthest = 0, result = 0, i = 0;\\n\\twhile( i < nums.length && furthest < nums.length - 1 ) {\\n\\t\\tint max = 0;\\n\\t\\twhile( i <= furthest ) {\\n\\t\\t\\tmax = Math.max(max, nums[i] + i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tfurthest = max;\\n\\t\\tresult++;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242676,
                "title": "python-o-n",
                "content": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndef minJumps(arr):\\n    if len(arr) < 2:\\n            return 0\\n    jump = 1\\n    step = arr[0]\\n    reach = arr[0]\\n    for i in range(1,len(arr)):\\n        if i > step:\\n            jump += 1\\n            step = reach\\n        reach = max(reach, i+arr[i])\\n\\n    return jump\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18017,
                "title": "possibly-the-simplest-o-n-solution-with-explanation-9-lines-in-c",
                "content": "My solution is based on the observation that if you can reach index `i`, then you are always able to reach index `i - 1` too (**proof:** think of the last jump taken to reach index `i`. If it was of length `1`, then you were already at index `i - 1`. If it was of length ` >= 2`, then you could have taken a 1-unit smaller jump to land on `i -1` instead of `i`). Furthermore, following the same reasoning, if you can reach index `i` in `w` jumps, you can also reach index `i-1` using no more than `w` jumps (but perhaps even less).\\n\\nLet `reach[i]` be the farthest you can reach in the next jump assuming you are able to reach index `i`. (Remember, if you can reach in `i` in `w` jumps, then you can also reach any smaller index in no more than `w` jumps).  Therefore, `reach[i]` is simply `max(k + nums[k])` for all `k` with `0 <= k <= i`). \\n\\nYou can precompute `reach[i]` in O(n) for all `i`'s. (Note that in my code I reuse `nums` to precompute it and avoid defining a new array to save some memory.)\\n\\nAfter that you just simulate the jumps, always reaching as far as you can until you reach the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      int n = nums.size();\\n      for (int i = 1; i < n; ++i) {\\n        nums[i] = max(nums[i - 1], i + nums[i]);\\n      }\\n      int jumps = 0;\\n      for (int at = 0; at < n - 1; at = nums[at]) {\\n        jumps++;\\n      }\\n      return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18213,
                "title": "o-n-runtime-o-1-space-java-solution",
                "content": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "solutionTags": [],
                "code": "Use two pointer to keep track of lower bound and upper bound each time I move forward.\\n\\n    public int jump(int[] A) {\\n            int step = 0;\\n            int low = 0;\\n            int high = 0;\\n            while(high < A.length-1){\\n                int preLow = low;\\n                int preHigh = high;\\n                for(int t = preLow;t <= preHigh;t++)\\n                    high = Math.max(t+A[t], high);\\n                low = preHigh+1;\\n                step++;\\n            }\\n            return step;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 18099,
                "title": "sharing-my-accepted-python-code",
                "content": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "solutionTags": [],
                "code": "I think the runtime should be O(N) and space complexity is O(1).\\n\\n    def jump(self, A):\\n        if len(A) <= 1:\\n            return 0\\n        end = 0 + A[0]\\n        start = 0\\n        step = 1\\n        maxDis = 0 + A[0]\\n        while end < len(A)-1:\\n            for i in range(start+1, end+1):\\n                maxDis = max(maxDis, A[i]+i)\\n            start = end\\n            end = maxDis\\n            step += 1\\n            \\n        return step",
                "codeTag": "Python3"
            },
            {
                "id": 3791862,
                "title": "c-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo on every step and check for maximum reach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there is only one step then return 1 or if you can not take any step return -1. Initially we will start from index 1, and traverse the array and keep updating the maximum reach and decrease steps.\\n 1. Suppose you are on index 1 (i.e. nums[1] is equal to 3) so you can take 1/2/3 steps and for every step you take max of reach.\\n 2. When step==0 i.e. you can not take any more step, so you will increment the jump by 1.\\n 3. And update step by step=max_reach-1. (simple maths)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1;\\n        int step = nums[0];\\n        if(n<=1) return 0; \\n        if(step==0) return -1; \\n        int max_reach=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(i==n-1) return ans;\\n            max_reach=max(max_reach,i+nums[i]);\\n            step--;\\n            if(step==0){\\n                ans++;\\n                if(i>= max_reach) return -1;\\n                step=max_reach-i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782140,
                "title": "c-recursive-memoized-and-tabulated-detailed-solution-with-example",
                "content": "# Intuition\\nWe have to start with index `0`, and we can jump upto `0+nums[0]`, and the process goes on. Thus we have to explore all the possible ways to reach the end index in order to get minimum jumps. We will use recursion to explore all the possibilities, and then go on to the memoization and tabulation approaches.\\n\\n# Recursive Approach\\nWe will start with index 0, and will try every possible jump i.e. till nums[i] for index `i`, and count the ways (if possible) to reach end index. Here it may be possible that we land at an index greater than `n-1`, thus the base case will be `if(j>=nums.size()-1) return 0;`. \\nThe approach is simple, the possible steps from current index are `j=i+nums[i]`, we initialise `mini` to `1e7` a big number (not to INT_MAX to avoid overflow) and we explore all jumps possible from `i+1` to `j`, compare the jumps/steps achieved for each jump to mini, and store it if we get comparatively less jumps. In the end we return **res+1**, consider this example: `nums:[1,4]` this will return 0, but we know we need atleat 1 jump to reach destination, so we return **result+1**.\\n\\n```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\\n\\n---\\n\\n\\n# Memoization\\nIn memoization we avoid repeating recursive calls, thus we declare a vector `dp` of size `n`. And as here we are taking the array to be of size n, there will be slight modification in the base case: `dp[n-1]=1`. Before computing just check if it is precomputed or not and before returning store the data in the data structure.\\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Tabulation\\nThere are 3 rules for tabulation: \\n1. Write the base cases.\\n2. Reverse the looping of the changing params.\\n3. Copy the recurrence relation.\\n\\nBase case will be `dp[n-1]=0`, and the *i* loop will run from `n-2` to `0` and we copy the recurrence relation.\\n\\n## Example\\nConsider nums to be [2, 3, 1, 1, 4]\\n- Start from the second-to-last position(n-2), \\n- At i=3, j=i+nums[i] = 3+1 = 4. We can jump to position 4. Now, we need to find the minimum jumps from positions 4.\\n- At i=2, j = i+nums[i] = 2+1 = 3. We can jump to position 3 or 4.\\n- The minimum jumps needed from position 3 is dp[3] = 0 (already known). The minimum jumps needed from position 4 is dp[4] = 0 (last index, no jumps needed). Since there\\'s only one jump needed from position 3 to position 4, the minimum jumps needed from position 2 is Update dp[2] = 1.\\n- At i=1, j = i+nums[i] = 1+3 = 4. We can jump to position 4.The minimum jumps needed from position 4 is dp[4]=0 (last index, no jumps needed).Since there\\'s only one jump needed from position 1 to position 4, the minimum jumps needed from position 1 is 1+1 = 2 Update dp[1]=2.\\n- At i=0, j = i+nums[i] = 0+2 = 2. We can jump to position 2. The minimum jumps needed from position 2 is dp[2]=1. Since there\\'s only one jump needed from position 0 to position 2, the minimum jumps needed from position 0 is 1+2=3. Update dp[0]=3. \\n- The dp array is now [3, 2, 1, 1, 0]. \\n- The minimum jumps needed to reach the last index (starting from position 0) is dp[0] = 3.\\n\\n**In the iterative version, the dp array correctly represents the minimum number of jumps needed to reach the last index from each position. There\\'s no need to add +1 again at the end because the dp array already contains the correct count of jumps.**\\n\\n\\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```\\n\\nUpvote if u liked :)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return 0;\\n        return f(0,nums,dp)+1;\\n}\\n\\nint f(int i, vector<int>& nums){\\n    int j=i+nums[i];\\n    if(j>=nums.size()-1) return 0;\\n    \\n    int mini=1e7;\\n    for(int k=i+1;k<=j;k++){\\n        int steps=1+f(k,nums);\\n        mini=min(mini, steps);\\n    }\\n\\n    return mini;\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    if(n==1) return 0;\\n    vector<int> dp(n, -1);\\n    return f(0,nums,dp)+1;\\n}\\n\\nint solve(int ind,vector<int>&nums,int minJump,vector<int>&dp){\\n    int f(int i, vector<int>& nums, vector<int> &dp){\\n        int j=i+nums[i];\\n        if(j>=nums.size()-1) return 0;\\n\\n        if(dp[i]!=-1) return dp[i];\\n        \\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+f(k,nums,dp);\\n            mini=min(mini, steps);\\n        }\\n\\n        return dp[i]=mini;\\n    }\\n}\\n```\n```\\nint jump(vector<int>& nums) {\\n    //O(n)\\n    //O(n)\\n    int n=nums.size();\\n    if(n==1) return 0;\\n    vector<int> dp(n, 0);\\n    dp[n-1]=0;\\n\\n    for(int i=n-2;i>=0;i--){\\n        int j=min(n-1,i+nums[i]);\\n        int mini=1e7;\\n        for(int k=i+1;k<=j;k++){\\n            int steps=1+dp[k];\\n            mini=min(mini, steps);\\n        }\\n\\n        dp[i] = mini;\\n    }\\n\\n    return dp[0]+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781653,
                "title": "super-simple-solution",
                "content": "# Intuition:\\nThe approach to solving this problem involves utilizing the Greedy algorithm technique. The main idea is to keep track of the farthest reachable index at each step and update it accordingly. We also maintain a variable current, which represents the current boundary of the next jump. Whenever we reach this boundary (i.e., when i equals current), we update current to the farthest reachable index found so far and increment the jump count.\\n\\n# Algorithm:\\n\\nInitialize three variables: farthest, current, and jump to 0. farthest keeps track of the farthest reachable index, current represents the current boundary of the next jump, and jump is used to count the number of jumps taken.\\nIterate through the nums array from index 0 to n-2 (since we don\\'t need to jump from the last index).\\na. Update farthest as the maximum of the current farthest value and the sum of the current element nums[i] and the current index i. This is because we can reach nums[i] + i from index i.\\nb. Check if we have reached the current boundary current, which means we need to make the next jump. If i equals current, update current to the current value of farthest (as it represents the farthest index reachable from the previous jump), and increment the jump count.\\nAfter processing all elements, return the final value of jump, which represents the minimum number of jumps to reach the last index.\\nComplexity Analysis:\\n\\n# Time Complexity:\\n The algorithm iterates through the nums array once, performing constant time operations at each step. Therefore, the time complexity is O(n), where n is the length of the input array nums.\\n# Space Complexity:\\n The algorithm uses only a constant amount of extra space to store the variables farthest, current, and jump, so the space complexity is O(1).\\nOverall, the algorithm has a linear time complexity of O(n) and a constant space complexity of O(1). It efficiently finds the minimum number of jumps required to reach the last index from the first index.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int farthest=0,current=0,jump=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==current){\\n                current=farthest;\\n                jump++;\\n            }\\n        }\\n        return jump;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687480,
                "title": "beats-100-explained-greedy-approach-c",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial intuition for this approach is to use the greedy strategy to find the minimum number of jumps required to reach the last index of the input vector `nums`. The idea is to iteratively update the current farthest index that can be reached from each index, while keeping track of the current end index. Whenever the current index reaches the current end index, it means we have reached the maximum position we can jump from the previous indices. In that case, we increment the jump count and update the current end index to the current farthest index. By doing this, we move forward in the vector and continue the process until we reach the last index.\\n\\nThe intuition behind this approach is that by greedily selecting the farthest index we can reach at each step, we can optimize the number of jumps needed to reach the end. This is based on the observation that if we can reach a certain index, we can also reach all the indices before it. Therefore, we can keep track of the current farthest index and update it whenever we find a farther index to jump to.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Easily Understandable Code\\n```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n-int jump(vector<int> &nums)\\n-{\\n-    int n = nums.size();\\n-    if (n == 1)\\n-        return 0;\\n-    int left = 0, right = 0;\\n-    int jump = 0;\\n-    while (right < n - 1)\\n-    {\\n-        int farthest = 0;\\n-        for (int i = left; i < right + 1; ++i)\\n-            farthest = max(farthest, i + nums[i]);\\n-        left = right + 1;\\n-        right = farthest;\\n-        ++jump;\\n-    }\\n-    return jump;\\n-}\\n```\n```\\nclass Solution\\n{\\npublic:\\n// This function calculates the minimum number of jumps required to reach the last index \\n// of the input vector.\\n\\nint jump(vector<int>& nums) {\\n    \\n    // Store the size of the input vector.\\n    int n = nums.size();\\n    \\n    // Declare and initialize variables for jumps, current end index, and current farthest index.\\n    int jumps = 0, currEnd = 0, currFarthest = 0;\\n    \\n    // Loop through the vector until the second to last element.\\n    for(int i = 0; i < n - 1; i++) {\\n        \\n        // Calculate the farthest index we can reach from the current index.\\n        currFarthest = max(currFarthest, i + nums[i]);\\n        \\n        // If we reach the current end index, we need to jump to the next furthest index.\\n        if(i == currEnd) {\\n            jumps++;\\n            currEnd = currFarthest;\\n        }\\n    } \\n    \\n    // Return the number of jumps required to reach the last index.\\n    return jumps;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580174,
                "title": "simple-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nLooks like a greedy problem. Select the maximum index you can reach for each jump.\\nFor this, we will require to keep track of the current maximum index we can reach with given number of jumps and the farthest index we can reach if we consider to take another jump. \\n\\n# Approach\\n1. Initialize currmax = 0, farthest = 0 and the number of jumps as 0.\\n\\n2. Interate over nums, for each index i, the farthest index we can reach from i is i + nums[i]. We update farthest = max(farthest, i + nums[i]).\\n\\n3. If i = currmax, it means we have finished the current jump, and should move on to the next jump. Increment jumps, and set currentmax = farthest as we can reach till farthest with the another jump. Repeat from step 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int jumps=0,currmax=0,farthest=0;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            farthest=max(farthest,nums[i]+i);\\n            if(i==currmax){\\n                currmax=farthest;\\n                jumps++;\\n            }\\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161869,
                "title": "c-4-approaches-explained-recursive-dp-straight-forward",
                "content": "# Intuition\\nHere, future decisions depend upon past decisions. Also bigger problems can be broken and thus solved in smaller parts hence, we can use DP here.\\n\\n# Approach 1 - Recursive (TLE)\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(1)$$\\n\\n## Code\\n\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\\n\\n# Approach 2 - Top Down DP\\n\\n## Complexity\\n- Time complexity: $$O(k*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\\n\\n# Approach 3 - Bottom Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*n)$$ \\nwhere k = largest element\\n- Space complexity: $$O(n)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n# Approach 4 - Straight forward logic\\n\\n## Complexity\\n- Time complexity: $$O(n)$$ \\n- Space complexity: $$O(1)$$\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        return func(0, nums);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums));\\n\\n        return steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        vector <int> dp(nums.size(), -1);\\n        return func(0, nums, dp);\\n    }\\n\\n    long long int func(int ind, vector<int> &nums, vector<int> &dp){\\n        if(ind>=nums.size()-1)\\n            return 0;\\n\\n        if(dp[ind] != -1)   return dp[ind];\\n\\n        long long int steps=INT_MAX;\\n        for(int i=1; i<=nums[ind]; i++)\\n            steps=min(steps, 1+func(ind+i, nums, dp));\\n\\n        return dp[ind]=steps;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> dp(n, INT_MAX);\\n        dp[n-1]=0;\\n\\n        for(int i=n-2; i>=0; i--)\\n            for(int j=1; j<=nums[i]; j++) \\n                dp[i]=min(dp[i], 1+dp[min(n-1, i+j)]);\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n      for(int i=1; i<nums.size(); i++)\\n        nums[i]=max(nums[i]+i, nums[i-1]);\\n\\n      int ind=0, ans=0;\\n\\n      while(ind<nums.size()-1){\\n        ind = nums[ind];\\n        ans++;\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160826,
                "title": "c-greedy-solution-with-approach",
                "content": "# Approach\\n1. We can use a greedy approach to solve this problem. We can keep track of the current farthest index we can reach and the current end of the current jump.\\n2. We can keep track of the current farthest index we can reach by taking the maximum of the current farthest index and the current index + the value at the current index.\\n3. If the current index is equal to the current end of the current jump, we can increment the number of jumps and set the current end of the current jump to the current farthest index.\\n4. We can return the number of jumps.\\n\\n# Complexity\\n![image.png](https://assets.leetcode.com/users/images/bb65f298-e499-471b-a3f9-f2391d44c899_1675870238.6241379.png)\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int Jump(int[] nums)\\n    {\\n        int jumps = 0, curEnd = 0, curFarthest = 0;\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            curFarthest = Math.Max(curFarthest, i + nums[i]);\\n            if (i == curEnd)\\n            {\\n                jumps++;\\n                curEnd = curFarthest;\\n            }\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159922,
                "title": "clean-code-jump-game-ii",
                "content": "# Intuition\\nMINIMIZATION PROBLEM WHERE WE HAVE TO MINIMIZE NO OF JUMPS TO REACH \\nTHE END OF ARRAY.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n\\n    int util(vector<int>& nums, int idx){\\n        if(idx>=nums.size()-1){\\n            return 0;\\n\\n        }\\n        if(dp[idx]!=-1)return dp[idx];\\n\\n        if(nums[idx]==0)return (int)1e5+5;\\n\\n        int ans= 1e5+5;\\n        for(int i= nums[idx]; i>=1; i--){\\n            ans= min(ans, util(nums, idx+i)+1);\\n        }\\n        return dp[idx]= ans;\\n    }\\n    int jump(vector<int>& nums) {\\n        dp.resize(nums.size()+1, -1);\\n\\n        return util(nums, 0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158946,
                "title": "python3-o-n-easiest-solution-beats-97-runtime-89-memory",
                "content": "# Approach\\n1. The aim is to get to the second last index, so a variable `n` with value of one less than length of `nums` list is inialized.\\n2. Three more variables are initialized with their value as zero : \\n    - `max_jump_index` : it will help in getting the maximum index to which jumping is possible.\\n    - `jumps` : count of jumps\\n    - `finish` : the end index from a particular jump\\n3. Iterate through the range `0` to `n` while calculating : \\n    - `max_jump_index` as maximum of itself or sum of current index and index till jumping is possible.\\n    - if the index is equal to the finish then `jumps` is incremented.\\n    - the new `finish` is the `max_jump_index`\\n4. After all the iterations `jumps` is returned.\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```\\n---\\n\\n### Happy Coding \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n\\n---\\n\\n### If this solution helped you then do consider Upvoting \\u2B06.\\n#### You can connect with me on LinkedIn : [Om Anand](https://www.linkedin.com/in/om-anand-38341a1ba/)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```python []\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n= len(nums)- 1\\n\\n        max_jump_index, jumps, finish= 0, 0, 0\\n\\n        for i in range(n):\\n            max_jump_index= max(max_jump_index, i+ nums[i])\\n\\n            if i== finish:\\n                jumps+= 1\\n                finish= max_jump_index\\n\\n        return jumps\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1711786,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1566472,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569596,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1570678,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568248,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568727,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1569674,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1575543,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1573427,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1568870,
                "content": [
                    {
                        "username": "tanti1234arjun",
                        "content": "i cant uderstand what is the question actually"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "You start from the first step ( `nums[0]` )\\nAt each step you can jump from your current step to `1 to num[0]` steps forward.\\nRepeat the above operation until you reach to the end.\\nAt last, return how many times you have jumped."
                    },
                    {
                        "username": "SOONG-E",
                        "content": "me neither\\n"
                    },
                    {
                        "username": "gepo",
                        "content": "if the first jump step is 0, it means you can never reach the end.\\nthen what is the result?"
                    },
                    {
                        "username": "eeddyy",
                        "content": "[@calm27](/calm27)  hahaha"
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "It\\'s guaranteed that you can reach nums[n - 1].  Read the constraints."
                    },
                    {
                        "username": "ayodudewth",
                        "content": "[@calm27](/calm27) Just realized that it\\'s already been 8 years since 2015. It was like yesterday..."
                    },
                    {
                        "username": "YuPengChen",
                        "content": "Given the description of the problem, the only valid test case is ```[0]``` if the first jump is ```0```. The answer should be ```0``` since no jumps are needed to reach ```n-1```, where ```n``` equals ```1```."
                    },
                    {
                        "username": "Ak_15",
                        "content": "[@dmkurilov](/dmkurilov) 1 is the answer right?"
                    },
                    {
                        "username": "calm27",
                        "content": "bro spent 8 years waiting for explanations "
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "It is given that answer exist then the first has to be the last step so answer is zero."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "[@Knight-03](/Knight-03), it\\'s wrong. `nums = [0]`  is a valid testcase."
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "It is provided that the test case are designed in a way that you will reach the end. You just have to find the optimum solution"
                    },
                    {
                        "username": "Evil_123",
                        "content": "read question one more time (The test cases are generated such that you can reach)"
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@AlecLC](/AlecLC) [0] is valid case. You need no jumps to reach the end since you start at the `n-1`."
                    },
                    {
                        "username": "Knight-03",
                        "content": "check before you do any other iteration\\nif ( nums[0] == 0) return -1; "
                    },
                    {
                        "username": "AlecLC",
                        "content": "LC says the result should be 1. But I think you\\'re right; [0] should not be a test case because it\\'s impossible to reach the end by the given rules. This one got me; had to put in a special case to handle it in order for the algorithm not to return 0"
                    },
                    {
                        "username": "NotSlypher",
                        "content": "it is given that the test cases are supposed to reach the end"
                    },
                    {
                        "username": "devilsblast",
                        "content": "it will be large value like INT_MAX "
                    },
                    {
                        "username": "Ashish_El",
                        "content": "The given question already mentioned that test case is generated in such a way you can reach n-1."
                    },
                    {
                        "username": "supermatthew",
                        "content": "My first thought for this problem, before learning the O(N) solution, was to make a memo:\\n**MinJumpsToEnd[i]**=minimum jumps to the end, starting from index i.\\nThe base case is MinJumpsToEnd[n-1]=0.\\nThen we fill the remaining entries from back to front. \\n\\nThe rule is:\\n**MinJumpsToEnd[i] = 1 + min { MinJumpsToEnd[i+1],MinJumpsToEnd[i+2],...,MinJumpsToEnd[i+k] }**\\nwhere k = nums[i].  However, taking this minimum requires k operations, and since k is an int, then computing this for the entire array can take **O(N^2)** time since the span of elements over which we take the minimum could go to the end of the memo.\\n\\nThere is a data structure called [segment tree](https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/), that given some array, A[i], allows computations of min{A[i],...,A[j]) in O(Log N) time rather than O(N).  It also allows updates of A[i] in O(Log N) time.\\n\\nConsider this with nums = [2,3,1,1,4].\\nInitially the memo MinJumpsToEnd = [\\u221E,\\u221E,\\u221E,\\u221E,0].\\nWe now build our segment tree off of this memo;\\nFor i = 3 (second-to-last element), we calculate minimum{memo[4]} = minimum{0} = 0, to get\\nMinJumpsToEnd = [\\u221E,\\u221E,\\u221E,1,0]. Then we update the segment tree with the \\u221E becoming 1.\\nFor i = 2, we calculate minimum{memo[3]} = minimum{1} = 1 to get\\nMinJumpsToEnd = [\\u221E,\\u221E,2,1,0]. Again we update the segment tree with the \\u221E becoming 2.\\nFor i = 1, we calculate minimum{memo[2],memo[3],memo[4]} = minimum{2,1,0} = 0, to get \\nMinJumpsToEnd = [\\u221E,1,2,1,0]. Update segment tree.\\nLastlt for i = 0, we calculate minimum{memo[1],memo[2]} = minimum{1,2} = 1 to get\\nMinJumpsToEnd = [2,1,2,1,0] and return 2.\\n\\nThe point is that we keep the segment tree accurate at each step to allow the potentially linear time calculation of minimum{...} to take place in Log N time instead.\\n\\n*Don\\'t do this since there is an O(N) solution.  This is just to demonstrate how you can do a DP solution in better than O(N^2) time.*"
                    },
                    {
                        "username": "t3rm",
                        "content": "bro putting Segtree in a interview problem :D"
                    },
                    {
                        "username": "bumholio",
                        "content": "The back to front DP version with min() jump scanning is exactly what I\\'ve implemented, in a tabulated format since recursion is for sissies. I was so proud of my accomplishment until I saw my solution was taking 5 times more time; when I saw the simple version it felt like Kadane\\'s professor must have felt when Kadane devised a O(n) in minutes after taking a lecture on the best known variant at that time. Fuck these wunder kids, back in my time all we had were relays. "
                    },
                    {
                        "username": "practice-Makes-Perfect-",
                        "content": "I also did a memoization approach. Can someone point to the O(N) solution you are talking about?"
                    },
                    {
                        "username": "DebashishDeka",
                        "content": "Jump Game 2:\\n\\n[A -- B -- C -- D -- E -- F -- G]\\n\\nAssume, you can jump from A to D at max. So you jumped (+1)\\nand came to D. At D, you are thinking to jump further right\\nBut then some QS came to your mind.\\n\\n1. Is D is the best place to jump further right ?\\n2. What if B was having a better jump beyond D in right side. What if C does even better ?\\n3. So, basically, we have three choices - [B,C,D] to jump beyond D assuming the fact that\\nwe already jumped from A (where ? not sure yet, no need also, we just need count)\\n4. So, we will keep maintaining maximum possible jump provided by B, C and D and choose the best one.\\n5. B,C,D becomes kind of similar in terms of jumping beyond D, we just need to choose the best jump \\nat D and do a +1"
                    },
                    {
                        "username": "abhishek0207",
                        "content": "![image](https://assets.leetcode.com/users/abhishek0207/image_1574817265.png)\\n"
                    },
                    {
                        "username": "Barun21",
                        "content": "when she says \" I like you but as a friend\"."
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "The acceptance rate will not be such low if allowing to use original recursion"
                    },
                    {
                        "username": "looser8271",
                        "content": "if u are using recursion try to memoize it "
                    },
                    {
                        "username": "badjatesoham",
                        "content": "dp?\\n"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "*bruh moment*"
                    },
                    {
                        "username": "dennychen31415926",
                        "content": "The common solution here is a BFS, ie. consider all possible nodes that can be reached in one step, then expand those nodes to get the range of possibilities for the next step.\\n\\nConsider the following counterexample for a BFS solution:\\n\\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until end of 10000 length array)]\\n\\nOf note is that:\\n\\n1. On the first step, the first 5000 elements of the array are visible.\\n2. On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step.\\n3. The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\\n\\nSo the algorithm will need to run 5000 steps, each of which must consider 5000 nodes. This seems like O(n^2) behavior to me, rather than O(n). Did I miss something?\\n\\nAdmittedly, this is a contrived input I designed from adversarial thinking, but iirc big O notation was \\'worst case\\'."
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "Here is something that might help: \\n1 - On the first step, the first 5000 elements of the array are visible. [True. The maximum reachable index is 5000]\\n2 - On all subsequent steps, the first 5000 elements do not help push the right pointer any further. It only moves 1 element each step. [Almost. The maximum reachable index is nums[i] + i  which is 5001. Once your right pointer has moved across this entire slice, we can \"jump\" the left pointer to the element that produced the maximum reachable index e. g if  the i-th element gave you nums[i]+ i then your left pointer can simply be moved to i] \\n3 - The left pointer also only moves 1 element each step, as all possibilities need to be considered. ie. even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000. [The left pointer does not need to move one step only. It can jump to the element that produced the maximum reachable index e.g if the right pointer moved across a slice [i, ..., i+k] and determined that the maximum reachable index is j, then the left can simply jump to j. At most, you are visiting each index twice, which is O(2n).  \\n\\n\"even if nums[i] is 50, nums[i+1] still must be considered, as it could be 10000.\" Yes, if nums[i+1] will be visited. Our left pointer will only be moved to an index inside the slice that right has gone through. This way, we never miss nums[i+1]. \\n\\nlet me know if this helps "
                    },
                    {
                        "username": "Vikram1511",
                        "content": "testing as custom input for [1,2] case giving me correct answer as expected, but when i submit the code it shows that my answer is wrong for the same test case? whats wrong"
                    },
                    {
                        "username": "Saimu_12",
                        "content": "![image](https://assets.leetcode.com/users/images/d9182472-aa7d-4914-8052-025f744bb59c_1626495194.6247609.png)\\nWhy Leetcode behave like these \\nGiving different answer on same output"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@ValyaVyrodova](/ValyaVyrodova) this is late but hes asking why its wrong, since he ran the same code twice...\\n\\nas mentioned by jemish, its probably static/global variable shenanigans "
                    },
                    {
                        "username": "jemish_169",
                        "content": "May be you used Static variables or global variables, so custom test cases are few then it can pass it and for whole dataset it can\\'t.  "
                    },
                    {
                        "username": "ValyaVyrodova",
                        "content": "Input - is the data, that we give to our code\nOutput- this is your result. \nStdout - this is \"console.log\" in your code. \nExpected - is the right result that you need to receive.  \nSo in the first screen your code is wrong, because output is must to be equal to expected, and in the second screen you code is give the correct result(because Output === Expected)\n\n*Maybe you just confused input and output"
                    },
                    {
                        "username": "silver_archon",
                        "content": "Most important rule: \\nYou **DO NOT** have to jump EXACTLY *x* spaces. Rather, you can **CHOOSE** to jump 1. 2. 3....*x* spaces.\\n\\nTherefore, suppose *num[i] < num[j*] and  *i< j*, then simply jump to *num[j]* if given the choice, since *num[j]* can cover all the positition coverd by *num[i]*. Therefore bigger the number the better, it means more choice.\\n\\nFor example:\\nnum[2] = 3, num[3] = 5.\\nIf you can choose between jump to idex 2 or 3, then you should jump to index 3. Because index 2 can jump to index 3, 4, 5, while index 3 can jump to 4, 5, 6, 7.\\n\\nIn conclusion: The problem can be solved using this simple greedy algorithm. The key to improving run speed of the solution is to realize that when choosing which index to jump to, always pick the the one that gives the maximum possible distance, which is given by ***index + num[index]***"
                    },
                    {
                        "username": "leetcode_deleted_user",
                        "content": "My main question about this problem is: What about array elements with value 0?\\nI can think of at least one situation where you would never be able to reach the end if you ran into a zero, namely input [2,1,0,5,2], and I am sure others can be found.\\nAs there are solutions that have passed this test, I can only assume that:\\n\\n - either trial-and-error have lead to the correct way of handling the situation;\\n - or none of the problem inputs actually have such a solution.\\n\\nSo, which one is it? And, to make it clear, how would one be expected to handle 0? Can we just assume that we would never hit a situation where 0 stops us from jumping on?\\n\\nMany Thanks,\\nMike"
                    },
                    {
                        "username": "rkroll17",
                        "content": "Hello comment from 2014. Description states: \"The test cases are generated such that you can reach nums[n - 1]\"."
                    }
                ]
            },
            {
                "id": 1815653,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1754394,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1576567,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1724178,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1978121,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1967279,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1872396,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1793015,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1792990,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1760231,
                "content": [
                    {
                        "username": "user5425SM",
                        "content": "typo in question phrase \"Return the minimum number of jumps to reach nums[n - 1].\" should be \".... number of jumps to reach n-1\""
                    },
                    {
                        "username": "The_error",
                        "content": "I think the question is correct. there can be multiple ways to jump and reach n-1, but it is asking to return the min jump required."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Instead of going back to front... trying going front to back."
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "Yeah\\nI want to know whether it is possible to solve this with Bottom up approach at all??"
                    },
                    {
                        "username": "abhijat_gupta",
                        "content": "Use case:\\n[4,1,1,3,1,1,1]\\n\\nMentioned expected output:2 jumps\\nCorrect expected output:3 jumps \\n\\nExplanation:\\n\\nwhen at index=0, i.e element=4, once can jump to index=4, i.e., element=1 => jumps=1\\nwhen at index=4, i.e element=1, once can jump to index=5, i.e., element=1 => jumps=2\\nwhen at index=5, i.e element=1, once can jump to index=6, i.e., element=1 => jumps=3\\n\\n\\nFeel free to correct me if I am wrong somewhere.\\n\\nthanks,\\nAbhijat\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "nums[0] -> nums [3] / nums [3] -> nums[6]\n= 2 jumps. "
                    },
                    {
                        "username": "rmramkumar",
                        "content": "[@Ankroh](/Ankroh) yah je is correct the value of nums[0] is the maximum jump and the selection of you need not be the maximum;"
                    },
                    {
                        "username": "Ankroh",
                        "content": "you can jump from 1 to 4 ,not only 4 !!\\nso you will jump to index 3 and from there to last index!"
                    },
                    {
                        "username": "miosokic",
                        "content": "goal it to reach n-1 not nums[n-1]"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "How come this testcase evaluates to the wrong answer for me:\\n\\nnums = [3,2,1]\\noutput = 2\\nexpected = 1\\n\\nHow can you make one jump from index 0 to index 2, when the nums[0] == 3 ?\\n\\nCan somebody please explain this ?"
                    },
                    {
                        "username": "user5797Xc",
                        "content": "Yup realized it later, thanks!"
                    },
                    {
                        "username": "spf4000",
                        "content": "Actually re-read it, 3 is the MAX number of jumps, you can still jump less"
                    },
                    {
                        "username": "spf4000",
                        "content": "I have the same issue. Half the test cases expect you to jump by nums[i] and the other half nums[i]-1"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I found the easiest solution for this was to start at the back end of the array and see what the furthest point towards the front you could reach and then repeat from there. Don\\'t need to worry about 0s or which point reaches further or anything really. Just search the array to find the max value and use that as your maximum steps back."
                    },
                    {
                        "username": "olegmak",
                        "content": "Is this a valid test case?\\n[2,1]\\nI think not because problem states that i + j < n but 0 + 2 < 2 is false (i = 0; j = 2; n = 2)"
                    },
                    {
                        "username": "Kikimora",
                        "content": "May I see all test cases if submit is successful?"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "don\\'t you think that this daily challange was the 3rd greedy problem in a row ...\\nanyways happy leetcode journey to one who is reading."
                    },
                    {
                        "username": "huanda1412",
                        "content": "I interpreted the question as a shortest path question without weightage, so I did a BFS with a queue. Turns out it is not efficient."
                    },
                    {
                        "username": "MaddyM",
                        "content": "It\\'s not the fastest, but it does get a correct solution \\uD83E\\uDEE1"
                    }
                ]
            },
            {
                "id": 1715945,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576140,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572683,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572500,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1572142,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571110,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571111,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1571112,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 1576598,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2041431,
                "content": [
                    {
                        "username": "leopoldkot",
                        "content": "Could someone help with a formal DP recurrent equations for this problem and show what is the optimal subproblem here? I don\\'t see an official submission here and all solutions I found in the solutions are very hand wavy (e.g. using hidden inner loops inside `min` functions) and don\\'t look like DP, especially don\\'t look like a tabulated solution where you would look up a fixed index offset in the past.\\n\\n(Mine solution is a `O(n)` greedy one, but I want to learn to discover DP optimal substructures)."
                    },
                    {
                        "username": "MaddyM",
                        "content": "Breadth first search maybe? Not particularly fast because of how many \"edges\" you can get, but tracking the distance for each visited index is somewhat DPish"
                    },
                    {
                        "username": "andvalsol",
                        "content": "According to the example 1 provided in the example we have the following\\n**Input**: [2,3,1,1,4]\\n**Output**: 2\\n\\nThe previous logic would be choose the first index (2), jump only once and the use the second value (3) and jump three times, ending at the last index, two jumps were needed, therefore the output is two.\\nHowever, for the following:\\n**Input**: [3,2,1]\\n**Output**:  1 \\nAs we can see the expected output is 1, using the same logic the value choosen was 3 which if chosen would jump over the index that we want.\\nDoes this means that it doesn\\xB4t matter if we jump over the last index?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The value is the **maximum** jumping distance. You can jump **up to** that distance. In this case you can jump up to 3 places, but you only need to jump 2 places to land on nums[n-1]. "
                    },
                    {
                        "username": "jlee243",
                        "content": "on the note it says: `You can assume that you can always reach the last index.`, so the description should mention positive integers instead of non-negative integers.  cases like [3,2,1,0,1] should be illegal following the rules that each element in the array represents your max jump length"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Not really. You can design cases with zeros in the array where you'll still be able to reach the last index (check the second example). That's all the description says and it's accurate."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "The problem description says the array has non-negative integers. This means it can has 0. When it evaluates the test cases, if you move into 0 it treats it like a 1. (You can find out this behaviour by running [0,0] and observe the expected answer of 2.) \\n\\nThis reduces the difficulty of the problem and makes the greedy one-pass solution possible to solve all test cases. This makes DP, BFS, DFS, backtrack, etc. over kill.\\n\\nIn my opinion, this problem only deserves a \"hard\" rating if it removes the assumption that the last position can always be reached and requires you to return -1 when it is impossible to move to the last position. And the evaluation has to respect that moving into a 0 means \"you\\'re stuck\".\\n"
                    },
                    {
                        "username": "fengshenfeilian",
                        "content": "You can try to reach max position in every step and update the max position until you reach the last point."
                    },
                    {
                        "username": "superplane",
                        "content": "For input [0,0,0,0,0], the test case gives solution of 4, while the destination can't be reached. Do we assume that the final index can always be reached?"
                    },
                    {
                        "username": "nph87903",
                        "content": "As it is mentioned, all the numbers are non-negative. If we include \"0\". most of the solution would fail.\\n\\nwish to consider this condition or change the description."
                    },
                    {
                        "username": "zhukov",
                        "content": "Since the array may contain 0, it is possible that n -1 is unreachable from 0, e.g.,\\nA[] = {0, 1, 2, 3} or {1, 0, 2, 3}.\\n\\nIf the array only contains positive integers, there always exists a minimum number of steps which is not greater than n - 1 since each step we can advance at least 1 index."
                    },
                    {
                        "username": "MickShow",
                        "content": "![image](https://assets.leetcode.com/users/images/2ecbe54e-b3e5-4c9b-a06a-12351fb5b731_1649493744.2732766.png)\\n"
                    },
                    {
                        "username": "NishchaySharma",
                        "content": "this code cleared 49/109 test cases, is there any possibility to make it pass all of them? what changes can help? \\n\\nvar jump = function(nums) {\\n    let count = 0\\n    if(nums.length <= 1)\\n    return 0\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i] == nums[0]){\\n            nums[i] = nums[i+1]\\n            ++count;\\n        }\\n    }\\n    return count\\n};"
                    }
                ]
            },
            {
                "id": 2038617,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2031441,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2027619,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2023096,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2010645,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 2003821,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1971719,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1968525,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967322,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1967271,
                "content": [
                    {
                        "username": "JOON1234",
                        "content": "Anyone have tips on how I can optimize my BFS code? I already solved problem using bottom-up DP so I am trying to solve it in an alternative approach. I am getting \"Memory Exceeded Error\" on some inputs: \n\n ```\nfrom collections import deque \nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        #can also solve using bfs traversal => keep track of nodes labeled by index positions\n        #using queue data structure! The first index position that equals end (n-1) one that \n        #is reachable in fewest number of edges from root to itself in rec. decision tree =>\n        #implies is reacahble in fewest # of jumps! \n        n = len(nums)\n        q = deque()\n        #start off bfs starting from index = 0! \n        q.append(0)\n        #now, process continuously as long as queue is non-empty! \n        minJumps = 0 \n        while q: \n            #at the very beginning, we should get length of queue => tell us # nodes\n            #we must go through at current level! \n            numNodes = len(q)\n            #process all nodes \n            while numNodes: \n                #current index! \n                cur = q.popleft()\n                #check if cur == n-1! If so, we reached end! \n                if cur == n-1:\n                    return minJumps \n                #from current index, see max upper bound for jump quantity! \n                maxJump = nums[cur]\n                #I can simply add next positions we can reach by jumping various quantities\n                #ranging from [1, maxJump]. Make sure we jump positive quantity or we stay still! \n                for i in range(1, maxJump+1):\n                    #add to queue to process lateR! \n                    q.append(cur + i)\n                #before we move to next iteration and expand our cur node's children, we should\n                #increment minJumps count since we move to next level of rec. dec. tree graph\n                #in bfs traversal! \n                numNodes -= 1 \n            minJumps += 1 \n        return minJumps \n```"
                    },
                    {
                        "username": "vinayvarma_45",
                        "content": "class Solution {\\npublic:\\n    long long int func(int i,int n,vector<int> nums,long long int& temp,int v,vector<long long int>& dp){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        v++;\\n        // cout<<v;\\n        for(int ind = 1;ind<=nums[i];ind++){\\n            temp = min(temp,v+func(ind+i,n,nums,temp,v,dp));\\n        }\\n        return dp[i] = temp;\\n    }\\n    int jump(vector<int>& nums) {\\n        int n =nums.size();\\n        long long int temp = INT_MAX;;\\n        vector<long long int> dp(n,-1);\\n        return func(0,n,nums,temp,0,dp);\\n    }\\n};\\nthe same code when used with recursion is giving expected output but while using memoisation it is giving wrong value \\none example for this is [2,3,3,0,1,2]\\ncan anyone share their opinion on this about where the code is missing the trick"
                    },
                    {
                        "username": "jukov",
                        "content": "Me: want to train DP.\\nSolution: greedy.\\n\\nThanks for proper tagging."
                    },
                    {
                        "username": "kapilchn7",
                        "content": "what the hell is wrong with this test case, \\n[4,1,1,3,1,1,1], my answer is 3 expected is 2,\\n\\nIf we start from 0th index, then we would land at 1 next to 3 not on 3, \\n\\n[2,3,0,1,4] another example, my answer is 2 expected is 2\\nwe first take 1 step to reach 3, then we take 3 steps to reach 4"
                    },
                    {
                        "username": "kapilchn7",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Thank you, I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each element nums[i] represents the **maximum** length of a forward jump.  \\nYou can do smaller jumps if that\\'s advantageous.  \\nIn your first example you can just 3 to get to index 3, then another 3 to get to 6, the target.  \\nIn your second example you can jump 1 to get to index 1, then 3 to get to index 4, the target."
                    },
                    {
                        "username": "rameshwar_prasad",
                        "content": "unable to get problem task please help me understand this problem."
                    },
                    {
                        "username": "RazPatel",
                        "content": "Try to use BFS"
                    },
                    {
                        "username": "ketkiambekar",
                        "content": "In the question statement,\n\n `you can jump to any nums[i + j] where`\n\nshould actually be\n\n `you can jump to any nums[i]+j where`\n\nThat should reduce the confusion\n"
                    },
                    {
                        "username": "Mostafaabdallah_",
                        "content": "why in the case of nums = [1,2,3] the output is 2 not 1 ? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "At index 0, we have 2 choices, either jump 0 step or jump 1 step.\\nWe will jump 1 step and reach index 1. // 1st Jump\\nAt index 1 we have 3 choices, jump 0,1,2 steps.\\nWe will jump 1 step and reach index n-1. // 2nd Jump\\n\\nSo output is 2, we need to make minimum 2 jumps."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "everyone, try O(n) solution, greedy BFS approach.\\nFeeling good after solving."
                    },
                    {
                        "username": "rayancsdc",
                        "content": "The recommended approach in this scenario is to use breadth-first search (BFS), which involves considering all possible nodes that can be reached in one step and then expanding those nodes to determine the range of possibilities for the next step.\n\nLet's examine a counterexample to demonstrate the potential inefficiency of a BFS solution:\n\nConsider the following sequence:\n\n[5000, 5000, 4999, 4998, 4997, 4996... 1, 1, 1, (1 repeated until the end of a 10000-length array)]\n\nKey observations:\n\nDuring the first step, the first 5000 elements of the array are visible.\nIn all subsequent steps, the first 5000 elements do not contribute to pushing the right pointer any further; it only moves forward by one element each step.\nThe left pointer also moves forward by only one element each step, as all possibilities must be considered. For example, even if nums[i] is 50, nums[i+1] still needs to be evaluated as it could be 10000.\nConsidering these factors, it appears that the algor[i](https://yumzlab.com/collections/mushroom-gummies-amanita-muscaria)thm would need to execute 5000 steps, with each step considering 5000 nodes. This suggests an O(n^2) behavior rather than O(n). Did I overlook something?\n\nI acknowledge that this is a contrived input I created through adversarial thinking. However, if I recall correctly, big O notation represents the \"worst-case\" scenari"
                    }
                ]
            },
            {
                "id": 1960871,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1958603,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1918874,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1868324,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1854696,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838890,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838856,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806089,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793545,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793533,
                "content": [
                    {
                        "username": "Haneet_Arya",
                        "content": "Always remember a concatenated print statement can create TLE"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "I have solution in java if you want to see, follow this link: https://leetcode.com/problems/jump-game-ii/submissions/987677306/"
                    },
                    {
                        "username": "YonatanHen",
                        "content": "Using the following solution:\n\nclass Solution:\n    def jump(self, nums: List[int], x:int = 0) -> int:\n        # if array length == 1 return jumps\n        if(len(nums) == 1):\n            print(nums)\n            if(x==0):\n                return x\n            return x+1\n        elif(len(nums) == 0):\n            return 0\n        # find the distant index from the last value in the array\n        # slice the array from start to the index found\n        # run the function again by adding the jump number\n        indices = \n        return self.jump(nums[:min([i for (y, i) in zip(nums, range(len(nums)-1)) if len(nums) - i -1 <= nums[i]])], x + 1)\n\nWhy [1,2] did not return the expected results? what is wrong?"
                    },
                    {
                        "username": "miha4406",
                        "content": "They just want you to choose an option with longest reach, so if it\\'s [2,3,1,1,4], you have to choose 3, coz it\\'s index+value is larger than in case of 1: (1+3)>(2+1).  That\\'s all.  About [0], you need 0 steps to reach the last element, so it\\'s 0.  "
                    },
                    {
                        "username": "Django_Developer",
                        "content": "can someone explain to me what is \"j\" in that problem? Why people are so obsessed with giving variables such an abnormal names?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "From the instructions: \"if you are at `nums[i]`, you can jump to any `nums[i + j]` where: `0 <= j <= nums[i]` and `i + j < n`\"  \nIn other words: If you are at `nums[i]` you can choose the length of your jump within the range `[0, nums[i]]` (but not jump beyone the end of `nums`.)\n"
                    },
                    {
                        "username": "aelrouby",
                        "content": "[4,1,1,3,1,1,1] this test case does not look correct.\\nit is expecting 2, while the correct answer is 3"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I have found what appear to be incorrect test cases in previous problems and so have just tested for them before starting the function and returning the expected output even if it\\'s wrong "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You start at index `0`. From there you can jump at most `4` positions.  \\nYou jump `3` positions to index `3`. From there you can jum at most `3` positions.  \\nYou jump `3` positions to the index `6`, the goal.  \\nThat\\'s two jumps."
                    },
                    {
                        "username": "aelrouby",
                        "content": "[3,2,1] this test case is giving wrong expectation.\\nthe system expected 1, while the correct is 2.\\n1 means that the first element takes us to the end of the array, while the first element (3) takes us outside of the array."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "\"Each element `nums[i]` represents the **maximum** length of a forward jump from index `i`.\""
                    },
                    {
                        "username": "Shrutipandey16",
                        "content": "why num.sum()-1,and when we have to return true or false then only it is num.size()?????"
                    },
                    {
                        "username": "Uttam-Gupta",
                        "content": "EZ ITERATION APPROACH\\n\\nclass Solution {\\npublic:\\n    int jump(vector<int>& nums) {\\n        if (nums.size()==1)\\n        return 0;\\n        int jump=1,i=1;\\n        int point1=nums[0],point2=nums[1],check=0;\\n        while(i<nums.size()-1){\\n            point1--;\\n            if((point2-i+check)<=nums[i]){\\n                check=i;\\n                point2=nums[i];\\n            }\\n            if(point1==0){\\n                point1=point2-i+check;\\n                point2=nums[i+1];\\n                jump++;\\n            }\\n            i++;\\n        }\\n        return jump;\\n    }\\n};"
                    },
                    {
                        "username": "yashk_07",
                        "content": "class Solution {\\npublic:\\n\\n    int jump(vector<int>& nums) {\\n\\n      for(int i = 1; i < nums.size(); i++)\\n      {\\n        nums[i] = max(nums[i] + i, nums[i-1]);\\n      }\\n\\n      int index = 0;\\n      int answer = 0;\\n\\n      while(index < nums.size() - 1)\\n      {\\n        answer++;\\n        index = nums[index];\\n      }\\n\\n      return answer;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793502,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793436,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793414,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793393,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793386,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793343,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793336,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793322,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793272,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793246,
                "content": [
                    {
                        "username": "shivam9935",
                        "content": "I am always able to think of recursion in this way but dynamic programing this is always a challenge for me. Can someone help me add memoization in this way?\\n\\n ```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = float(\\'inf\\')\\n        \\n        def j(current, jumps, left):\\n            if current == n-1:\\n                nonlocal m\\n                m = min(m, jumps)\\n                return\\n            if left == 0:\\n                # we have to take this jump\\n                j(current+1, jumps+1, nums[current]-1)\\n            if left > 0:\\n                #either we take it\\n                j(current+1, jumps+1, nums[current]-1)\\n                #or we leave current index\\n                j(current+1, jumps, left-1)\\n        \\n        j(0,0,0)\\n        return m\\n```"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "how  [1,1,1,1] answer is 3"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar)  great\\nyou can see my submission there are 3 diffrenet code in it\\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894277570/)"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "thank u [@harsh_negi_07](/harsh_negi_07) \\ni solved this, here is my  c code (beats 90%) \\nhere js = jumps, m = next index where we jump\\nint jump(int* nums, int n){\\n    int js = 0, m;\\n    if (n == 1) return 0;\\n    for (int i = 0; i < n; ){\\n        if (i + nums[i] >= n-1) return ++js;\\n        m = i+1;\\n        for (int j = i+2, k = nums[i]-1; k > 0; j++, k--)\\n            if ((nums[j] + j) >= (nums[m] + m)) m = j;\\n         i = m;\\n         ++js;\\n    }\\n    return js;\\n}"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohitjakhar](/mohitjakhar) \\n0 <= j <= nums[i] is the value of jump that you can take\\nit\\'s not a comparison statement ...\\nit\\'s telling you the value of jump you can take from current index and not going out of bound that is n"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "[@harsh_negi_07](/harsh_negi_07) \\nbut the question says \\n\"if you are at nums[i], you can jump to any nums[i + j] where:\\n\\n0 <= j <= nums[i] and\\ni + j < n\"\\nso when we are at index 1 how can we jump to index 2 bcz 2 > nums[1]\\nplz tell if i understand question wrong"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "[@mohit](/mohitjakhar) \nInitially number of jump is **zero**\nfrom index 0 you can take max jump 1\n```jump = 1  ( 0 -> 1)```\nfrom index 1 you can take max jump 1\n```jump = 2   (1 -> 2)```\nfrom index 2 you can take max jump 1\n```jump = 3   (2 -> 3)```\nyou reached index 3 with jump = 3\n#  InShort at starting index jump = 0"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Thought too much, could be directly solved via BFS"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I tried normal bfs but it was giving tle.... so i tried to memoize my solution it got accepted.... 5% fast (pretty slow)\n[my solution](https://leetcode.com/problems/jump-game-ii/submissions/894138084/)"
                    },
                    {
                        "username": "rammanoj",
                        "content": "BFS was also giving me a TLE initially. If my code was able to reach index 5 in 3 steps. 3 is the minimum number of steps I can reach 5. I should never take 5 into account again i.e. don\\'t push 5 into the queue again. Mantain a maxReach variable which specifies about maximum index reached in current iteration. Only push to queue if current index could reach more than maxReach. Hope it helps!"
                    },
                    {
                        "username": "____shubham____",
                        "content": "Can anyone please explain me the question\\n\\nInput: nums = [2,3,1,1,4]\\nOutput: 2\\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\\n\\nIt says \"You are initially positioned at nums[0].\"\\nso my source is nums[0] => 2\\nand dest is nums[n - 1] => 4\\n\\nBut the solution says \"Jump 1 step from index 0 to 1\"\\n\\nMy source is 0 or nums[0]?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "0 bro\\nnums[0] is the maximum jump you can take\\nlike in above tc\\ni = 0 and nums[0] = 2\\nso you can take 1 <= jump <= nums[0] and then you will go to i + jump index "
                    },
                    {
                        "username": "sg3175",
                        "content": "How do we get started in solving this question using C language ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Many problems are pretty hard to solve in C because you have to do everything by hand, allocate memory, write comparators, or use the rather uncomfortable UTHash.  \\nBut this one is quite simple. Imagine you\\'re at index `0`, and `nums[0]` is `6`. You can now \"jump\" to indexes `1`, `2`, `3`, `4`, `5`, or `6`. So which one to choose? How about the one that gets you the farthest on your next jump.  \\nSo all you need for this problem is a single loop and a few variables to keep track of the result, the maximal index of the current jump, and the maximal index of the next jump."
                    },
                    {
                        "username": "babaska",
                        "content": "4 test in submit is failed, bun in testcase he is true. Why???"
                    },
                    {
                        "username": "MichaelTeguhLaksana",
                        "content": "Hi, I tried to use BFS instead to solve this question. However, I found that its too slow. I haven\\'t given it much thought, but shouldn\\'t what BFS (without checking the same index twice) do is the same as the suggested Greedy algorithm? Is it probably how I implemented it that\\'s the issue?"
                    },
                    {
                        "username": "sajjadzh",
                        "content": "for those who wanna implement a easy to understand O(n) approach , they should think about \"snake and ladder\" problem - solved by BFS. "
                    },
                    {
                        "username": "185535",
                        "content": "can someone just help me understand the problem statment? It is very complex and I am quite sure there is a better way to explain this."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Your goal is to reach the last index in the least amount of jumps. Every value that you land on specifies the maximum jumping distance from that index. If you land on a 3, you can jump **up to** 3 places from that index etc. \n\ninput: [2,3,1,1,4]\n\nYou start on nums[0]. nums[0] = 2, therefore you can jump up to 2 places from here --> you land on either 3 or 1. From 3 you can jump up to 3 places --> you land on 1, 1 or 4 (the last index). It took you 2 jumps to get from nums[0] to nums [n - 1], therefore the output is 2. "
                    }
                ]
            },
            {
                "id": 1793151,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793060,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1793028,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792979,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792967,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792924,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792910,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792845,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792789,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792787,
                "content": [
                    {
                        "username": "adilkhanovkz",
                        "content": "Do I need to really provide O(n) solution if my O(n^2) solution is accepted. I have not expected that my O(n^2) solution will be accepted but I just tried and it is passed. Or it is opportunity  to write appropriate test case? "
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "My memoization beats only 5%.\\nCan anyone suggest a DP Course?"
                    },
                    {
                        "username": "hellobhaskarhere",
                        "content": "\\nThis test case [1,2,1,1,1] is failing?\\ncan anyone please help me?\\n\\n \\n\\nclass Solution {\\npublic:\\n    \\n    int jumpUtil(vector<int> &nums,int i,int &n,int steps,int &ans,vector<int>&dp)\\n    {\\n        \\n        if(i>=n-1)\\n        {\\n              return dp[n-1]=min(steps,dp[n-1]);\\n        }\\n\\n        if(nums[i]==0)\\n        return INT_MAX;\\n\\n        if(dp[i]!=INT_MAX)\\n        return dp[i];\\n\\n         for(int j=1;j<=nums[i];j++)\\n         {\\n              \\n             dp[i]=min(dp[i],jumpUtil(nums,i+j,n,steps+1,ans,dp));\\n         }\\n         return dp[i];\\n\\n         \\n    }\\n    int jump(vector<int>& nums) {\\n        int i=0;\\n        int n=nums.size();\\n        int steps=0;\\n        int ans=INT_MAX;\\n       vector<int> dp(n,INT_MAX);\\n       \\n       return  jumpUtil(nums,i,n,steps,ans,dp);\\n       \\n\\n    }\\n};"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "I guess in base case you should return 0. As you are already at end or beyond meaning you don\\'t require any jump."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Please anyone give idea to optimise bfs..\\ngetting tle 82 testcase\\n.. i also tried priority_queue "
                    },
                    {
                        "username": "UjjwalSharma",
                        "content": "Wrong Answer\\n\\nInput\\nnums =\\n[4,1,1,3,1,1,1]\\n59 / 109 testcases passed\\nOutput\\n3\\nExpected\\n2\\n\\nWhy output is 2..?\\nFrom 0 we reach 4th index i.e. 1 jump and take  1 jump and reach 5th index i.e. 2nd jump and at last we again take a jump of 1 and reach 6th index i.e. 3rd jump. How 2 then..??"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Only two jumps are needed : From index 0 (value=4) jump to index 3. From index 3 jump to the last index. Note that for a given index i, it is not mandatory to make a jump equal to the exact value of nums[i]. For example, if nums[i]=4, you can jump to i+1, i+2,i+3 OR i+4. Here's the solution : https://leetcode.com/problems/jump-game-ii/solutions/3159224/greedy-vs-dynamic-programming-c-both-explained/"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Greedy is not always a bad option !!"
                    },
                    {
                        "username": "Praveen_Kispotta",
                        "content": "How many jumps we can make at once...?"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Maximum - nums[i], minimum - 1 if nums[i]!=0."
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was a nightmare for me.  struggled with optimization until the forums hinted that greedy O(N) solution works."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "4 days of easy leetcoding:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Make sure you iterate till n-2"
                    }
                ]
            },
            {
                "id": 1792785,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792765,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792722,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792708,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792668,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1792594,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1760266,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1752623,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1728462,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            },
            {
                "id": 1725093,
                "content": [
                    {
                        "username": "rushi_4123",
                        "content": "In greedy approach :\\nJust make sure you keep track of how far you can reach by using every index step, and boom! you will reach the last index in min jumps!!\\n:)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Should i use DP"
                    },
                    {
                        "username": "TsuruLee",
                        "content": "Ahh. This problem again"
                    },
                    {
                        "username": "trantanloc2111",
                        "content": "The simple idea just is find the max step from current position by compare (distance from current to i + value of i position)"
                    },
                    {
                        "username": "karthikbhandary2",
                        "content": "what is j in nums[i + j], 0 <= j <= nums[i] and i + j < n?"
                    },
                    {
                        "username": "dunglee30",
                        "content": "At every position, keep track of furthest position possibly reaching by comparing the current furthest position to the possibly furthest position that the current position i can reach. if current position have passed the last furthest position being tracked, update the next furthest position, keep doing it until we reach the position where its possibly furthest position reach n-1."
                    },
                    {
                        "username": "colabee992",
                        "content": "In Jump Game 1, thinking DP, you jump backwards trying from the closest number to the end goal. This is to get max coverage of all possible jumps.\\n\\nHere, it is reversed. You also try jumping backwards, but try from the number furthest from the end goal, so you capture the best (earliest) possible jump start point."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Why does Recursion with memiozation , gives a Timeout ? "
                    },
                    {
                        "username": "namanchandak",
                        "content": "why tabulation is showing me wrong ans in [1,3,2]  test case\\n\\n\\n\\n\\n\\nint jump(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >dp(n+3,0);\\n\\n\\n        for(int ind=n;ind>=0;ind--)\\n        {\\n\\n            int jump=1e9;\\n        for(int i=1;i<=nums[ind];i++)\\n        {\\n            // if(nums[i+ind]>=nums.size()-1)\\n            // return 1;\\n            int path=0;\\n            if(i+ind<=n)\\n            path=1+dp[i+ind];\\n            jump=min(jump,path);\\n        }\\n\\n        dp[ind]= jump;\\n\\n\\n\\n        }\\n\\n        \\n\\n\\n       return dp[0]; \\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Postorder Traversal",
        "question_content": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 127px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 45551,
                "title": "preorder-inorder-and-postorder-iteratively-summarization",
                "content": "Here I summarize the iterative implementation for preorder, inorder, and postorder traverse.\\n\\n<hr>\\n<h3>Pre Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                result.add(p.val);  // Add before going to children\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>In Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                result.add(node.val);  // Add after all left children\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Post Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                result.add(p.val);  // Add before going to children\\n                stack.push(p);\\n                p = p.right;\\n            } else {\\n                p = stack.pop();\\n                p = p.left;\\n            }\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Appendix: Post Order Traverse V2</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while(!stack.isEmpty() || p != null) {\\n            if(p != null) {\\n                stack.push(p);\\n                result.addFirst(p.val);  // Reverse the process of preorder\\n                p = p.right;             // Reverse the process of preorder\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.left;           // Reverse the process of preorder\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here I summarize the iterative implementation for preorder, inorder, and postorder traverse.\\n\\n<hr>\\n<h3>Pre Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                result.add(p.val);  // Add before going to children\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>In Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                TreeNode node = stack.pop();\\n                result.add(node.val);  // Add after all left children\\n                p = node.right;   \\n            }\\n        }\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Post Order Traverse</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                result.add(p.val);  // Add before going to children\\n                stack.push(p);\\n                p = p.right;\\n            } else {\\n                p = stack.pop();\\n                p = p.left;\\n            }\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n\\n<hr>\\n<h3>Appendix: Post Order Traverse V2</h3>\\n<hr>\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode p = root;\\n        while(!stack.isEmpty() || p != null) {\\n            if(p != null) {\\n                stack.push(p);\\n                result.addFirst(p.val);  // Reverse the process of preorder\\n                p = p.right;             // Reverse the process of preorder\\n            } else {\\n                TreeNode node = stack.pop();\\n                p = node.left;           // Reverse the process of preorder\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45556,
                "title": "java-simple-and-clean",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n    \\tLinkedList<Integer> ans = new LinkedList<>();\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tif (root == null) return ans;\\n    \\t\\n    \\tstack.push(root);\\n    \\twhile (!stack.isEmpty()) {\\n    \\t\\tTreeNode cur = stack.pop();\\n    \\t\\tans.addFirst(cur.val);\\n    \\t\\tif (cur.left != null) {\\n    \\t\\t\\tstack.push(cur.left);\\n    \\t\\t}\\n    \\t\\tif (cur.right != null) {\\n    \\t\\t\\tstack.push(cur.right);\\n    \\t\\t} \\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n    \\tLinkedList<Integer> ans = new LinkedList<>();\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tif (root == null) return ans;\\n    \\t\\n    \\tstack.push(root);\\n    \\twhile (!stack.isEmpty()) {\\n    \\t\\tTreeNode cur = stack.pop();\\n    \\t\\tans.addFirst(cur.val);\\n    \\t\\tif (cur.left != null) {\\n    \\t\\t\\tstack.push(cur.left);\\n    \\t\\t}\\n    \\t\\tif (cur.right != null) {\\n    \\t\\t\\tstack.push(cur.right);\\n    \\t\\t} \\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45785,
                "title": "share-my-two-python-iterative-solutions-post-order-and-modified-preorder-then-reverse",
                "content": "The first is by postorder using a flag to indicate whether the node has been visited or not.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            traversal, stack = [], [(root, False)]\\n            while stack:\\n                node, visited = stack.pop()\\n                if node:\\n                    if visited:\\n                        # add to result if visited\\n                        traversal.append(node.val)\\n                    else:\\n                        # post-order\\n                        stack.append((node, True))\\n                        stack.append((node.right, False))\\n                        stack.append((node.left, False))\\n    \\n            return traversal\\n\\nThe 2nd uses modified preorder (right subtree first). Then reverse the result.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            traversal, stack = [], [root]\\n            while stack:\\n                node = stack.pop()\\n                if node:\\n                    # pre-order, right first\\n                    traversal.append(node.val)\\n                    stack.append(node.left)\\n                    stack.append(node.right)\\n    \\n            # reverse result\\n            return traversal[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 45550,
                "title": "c-iterative-recursive-and-morris-traversal",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack --- `O(n)` time and `O(n)` space;\\n 2. Recursive solution --- `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal --- `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        postorder(root -> left, nodes);\\n        postorder(root -> right, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        TreeNode* dummy = new TreeNode(0);\\n        dummy -> left = root;\\n        TreeNode* cur = dummy;\\n        while (cur) {\\n            if (cur -> left) {\\n                TreeNode* pre = cur -> left;\\n                while (pre -> right && (pre -> right != cur)) {\\n                    pre = pre -> right;\\n                }\\n                if (!(pre -> right)) {\\n                    pre -> right = cur;\\n                    cur = cur -> left;\\n                } else {\\n                    reverseAddNodes(cur -> left, pre, nodes);\\n                    pre -> right = NULL;\\n                    cur = cur -> right;\\n                }\\n            } else {\\n                cur = cur -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\nprivate:\\n    void reverseNodes(TreeNode* start, TreeNode* end) {\\n        if (start == end) {\\n            return;\\n        }\\n        TreeNode* x = start;\\n        TreeNode* y = start -> right;\\n        TreeNode* z;\\n        while (x != end) {\\n            z = y -> right;\\n            y -> right = x;\\n            x = y;\\n            y = z;\\n        }\\n    }\\n    void reverseAddNodes(TreeNode* start, TreeNode* end, vector<int>& nodes) {\\n        reverseNodes(start, end);\\n        TreeNode* node = end;\\n        while (true) {\\n            nodes.push_back(node -> val);\\n            if (node == start) {\\n                break;\\n            }\\n            node = node -> right;\\n        }\\n        reverseNodes(end, start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        postorder(root -> left, nodes);\\n        postorder(root -> right, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        TreeNode* dummy = new TreeNode(0);\\n        dummy -> left = root;\\n        TreeNode* cur = dummy;\\n        while (cur) {\\n            if (cur -> left) {\\n                TreeNode* pre = cur -> left;\\n                while (pre -> right && (pre -> right != cur)) {\\n                    pre = pre -> right;\\n                }\\n                if (!(pre -> right)) {\\n                    pre -> right = cur;\\n                    cur = cur -> left;\\n                } else {\\n                    reverseAddNodes(cur -> left, pre, nodes);\\n                    pre -> right = NULL;\\n                    cur = cur -> right;\\n                }\\n            } else {\\n                cur = cur -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\nprivate:\\n    void reverseNodes(TreeNode* start, TreeNode* end) {\\n        if (start == end) {\\n            return;\\n        }\\n        TreeNode* x = start;\\n        TreeNode* y = start -> right;\\n        TreeNode* z;\\n        while (x != end) {\\n            z = y -> right;\\n            y -> right = x;\\n            x = y;\\n            y = z;\\n        }\\n    }\\n    void reverseAddNodes(TreeNode* start, TreeNode* end, vector<int>& nodes) {\\n        reverseNodes(start, end);\\n        TreeNode* node = end;\\n        while (true) {\\n            nodes.push_back(node -> val);\\n            if (node == start) {\\n                break;\\n            }\\n            node = node -> right;\\n        }\\n        reverseNodes(end, start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45559,
                "title": "my-accepted-code-with-explaination-does-anyone-have-a-better-idea",
                "content": "pre-order traversal is **root-left-right**, and post order is **left-right-root**. modify the code for pre-order to make it root-right-left, and then  **reverse** the output so that we can get left-right-root .\\n\\n\\n 1. Create an empty stack, Push root node to the stack.\\n 2. Do following while stack is not empty.\\n\\n 2.1. pop an item from the stack and print it.\\n \\n 2.2. push the left child of popped item to stack.\\n\\n 2.3. push the right child of popped item to stack.\\n\\n 3. reverse the ouput.\\n\\n        class Solution {\\n        public:\\n            vector<int> postorderTraversal(TreeNode *root) {\\n                stack<TreeNode*> nodeStack;\\n                vector<int> result;\\n                //base case\\n                if(root==NULL)\\n                return result;\\n                nodeStack.push(root);\\n            while(!nodeStack.empty())\\n            {\\n                TreeNode* node= nodeStack.top();  \\n                result.push_back(node->val);\\n                nodeStack.pop();\\n                if(node->left)\\n                nodeStack.push(node->left);\\n                if(node->right)\\n                nodeStack.push(node->right);\\n            }\\n             reverse(result.begin(),result.end());\\n             return result;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> postorderTraversal(TreeNode *root) {\\n                stack<TreeNode*> nodeStack;\\n                vector<int> result;\\n                //base case\\n                if(root==NULL)\\n                return result;\\n                nodeStack.push(root);\\n            while(!nodeStack.empty())\\n            {\\n                TreeNode* node= nodeStack.top();  \\n                result.push_back(node->val);\\n                nodeStack.pop();\\n                if(node->left)\\n                nodeStack.push(node->left);\\n                if(node->right)\\n                nodeStack.push(node->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45628,
                "title": "morris-traversal-time-o-n-space-o-1-inorder-preorder-postorder",
                "content": "Morris Traversal is a way of traversing BST with O(1) space and O(n) time. It's a little hard to understand but the basic idea is to link predecessor back to current node so that we can trace back to top of BST. It's also a little tricky to see how it is O(n) since finding predecessor is often O(logn). The answer is , we don't have to find predecessor for every node, only the nodes with valid left child. It will be obvious if you draw a tree to see that every edge is only visited constant time.\\n\\nInorder\\n\\n```\\n    def inorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    result.append(node.val)\\n                    node=node.right\\n        return result\\n```\\n\\nPreorder, basically the same, just one line of change\\n```\\n    def preorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            #print(node.val)\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=node and pre.right!=None:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    result.append(node.val)\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    node=node.right\\n        return result\\n```\\n\\nPostorder, this is a little tricky, you have to output path along predecessor in reverse order. \\n```\\n    def postorderTraversal(self, root):\\n        result=[]\\n        def reverseOrder(left,right):\\n            while left<right:\\n                result[left],result[right]=result[right],result[left]\\n                left+=1\\n                right-=1\\n        dummynode= TreeNode(None) #dummy node\\n        node=dummynode\\n        node.left=root\\n        while node!=None:\\n            print(node.val)\\n            if node.left==None:\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre=node.left\\n                    count=1\\n                    while pre.right!=None and pre.right!=node:\\n                        result.append(pre.val)\\n                        pre=pre.right\\n                        count+=1\\n                    result.append(pre.val)\\n                    pre.right=None\\n                    reverseOrder(len(result)-count,len(result)-1)\\n                    node=node.right\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    result.append(node.val)\\n                    node=node.right\\n        return result\\n```\n```\\n    def preorderTraversal(self, root):\\n        result=[]\\n        node=root\\n        while node!=None:\\n            #print(node.val)\\n            if node.left==None:\\n                result.append(node.val)\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=node and pre.right!=None:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    result.append(node.val)\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre.right=None\\n                    node=node.right\\n        return result\\n```\n```\\n    def postorderTraversal(self, root):\\n        result=[]\\n        def reverseOrder(left,right):\\n            while left<right:\\n                result[left],result[right]=result[right],result[left]\\n                left+=1\\n                right-=1\\n        dummynode= TreeNode(None) #dummy node\\n        node=dummynode\\n        node.left=root\\n        while node!=None:\\n            print(node.val)\\n            if node.left==None:\\n                node=node.right\\n            else:\\n                pre=node.left\\n                while pre.right!=None and pre.right!=node:\\n                    pre=pre.right\\n                if pre.right==None:\\n                    pre.right=node\\n                    node=node.left\\n                else:\\n                    pre=node.left\\n                    count=1\\n                    while pre.right!=None and pre.right!=node:\\n                        result.append(pre.val)\\n                        pre=pre.right\\n                        count+=1\\n                    result.append(pre.val)\\n                    pre.right=None\\n                    reverseOrder(len(result)-count,len(result)-1)\\n                    node=node.right\\n                    \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 45582,
                "title": "a-real-postorder-traversal-without-reverse-or-insert-4ms",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            vector<int> ret;\\n            if(!root) return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            st.push(root);\\n            TreeNode *cur;\\n            while(!st.empty()){\\n                cur = st.top();\\n                st.pop();\\n                if(!st.empty()&&st.top() == cur){\\n                    if(cur->right) {\\n                        st.push(cur->right);\\n                        st.push(cur->right);\\n                    }\\n                    if(cur->left){\\n                        st.push(cur->left);\\n                        st.push(cur->left);\\n                    }\\n                }\\n                else\\n                    ret.push_back(cur->val);\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            vector<int> ret;\\n            if(!root) return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            st.push(root);\\n            TreeNode *cur;\\n            while(!st.empty()){\\n                cur = st.top();\\n                st.pop();\\n                if(!st.empty()&&st.top() == cur){\\n                    if(cur->right) {\\n                        st.push(cur->right);\\n                        st.push(cur->right);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 45648,
                "title": "3-ways-of-iterative-postorder-traversing-morris-traversal",
                "content": "Three types of Iterative Postorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\nThis is similar to [Inorder using 1 Stack](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation). The difference is we keep track of the previously printed node in `pre`. And we only print a node if its right child is `null` or equal to `pre`.\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* `root` = `s.peek()`\\n\\t* if `root.right` = `null` or `pre`  (Means we have traversed the right subtree already)\\n\\t\\t* We print `root` and  pop it from `s`.\\n\\t\\t* Make `pre` = `root`\\n\\t\\t* `root` = `null` (So we dont go down to left child again)\\n\\t* else\\n\\t\\t* `root` = `root.right` (Traverse the right subtree before printing `root`)\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre=null;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.peek();\\n\\t\\t\\t\\tif(root.right==null || root.right==pre){\\n\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t    s.pop();\\n\\t\\t\\t\\t    pre=root;\\n\\t\\t\\t\\t    root = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t    root = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.peek()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Print `root` and push it into `path`.\\n\\t\\t\\t* Push `root`\\'s children into `s` in reverse order. (Remember it\\'s a stack!)\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* `Pop` from `both` stacks.\\n\\t\\t\\n```\\n\\n\\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t    List<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                out.add(root.val);\\n\\t\\t    s.pop();\\n                path.pop();\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\nSimilar to [Inorder Morris Traversal](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation).\\n![0_1477341646335_postorder.jpg](/uploads/files/1477341648349-postorder.jpg) \\nWe reverse each diagonal shown in the picture (d1-d4), print it and re-reverse it.\\n\\n\\t* Create a `dummy` node and make `dummy.left` = `root`.\\n\\t* `root` = `dummy`\\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor` => `pre`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* `pre.right` = `root` (Make it point to root).\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Reverse from `root.left` to `pre`.\\n\\t\\t\\t\\t* Traverse from `pre` to `root.left` and print the nodes.\\n\\t\\t\\t\\t* Re-reverse it back to normal.\\n\\t\\t\\t\\t* `pre.right` = `null`.\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n\\tList<Integer> out = new ArrayList<Integer>();\\n\\tif(root == null)\\n\\t\\treturn out;\\n\\tTreeNode dummy = new TreeNode(-1), pre = null;\\n\\tdummy.left = root; root = dummy;\\n\\twhile(root != null){\\n\\t\\tif(root.left != null){\\n\\t\\t\\tpre = root.left;\\n\\t\\t\\twhile(pre.right != null && pre.right != root)\\n\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\tif(pre.right == null){\\n\\t\\t\\t\\tpre.right = root;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tTreeNode node = pre;\\n\\t\\t\\t\\treverse(root.left,pre);\\n\\t\\t\\t\\twhile(node != root.left){\\n\\t\\t\\t\\t\\tout.add(node.val);\\n\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.add(node.val);          // Print again since we are stopping at node=root.left\\n\\t\\t\\t\\treverse(pre,root.left);\\n\\t\\t\\t\\tpre.right = null;\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\troot = root.right;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n\\n```\\n    \\n    public void reverse(TreeNode from, TreeNode to){\\n        if(from == to)\\n            return;\\n        TreeNode prev = from, node = from.right;\\n        while(prev != to){\\n            TreeNode next = node.right;\\n            node.right = prev;\\n            prev = node;\\n            node = next;\\n        }\\n    }\\n\\n\\nAlso checkout [Inorder](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre=null;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.peek();\\n\\t\\t\\t\\tif(root.right==null || root.right==pre){\\n\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t    s.pop();\\n\\t\\t\\t\\t    pre=root;\\n\\t\\t\\t\\t    root = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t    root = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t    List<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                out.add(root.val);\\n\\t\\t    s.pop();\\n                path.pop();\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n\\tList<Integer> out = new ArrayList<Integer>();\\n\\tif(root == null)\\n\\t\\treturn out;\\n\\tTreeNode dummy = new TreeNode(-1), pre = null;\\n\\tdummy.left = root; root = dummy;\\n\\twhile(root != null){\\n\\t\\tif(root.left != null){\\n\\t\\t\\tpre = root.left;\\n\\t\\t\\twhile(pre.right != null && pre.right != root)\\n\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\tif(pre.right == null){\\n\\t\\t\\t\\tpre.right = root;\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tTreeNode node = pre;\\n\\t\\t\\t\\treverse(root.left,pre);\\n\\t\\t\\t\\twhile(node != root.left){\\n\\t\\t\\t\\t\\tout.add(node.val);\\n\\t\\t\\t\\t\\tnode = node.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tout.add(node.val);          // Print again since we are stopping at node=root.left\\n\\t\\t\\t\\treverse(pre,root.left);\\n\\t\\t\\t\\tpre.right = null;\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\troot = root.right;\\n\\t\\t}\\n\\t}\\n\\treturn out;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45621,
                "title": "preorder-inorder-and-postorder-traversal-iterative-java-solution",
                "content": "Postorder traversal : [Binary Tree Postorder Traversal][1]\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(0, root.val);\\n            if(root.left != null) stack.push(root.left);\\n            if(root.right != null) stack.push(root.right);\\n        }\\n        return list;\\n    }\\n\\n\\nPreorder traversal : [Binary Tree Preorder Traversal][2]\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null) stack.push(root.right);\\n            if(root.left != null) stack.push(root.left);\\n        }\\n        return list;\\n    }\\n\\n\\nInorder traversal : [Binary Tree Inorder Traversal][3]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n  [2]: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n  [3]: https://leetcode.com/problems/binary-tree-inorder-traversal/",
                "solutionTags": [
                    "Java"
                ],
                "code": "Postorder traversal : [Binary Tree Postorder Traversal][1]\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(0, root.val);\\n            if(root.left != null) stack.push(root.left);\\n            if(root.right != null) stack.push(root.right);\\n        }\\n        return list;\\n    }\\n\\n\\nPreorder traversal : [Binary Tree Preorder Traversal][2]\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()){\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null) stack.push(root.right);\\n            if(root.left != null) stack.push(root.left);\\n        }\\n        return list;\\n    }\\n\\n\\nInorder traversal : [Binary Tree Inorder Traversal][3]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n  [2]: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n  [3]: https://leetcode.com/problems/binary-tree-inorder-traversal/",
                "codeTag": "Unknown"
            },
            {
                "id": 45558,
                "title": "a-very-concise-solution",
                "content": "i have saw lots of post in this discussion, but most of them are not concise, just share mine for your  reference, writing a concise code is very important\\n  \\n    vector<int> postorderTraversal(TreeNode *root) {\\n        vector<int> v;\\n        if (!root) return v;\\n        \\n        stack<TreeNode *> s;\\n        s.push(root);\\n        \\n        TreeNode *p = NULL;\\n        while(!s.empty()) {\\n            p = s.top();\\n            s.pop();\\n            v.insert(v.begin(), p->val);\\n            if (p->left) s.push(p->left);\\n            if (p->right) s.push(p->right);\\n        }\\n        \\n        return v;\\n    }",
                "solutionTags": [],
                "code": "i have saw lots of post in this discussion, but most of them are not concise, just share mine for your  reference, writing a concise code is very important\\n  \\n    vector<int> postorderTraversal(TreeNode *root) {\\n        vector<int> v;\\n        if (!root) return v;\\n        \\n        stack<TreeNode *> s;\\n        s.push(root);\\n        \\n        TreeNode *p = NULL;\\n        while(!s.empty()) {\\n            p = s.top();\\n            s.pop();\\n            v.insert(v.begin(), p->val);\\n            if (p->left) s.push(p->left);\\n            if (p->right) s.push(p->right);\\n        }\\n        \\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45740,
                "title": "summary-of-preorder-inorder-postorder-four-traversal-ways-for-each",
                "content": "There are four traversal ways for each included recursive, iterative and morris traversal.\\n\\n**Recursive Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            return ([root.val] + sum(map(self.preorderTraversal, (root.left, root.right)), [])) if root else []\\n    \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n            \\n            left, right = map(self.inorderTraversal, (root.left, root.right))\\n            return left + [root.val] + right\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            return (sum(map(self.postorderTraversal, (root.left, root.right)), []) + [root.val]) if root else []\\n\\n**Iterative Way With Stack + Visited State**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n            return r\\n \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r, poped = [[root, 0]], [], False\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    poped = True\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                        poped = False\\n    \\n                elif top[0].left and not poped:\\n                    stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n            return r\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n    \\n            return r[::-1]\\n\\n**Iterative Way With Stack**\\n\\nThis way was inspired by [Preorder, Inorder, and Postorder Iteratively Summarization][1]\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    root = stack.pop().right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    root = root.left\\n                else:\\n                    root = stack.pop()\\n                    r.append(root.val)\\n                    root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    r.append(root.val)\\n                    stack.append(root)\\n                    root = root.right\\n                else:\\n                    root = stack.pop().left\\n    \\n            return r[::-1]\\n\\n**Morris Traversal Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        r.append(root.val)\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        root = root.right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        r.append(root.val)\\n                        root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.right:\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    next = root.right\\n                    while next.left and next.left != root:\\n                        next = next.left\\n    \\n                    if not next.left:\\n                        r.append(root.val)\\n                        next.left = root\\n                        root = root.right\\n                    else:\\n                        root = root.left\\n            return r[::-1]\\n\\n  [1]: https://leetcode.com/discuss/71943/preorder-inorder-and-postorder-iteratively-summarization",
                "solutionTags": [
                    "Python"
                ],
                "code": "There are four traversal ways for each included recursive, iterative and morris traversal.\\n\\n**Recursive Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            return ([root.val] + sum(map(self.preorderTraversal, (root.left, root.right)), [])) if root else []\\n    \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n            \\n            left, right = map(self.inorderTraversal, (root.left, root.right))\\n            return left + [root.val] + right\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            return (sum(map(self.postorderTraversal, (root.left, root.right)), []) + [root.val]) if root else []\\n\\n**Iterative Way With Stack + Visited State**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n            return r\\n \\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r, poped = [[root, 0]], [], False\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    poped = True\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n                        poped = False\\n    \\n                elif top[0].left and not poped:\\n                    stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n            return r\\n    \\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            stack, r = [[root, 0]], []\\n            while stack:\\n                top = stack[-1]\\n    \\n                if top[1]:\\n                    stack.pop()\\n                    if top[0].left:\\n                        stack.append([top[0].left, 0])\\n                else:\\n                    r.append(top[0].val)\\n                    top[1] = 1\\n    \\n                    if top[0].right:\\n                        stack.append([top[0].right, 0])\\n    \\n            return r[::-1]\\n\\n**Iterative Way With Stack**\\n\\nThis way was inspired by [Preorder, Inorder, and Postorder Iteratively Summarization][1]\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    root = stack.pop().right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    stack.append(root)\\n                    root = root.left\\n                else:\\n                    root = stack.pop()\\n                    r.append(root.val)\\n                    root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            stack, r = [], []\\n            while stack or root:\\n                if root:\\n                    r.append(root.val)\\n                    stack.append(root)\\n                    root = root.right\\n                else:\\n                    root = stack.pop().left\\n    \\n            return r[::-1]\\n\\n**Morris Traversal Way**\\n    \\n    # preorder\\n    class Solution(object):\\n        def preorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        r.append(root.val)\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        root = root.right\\n            return r\\n\\n    # inorder\\n    class Solution(object):\\n        def inorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.left:\\n                    r.append(root.val)\\n                    root = root.right\\n                else:\\n                    pre = root.left\\n                    while pre.right and pre.right != root:\\n                        pre = pre.right\\n    \\n                    if not pre.right:\\n                        pre.right = root\\n                        root = root.left\\n                    else:\\n                        r.append(root.val)\\n                        root = root.right\\n            return r\\n\\n    # postorder\\n    class Solution(object):\\n        def postorderTraversal(self, root):\\n            r = []\\n            while root:\\n                if not root.right:\\n                    r.append(root.val)\\n                    root = root.left\\n                else:\\n                    next = root.right\\n                    while next.left and next.left != root:\\n                        next = next.left\\n    \\n                    if not next.left:\\n                        r.append(root.val)\\n                        next.left = root\\n                        root = root.right\\n                    else:\\n                        root = root.left\\n            return r[::-1]\\n\\n  [1]: https://leetcode.com/discuss/71943/preorder-inorder-and-postorder-iteratively-summarization",
                "codeTag": "Java"
            },
            {
                "id": 45786,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively \\n    def postorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n            res.append(root.val)\\n    \\n    # iteratively        \\n    def postorderTraversal(self, root):\\n        res, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.left)\\n                stack.append(node.right)\\n        return res[::-1]",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively \\n    def postorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n            res.append(root.val)\\n    \\n    # iteratively        \\n    def postorderTraversal(self, root):\\n        res, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.left)\\n                stack.append(node.right)\\n        return res[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 45803,
                "title": "java-solution-using-two-stacks",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> s1 = new Stack<TreeNode>();\\n      Stack<TreeNode> s2 = new Stack<TreeNode>();\\n      \\n      s1.push(root);\\n      \\n      while (!s1.isEmpty()) {\\n        TreeNode node = s1.pop();\\n        s2.push(node);\\n        \\n        if (node.left != null)\\n          s1.push(node.left);\\n        \\n        if (node.right != null)\\n          s1.push(node.right);\\n      }\\n      \\n      while (!s2.isEmpty())\\n        res.add(s2.pop().val);\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> s1 = new Stack<TreeNode>();\\n      Stack<TreeNode> s2 = new Stack<TreeNode>();\\n      \\n      s1.push(root);\\n      \\n      while (!s1.isEmpty()) {\\n        TreeNode node = s1.pop();\\n        s2.push(node);\\n        \\n        if (node.left != null)\\n          s1.push(node.left);\\n        \\n        if (node.right != null)\\n          s1.push(node.right);\\n      }\\n      \\n      while (!s2.isEmpty())\\n        res.add(s2.pop().val);\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45539,
                "title": "iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code",
                "content": "For three different kinds of traversal, we only need to change the order of tuples in one line as we've done this in the recursive solution which is very decent and classical. Just put `(0, p[1])` in different position!\\n\\nFor post-order traversal:\\n\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\nFor in-order traversal:\\n\\n    def inorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\n\\nFor pre-order traversal:\\n\\n    def preorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val)\\n        return res",
                "solutionTags": [],
                "code": "For three different kinds of traversal, we only need to change the order of tuples in one line as we've done this in the recursive solution which is very decent and classical. Just put `(0, p[1])` in different position!\\n\\nFor post-order traversal:\\n\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\nFor in-order traversal:\\n\\n    def inorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\\n        return res\\n\\n\\nFor pre-order traversal:\\n\\n    def preorderTraversal(self, root):\\n        res, stack = [], [(1, root)]\\n        while stack:\\n            p = stack.pop()\\n            if not p[1]: continue\\n            stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 45640,
                "title": "an-extremly-straightforward-way-to-write-iterative-code-from-recursions-for-dummies",
                "content": "Here I provide a very straightforward and general way to transform recursion into iterative code. This works especially well for dummies like me.\\n\\nAs we know, the recursion code is very easy to write\\n```\\n    void recursion(TreeNode * cur, vector<int> & result) {\\n        if (cur->left) recursion(cur->left);        // line 0\\n        if (cur->right) recursion(cur->right);      // line 1\\n        result.push_back(cur->val);                 // line 2\\n        return;                                     // line 3\\n    }\\n```\\n\\nThe difficulty is to write the iterative version of such code. I fully mimic the function call stacks. I maintain two stacks: variable stack and pc stack (pc stands for programming counter). Here the variable stack maintains the value of each variable of each function call in the recursion. The pc stack stores the **line of code that is to be executed in each corresponding function**\\n\\nThe entry point in the recursion code is to call recursion(root) function. Hence, in the iterative version of the code, we push root to the variable stack, and 0 to the pc stack. This means that the first line (line 0) of recursion(root) function is to be executed.\\n\\nThen I execute the following loop until the stack is empty.\\n1. Inspect the top of the pc stack. Then increment the top of pc stack, which means that the current line of code has been executed.\\n2. If pc == 0, push the left child of the top of the variable stack to the stack if such child exists. Also push 0 to the pc stack.\\n3. If pc == 1, push the right child of the top of the variable stack to the stack if such child exists. Also push 0 to the pc stack.\\n4. if pc == 2, append the value of the top of the variable stack to the result.\\n5. If pc == 3, pop both variable and pc stack.\\n\\nYou can find pc here fully corresponds to the line number in the previous recursion code! \\n\\nThe complete code is following.\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode *> varStack;\\n        stack<int> PCStack;\\n        vector<int> result;\\n        if (!root) return result;\\n        varStack.push(root);\\n        PCStack.push(0);\\n        while (!varStack.empty()) {\\n            TreeNode * cur = varStack.top();\\n            int pc = PCStack.top();\\n            PCStack.top()++;\\n            if (pc == 0) {\\n                // line 0: if (cur->left) recursion(cur->left); \\n                if (cur->left) {\\n                    varStack.push(cur->left);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 1) {\\n                // line 1: if (cur->right) recursion(cur->right); \\n                if (cur->right) {\\n                    varStack.push(cur->right);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 2) {\\n                // line 2: result.push_back(cur->val);\\n                result.push_back(cur->val);\\n            }\\n            else if (pc == 3) {\\n                // line 3: return\\n                varStack.pop();\\n                PCStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nYes it is LONG. But it is extremely easy to write, since you are simply simulating how the computer does for recursion.\\n\\nThe most **amazing** part of such method is that, it works for all recursions!!! I think that it also shows your understanding of call stacks if you analyze recursion in such a straightforward way.",
                "solutionTags": [],
                "code": "```\\n    void recursion(TreeNode * cur, vector<int> & result) {\\n        if (cur->left) recursion(cur->left);        // line 0\\n        if (cur->right) recursion(cur->right);      // line 1\\n        result.push_back(cur->val);                 // line 2\\n        return;                                     // line 3\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode *> varStack;\\n        stack<int> PCStack;\\n        vector<int> result;\\n        if (!root) return result;\\n        varStack.push(root);\\n        PCStack.push(0);\\n        while (!varStack.empty()) {\\n            TreeNode * cur = varStack.top();\\n            int pc = PCStack.top();\\n            PCStack.top()++;\\n            if (pc == 0) {\\n                // line 0: if (cur->left) recursion(cur->left); \\n                if (cur->left) {\\n                    varStack.push(cur->left);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 1) {\\n                // line 1: if (cur->right) recursion(cur->right); \\n                if (cur->right) {\\n                    varStack.push(cur->right);\\n                    PCStack.push(0);\\n                }\\n            }\\n            else if (pc == 2) {\\n                // line 2: result.push_back(cur->val);\\n                result.push_back(cur->val);\\n            }\\n            else if (pc == 3) {\\n                // line 3: return\\n                varStack.pop();\\n                PCStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443702,
                "title": "easy-recursive-iterative-100-explained-java-c-python-python3",
                "content": "# **Java Solution (Iterative Approach Using Stack):**\\nRuntime: 1 ms, faster than 89.81% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 42 MB, less than 74.94% of Java online submissions for Binary Tree Postorder Traversal.\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<Integer>();\\n        // Return the solution answer if the tree is empty...\\n        if(root==null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<TreeNode>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()) {\\n            // set peek a node from the stack...\\n            TreeNode node = bag.peek();\\n            // If the subtrees of that node are null, then pop & store the pop value into solution result...\\n            if(node.left==null && node.right==null) {\\n                TreeNode pop = bag.pop();\\n                sol.add(pop.val);\\n            }\\n            else {\\n                // Push the right child of the popped node into the stack...\\n                if(node.right!=null) {\\n                    bag.push(node.right);\\n                    node.right = null;\\n                }\\n                // Push the left child of the popped node into the stack...\\n                if(node.left!=null) {\\n                    bag.push(node.left);\\n                    node.left = null;\\n                }\\n            }\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\\n\\n# **C++ Solution: (Recursive Approach)**\\nRuntime: 1 ms, faster than 93.22% of C++ online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 8.3 MB, less than 96.14% of C++ online submissions for Binary Tree Postorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> sol;\\n        postorder(root, sol);\\n        return sol;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& sol) {\\n        if (!root)\\n            return;\\n        postorder(root->left, sol);\\n        postorder(root->right, sol);\\n        sol.push_back(root->val);\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Iterative Approach Using Stack):**\\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        # Base case...\\n        if not root: return []\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            sol.append(node.val)\\n            # Push the left child of the popped node into the stack...\\n            if node.left:\\n                bag.append(node.left)\\n            # Append the right child of the popped node into the stack...\\n            if node.right:\\n                bag.append(node.right)\\n        return sol[::-1]       # Return the solution list...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<Integer>();\\n        // Return the solution answer if the tree is empty...\\n        if(root==null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<TreeNode>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()) {\\n            // set peek a node from the stack...\\n            TreeNode node = bag.peek();\\n            // If the subtrees of that node are null, then pop & store the pop value into solution result...\\n            if(node.left==null && node.right==null) {\\n                TreeNode pop = bag.pop();\\n                sol.add(pop.val);\\n            }\\n            else {\\n                // Push the right child of the popped node into the stack...\\n                if(node.right!=null) {\\n                    bag.push(node.right);\\n                    node.right = null;\\n                }\\n                // Push the left child of the popped node into the stack...\\n                if(node.left!=null) {\\n                    bag.push(node.left);\\n                    node.left = null;\\n                }\\n            }\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> sol;\\n        postorder(root, sol);\\n        return sol;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector<int>& sol) {\\n        if (!root)\\n            return;\\n        postorder(root->left, sol);\\n        postorder(root->right, sol);\\n        sol.push_back(root->val);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        # Base case...\\n        if not root: return []\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            sol.append(node.val)\\n            # Push the left child of the popped node into the stack...\\n            if node.left:\\n                bag.append(node.left)\\n            # Append the right child of the popped node into the stack...\\n            if node.right:\\n                bag.append(node.right)\\n        return sol[::-1]       # Return the solution list...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354194,
                "title": "python-iterative-method-for-post-in-preorder-traversal",
                "content": "I add ```isinstance``` method to judge what type the value popup from stack. By adding the judge, we can easily simulate system stack and get right order. Hope it is helpful\\n```\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.val)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\\n\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.val)\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\\n\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                    stack.append(temp.val)\\n                else:\\n                    res.append(temp)\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```isinstance```\n```\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.right)\\n                    stack.append(temp.val)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root]\\n        res = []\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                if isinstance(temp, TreeNode):\\n                    stack.append(temp.val)\\n                    stack.append(temp.right)\\n                    stack.append(temp.left)\\n                else:\\n                    res.append(temp)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1026669,
                "title": "simple-java-iterative-postorder-traversal-using-one-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        \\n        if(root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        // We will have a pointer to the recently popped node\\n        TreeNode curr = root, prev = null;\\n        \\n        while(curr != null || !stack.isEmpty()) {\\n            // Keep on iterating towards the leftmost node\\n            while(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // If there is no right child\\n            // or right child is the one that we recently visited\\n            // it means we have traversed all the nodes of stack.peek()\\n            \\n            if(stack.peek().right == null || stack.peek().right == prev) {\\n                // we will update the prev node\\n                prev = stack.pop();\\n                ans.add(prev.val);\\n            } else {\\n                // Otherwise we will visit the right child.\\n                curr = stack.peek().right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        \\n        if(root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        // We will have a pointer to the recently popped node\\n        TreeNode curr = root, prev = null;\\n        \\n        while(curr != null || !stack.isEmpty()) {\\n            // Keep on iterating towards the leftmost node\\n            while(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // If there is no right child\\n            // or right child is the one that we recently visited\\n            // it means we have traversed all the nodes of stack.peek()\\n            \\n            if(stack.peek().right == null || stack.peek().right == prev) {\\n                // we will update the prev node\\n                prev = stack.pop();\\n                ans.add(prev.val);\\n            } else {\\n                // Otherwise we will visit the right child.\\n                curr = stack.peek().right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869679,
                "title": "c-iterative-solution-with-1-stack",
                "content": "A solution I found on Chinese site. \\nIt is really amazing so I want to share it. \\nIt uses only 1 stack and does not need extra space like queue or auxiliary stack.\\nThe trick is to use a `nullptr`(or anything markable) to mark a parent node. When we find a `nullptr` on the top of the stack, it means that all children nodes of a node (which is under the current `nullptr`) has been visited. So we can pop it (and of course, the mark `nullptr`).\\n\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        if(root)stk.push(root);\\n        vector<int> ans;\\n        while(stk.size())\\n        {\\n            auto p = stk.top();\\n            //All children nodes are visited\\n            if(p == nullptr)\\n            {\\n                stk.pop();\\n                ans.push_back(stk.top()->val);\\n                stk.pop();\\n                continue;\\n            }\\n            //Use nullptr to mark parent node\\n            stk.push(nullptr);\\n            //last in first out\\n            if(p->right)stk.push(p->right);\\n            if(p->left)stk.push(p->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        if(root)stk.push(root);\\n        vector<int> ans;\\n        while(stk.size())\\n        {\\n            auto p = stk.top();\\n            //All children nodes are visited\\n            if(p == nullptr)\\n            {\\n                stk.pop();\\n                ans.push_back(stk.top()->val);\\n                stk.pop();\\n                continue;\\n            }\\n            //Use nullptr to mark parent node\\n            stk.push(nullptr);\\n            //last in first out\\n            if(p->right)stk.push(p->right);\\n            if(p->left)stk.push(p->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527604,
                "title": "python3-pre-in-post-iteratively-summarization",
                "content": "### [Python3] Pre, In, Post Iteratively Summarization\\n\\nIn preorder, the order should be\\n\\n**root -> left -> right**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**right -> left -> root**\\n\\n**Pre**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n\\t\\t\\n```\\n<br>\\n<br>  \\nIn inorder, the order should be\\n\\n**left -> root -> right**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**right -> root -> left**\\n\\n**In**\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\\n<br>\\n<br>\\nIn postorder, the order should be\\n\\n**left -> right -> root**\\n\\nBut when we use stack, the order should be reversed:\\n\\n**root -> right -> left**\\n\\n**Post**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\\nIf you like this solution, please click \"Star\" on Github:\\nhttps://github.com/ceezyyy/LeetCode-daily/blob/master/Python3/145.Binary%20Tree%20Postorder%20Traversal.py\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912651,
                "title": "python-easy-to-remember-different-order-traversal-by-one-template",
                "content": "It depends on `res.append(node.val)` location \\n\\n**Template**\\n```\\nclass Solution:\\n    def Traversal(self, root: Optional[TreeNode]):\\n\\t\\tstack = []\\n\\t\\tnode = root \\n\\t\\twhile node or stack:\\n\\t\\t\\twhile node:\\n\\t\\t\\t\\tstack.append(node)\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tnode = node.right\\n\\n```\\n\\n**Preorder**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root \\n        while node or stack:\\n            while node:\\n                res.append(node.val) ###\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            node = node.right\\n        \\n        return res\\n\\n```\\n\\n**Inorder**\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val) ###\\n            node = node.right\\n        \\n        return res\\n```\\n**Postorder**\\n![image](https://assets.leetcode.com/users/images/c07b2fc1-16b8-45df-b0d6-3202b399d318_1649147321.7663379.png)\\n\\nPostorder traversal gets value when we back from right node so we use \"pushing twice strategy\"\\nFirst \"H\" node pop from stack when we back from left node\\nSecond \"H\" node pop from stack when we back from right node\\nver1\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append((node, 2)) \\n                stack.append((node, 1))\\n                node = node.left\\n                \\n            node, seen = stack.pop()\\n            if seen == 2:\\n                res.append(node.val) ###\\n                node = None\\n            else:\\n                node = node.right\\n        \\n        return res\\n```\\nver2\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append([node, 1])\\n                node = node.left                \\n            node, seen = stack[-1]\\n            if seen == 2:\\n                node, seen = stack.pop()\\n                res.append(node.val)\\n                node = None\\n            else:\\n                stack[-1][1] = 2\\n                node = node.right\\n        \\n        return res\\n```\\n\\n**worst  case O(N^2) recursive**\\nbecause list + list  is a N operation\\n\\n**Preorder recursive**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            [root.val] +\\n            self.preorderTraversal(root.left) +\\n            self.preorderTraversal(root.right)\\n        )\\n```\\n**Inorder recursive**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.inorderTraversal(root.left) +\\n            [root.val] +\\n            self.inorderTraversal(root.right)\\n        )\\n```\\n**Postorder recursive**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.postorderTraversal(root.left) +\\n            self.postorderTraversal(root.right) +\\n            [root.val] \\n        )\\n```\\n\\n**O(N)**\\n\\n**Preorder recursive**\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n**Inorder recursive**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n**Postorder recursive**\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    \\tarr.append(node.val)\\n\\t    dfs(root)\\n\\t    return arr\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def Traversal(self, root: Optional[TreeNode]):\\n\\t\\tstack = []\\n\\t\\tnode = root \\n\\t\\twhile node or stack:\\n\\t\\t\\twhile node:\\n\\t\\t\\t\\tstack.append(node)\\n\\t\\t\\t\\tnode = node.left\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tnode = node.right\\n\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root \\n        while node or stack:\\n            while node:\\n                res.append(node.val) ###\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            node = node.right\\n        \\n        return res\\n\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val) ###\\n            node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append((node, 2)) \\n                stack.append((node, 1))\\n                node = node.left\\n                \\n            node, seen = stack.pop()\\n            if seen == 2:\\n                res.append(node.val) ###\\n                node = None\\n            else:\\n                node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res, stack = [], []\\n        node = root\\n        while node or stack:\\n            while node:\\n                stack.append([node, 1])\\n                node = node.left                \\n            node, seen = stack[-1]\\n            if seen == 2:\\n                node, seen = stack.pop()\\n                res.append(node.val)\\n                node = None\\n            else:\\n                stack[-1][1] = 2\\n                node = node.right\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            [root.val] +\\n            self.preorderTraversal(root.left) +\\n            self.preorderTraversal(root.right)\\n        )\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.inorderTraversal(root.left) +\\n            [root.val] +\\n            self.inorderTraversal(root.right)\\n        )\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return [] \\n        return ( \\n            self.postorderTraversal(root.left) +\\n            self.postorderTraversal(root.right) +\\n            [root.val] \\n        )\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t\\t\\tarr.append(node.val)\\n\\t    \\tdfs(node.right)\\n\\t    dfs(root)\\n\\t    return arr\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t    arr = []\\n\\t    def dfs(node):\\n\\t    \\tif not node: return \\n\\t    \\tdfs(node.left)\\n\\t    \\tdfs(node.right)\\n\\t    \\tarr.append(node.val)\\n\\t    dfs(root)\\n\\t    return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498697,
                "title": "c-using-1-stack-iterative-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return {};\\n        }\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            TreeNode* curr = s.top();\\n            if(curr->left){\\n                s.push(curr->left);\\n                curr->left = NULL;\\n            }\\n            else{\\n                if(curr->right){\\n                    s.push(curr->right);\\n                    curr->right = NULL;\\n                }\\n                else{\\n                    ans.push_back(curr->val);\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you like this solution then please upvote this solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return {};\\n        }\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            TreeNode* curr = s.top();\\n            if(curr->left){\\n                s.push(curr->left);\\n                curr->left = NULL;\\n            }\\n            else{\\n                if(curr->right){\\n                    s.push(curr->right);\\n                    curr->right = NULL;\\n                }\\n                else{\\n                    ans.push_back(curr->val);\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45674,
                "title": "accepted-tiny-java-solution-only-left-hand-children-in-stack",
                "content": "Share my solution using stack and LinkedList.\\n\\nNotes:\\n\\n 1. In this code I push only left-hand children in to the stack.\\n 2. To store result I use LinkedList and addFirst() method of it.\\n     With such approuch we can save on reverce the result.\\n\\n----------\\n\\n    public List<Integer> postorderTraversal(TreeNode node) {\\n\\t\\tLinkedList<Integer> result = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> leftChildren = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tresult.addFirst(node.val);\\n\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\tleftChildren.push(node.left);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.right;\\n\\t\\t\\tif (node == null && !leftChildren.isEmpty()) {\\n\\t\\t\\t\\tnode = leftChildren.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Share my solution using stack and LinkedList.\\n\\nNotes:\\n\\n 1. In this code I push only left-hand children in to the stack.\\n 2. To store result I use LinkedList and addFirst() method of it.\\n     With such approuch we can save on reverce the result.\\n\\n----------\\n\\n    public List<Integer> postorderTraversal(TreeNode node) {\\n\\t\\tLinkedList<Integer> result = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> leftChildren = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tresult.addFirst(node.val);\\n\\t\\t\\tif (node.left != null) {\\n\\t\\t\\t\\tleftChildren.push(node.left);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.right;\\n\\t\\t\\tif (node == null && !leftChildren.isEmpty()) {\\n\\t\\t\\t\\tnode = leftChildren.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1104634,
                "title": "java-iterative-with-one-stack-and-no-hack-wiki",
                "content": "See more in https://en.wikipedia.org/wiki/Tree_traversal#Post-order\\n1. Just like with in-order traversal we go to the left subtree as long as we can. At the same time we keep adding the nodes to the stack.\\n2. If we can\\'t (left = null) - we try to go to the right subtree. In order to do that we check the last one we added to the stack.\\n3. If it has a right subtree and we haven\\'t visited it yet then we go there and repeat steps 1 and 2.\\n4. Else we visit the node (also pop out of the stack) \\'cause by that time we visited left and right subtrees snd it\\'s time to visit their parent. After that we continue the outer loop, peek another node from the stack and repeat 2, 3.\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode cur = root, lastVisited = null;\\n        \\n        while (!stack.isEmpty() || cur != null) {\\n            if (cur != null) {\\n                stack.addLast(cur);\\n                cur = cur.left;\\n            } else {\\n                TreeNode peek = stack.peekLast();\\n                if (peek.right != null && peek.right != lastVisited) {\\n                    cur = peek.right;\\n                } else {\\n                    res.add(peek.val);\\n                    lastVisited = stack.removeLast();\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        TreeNode cur = root, lastVisited = null;\\n        \\n        while (!stack.isEmpty() || cur != null) {\\n            if (cur != null) {\\n                stack.addLast(cur);\\n                cur = cur.left;\\n            } else {\\n                TreeNode peek = stack.peekLast();\\n                if (peek.right != null && peek.right != lastVisited) {\\n                    cur = peek.right;\\n                } else {\\n                    res.add(peek.val);\\n                    lastVisited = stack.removeLast();\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774726,
                "title": "c-iterative-stack-based",
                "content": "\\n\\n      class Solution {\\n      public:\\n          vector<int> postorderTraversal(TreeNode* root) {\\n              if(root==NULL)\\n                  return {};\\n              stack<TreeNode*> s1;\\n              stack<TreeNode*> s2;\\n              vector<int> vec;\\n              s1.push(root);\\n              while(!s1.empty()){\\n                  root=s1.top();\\n                  s1.pop();\\n                  if(root->left!=NULL){\\n                      s1.push(root->left);\\n                  }\\n                  if(root->right!=NULL){\\n                      s1.push(root->right);\\n                  }\\n                  s2.push(root);\\n              }\\n              while(!s2.empty()){\\n                  vec.push_back(s2.top()->val);\\n                  s2.pop();\\n              }\\n              return vec;\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n      public:\\n          vector<int> postorderTraversal(TreeNode* root) {\\n              if(root==NULL)\\n                  return {}",
                "codeTag": "Java"
            },
            {
                "id": 158289,
                "title": "python-dfs-stack",
                "content": "### 145. Binary Tree Postorder Traversal\\n```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.dfs(root.left)\\n        self.dfs(root.right) \\n        self.res.append(root.val)\\n```\\n<br>\\n\\n#### Stack (Reverse Preorder)\\n\\n\\u5229\\u7528Postorder\\u548CPreorder\\u7684\\u5173\\u7CFB\\uFF0C\\u53D6\\u5DE7\\u7684\\u5148\\u8FED\\u4EE3\\u53F3\\u8FB9\\u5B50\\u5B59\\uFF0C\\u6700\\u540E\\u8FD4\\u56DEreversed\\u7684List\\u5373\\u53EF\\uFF0C\\u8111\\u5B50\\u6655\\u7684\\u5C0F\\u4F19\\u4F34\\u53BB\\u753B\\u5F20\\u56FE\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.right     #\\u5148\\u52A0\\u53F3\\u8FB9\\uFF0C\\u5728\\u5DE6\\u8FB9\\u3002\\n            else:\\n                node = stack.pop()\\n                root = node.left\\n        return res[::-1]     #\\u8FD4\\u56DEReversed\\u7684list\\n```\\n<br>\\n\\n#### Stack (\\u5229\\u7528Flag)\\n\\n\\u6BCF\\u6B21\\u5F80Stack\\u91CC\\u9762\\u50A8\\u5B58\\u7684\\u987A\\u5E8F\\u662F\\uFF0C\\u5148\\u5B58\\u50A8\\u5F53\\u524D`root`\\uFF0C\\u7136\\u540E`right`\\uFF0C\\u6700\\u540E`left`\\uFF0C\\u8FD9\\u6837\\u5F53pop\\u5230\\u6700\\u5DE6\\u8FB9\\u53F6\\u5B50\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0C\\u5C31\\u4E3A\\u7B2C\\u4E00\\u4E2A`print`\\u7684\\u6570\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21`pop`\\u5B8C\\u4E4B\\u540E\\u7684`root`\\u4E4B\\u540E\\u8FD8\\u4F1A\\u7528\\u5230\\uFF0C\\u6240\\u4EE5\\u8FD9\\u91CC\\u5229\\u7528flag\\uFF0C\\u6BCF\\u6B21\\u53CA\\u65F6\\u4F7F\\u7528\\u5B8C`root`\\u4E5F\\u5C06root\\u91CD\\u65B0\\u653E\\u56DEstack\\uFF0C\\u5728\\u4E4B\\u540Epop\\u8FC7\\u7A0B\\u4E2D\\u518D\\u68C0\\u67E5flag\\uFF0C\\u5982\\u679Cvisited\\u8FC7\\uFF0C\\u5219\\u4E0D\\u518D\\u653E\\u56DEstack\\u3002\\n\\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.dfs(root.left)\\n        self.dfs(root.right) \\n        self.res.append(root.val)\\n```\n```python\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.right     #\\u5148\\u52A0\\u53F3\\u8FB9\\uFF0C\\u5728\\u5DE6\\u8FB9\\u3002\\n            else:\\n                node = stack.pop()\\n                root = node.left\\n        return res[::-1]     #\\u8FD4\\u56DEReversed\\u7684list\\n```\n```\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45853,
                "title": "accepted-just-a-reversal-of-a-modified-pre-order-traversal",
                "content": "This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here's my code... \\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a list of integers\\n    def postorderTraversal(self, root):\\n        traversalInt = list()\\n        if root!=None:\\n            traversal = list()\\n            traversal.append(root)\\n            \\n            while len(traversal)>0:\\n                probe = traversal[0]\\n                traversalInt.append(probe.val)\\n                traversal.remove(probe)\\n                if (probe.left != None):\\n                    traversal.insert(0,probe.left)\\n                if (probe.right != None):\\n                    traversal.insert(0,probe.right)\\n        return traversalInt[::-1]",
                "solutionTags": [],
                "code": "This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here's my code... \\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a list of integers\\n    def postorderTraversal(self, root):\\n        traversalInt = list()\\n        if root!=None:\\n            traversal = list()\\n            traversal.append(root)\\n            \\n            while len(traversal)>0:\\n                probe = traversal[0]\\n                traversalInt.append(probe.val)\\n                traversal.remove(probe)\\n                if (probe.left != None):\\n                    traversal.insert(0,probe.left)\\n                if (probe.right != None):\\n                    traversal.insert(0,probe.right)\\n        return traversalInt[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 880981,
                "title": "iterative-recursive-js-solutions",
                "content": "```\\n// Iterative Solution\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack[stack.length-1];\\n        if (node.left) {\\n            stack.push(node.left);\\n            node.left = null;\\n        }\\n        else if (node.right) {\\n            stack.push(node.right);\\n            node.right = null;\\n        }\\n        else res.push(stack.pop().val);\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\n// Recursive Solution\\nvar postorderTraversal = function(root) {\\n    let res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        traverse(node.right);\\n        res.push(node.val);\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Iterative Solution\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack[stack.length-1];\\n        if (node.left) {\\n            stack.push(node.left);\\n            node.left = null;\\n        }\\n        else if (node.right) {\\n            stack.push(node.right);\\n            node.right = null;\\n        }\\n        else res.push(stack.pop().val);\\n    }\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\n```\\n// Recursive Solution\\nvar postorderTraversal = function(root) {\\n    let res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        traverse(node.right);\\n        res.push(node.val);\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941817,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func postOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            postOrder(root.left)\\n            postOrder(root.right)\\n            res.append(root.val)\\n        }\\n        \\n        postOrder(root)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func postOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            postOrder(root.left)\\n            postOrder(root.right)\\n            res.append(root.val)\\n        }\\n        \\n        postOrder(root)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245727,
                "title": "c-preorder-inorder-postorder-morris-traversal",
                "content": "O(n) time and O(1) space\\nThe basic idea is the postorder traversal can be considered as a reverse process of preorder traversal. Therefore, we just need to change all left child to right child and always insert elements at the beginning of the vector. \\n\\n* **PostOrder**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* current = root;\\n        vector<int> values;\\n        while (current != NULL){\\n            if (current->right == NULL){\\n                // Always insert at the beginning\\n                values.insert(values.begin(), current->val);\\n                current = current->left; // Reverse of preorder traversal\\n            }else{\\n                TreeNode* predecessor = findPredecessor(current);\\n                if (predecessor->left == NULL){\\n                    // Link to current\\n                    predecessor->left = current;\\n                    values.insert(values.begin(), current->val);\\n                    current = current->right;   // Reverse of preorder\\n                }else{\\n                    predecessor->left = NULL;\\n                    current = current->left;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        // Reverse of preorder traversal\\n        TreeNode* predecessor = current->right; \\n        while (predecessor->left != NULL && predecessor->left != current){\\n            predecessor = predecessor->left;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\\n* **PreOrder**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while(current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode *predecessor = findPredecessor(current);\\n                if (predecessor->right == NULL){\\n                    predecessor->right = current;\\n                    values.push_back(current->val);\\n                    current = current->left;\\n                }else{\\n                    predecessor->right = NULL;\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* predecessor = current->left;\\n        while(predecessor->right != NULL && predecessor->right != current){\\n            predecessor = predecessor->right;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\\n* **InOrder**\\nThe difference between inorder and preorder is the place for inserting elements to the vector.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while (current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode* preDecessor = findPredecessor(current);\\n                if (preDecessor->right == NULL){\\n                    preDecessor->right = current;\\n                    current = current->left;\\n                }else{\\n                    preDecessor->right = NULL;\\n                    values.push_back(current->val);\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* preDecessor = current->left;\\n        while (preDecessor->right != NULL && preDecessor->right != current){\\n            preDecessor = preDecessor->right;\\n        }\\n        return preDecessor;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* current = root;\\n        vector<int> values;\\n        while (current != NULL){\\n            if (current->right == NULL){\\n                // Always insert at the beginning\\n                values.insert(values.begin(), current->val);\\n                current = current->left; // Reverse of preorder traversal\\n            }else{\\n                TreeNode* predecessor = findPredecessor(current);\\n                if (predecessor->left == NULL){\\n                    // Link to current\\n                    predecessor->left = current;\\n                    values.insert(values.begin(), current->val);\\n                    current = current->right;   // Reverse of preorder\\n                }else{\\n                    predecessor->left = NULL;\\n                    current = current->left;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        // Reverse of preorder traversal\\n        TreeNode* predecessor = current->right; \\n        while (predecessor->left != NULL && predecessor->left != current){\\n            predecessor = predecessor->left;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while(current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode *predecessor = findPredecessor(current);\\n                if (predecessor->right == NULL){\\n                    predecessor->right = current;\\n                    values.push_back(current->val);\\n                    current = current->left;\\n                }else{\\n                    predecessor->right = NULL;\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* predecessor = current->left;\\n        while(predecessor->right != NULL && predecessor->right != current){\\n            predecessor = predecessor->right;\\n        }\\n        return predecessor;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> values;\\n        TreeNode *current = root;\\n        while (current != NULL){\\n            if (current->left == NULL){\\n                values.push_back(current->val);\\n                current = current->right;\\n            }else{\\n                TreeNode* preDecessor = findPredecessor(current);\\n                if (preDecessor->right == NULL){\\n                    preDecessor->right = current;\\n                    current = current->left;\\n                }else{\\n                    preDecessor->right = NULL;\\n                    values.push_back(current->val);\\n                    current = current->right;\\n                }\\n            }\\n        }\\n        return values;\\n    }\\n    TreeNode* findPredecessor(TreeNode* current){\\n        TreeNode* preDecessor = current->left;\\n        while (preDecessor->right != NULL && preDecessor->right != current){\\n            preDecessor = preDecessor->right;\\n        }\\n        return preDecessor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45793,
                "title": "a-java-simple-solution-based-on-preorder-traversal",
                "content": "Postorder traversal, which is in Left-Right-Root order. We can observe that the preorder traversal is in Root-Left-Right order, which means if we swap the order of left and right subtree when pushing into stack, we'll get Root-Right-Left, a new traversal.\\n\\nIt is just the opposite way of postorder one. And that's why the following code works.\\n\\n    public class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<Integer>();\\n        if(root == null) return result;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            root = stack.pop();\\n            result.addFirst(root.val);\\n            if(root.left != null){\\n                stack.push(root.left);\\n            }\\n            if(root.right != null){\\n                stack.push(root.right);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> result = new LinkedList<Integer>();\\n        if(root == null) return result;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            root = stack.pop();\\n            result.addFirst(root.val);\\n            if(root.left != null){\\n                stack.push(root.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 332286,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            dfs(node.right)\\n            post_order.append(node.val)\\n        \\n        post_order = []\\n        dfs(root)\\n        return post_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        post_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_next = True\\n            if top.right and top.right not in visited:\\n                stack.append(top.right)\\n                visited.add(top.right)\\n                no_next = False\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_next = False\\n            if no_next:\\n                post_order.append(top.val)\\n\\t\\t\\t\\tstack.pop()\\n        return post_order\\n```\\n\\nIterative solution 2: use a stack and two pointers\\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        post_order, stack = [], []\\n        prev, p = None, root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                top = stack[-1]\\n                if top.right and top.right != prev:\\n                    p = top.right\\n                else:\\n                    post_order.append(top.val)\\n                    prev = top\\n                    stack.pop()\\n        return post_order\\n```",
                "solutionTags": [],
                "code": "```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            dfs(node.right)\\n            post_order.append(node.val)\\n        \\n        post_order = []\\n        dfs(root)\\n        return post_order\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        post_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_next = True\\n            if top.right and top.right not in visited:\\n                stack.append(top.right)\\n                visited.add(top.right)\\n                no_next = False\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_next = False\\n            if no_next:\\n                post_order.append(top.val)\\n\\t\\t\\t\\tstack.pop()\\n        return post_order\\n```\n```\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        post_order, stack = [], []\\n        prev, p = None, root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                top = stack[-1]\\n                if top.right and top.right != prev:\\n                    p = top.right\\n                else:\\n                    post_order.append(top.val)\\n                    prev = top\\n                    stack.pop()\\n        return post_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2356012,
                "title": "python-iterative-solution-no-reversal-concise-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        s = [root]\\n        res = []        \\n        \\n        while s:\\n            cur = s[-1]\\n            if not cur.left and not cur.right:\\n                s.pop()\\n                res.append(cur.val)\\n\\n            if cur.right:\\n                s.append(cur.right)\\n                cur.right = None\\n            \\n            if cur.left:\\n                s.append(cur.left)\\n                cur.left = None\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        s = [root]\\n        res = []        \\n        \\n        while s:\\n            cur = s[-1]\\n            if not cur.left and not cur.right:\\n                s.pop()\\n                res.append(cur.val)\\n\\n            if cur.right:\\n                s.append(cur.right)\\n                cur.right = None\\n            \\n            if cur.left:\\n                s.append(cur.left)\\n                cur.left = None\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404980,
                "title": "binary-tree-postorder-traversal-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> output = new ArrayList<>();\\n        postorder(root, output);\\n        return output;\\n    }\\n    \\n    public void postorder(TreeNode root,List<Integer> output){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, output);\\n        postorder(root.right, output);\\n        output.add(root.val);\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> output = new ArrayList<>();\\n        postorder(root, output);\\n        return output;\\n    }\\n    \\n    public void postorder(TreeNode root,List<Integer> output){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, output);\\n        postorder(root.right, output);\\n        output.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357925,
                "title": "python-easy-template-for-iterative-traversal-preorder-inorder-postorder",
                "content": "This is a simple solution using with just one stack and a while loop with `O(n)` complexity. Almost as simple as the recursive solution and inspired by [autekwing](https://leetcode.com/autekwing/) comment [here](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31381/Python-recursive-and-iterative-solutions./30044).\\n\\nTemplate:\\n```\\ndef iterativeTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n\\t\\t\\t\\t# pop the stack\\n                # append to answer list\\n\\t\\t\\t\\t# update node to go right\\n                \\n        return ans            \\n```\\n\\nActual code with with runtime that beats more than 70% of submissions:\\n\\nPostorder\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack[-1].right:\\n                root = stack[-1].right\\n                stack[-1].right = None\\n            else:\\n                ans.append(stack.pop().val)\\n                \\n        return ans            \\n```\\n\\nInorder\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        res = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                curr = stack.pop()\\n                res.append(curr.val)\\n                root = curr.right\\n                \\n        return res\\n```\\n\\nPreorder\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n\\t\\t\\n        while stack or root:\\n            if root:\\n                ans.append(root.val)\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef iterativeTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n\\t\\t\\t\\t# pop the stack\\n                # append to answer list\\n\\t\\t\\t\\t# update node to go right\\n                \\n        return ans            \\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack[-1].right:\\n                root = stack[-1].right\\n                stack[-1].right = None\\n            else:\\n                ans.append(stack.pop().val)\\n                \\n        return ans            \\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        res = list()\\n        \\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                curr = stack.pop()\\n                res.append(curr.val)\\n                root = curr.right\\n                \\n        return res\\n```\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = list()\\n        ans = list()\\n\\t\\t\\n        while stack or root:\\n            if root:\\n                ans.append(root.val)\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 287305,
                "title": "java-solution-without-using-linked-list-or-without-reversing",
                "content": "The idea is a small extension to Inorder iterative traversal.\\n\\nHere\\'s the iterative inorder traversal:\\n```\\npublic List < Integer > inorderTraversal(TreeNode root) {\\n        List < Integer > res = new ArrayList < > ();\\n        Stack < TreeNode > stack = new Stack < > ();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n```\\nFor post order traversal:\\nSo, while moving to the left most node, we also add the curr roots right to the stack along with the curr node.\\nThen when we reach the left most node, if it doesn\\'t have any right node (i.e it is a leaf node), we add it to result and set curr to null. \\n\\nElse, if the curr node\\'s right node is same as the stack\\'s top., this means that the current\\'s right tree is yet to be processed. So, before processing curr, we have to process its right subtree., so, we pop the right node from stack, push curr to the stack and point curr to its right node and continue with processing.\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n\\t\\t\\t    // push right on to stack before curr\\n                if (curr.right != null) stack.push(curr.right);\\n\\t\\t\\t\\t//push curr onto stack and move left\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = stack.pop();\\n\\n            // if curr\\'s right is at the top of stack i.e, it is not yet processed\\n            if (!stack.isEmpty() && curr.right == stack.peek()) {\\n\\t\\t\\t    //pop its right from stack\\n                stack.pop();\\n\\t\\t\\t\\t//push curr to stack to process it in future\\n                stack.push(curr);\\n\\t\\t\\t\\t//point curr to its right\\n                curr = curr.right;\\n            }\\n            else {\\n\\t\\t\\t    // if curr is left most and doesnt have any right or if its right has already been processed, process curr and set it to null\\n                res.add(curr.val);\\n                curr = null;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List < Integer > inorderTraversal(TreeNode root) {\\n        List < Integer > res = new ArrayList < > ();\\n        Stack < TreeNode > stack = new Stack < > ();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n\\n        List<Integer> res = new ArrayList<>();\\n\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n\\t\\t\\t    // push right on to stack before curr\\n                if (curr.right != null) stack.push(curr.right);\\n\\t\\t\\t\\t//push curr onto stack and move left\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = stack.pop();\\n\\n            // if curr\\'s right is at the top of stack i.e, it is not yet processed\\n            if (!stack.isEmpty() && curr.right == stack.peek()) {\\n\\t\\t\\t    //pop its right from stack\\n                stack.pop();\\n\\t\\t\\t\\t//push curr to stack to process it in future\\n                stack.push(curr);\\n\\t\\t\\t\\t//point curr to its right\\n                curr = curr.right;\\n            }\\n            else {\\n\\t\\t\\t    // if curr is left most and doesnt have any right or if its right has already been processed, process curr and set it to null\\n                res.add(curr.val);\\n                curr = null;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45806,
                "title": "python-iterative-solution",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def postorderTraversal(self, root):\\n            if not root:\\n                return []\\n    \\n            result, queue = [], [(root, False)]\\n            while queue:\\n                curNode, visited = queue.pop()\\n                if curNode:\\n                    if visited:\\n                        result.append(curNode.val)\\n                    else:\\n                        queue.append((curNode, True))\\n                        queue.append((curNode.right, False))\\n                        queue.append((curNode.left, False))\\n    \\n            return result",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 45557,
                "title": "my-accepted-code-of-binary-tree-postorder-traversal",
                "content": "**Method 1: Using one stack and will change the input data. Consume time 36 ms** \\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <stack>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* n = s.top();\\n    \\t\\t\\tif(n->right)\\n    \\t\\t\\t\\ts.push(n->right);\\n    \\t\\t\\tif(n->left)\\n    \\t\\t\\t\\ts.push(n->left);\\n    \\t\\t\\tn->left = NULL;\\n    \\t\\t\\tn->right = NULL;\\n    \\n    \\t\\t\\tn = s.top();\\n    \\t\\t\\tif(n->left == NULL && n->right == NULL)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tvec.push_back(n->val);\\n    \\t\\t\\t\\ts.pop();\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn vec;\\n        }\\n    };\\n\\n**Method 2: Using two stacks and do not change the input data. Consume time 8ms**\\n\\n    #include <iostream>\\n    #include <vector>\\n    #include <stack>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n             stack<TreeNode*> s,out;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* node = s.top();\\n    \\t\\t\\ts.pop();\\n    \\t\\t\\tout.push(node);\\n    \\t\\t\\tif(node->left)\\n    \\t\\t\\t\\ts.push(node->left);\\n    \\t\\t\\tif(node->right)\\n    \\t\\t\\t\\ts.push(node->right);\\n    \\t\\t}\\n    \\n    \\t\\twhile(!out.empty())\\n    \\t\\t{\\n    \\t\\t\\tvec.push_back(out.top()->val);\\n    \\t\\t\\tout.pop();\\n    \\t\\t}\\n    \\t\\treturn vec;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n    \\t\\tvector<int> vec;\\n    \\t\\tif(root == NULL)\\n    \\t\\t\\treturn vec;\\n    \\n    \\t\\ts.push(root);\\n    \\t\\twhile(!s.empty())\\n    \\t\\t{\\n    \\t\\t\\tTreeNode* n = s.top();\\n    \\t\\t\\tif(n->right)\\n    \\t\\t\\t\\ts.push(n->right);\\n    \\t\\t\\tif(n->left)\\n    \\t\\t\\t\\ts.push(n->left);\\n    \\t\\t\\tn->left = NULL;\\n    \\t\\t\\tn->right = NULL;\\n    \\n    \\t\\t\\tn = s.top();\\n    \\t\\t\\tif(n->left == NULL && n->right == NULL)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tvec.push_back(n->val);\\n    \\t\\t\\t\\ts.pop();\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1038517,
                "title": "javascript-2-solutions-stack-recursive-easy-to-understand",
                "content": "**Stack Solution**\\n```\\nvar postorderTraversal = function(root) {\\n    if(!root) return [];\\n\\n    const stack = [root];\\n    const result = [];\\n    while(stack.length > 0) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        if(node.left) stack.push(node.left);\\n        if(node.right) stack.push(node.right);\\n    }\\n    \\n    return result.reverse();\\n};\\n```\\n\\n**Recursive Solution**\\n```\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    const recursive = (node) => {\\n        if(!node) return;\\n\\n        if(node.left) recursive(node.left);\\n        if(node.right) recursive(node.right);\\n        result.push(node.val);\\n    }\\n\\n    recursive(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    if(!root) return [];\\n\\n    const stack = [root];\\n    const result = [];\\n    while(stack.length > 0) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        if(node.left) stack.push(node.left);\\n        if(node.right) stack.push(node.right);\\n    }\\n    \\n    return result.reverse();\\n};\\n```\n```\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    const recursive = (node) => {\\n        if(!node) return;\\n\\n        if(node.left) recursive(node.left);\\n        if(node.right) recursive(node.right);\\n        result.push(node.val);\\n    }\\n\\n    recursive(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45818,
                "title": "sharing-my-implementation-and-looking-for-an-even-more-concise-one",
                "content": "I have checked many implementations of iterative solutions to this problem; many of them seem to be rather verbose. After some investigations, I have come up with this following solution:\\n\\n    vector<int> postorderTraversal(TreeNode *root) {\\n        stack<TreeNode*> s;\\n        TreeNode* cur = root;\\n        vector<int> temp;\\n        while(true)\\n        {\\n            if (cur == NULL)  // If the current branch is finished, then go back to the most recent unvisited branch\\n            {\\n                if (!s.empty()) {cur = s.top(); s.pop(); continue;} // Checked the first unvisited branch\\n                else break;\\n            }\\n            temp.push_back(cur->val); // Add the current value to the FRONT of list\\n            s.push(cur->left);         // Push the left child to the stack\\n            cur = cur->right;          // Go the right child\\n        }\\n        // Don't forget to reverse the 'right-to-left' pre-order traversal!\\n        return vector<int>(temp.rbegin(), temp.rend()); \\n    }\\n\\nThe idea is to exploit the fact that Post-order Traversal is equivalent to the REVERSE of a 'right-to-left' (i.e. traverse the right children then the left ones) pre-order traversal. For example, for the following tree:\\n\\n           A\\n          / \\\\\\n         B   C\\n        / \\\\\\n       D   E\\n\\npost-order: D E B C A\\n\\n'right-to-left' pre-order: A C B E D \\n\\nAs for the pre-order traversal, we initialize the current node to the root. Then we keep adding the value of the current node to the traversal list, and then push its left child to a stack, and set its right child as the current node. That way, each element in the stack represents the root of a branch that we should visit at later time, with the top element being the first one that we visit as soon as we get the chance to.\\n\\nIf we find the current node is NULL, it means we have reached the end of a branch, then we should visit a new branch beginning at the top of the stack. If the top element of the stack is also NULL, it means this branch does not contain anything, then we should pop it out, then check the new top element until it is no longer NULL. If the stack turns empty before we find a non-NULL node in it, then we have visited all the nodes in the tree.\\n \\nAnd it boils down to this simple iterative rule:\\n\\n------------\\n\\nIn each iteration\\n\\n1. If the current node is not NULL, then \\n\\n  A) add its value to the traversal list, and \\n\\n  B) push its LEFT child to stack, and \\n\\n  C) go to its RIGHT child. \\n\\n2. If the current node is NULL, then set the current node to the top of the stack (terminate if the stack is already empty).\\n\\n-------------\\n\\n Implementation-wise, this is the most concise solution I have come up so far. And the code can be applied almost directly to a similar problem ('Binary Tree Pre-Order Traversal') with little modification. \\nI really would like to know if there is any better algorithm that would result in an even more concise implementation than this one. Any comments/suggestions are welcome!",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "I have checked many implementations of iterative solutions to this problem; many of them seem to be rather verbose. After some investigations, I have come up with this following solution:\\n\\n    vector<int> postorderTraversal(TreeNode *root) {\\n        stack<TreeNode*> s;\\n        TreeNode* cur = root;\\n        vector<int> temp;\\n        while(true)\\n        {\\n            if (cur == NULL)  // If the current branch is finished, then go back to the most recent unvisited branch\\n            {\\n                if (!s.empty()) {cur = s.top(); s.pop(); continue;} // Checked the first unvisited branch\\n                else break;\\n            }\\n            temp.push_back(cur->val); // Add the current value to the FRONT of list\\n            s.push(cur->left);         // Push the left child to the stack\\n            cur = cur->right;          // Go the right child\\n        }\\n        // Don't forget to reverse the 'right-to-left' pre-order traversal!\\n        return vector<int>(temp.rbegin(), temp.rend()); \\n    }\\n\\nThe idea is to exploit the fact that Post-order Traversal is equivalent to the REVERSE of a 'right-to-left' (i.e. traverse the right children then the left ones) pre-order traversal. For example, for the following tree:\\n\\n           A\\n          / \\\\\\n         B   C\\n        / \\\\\\n       D   E\\n\\npost-order: D E B C A\\n\\n'right-to-left' pre-order: A C B E D \\n\\nAs for the pre-order traversal, we initialize the current node to the root. Then we keep adding the value of the current node to the traversal list, and then push its left child to a stack, and set its right child as the current node. That way, each element in the stack represents the root of a branch that we should visit at later time, with the top element being the first one that we visit as soon as we get the chance to.\\n\\nIf we find the current node is NULL, it means we have reached the end of a branch, then we should visit a new branch beginning at the top of the stack. If the top element of the stack is also NULL, it means this branch does not contain anything, then we should pop it out, then check the new top element until it is no longer NULL. If the stack turns empty before we find a non-NULL node in it, then we have visited all the nodes in the tree.\\n \\nAnd it boils down to this simple iterative rule:\\n\\n------------\\n\\nIn each iteration\\n\\n1. If the current node is not NULL, then \\n\\n  A) add its value to the traversal list, and \\n\\n  B) push its LEFT child to stack, and \\n\\n  C) go to its RIGHT child. \\n\\n2. If the current node is NULL, then set the current node to the top of the stack (terminate if the stack is already empty).\\n\\n-------------\\n\\n Implementation-wise, this is the most concise solution I have come up so far. And the code can be applied almost directly to a similar problem ('Binary Tree Pre-Order Traversal') with little modification. \\nI really would like to know if there is any better algorithm that would result in an even more concise implementation than this one. Any comments/suggestions are welcome!",
                "codeTag": "Unknown"
            },
            {
                "id": 1003772,
                "title": "simple-one-stack",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\t\\t# Stack of nodes to process. \"True\" only when children trees have been traversed.\\t\\n        stack = [(root, False)]\\n        result = []\\n        while stack:\\n            node, done = stack.pop()\\n            if done:\\n                result.append(node.val)\\n            else:\\n\\t\\t\\t    # For post-order traversal, need to first visit left then right before node is \"done\", so add them in reverse order to the stack.\\n\\t\\t\\t\\t# By changing the order here we could achieve pre- or in-order as well.\\n                stack.append((node, True))\\n                if node.right:\\n                    stack.append((node.right, False))\\n                if node.left:\\n                    stack.append((node.left, False))\\n        return result                    \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\t\\t# Stack of nodes to process. \"True\" only when children trees have been traversed.\\t\\n        stack = [(root, False)]\\n        result = []\\n        while stack:\\n            node, done = stack.pop()\\n            if done:\\n                result.append(node.val)\\n            else:\\n\\t\\t\\t    # For post-order traversal, need to first visit left then right before node is \"done\", so add them in reverse order to the stack.\\n\\t\\t\\t\\t# By changing the order here we could achieve pre- or in-order as well.\\n                stack.append((node, True))\\n                if node.right:\\n                    stack.append((node.right, False))\\n                if node.left:\\n                    stack.append((node.left, False))\\n        return result                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 45548,
                "title": "simple-javascript-solution",
                "content": "A postorder traversal can be easily reversed by a preorder traversal like this:\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    \\n    var result = [], stack = [root];\\n    \\n    while (stack.length) {\\n        var node = stack.pop();\\n        // insert the node val to the front\\n        result.unshift(node.val);\\n\\n        if (node.left) stack.push(node.left); // left first\\n        if (node.right) stack.push(node.right); // then right\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    \\n    var result = [], stack = [root];\\n    \\n    while (stack.length) {\\n        var node = stack.pop();\\n        // insert the node val to the front\\n        result.unshift(node.val);\\n\\n        if (node.left) stack.push(node.left); // left first\\n        if (node.right) stack.push(node.right); // then right\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45866,
                "title": "my-accepted-java-solution",
                "content": "Straightforward thought:\\nYou will meet a node three times from a stack.\\nFor the first time, push the left. The second time, push the right, The third time you meet it, move it to result.\\n\\n\\tclass TreeNodeStack {\\n\\t\\tTreeNode node;\\n\\t\\tint count;\\n\\n\\t\\tTreeNodeStack(TreeNode node) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tDeque<TreeNodeStack> stack = new ArrayDeque<TreeNodeStack>();\\n\\t\\tstack.add(new TreeNodeStack(root));\\n\\t\\twhile (stack.size() > 0) {\\n\\t\\t\\tTreeNodeStack s = stack.peekLast();\\n\\t\\t\\ts.count++;\\n\\t\\t\\tif (s.node == null) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==1){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.left));\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==2){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.right));\\n\\t\\t\\t}\\n\\t\\t\\telse if (s.count == 3) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t\\tresult.add(s.node.val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "Straightforward thought:\\nYou will meet a node three times from a stack.\\nFor the first time, push the left. The second time, push the right, The third time you meet it, move it to result.\\n\\n\\tclass TreeNodeStack {\\n\\t\\tTreeNode node;\\n\\t\\tint count;\\n\\n\\t\\tTreeNodeStack(TreeNode node) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic List<Integer> postorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> result = new ArrayList<Integer>();\\n\\t\\tDeque<TreeNodeStack> stack = new ArrayDeque<TreeNodeStack>();\\n\\t\\tstack.add(new TreeNodeStack(root));\\n\\t\\twhile (stack.size() > 0) {\\n\\t\\t\\tTreeNodeStack s = stack.peekLast();\\n\\t\\t\\ts.count++;\\n\\t\\t\\tif (s.node == null) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==1){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.left));\\n\\t\\t\\t}\\n\\t\\t\\telse if(s.count==2){\\n\\t\\t\\t\\tstack.add(new TreeNodeStack(s.node.right));\\n\\t\\t\\t}\\n\\t\\t\\telse if (s.count == 3) {\\n\\t\\t\\t\\tstack.pollLast();\\n\\t\\t\\t\\tresult.add(s.node.val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2386026,
                "title": "easiest-traversal-without-stack-queue-100-postorder",
                "content": "## **Using This Solution We Can Make Postorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        return v;\\n    }\\n};\\n```\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151213,
                "title": "short-simple-python-solution-beats-98-98",
                "content": "Here is the simple logic:\\n* If you are confused every time with preorder, inorder or postorder traversal just remember this typical 2 lines of code where tree is visited from left to right.\\n```\\n# Preorder means just b4 recursions w/o visiting left and right branches\\ndfs(node.left)\\n# Inorder means after visiting left branch\\ndfs(node.right)\\n# Postorder means after visiting left and right branches\\n```\\n* Now it looks clear.\\n* Basically, the question is asking putting children nodes first and then the parent node in the order of left - right - node. \\n* We can do this exactly by DFS traversal from right to left and then reverse the order.\\n```\\nclass Solution:\\n    def postorderTraversal(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in (node.left, node.right) if child]\\n        return ret[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n# Preorder means just b4 recursions w/o visiting left and right branches\\ndfs(node.left)\\n# Inorder means after visiting left branch\\ndfs(node.right)\\n# Postorder means after visiting left and right branches\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in (node.left, node.right) if child]\\n        return ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905483,
                "title": "python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        result=[]\\n        stack=[]\\n        while root or stack:\\n            while root:\\n                stack.append(root) # push nodes into the stack\\n                root=root.left if root.left else root.right\\n            root=stack.pop()\\n            result.append(root.val) #Deal with the root node whenever it is popped from stack\\n            if stack and stack[len(stack)-1].left==root: #check whether it has been traversed \\n                root=stack[len(stack)-1].right\\n            else:\\n                root=None #Force to quit the loop\\n        return(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        result=[]\\n        stack=[]\\n        while root or stack:\\n            while root:\\n                stack.append(root) # push nodes into the stack\\n                root=root.left if root.left else root.right\\n            root=stack.pop()\\n            result.append(root.val) #Deal with the root node whenever it is popped from stack\\n            if stack and stack[len(stack)-1].left==root: #check whether it has been traversed \\n                root=stack[len(stack)-1].right\\n            else:\\n                root=None #Force to quit the loop\\n        return(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805637,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        TreeNode* last = NULL;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            } else {\\n                TreeNode* node = todo.top();\\n                if (node -> right && last != node -> right) {\\n                    root = node -> right;\\n                } else {\\n                    nodes.push_back(node -> val);\\n                    last = node;\\n                    todo.pop();\\n                }\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373617,
                "title": "python-elegant-short-dfs-bfs-based-on-generators",
                "content": "# BFS solution:\\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tif root is None:\\n\\t\\t\\treturn []\\n\\n\\t\\tpostorder = []\\n\\t\\tstack = [root]\\n\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tpostorder.append(node.val)\\n\\t\\t\\tif node.left is not None:\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right is not None:\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\treturn postorder[::-1]\\n```\\n# DFS solution:\\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\treturn list(self.postorder_generator(root))\\n\\n\\t@classmethod\\n\\tdef postorder_generator(cls, tree: Optional[TreeNode]):\\n\\t\\tif tree is not None:\\n\\t\\t\\tyield from cls.postorder_generator(tree.left)\\n\\t\\t\\tyield from cls.postorder_generator(tree.right)\\n\\t\\t\\tyield tree.val\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tif root is None:\\n\\t\\t\\treturn []\\n\\n\\t\\tpostorder = []\\n\\t\\tstack = [root]\\n\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tpostorder.append(node.val)\\n\\t\\t\\tif node.left is not None:\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\tif node.right is not None:\\n\\t\\t\\t\\tstack.append(node.right)\\n\\n\\t\\treturn postorder[::-1]\\n```\n```\\nfrom typing import List, Optional\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tdef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\treturn list(self.postorder_generator(root))\\n\\n\\t@classmethod\\n\\tdef postorder_generator(cls, tree: Optional[TreeNode]):\\n\\t\\tif tree is not None:\\n\\t\\t\\tyield from cls.postorder_generator(tree.left)\\n\\t\\t\\tyield from cls.postorder_generator(tree.right)\\n\\t\\t\\tyield tree.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556668,
                "title": "recursive-iterative-using-1-stack-2-stacks-both-easy-soln-c",
                "content": "Recursive:\\n```\\n\\t class Solution {\\n\\tpublic:\\n\\t\\tvector<int> postorderTraversal(TreeNode* root) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tPostOrder(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid PostOrder(TreeNode* root, vector<int>& ans)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tPostOrder(root->left,ans);\\n\\t\\t\\tPostOrder(root->right,ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t}\\n\\t};\\n```\\nIterative (Two Stacks):\\n```\\t\\n\\tclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>s1;\\n        stack<TreeNode*>s2;\\n        s1.push(root);\\n        while(!s1.empty())\\n        {\\n            root = s1.top();\\n            s2.push(root);\\n            s1.pop();\\n            if(root->left)s1.push(root->left);\\n            if(root->right)s1.push(root->right);\\n        }\\n        while(!s2.empty())\\n        {\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIterative (One Stack):\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        TreeNode* curr = root;\\n        stack<TreeNode*> s;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        while(curr!=NULL || !s.empty())\\n        {\\n            if(curr!=NULL)\\n            {\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else\\n            {\\n                TreeNode* temp = s.top()->right;\\n                if(temp !=NULL)\\n                {\\n                    curr = temp;\\n                }\\n                else\\n                {\\n                    temp = s.top();\\n                    s.pop();\\n                    ans.push_back(temp->val);\\n                    while(!s.empty() && temp == s.top()->right)\\n                    {\\n                        temp = s.top();\\n                        s.pop();\\n                        ans.push_back(temp->val);\\n                    }     \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t class Solution {\\n\\tpublic:\\n\\t\\tvector<int> postorderTraversal(TreeNode* root) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tPostOrder(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid PostOrder(TreeNode* root, vector<int>& ans)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tPostOrder(root->left,ans);\\n\\t\\t\\tPostOrder(root->right,ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t}\\n\\t};\\n```\n```\\t\\n\\tclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>s1;\\n        stack<TreeNode*>s2;\\n        s1.push(root);\\n        while(!s1.empty())\\n        {\\n            root = s1.top();\\n            s2.push(root);\\n            s1.pop();\\n            if(root->left)s1.push(root->left);\\n            if(root->right)s1.push(root->right);\\n        }\\n        while(!s2.empty())\\n        {\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        TreeNode* curr = root;\\n        stack<TreeNode*> s;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        while(curr!=NULL || !s.empty())\\n        {\\n            if(curr!=NULL)\\n            {\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else\\n            {\\n                TreeNode* temp = s.top()->right;\\n                if(temp !=NULL)\\n                {\\n                    curr = temp;\\n                }\\n                else\\n                {\\n                    temp = s.top();\\n                    s.pop();\\n                    ans.push_back(temp->val);\\n                    while(!s.empty() && temp == s.top()->right)\\n                    {\\n                        temp = s.top();\\n                        s.pop();\\n                        ans.push_back(temp->val);\\n                    }     \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342471,
                "title": "python-clean-iterative-dfs",
                "content": "### Simple\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root: \\n            return []\\n        postorder, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node: \\n                continue\\n            postorder.append(node.val)\\n            stack.append(node.left)\\n            stack.append(node.right)\\n        return postorder[::-1]\\n```\\n### Runtime Optimal\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        post_order, stack = [], []\\n        node = root\\n        while stack or node:\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                stack.append(node)\\n                node = node.left\\n            last = stack.pop()\\n            if last.right and stack and last.right == stack[-1]:\\n                node = stack.pop()\\n                stack.append(last)\\n            else:\\n                post_order.append(last.val)\\n        return post_order\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root: \\n            return []\\n        postorder, stack = [], [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node: \\n                continue\\n            postorder.append(node.val)\\n            stack.append(node.left)\\n            stack.append(node.right)\\n        return postorder[::-1]\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        post_order, stack = [], []\\n        node = root\\n        while stack or node:\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                stack.append(node)\\n                node = node.left\\n            last = stack.pop()\\n            if last.right and stack and last.right == stack[-1]:\\n                node = stack.pop()\\n                stack.append(last)\\n            else:\\n                post_order.append(last.val)\\n        return post_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304192,
                "title": "post-order-traversal-with-a-iterator",
                "content": "There isn\\'t seem to be a solution with iterator, so I came up with my own binary tree post-order traversal iterator. \\nTime complexity for next() is O(height)\\nSpace complexity is also O(height)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class BSTIterator {\\n        Deque<TreeNode> stack = new ArrayDeque();\\n        TreeNode lastNode = null;\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n        \\n        private void pushAll(TreeNode cursor) {\\n            while(cursor != null) {\\n                stack.offerFirst(cursor);\\n                if(cursor.left!=null) cursor = cursor.left;\\n                else if(cursor.right!=null) cursor = cursor.right;\\n                else cursor = null;\\n            }\\n        }\\n\\n        public TreeNode next() {\\n            TreeNode cur = stack.peekFirst();\\n            if(cur == null) return null;\\n            if(lastNode == cur.right){\\n                lastNode = cur;\\n                return stack.pollFirst();\\n            } else {\\n                pushAll(cur.right);\\n                lastNode = stack.pollFirst();\\n                return lastNode;\\n            }\\n        }\\n\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    }\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if(root == null) return Arrays.asList();\\n        ArrayList<Integer> result = new ArrayList();\\n        BSTIterator iterator = new BSTIterator(root);\\n        while(iterator.hasNext()){\\n            result.add(iterator.next().val);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class BSTIterator {\\n        Deque<TreeNode> stack = new ArrayDeque();\\n        TreeNode lastNode = null;\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n        \\n        private void pushAll(TreeNode cursor) {\\n            while(cursor != null) {\\n                stack.offerFirst(cursor);\\n                if(cursor.left!=null) cursor = cursor.left;\\n                else if(cursor.right!=null) cursor = cursor.right;\\n                else cursor = null;\\n            }\\n        }\\n\\n        public TreeNode next() {\\n            TreeNode cur = stack.peekFirst();\\n            if(cur == null) return null;\\n            if(lastNode == cur.right){\\n                lastNode = cur;\\n                return stack.pollFirst();\\n            } else {\\n                pushAll(cur.right);\\n                lastNode = stack.pollFirst();\\n                return lastNode;\\n            }\\n        }\\n\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    }\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if(root == null) return Arrays.asList();\\n        ArrayList<Integer> result = new ArrayList();\\n        BSTIterator iterator = new BSTIterator(root);\\n        while(iterator.hasNext()){\\n            result.add(iterator.next().val);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068200,
                "title": "c-iterative-100-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\nvector<int> Solution::postorderTraversal(TreeNode* root) {\\n    vector<int> v;\\n    if (root == NULL) \\n        return v; \\n  \\n    // Create two stacks \\n    stack<TreeNode *> s1, s2; \\n  \\n    // push root to first stack \\n    s1.push(root); \\n    TreeNode* node; \\n    // Run while first stack is not empty \\n    while (!s1.empty()) { \\n        // Pop an item from s1 and push it to s2 \\n        node = s1.top(); \\n        s1.pop(); \\n        s2.push(node); \\n  \\n        // Push left and right children \\n        // of removed item to s1 \\n        if (node->left) \\n            s1.push(node->left); \\n        if (node->right) \\n            s1.push(node->right); \\n    }\\n    \\n    while (!s2.empty()) { \\n        node = s2.top(); \\n        s2.pop(); \\n        v.push_back(node->val); \\n    } \\n    \\n    return v;   \\n}\\n};\\n```\\n**Plz upvote it..**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> Solution::postorderTraversal(TreeNode* root) {\\n    vector<int> v;\\n    if (root == NULL) \\n        return v; \\n  \\n    // Create two stacks \\n    stack<TreeNode *> s1, s2; \\n  \\n    // push root to first stack \\n    s1.push(root); \\n    TreeNode* node; \\n    // Run while first stack is not empty \\n    while (!s1.empty()) { \\n        // Pop an item from s1 and push it to s2 \\n        node = s1.top(); \\n        s1.pop(); \\n        s2.push(node); \\n  \\n        // Push left and right children \\n        // of removed item to s1 \\n        if (node->left) \\n            s1.push(node->left); \\n        if (node->right) \\n            s1.push(node->right); \\n    }\\n    \\n    while (!s2.empty()) { \\n        node = s2.top(); \\n        s2.pop(); \\n        v.push_back(node->val); \\n    } \\n    \\n    return v;   \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584697,
                "title": "python-same-iterative-code-for-inorder-preorder-postorder-traversal",
                "content": "The official iterative solutions are very different for inorder, preorder, postorder traversals. My way is more universal and fits all three problems with same code, only changes on stack appending order.\\nBasic idea is, If the end of the stack is a number, append it to result array. If it is not a number, but a node, then push the node\\'s children back to stack and pop again.\\n\\nSame code for 3 problems.\\n\\nPostorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.val, node.right, node.left])\\n        return res\\n```\\n\\nInorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.val, node.left])\\n        return res\\n```\\n\\nPreorder:\\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.left, node.val])\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.val, node.right, node.left])\\n        return res\\n```\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.val, node.left])\\n        return res\\n```\n```\\n        stack,res=[root],[]\\n        while stack:\\n            if isinstance(stack[-1],int):\\n                res.append(stack.pop())\\n                continue\\n            node=stack.pop()\\n            if not node:\\n                continue\\n            stack.extend([node.right, node.left, node.val])\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478112,
                "title": "iterative-solution-using-one-stack-beats-99-25-solutions-in-runtime",
                "content": "Psuedocode:\\n\\nwhile curr node exists , keep pushing in stack and keep makking curr = curr.left\\n\\nwhen curr is null, \\n\\tif(stackTop.right is exists) -> make curr = curr.right since its unvisited\\n\\tif(stackTop.right does not exist) -> \\n\\t\\tpop the curr top from stack\\n\\t\\twhile the popped el is right child of stack\\'s top and stack is not empty, keep popping\\n\\t\\t\\n\\t\\tnow either stack is empty or popped el was the left child\\n\\t\\t  if stack empty -> make curr null -> as traversal is done\\n\\t\\t  if it was the left child -> we need to set the curr to stackpop.right\\n\\t\\t  \\nWorking code:\\n```\\nvar postorderTraversal = function(root) {\\n    if(root == null) return [];\\n    let curr = root;\\n    let stack = [];\\n    let result = [];\\n    let prev = null;\\n    while(curr || stack.length) {\\n        if(curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        } else {\\n            curr = stack[stack.length - 1];  //peek for top\\n            if(curr.right) {\\n                curr = curr.right;\\n            }\\n            else { //right of top does not exist, so need to pop\\n                curr = stack.pop();\\n                result.push(curr.val);\\n                while(stack.length && curr == stack[stack.length -1].right) {  //while last popped el is top\\'s right child, visit it\\n                    curr = stack.pop();\\n                    result.push(curr.val);\\n                }\\n                if(stack.length) { //end case, this cond will break is stack is empty\\n                    curr = stack[stack.length - 1].right; \\n                } else {\\n                    curr = null;\\n                }\\n            }                \\n\\n        }\\n    }\\n    return result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    if(root == null) return [];\\n    let curr = root;\\n    let stack = [];\\n    let result = [];\\n    let prev = null;\\n    while(curr || stack.length) {\\n        if(curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        } else {\\n            curr = stack[stack.length - 1];  //peek for top\\n            if(curr.right) {\\n                curr = curr.right;\\n            }\\n            else { //right of top does not exist, so need to pop\\n                curr = stack.pop();\\n                result.push(curr.val);\\n                while(stack.length && curr == stack[stack.length -1].right) {  //while last popped el is top\\'s right child, visit it\\n                    curr = stack.pop();\\n                    result.push(curr.val);\\n                }\\n                if(stack.length) { //end case, this cond will break is stack is empty\\n                    curr = stack[stack.length - 1].right; \\n                } else {\\n                    curr = null;\\n                }\\n            }                \\n\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45711,
                "title": "java-recursive-and-iterative-solutions",
                "content": "       \\n    // recursively\\n    public List<Integer> postorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n            ret.add(root.val);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        List<Integer> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.left);\\n                stack.push(node.right);\\n            }\\n        }\\n        Collections.reverse(ret);\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "       \\n    // recursively\\n    public List<Integer> postorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n            ret.add(root.val);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        List<Integer> ret = new ArrayList<>();\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.left);\\n                stack.push(node.right);\\n            }\\n        }\\n        Collections.reverse(ret);\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45784,
                "title": "share-my-simple-neat-cpp-solution-0-ms-use-stack-without-changing-tree-easy-to-understand",
                "content": "    vector<int> postorderTraversal(TreeNode *root)\\n    {\\n        vector<int> result;\\n        if (!root) return result;\\t\\n        stack<TreeNode *> stk;\\n        stk.push(root);\\n        TreeNode *pre = root;\\n        while (!stk.empty())\\n        {\\n        \\tTreeNode *i_root = stk.top();\\n        \\tif (i_root->left && i_root->left != pre && i_root->right != pre)\\n        \\t{\\n        \\t\\tstk.push(i_root->left);\\t\\t\\t//push left child\\n        \\t}\\n        \\telse if (i_root->right && i_root->right != pre)\\n        \\t{\\t\\n        \\t\\tstk.push(i_root->right);\\t\\t//push right child\\n        \\t}\\n        \\telse\\n        \\t{\\n        \\t\\tresult.push_back(i_root->val);\\t//record root\\n        \\t\\tpre = stk.top();\\n        \\t\\tstk.pop();\\t\\t\\t\\t\\t\\t//stack pop\\n        \\t}\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> postorderTraversal(TreeNode *root)\\n    {\\n        vector<int> result;\\n        if (!root) return result;\\t\\n        stack<TreeNode *> stk;\\n        stk.push(root);\\n        TreeNode *pre = root;\\n        while (!stk.empty())\\n        {\\n        \\tTreeNode *i_root = stk.top();\\n        \\tif (i_root->left && i_root->left != pre && i_root->right != pre)\\n        \\t{\\n        \\t\\tstk.push(i_root->left);\\t\\t\\t//push left child\\n        \\t}\\n        \\telse if (i_root->right && i_root->right != pre)\\n        \\t{\\t\\n        \\t\\tstk.push(i_root->right);\\t\\t//push right child\\n        \\t}\\n        \\telse\\n        \\t{\\n        \\t\\tresult.push_back(i_root->val);\\t//record root\\n        \\t\\tpre = stk.top();\\n        \\t\\tstk.pop();\\t\\t\\t\\t\\t\\t//stack pop\\n        \\t}\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45814,
                "title": "share-my-easy-understanding-c-solution-2ms",
                "content": "    //use a stack\\n    //stack pop order:root,right,left\\n    //reverse the result\\n    class Solution {\\n    public:\\n    \\tvector<int> postorderTraversal(TreeNode* root) {\\n    \\t\\tvector<int> res;\\n    \\t\\tstack<TreeNode*> tree;\\n    \\t\\tTreeNode* tmp;\\n    \\t\\tif(!root)\\n    \\t\\t\\treturn res;\\n    \\t\\ttree.push(root);\\n    \\t\\twhile(!tree.empty()){\\n    \\t\\t\\ttmp=tree.top();\\n    \\t\\t\\ttree.pop();\\n    \\t\\t\\tres.push_back(tmp->val);\\n    \\t\\t\\tif(tmp->left)\\n    \\t\\t\\t\\ttree.push(tmp->left);\\n    \\t\\t\\tif(tmp->right)\\n    \\t\\t\\t\\ttree.push(tmp->right);\\n    \\t\\t}\\n    \\t\\treverse(res.begin(),res.end());\\n    \\t\\treturn res;\\n    \\t}\\t\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<int> postorderTraversal(TreeNode* root) {\\n    \\t\\tvector<int> res;\\n    \\t\\tstack<TreeNode*> tree;\\n    \\t\\tTreeNode* tmp;\\n    \\t\\tif(!root)\\n    \\t\\t\\treturn res;\\n    \\t\\ttree.push(root);\\n    \\t\\twhile(!tree.empty()){\\n    \\t\\t\\ttmp=tree.top();\\n    \\t\\t\\ttree.pop();\\n    \\t\\t\\tres.push_back(tmp->val);\\n    \\t\\t\\tif(tmp->left)\\n    \\t\\t\\t\\ttree.push(tmp->left);\\n    \\t\\t\\tif(tmp->right)\\n    \\t\\t\\t\\ttree.push(tmp->right);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 728983,
                "title": "c-clean-and-minimal-modification-for-iterative-version-of-tree-preorder-inorder-and-postorder",
                "content": "* preorder \\n```c++\\n/**\\nformat:\\n    L0\\n   L1\\n  L2\\n L3 R1\\n \\n1. put all of the leftmost branch to stk.\\n    a. preorder: report node before entering stk\\n2. move to the right branch of the top node in the stk      \\n\\nT: O(n)\\nS: O(h), in average; O(n) in worst case\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* inorder \\n\\t* only one line different from that of preorder version. \\n```c++\\n/**\\nformat: \\n1. put leftmost node in the stack\\n2. for inorder traversal, report the node once picking it from the stack\\n3. move to the right branch \\n\\nT: O(N)\\nS: O(h) in average; O(N) in worst case \\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode*> stk;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                // only this line is different from that of preorder \\n                res.push_back(stk.top()->val);\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* postorder \\n\\t* onlye one line different from that of preorder version\\n\\t* reverse the sequence \\n\\n```c++\\n/**\\npostorder \\n= left, right, root\\npreorder\\n= root, left, right\\n\\nmodifty preorder\\n= root, right, right\\n\\n1. do by modifoed preorder \\n2. reverse the result \\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                // only this line is different from that of preorder \\n                crt = crt->right;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->left;\\n                stk.pop();\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n/**\\nformat:\\n    L0\\n   L1\\n  L2\\n L3 R1\\n \\n1. put all of the leftmost branch to stk.\\n    a. preorder: report node before entering stk\\n2. move to the right branch of the top node in the stk      \\n\\nT: O(n)\\nS: O(h), in average; O(n) in worst case\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```c++\\n/**\\nformat: \\n1. put leftmost node in the stack\\n2. for inorder traversal, report the node once picking it from the stack\\n3. move to the right branch \\n\\nT: O(N)\\nS: O(h) in average; O(N) in worst case \\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode*> stk;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                stk.push(crt);\\n                crt = crt->left;\\n            }\\n            if(!stk.empty()) {\\n                // only this line is different from that of preorder \\n                res.push_back(stk.top()->val);\\n                crt = stk.top()->right;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```c++\\n/**\\npostorder \\n= left, right, root\\npreorder\\n= root, left, right\\n\\nmodifty preorder\\n= root, right, right\\n\\n1. do by modifoed preorder \\n2. reverse the result \\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> stk;\\n        vector<int> res;\\n        TreeNode* crt = root;\\n        while(crt || !stk.empty()) {\\n            while(crt) {\\n                res.push_back(crt->val);\\n                stk.push(crt);\\n                // only this line is different from that of preorder \\n                crt = crt->right;\\n            }\\n            if(!stk.empty()) {\\n                crt = stk.top()->left;\\n                stk.pop();\\n            }\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634448,
                "title": "morris-traversal",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> list = new LinkedList<>();  \\n        if (root == null) {\\n            return list;\\n        }        \\n        //Use the idea of Morris Traversal, but we change the order between right and left \\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.right == null) {\\n                list.addFirst(node.val);\\n                node = node.left;  \\n            } else {\\n                TreeNode curNode = node.right;\\n                while (curNode.left != node && curNode.left != null) {\\n                    curNode = curNode.left;\\n                }\\n                if (curNode.left == node) { //second time visit, we break the link, and go to the left branch\\n                    curNode.left = null;\\n                    node = node.left;      \\n                } else { //first time visit, we connect two nodes here, and go to the right branch\\n                    curNode.left = node;\\n                    list.addFirst(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        LinkedList<Integer> list = new LinkedList<>();  \\n        if (root == null) {\\n            return list;\\n        }        \\n        //Use the idea of Morris Traversal, but we change the order between right and left \\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.right == null) {\\n                list.addFirst(node.val);\\n                node = node.left;  \\n            } else {\\n                TreeNode curNode = node.right;\\n                while (curNode.left != node && curNode.left != null) {\\n                    curNode = curNode.left;\\n                }\\n                if (curNode.left == node) { //second time visit, we break the link, and go to the left branch\\n                    curNode.left = null;\\n                    node = node.left;      \\n                } else { //first time visit, we connect two nodes here, and go to the right branch\\n                    curNode.left = node;\\n                    list.addFirst(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45703,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>res;\\n        stack<TreeNode *>stack;\\n        TreeNode * temp;\\n        if(!root)return res;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            temp=stack.top();\\n            stack.pop();\\n            res.insert(res.begin(), temp->val);\\n            if(temp->left)stack.push(temp->left);\\n            if(temp->right)stack.push(temp->right);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>res;\\n        stack<TreeNode *>stack;\\n        TreeNode * temp;\\n        if(!root)return res;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            temp=stack.top();\\n            stack.pop();\\n            res.insert(res.begin(), temp->val);\\n            if(temp->left)stack.push(temp->left);\\n            if(temp->right)stack.push(temp->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45817,
                "title": "accepted-tiny-java-code-by-reversing-root-right-left",
                "content": "the idea is to convert the problem to (root, right, left) with add first into the linkedlist.\\n\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            LinkedList<Integer> result = new LinkedList<>();\\n            if (root == null)  return result;\\n            TreeNode curr = root;\\n            Stack<TreeNode> stack = new Stack<>();\\n            stack.push(curr);\\n            while (!stack.isEmpty()) {\\n                curr = stack.pop();\\n                result.addFirst(curr.val);\\n                if (curr.left != null )  stack.push(curr.left);\\n                if (curr.right !=null ) stack.push(curr.right);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            LinkedList<Integer> result = new LinkedList<>();\\n            if (root == null)  return result;\\n            TreeNode curr = root;\\n            Stack<TreeNode> stack = new Stack<>();\\n            stack.push(curr);\\n            while (!stack.isEmpty()) {\\n                curr = stack.pop();\\n                result.addFirst(curr.val);\\n                if (curr.left != null )  stack.push(curr.left);\\n                if (curr.right !=null ) stack.push(curr.right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1976373,
                "title": "c-easiest-code-with-memory-optimization-100",
                "content": "class Solution {\\n    private : vector<int>res;\\n    void postorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        postorder(root->left,res);\\n        \\n        postorder(root->right,res);\\n        res.push_back(root->val);\\n        return;\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    private : vector<int>res;\\n    void postorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        postorder(root->left,res);\\n        \\n        postorder(root->right,res);\\n        res.push_back(root->val);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1516080,
                "title": "python-recursive-iterative-simple-solutions",
                "content": "## Recursive Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, postorder):\\n        if root:\\n            self.traversal(root.left, postorder)\\n            self.traversal(root.right, postorder)\\n            postorder.append(root.val)\\n            \\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        self.traversal(root, postorder)\\n        return postorder\\n```\\n\\n## Iterative Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        stack = [root]\\n        visited = set()\\n        while stack:\\n            root = stack[-1]\\n            if root:\\n                if root not in visited:\\n                    visited.add(root)\\n                    stack.append(root.left)\\n                elif root.right and root.right not in visited:\\n                    stack.append(root.right)\\n                else:\\n                    root = stack.pop()\\n                    postorder.append(root.val)                    \\n            else:\\n                stack.pop()\\n                \\n        return postorder\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, postorder):\\n        if root:\\n            self.traversal(root.left, postorder)\\n            self.traversal(root.right, postorder)\\n            postorder.append(root.val)\\n            \\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        self.traversal(root, postorder)\\n        return postorder\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        postorder = []\\n        stack = [root]\\n        visited = set()\\n        while stack:\\n            root = stack[-1]\\n            if root:\\n                if root not in visited:\\n                    visited.add(root)\\n                    stack.append(root.left)\\n                elif root.right and root.right not in visited:\\n                    stack.append(root.right)\\n                else:\\n                    root = stack.pop()\\n                    postorder.append(root.val)                    \\n            else:\\n                stack.pop()\\n                \\n        return postorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315230,
                "title": "iterative-traversal",
                "content": "## Iterative Traversal\\n**PreOrder**\\n```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> rights = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!rights.isEmpty() || p != null) {\\n        if(p != null) {\\n            ans.add(p.val);\\n            if(p.right != null) rights.push(p.right);\\n            p = p.left;\\n        } else {\\n            p = rights.pop();\\n        }\\n    }\\n    return ans;\\n}\\n```\\nIntuitively, when recursive, the stack only records the **context state** of the previous function call. In fact, the remaining context state here is the information of the **right child** of the previous node. We can use stack to keep this information.\\n\\n---\\n**InOrder**\\n```java\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!fa.isEmpty() || p != null){\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            TreeNode top = fa.pop();\\n            ans.add(top.val);\\n            p = top.right;\\n        }\\n    }\\n    return ans;\\n}\\n```\\nFor inorder traversal, the information retained by the node at the previous level is actually its **value** and **right child**, so the parent node can be kept in the stack.\\n\\n---\\n**PostOrder**\\n```java\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    TreeNode lastReturn = null;\\n    while(!fa.isEmpty() || p != null) {\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            if(fa.peek().right == null || lastReturn == fa.peek().right) {\\n                ans.add(fa.peek().val);\\n                lastReturn = fa.pop();\\n            } else {\\n                p = fa.peek().right;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\nThe postorder traversal is a little more complicated, because the value and the right child information of the node of previous layer are to be retained, and the **value** is to be retained until the end. Therefore, when `p==null`, it is not possible to determine whether the right subtree of the parent has been traversed, but only after the right subtree has been traversed, the value of the parent can be output. So we\\'re going to record the last node that popped up,` lastReturn`, and if it\\'s equal to the right child of the parent, that means that the right subtree has been traversed, that parent can be safely popped up, and `lastReturn` is equal to the popped up node. \\n\\n**Discussion**\\nWhy don\\'t we worry about this when we use recursive method?\\nBecause at the time of recursion, stack frame will automatically record the context information of the function, including the program execution to which step. But in our \"stack\", we simply recorded the information of the node (the value and right subtree). So we don\\'t know we execute to which step. We need to make some special judgments to know where we are currently executing.",
                "solutionTags": [],
                "code": "```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> rights = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!rights.isEmpty() || p != null) {\\n        if(p != null) {\\n            ans.add(p.val);\\n            if(p.right != null) rights.push(p.right);\\n            p = p.left;\\n        } else {\\n            p = rights.pop();\\n        }\\n    }\\n    return ans;\\n}\\n```\n```java\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    while(!fa.isEmpty() || p != null){\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            TreeNode top = fa.pop();\\n            ans.add(top.val);\\n            p = top.right;\\n        }\\n    }\\n    return ans;\\n}\\n```\n```java\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<TreeNode> fa = new LinkedList<>();\\n    TreeNode p = root;\\n    TreeNode lastReturn = null;\\n    while(!fa.isEmpty() || p != null) {\\n        if(p != null) {\\n            fa.push(p);\\n            p = p.left;\\n        } else {\\n            if(fa.peek().right == null || lastReturn == fa.peek().right) {\\n                ans.add(fa.peek().val);\\n                lastReturn = fa.pop();\\n            } else {\\n                p = fa.peek().right;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020132,
                "title": "recursive-c-easy-understanding",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        vec.push_back(root->val);\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        vec.push_back(root->val);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953213,
                "title": "easy-peasy-approach-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int>v;\\n        stack<TreeNode*>s;\\n        while(1)\\n        {\\n            while(root)\\n            {\\n                v.push_back(root->val);\\n                s.push(root);\\n                root=root->right;\\n            }\\n            if(s.empty())break;\\n            root=s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) \\n    {\\n        vector<int>v;\\n        stack<TreeNode*>s;\\n        while(1)\\n        {\\n            while(root)\\n            {\\n                v.push_back(root->val);\\n                s.push(root);\\n                root=root->right;\\n            }\\n            if(s.empty())break;\\n            root=s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216883,
                "title": "general-iteration-for-preorder-inorder-postorder-and-for-n-ary-tree-only-one-line-change",
                "content": "since the recursion version traverse is so easy and general, why does iteration have to be so different for  different traverse(especially for postorder).\\nWe can actually simulate program stack and make iteration more general and intuitive.\\nOnly one line change can switch from one method to another \\n#### Postorder Traverse\\n```\\npublic List<Integer> postorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.val);\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\\n\\n#### Inorder Traverse\\n```\\npublic List<Integer> inorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.val);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\\n\\n#### Preorder Traverse\\n```\\npublic List<Integer> preorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n \\n```\\n\\n#### 590. N-ary Tree Postorder Traversal\\n```\\npublic List<Integer> postorder(Node root) \\n\\t{\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                myStack.push(node.val);\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n```\\n#### 589. N-ary Tree Preorder Traversal\\n```\\npublic List<Integer> preorder(Node root) \\n    {\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.val);\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\n```\\npublic List<Integer> inorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.val);\\n                myStack.push(node.left);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root)\\n    {\\n        List<Integer> resultList = new ArrayList<>();\\n        Stack<Object> myStack = new Stack<>();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object o = myStack.pop();\\n            if(o == null)\\n            {\\n                continue;\\n            }\\n            if(o instanceof TreeNode)\\n            {\\n                TreeNode node = (TreeNode)o;\\n                myStack.push(node.right);\\n                myStack.push(node.left);\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                resultList.add((Integer)o);\\n            }\\n        }\\n        return resultList;\\n    }\\n \\n```\n```\\npublic List<Integer> postorder(Node root) \\n\\t{\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                myStack.push(node.val);\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n\\n    }\\n```\n```\\npublic List<Integer> preorder(Node root) \\n    {\\n        List<Integer> result = new ArrayList();\\n        Stack<Object> myStack = new Stack();\\n        myStack.push(root);\\n        while(!myStack.isEmpty())\\n        {\\n            Object object = myStack.pop();\\n            if(object == null)\\n            {\\n                continue;\\n            }\\n            if(object instanceof Node)\\n            {\\n                Node node = (Node)object;\\n                List<Node> children = node.children;\\n                for(int i = children.size() - 1; i >= 0; i--)\\n                {\\n                    myStack.push(children.get(i));\\n                }\\n                myStack.push(node.val);\\n            }\\n            else\\n            {\\n                result.add((Integer)object);\\n            }\\n\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167091,
                "title": "javascript-traversal-pre-in-post-iteration-template-inspired-by-luffyzhou-s-solution",
                "content": "I got inspired by luffyzhou\\'s python solution which only use one line change to cover the `preOrder`, `inOrder` and  `postOrder` iteration traversal.\\n\\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45539/Iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code\\n\\nHere is Javascript version.\\n\\nEasy understand tips:\\n* PreOrder => currentNode - leftChild - rightChild\\n* InOrder =>  leftChild - currentNode - rightChild\\n* PostOrder => leftChild -  rightChild - currentNode\\n\\nTherefore, just need to change the order depends on these rules and reverse them, then push to stack.\\n\\nSolution for PostOrder\\nUse rule : **PostOrder => leftChild - rightChild - currentNode**\\n\\n```\\nvar postorderTraversal = function (root) {\\n  if (!root) return []\\n\\n  const result = []\\n  const stack = [{node: root, visited: false}]\\n\\n  while (stack.length) {\\n    let {\\n      node: currentNode,\\n      visited\\n    } = stack.pop()\\n\\n    if (!currentNode) continue\\n\\n    visited ?\\n      result.push(currentNode.val) :\\n      stack.push(...[\\n          {node: currentNode.left, visited: false},\\n          {node: currentNode.right, visited: false},\\n          {node: currentNode, visited: true}\\n        ].reverse()\\n      )\\n  }\\n\\n  return result\\n}\\n```\\n\\nFor InOrder, change the array which stack push as: \\n\\n```\\n[\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode, visited: true},\\n  {node: currentNode.right, visited: false}\\n]\\n```\\n\\nFor PreOrder, change the array which stack push as: \\n\\n```\\n[\\n  {node: currentNode, visited: true},\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode.right, visited: false}\\n]\\n```",
                "solutionTags": [],
                "code": "```\\nvar postorderTraversal = function (root) {\\n  if (!root) return []\\n\\n  const result = []\\n  const stack = [{node: root, visited: false}]\\n\\n  while (stack.length) {\\n    let {\\n      node: currentNode,\\n      visited\\n    } = stack.pop()\\n\\n    if (!currentNode) continue\\n\\n    visited ?\\n      result.push(currentNode.val) :\\n      stack.push(...[\\n          {node: currentNode.left, visited: false},\\n          {node: currentNode.right, visited: false},\\n          {node: currentNode, visited: true}\\n        ].reverse()\\n      )\\n  }\\n\\n  return result\\n}\\n```\n```\\n[\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode, visited: true},\\n  {node: currentNode.right, visited: false}\\n]\\n```\n```\\n[\\n  {node: currentNode, visited: true},\\n  {node: currentNode.left, visited: false},\\n  {node: currentNode.right, visited: false}\\n]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45713,
                "title": "preorder-u3001inorder-u3001postorder-iterative-solution-by-c",
                "content": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45716,
                "title": "simple-1ms-java-solution-using-o-1-extra-space-morris-traversal",
                "content": "The key to keeping the solution simple is to add the element from the **front** of the result list. Then the problem becomes a mirrored version of [Morris pre-order traversal][1]\\n\\n\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new LinkedList<>();\\n            while (root != null) {\\n                if (root.right == null) {\\n                    result.add(0, root.val);\\n                    root = root.left;\\n                } else {\\n                    TreeNode predecessor = root.right;\\n                    while (predecessor.left != null && predecessor.left != root) {\\n                        predecessor = predecessor.left;\\n                    }\\n                    if (predecessor.left == null) {\\n                        predecessor.left = root;\\n                        result.add(0, root.val);\\n                        root = root.right;\\n                    } else {\\n                        predecessor.left = null;\\n                        root = root.left;\\n                    }\\n                }\\n            }\\n            \\n            return result;\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/63018/morris-traversal-time-space-applied-inorder-and-postorder",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new LinkedList<>();\\n            while (root != null) {\\n                if (root.right == null) {\\n                    result.add(0, root.val);\\n                    root = root.left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 45778,
                "title": "a-very-simple-c-solution-0-ms-runtime",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) \\n        {\\n            vector<int> output;\\n            if(root == NULL)\\n                return output;\\n                \\n            stack<TreeNode*> stk;\\n            \\n            stk.push(root);\\n            while(!stk.empty())\\n            {\\n                TreeNode *t = stk.top();\\n                stk.pop();\\n                output.push_back(t->val);\\n                if(t->left)\\n                    stk.push(t->left);\\n                if(t->right)\\n                    stk.push(t->right);\\n            }\\n            \\n            reverse(output.begin(), output.end());\\n            return output;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) \\n        {\\n            vector<int> output;\\n            if(root == NULL)\\n                return output;\\n                \\n            stack<TreeNode*> stk;\\n            \\n            stk.push(root);\\n            while(!stk.empty())\\n            {\\n                TreeNode *t = stk.top();\\n                stk.pop();\\n                output.push_back(t->val);\\n                if(t->left)\\n                    stk.push(t->left);\\n                if(t->right)\\n                    stk.push(t->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45849,
                "title": "4ms-c-simple-solution-with-explaination",
                "content": "    class Solution {\\n    public:\\n        void pushPathToLeftmostLeaf(TreeNode* n, stack<TreeNode*>& s) {\\n            while(n) {\\n                s.push(n);\\n                n = n->left != NULL ? n->left : n->right;\\n            }\\n        }\\n        // LOGIC: A good way to think about this would be \\n        // think about the stack of the recursive solution\\n        // you just have to mimick that behaviour. :)\\n        vector<int> postorderTraversal(TreeNode *root) {\\n           stack<TreeNode*> s;\\n           pushPathToLeftmostLeaf(root, s);\\n           vector<int> result;\\n           while(!s.empty()) {\\n               TreeNode* cur  = s.top();\\n               s.pop();\\n               result.push_back(cur->val);\\n               TreeNode* next = s.empty() ? NULL : s.top();\\n               // check if the cur is the left child of next\\n               // if it is, then we are yet to explore the right child\\n               // of next\\n               if (next && next->left == cur) {\\n                   pushPathToLeftmostLeaf(next->right,s);\\n               }\\n           }\\n           return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        void pushPathToLeftmostLeaf(TreeNode* n, stack<TreeNode*>& s) {\\n            while(n) {\\n                s.push(n);\\n                n = n->left != NULL ? n->left : n->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3206647,
                "title": "145-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a stack to implement an iterative postorder traversal of the binary tree. The algorithm starts by adding the root node to the stack. Then, while the stack is not empty, it pops the next node from the stack, appends its value to the result list, and adds its left and right children to the stack (if they exist). Finally, the result list is reversed and returned as the final output.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        result = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return result[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        result = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return result[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008957,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity : $$O(N)$$\\n\\n- Space complexity : $$O(1)$$, if we don\\u2019t consider the size of the stack for function. Otherwise, $$O(H)$$ where H is the height of the tree. \\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root != NULL)\\n        {\\n            postorderTraversal(root->left);\\n            postorderTraversal(root->right);\\n            res.push_back(root->val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root != NULL)\\n        {\\n            postorderTraversal(root->left);\\n            postorderTraversal(root->right);\\n            res.push_back(root->val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816601,
                "title": "c-simple-recursive-approach",
                "content": "**Post - Order Traversal using Recursion:** \\n```\\n    void postOrder(TreeNode* root, vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        // left - right - node\\n        postOrder(root->left, ans);\\n        postOrder(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n```\\n***Do upvote !!***",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    void postOrder(TreeNode* root, vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        // left - right - node\\n        postOrder(root->left, ans);\\n        postOrder(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1876584,
                "title": "all-the-method-from-striver-free-ka-tree-series-recursive-1-stack-2-stack",
                "content": "# Iterative using 1 stack\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        TreeNode* curr=root,*temp;\\n        vector<int>v;\\n        while(curr or !st.empty())\\n        { if( curr!=0)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n        else{\\n            temp=st.top()->right;\\n            if(temp==0)\\n            {\\n                temp=st.top();\\n                st.pop();\\n                v.push_back(temp->val);\\n                while(!st.empty() and temp==st.top()->right)\\n                {\\n                    temp=st.top();\\n                    st.pop();\\n                      v.push_back(temp->val);\\n                }\\n            }\\n            else curr=temp;\\n        }\\n        }\\n        return v;\\n    }\\n```\\n# Recusive\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n   void solve(TreeNode* root)\\n    {\\n        if(root==0)\\n            return ;\\n      \\n       solve(root->left);\\n       \\n       solve(root->right);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n          solve(root);\\n        return ans;\\n    \\n    }\\n};\\n```\\n# itreative using 2 stack\\n```\\n vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int >v;\\n        stack<TreeNode*>st1;\\n        stack<TreeNode*>st2;\\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            TreeNode* node =st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left!=0) st1.push(node->left);\\n             if(node->right!=0) st1.push(node->right);\\n        }\\n        while(st2.size())\\n        {\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return v;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        TreeNode* curr=root,*temp;\\n        vector<int>v;\\n        while(curr or !st.empty())\\n        { if( curr!=0)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n        else{\\n            temp=st.top()->right;\\n            if(temp==0)\\n            {\\n                temp=st.top();\\n                st.pop();\\n                v.push_back(temp->val);\\n                while(!st.empty() and temp==st.top()->right)\\n                {\\n                    temp=st.top();\\n                    st.pop();\\n                      v.push_back(temp->val);\\n                }\\n            }\\n            else curr=temp;\\n        }\\n        }\\n        return v;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n   void solve(TreeNode* root)\\n    {\\n        if(root==0)\\n            return ;\\n      \\n       solve(root->left);\\n       \\n       solve(root->right);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n          solve(root);\\n        return ans;\\n    \\n    }\\n};\\n```\n```\\n vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int >v;\\n        stack<TreeNode*>st1;\\n        stack<TreeNode*>st2;\\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            TreeNode* node =st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left!=0) st1.push(node->left);\\n             if(node->right!=0) st1.push(node->right);\\n        }\\n        while(st2.size())\\n        {\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765414,
                "title": "99-52-faster-python3-solution-recursively",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e559c721-2fc0-482a-a5dd-e71f2f205c74_1644671962.748144.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736052,
                "title": "java-this-simple-template-can-be-used-for-3-traversals",
                "content": "**Why this template?**\\nI do see other templates like this https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45551/Preorder-Inorder-and-Postorder-Iteratively-Summarization are highly voted, but the problem is that for post-order traversal, its traversal order is not really post-order. It just makes the end result look the same as post-order by reversing the list. In contrast, the following tempalte gives us a real post-order traversal. Also, the following template can provides clean code and it is very easy to understand.\\n\\n**The template**\\nFirst we define a helper class `Pair`:\\n\\n```\\nprivate class Pair {\\n    boolean visited;\\n    TreeNode node;\\n\\n    Pair(TreeNode node, boolean visited) {\\n        this.node = node;\\n        this.visited = visited;\\n    }\\n}\\n```\\n1) https://leetcode.com/problems/binary-tree-preorder-traversal/\\n\\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));      --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));       --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));             --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n2) https://leetcode.com/problems/binary-tree-inorder-traversal/\\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));   --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));          --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));    --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n3) https://leetcode.com/problems/binary-tree-postorder-traversal/\\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node, true));               --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.right, false));        --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));         --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Iterator"
                ],
                "code": "```\\nprivate class Pair {\\n    boolean visited;\\n    TreeNode node;\\n\\n    Pair(TreeNode node, boolean visited) {\\n        this.node = node;\\n        this.visited = visited;\\n    }\\n}\\n```\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));      --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));       --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));             --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        Stack<Pair> stack = new Stack();\\n        stack.push(new Pair(root, false));\\n        List<Integer> res = new ArrayList();\\n        while (!stack.isEmpty()) {\\n            Pair curr = stack.pop();\\n            if (curr.node == null)\\n                continue;\\n            if (curr.visited) {\\n                res.add(curr.node.val);\\n            } else {\\n                stack.push(new Pair(curr.node.right, false));   --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node, true));          --- only this block of code needs to be adujsted\\n                stack.push(new Pair(curr.node.left, false));    --- only this block of code needs to be adujsted\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334846,
                "title": "c-solution-faster-than-100-iterative-approach-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> postOrder;\\n        if (root == NULL)\\n            return postOrder;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            postOrder.insert(postOrder.begin(), curr->val);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n        }\\n        return postOrder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> postOrder;\\n        if (root == NULL)\\n            return postOrder;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            postOrder.insert(postOrder.begin(), curr->val);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n        }\\n        return postOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329931,
                "title": "python-iterative-solution-with-deque",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        stack, ret_val = list(), deque()\\n        stack.append(root)\\n        \\n        while stack:\\n            node = stack.pop()\\n            \\n            ret_val.appendleft(node.val)\\n            \\n            if node.left:\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return ret_val\\n            \\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return [root.val]\\n        \\n        stack, ret_val = list(), deque()\\n        stack.append(root)\\n        \\n        while stack:\\n            node = stack.pop()\\n            \\n            ret_val.appendleft(node.val)\\n            \\n            if node.left:\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                stack.append(node.right)\\n        \\n        return ret_val\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 816957,
                "title": "preorder-inorder-postorder-iterative-recursive-explanation",
                "content": "When it comes to the traversal tree problems we can make use of Stack data structure. All the three very famous tree traversals i.e preOrder, postOrder and inOrder can be solved with the help of stack data structure. In this post i\\'ll try to explain what similarities they have in common.\\n\\n<b>Consider out tree looks like this:</b>\\n```\\n\\t\\t   \\t1\\n\\t\\t\\t\\n\\t\\t2      3\\n```\\n\\nThe preOrder traversal  will be ( Root - Left - Right ) : 1 2 3\\nThe postOrder traversal will be ( Left - Right - Root ) : 2 3 1\\nThe inOrder traversal will be ( Left - Root - Right ) : 2 1 3\\n\\nA simple technique to remember is that the answer lies in the name actually, like in case of <b>in</b>Order, the in will simply mean in-between and hence the Root is in between the left and right subtree, similarly in case of <b>pre</b>Order, the pre will imply before the left and right and hence the root is before, same goes for the postOrder.\\n\\n<b>Recursive Solution</b>\\n\\nThe recursive approach is probably lot easier to write in code as recursion handles all the good work which normally people don\\'t dry-run.\\n\\n<b>postOrder</b>\\n```\\n private static void postOrder(TreeNode root){\\n        if(root == null) return;\\n        postOrder(root.left);\\n        postOrder(root.right);\\n        System.out.print(root.val+\" \");\\n    }\\n```\\n\\n<b>preOrder</b>\\n```\\n private static void preOrder(TreeNode root){\\n        if(root == null) return;\\n        System.out.print(root.val+\" \");\\n        preOrder(root.left);\\n        preOrder(root.right);\\n    }\\n```\\n\\n<b>inOrder</b>\\n```\\n private static void inOrder(TreeNode root){\\n        if(root == null) return;\\n        inOrder(root.left);\\n        System.out.print(root.val+\" \");\\n        inOrder(root.right);\\n    }\\n```\\n\\nYou can easily notice, that the only notable difference between them is the positioning of the print statement which basically denotes the root node.\\n\\n<b>Iterative Solutions</b>\\n\\n<b>postOrder</b>\\nIn case of postOrder we need to make use of two stacks, we first insert the root of node of the tree in stack1, then we push this node to the stack2 following with the check for the left subtree node and insert that node first and then for the right substree one.\\n\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while(!stack1.isEmpty()){\\n            TreeNode node = stack1.pop();\\n            stack2.push(node);\\n            if(node.left!=null) stack1.push(node.left);\\n            if(node.right!=null) stack1.push(node.right);\\n        }\\n        while(!stack2.isEmpty()){\\n            TreeNode node = stack2.pop();\\n            list.add(node.val);\\n        }\\n        return list;\\n    }\\n```\\n\\n<b>preOrder Iterative</b>\\nQuite simple actually, just use the LIFO property of stack, and insert the right node first then the left subtree node and you are done.\\n\\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null) stack.push(node.right);\\n            if(node.left!=null) stack.push(node.left);\\n        }\\n        return list;\\n    }\\n```\\n\\n<b>inOrder Iterative</b>\\nTricky! Traverse as left as you can, then consider print the leftmost then print the root and then check for the right subtree and then again go to the left subtree.\\n\\n```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root!=null){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null){\\n                node = node.right;\\n                while(node!=null){\\n                    stack.push(node);\\n                    node = node.left;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n```\\nHope this helps!",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t   \\t1\\n\\t\\t\\t\\n\\t\\t2      3\\n```\n```\\n private static void postOrder(TreeNode root){\\n        if(root == null) return;\\n        postOrder(root.left);\\n        postOrder(root.right);\\n        System.out.print(root.val+\" \");\\n    }\\n```\n```\\n private static void preOrder(TreeNode root){\\n        if(root == null) return;\\n        System.out.print(root.val+\" \");\\n        preOrder(root.left);\\n        preOrder(root.right);\\n    }\\n```\n```\\n private static void inOrder(TreeNode root){\\n        if(root == null) return;\\n        inOrder(root.left);\\n        System.out.print(root.val+\" \");\\n        inOrder(root.right);\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack1 = new Stack<>();\\n        Stack<TreeNode> stack2 = new Stack<>();\\n        stack1.push(root);\\n        while(!stack1.isEmpty()){\\n            TreeNode node = stack1.pop();\\n            stack2.push(node);\\n            if(node.left!=null) stack1.push(node.left);\\n            if(node.right!=null) stack1.push(node.right);\\n        }\\n        while(!stack2.isEmpty()){\\n            TreeNode node = stack2.pop();\\n            list.add(node.val);\\n        }\\n        return list;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null) stack.push(node.right);\\n            if(node.left!=null) stack.push(node.left);\\n        }\\n        return list;\\n    }\\n```\n```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root!=null){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.pop();\\n            list.add(node.val);\\n            if(node.right!=null){\\n                node = node.right;\\n                while(node!=null){\\n                    stack.push(node);\\n                    node = node.left;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 651066,
                "title": "explanation-iterative-using-stack",
                "content": "self Explanatory code { aka good coding practice } \\n```\\n    // we will maintain two stacks named as \"parent\" and \"preCompute\";\\n    // logic is to directly build postorder taversal with the help of parent stack\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        if(!root)   return {};\\n        stack<TreeNode*> parent , preCompute;\\n        parent.emplace(root);\\n        \\n        while(parent.size())\\n        {\\n            TreeNode *temp = parent.top();  \\n            parent.pop();\\n            if(temp->left)\\n                parent.emplace(temp->left);\\n            if(temp->right)\\n                parent.emplace(temp->right);\\n            preCompute.emplace(temp);                \\n        }\\n        vector<int> ans;\\n        while(preCompute.size())\\n            ans.emplace_back( preCompute.top()->val) , preCompute.pop();\\n        return ans;\\n    }\\n};\\n```\\n**related follow up question :** https://leetcode.com/problems/n-ary-tree-postorder-traversal/discuss/650999/iterative-approach-explained",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    // we will maintain two stacks named as \"parent\" and \"preCompute\";\\n    // logic is to directly build postorder taversal with the help of parent stack\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        if(!root)   return {};\\n        stack<TreeNode*> parent , preCompute;\\n        parent.emplace(root);\\n        \\n        while(parent.size())\\n        {\\n            TreeNode *temp = parent.top();  \\n            parent.pop();\\n            if(temp->left)\\n                parent.emplace(temp->left);\\n            if(temp->right)\\n                parent.emplace(temp->right);\\n            preCompute.emplace(temp);                \\n        }\\n        vector<int> ans;\\n        while(preCompute.size())\\n            ans.emplace_back( preCompute.top()->val) , preCompute.pop();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450823,
                "title": "a-template-for-tree-traversals-pre-order-in-order-post-order-easy-to-memorize-for-interview",
                "content": "While there are many posts shareing different implementations with tree traverses, it is a bit cumbersome to memorize different implementations for different traversal types. And it requires lots of effort to ensure a bug-free implementation. \\n\\nFor better interview purpose, I would like to share my template that works uniformly for pre-order, in-order and post-order traversals. It is easily memorizable, and you can simply write it down in the whiteboard on spot.  \\n\\nThe idea is still to use a Stack to keep the traverse path. The trick in the template is to keep track of the occurances of a node. Depending the occurance, we know if it is ready to be popped for post-order, in-order, and pre-order. Below is the template:\\n\\n```\\n@AllArgsConstructor\\n class Pair {\\n        TreeNode treeNode;\\n        int visited;\\n }\\n\\n public void treeTraverse(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n\\t\\t\\tif(top.visited == 2) {\\n\\t\\t\\t\\tSystem.out.println(\"Both children has been processed\");\\n\\t\\t\\t} else if(top.visited == 1) {\\n\\t\\t\\t   System.out.println(\"Left children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t} else {\\n              System.out.println(\"No children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t}\\n        }\\n    }\\n```\\nSo this template push a node at most three times, and based on its occurance, we can determine the state of the traverse.\\nThe simple rule is:\\n1. visited == 0,  no children has been processed, if we print current node, it is **pre-order** traversal\\n2. visited == 1, all left children has been processed, if we print current node, it is **in-order** traversal\\n3. visited == 2, all left and right children has been processed, if we print current node, it is **post-order** traversal.\\n\\nThe completed AC code for the three variants are as below. Although they are not the fastest implementation, but they are easy to remember and bug-free.\\n\\nPost-order:\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 2) {\\n                ans.add(top.treeNode.val);\\n            } else if (top.visited == 1) {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nIn-order:\\n```\\n public List<Integer> inorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 1) {\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nPre-order:\\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if(top.visited == 0) { // it is not necessary for pre-order to have this check, but here is for the integrity of template\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nHope this would help you during the coding interview.\\n\\nP.S. In the above template, we only use one stack. Another benefit it can bring is to implement tree-iterators easily. The DFS solution in the reference solution does not provide such benefit. \\n\\n",
                "solutionTags": [],
                "code": "```\\n@AllArgsConstructor\\n class Pair {\\n        TreeNode treeNode;\\n        int visited;\\n }\\n\\n public void treeTraverse(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n\\t\\t\\tif(top.visited == 2) {\\n\\t\\t\\t\\tSystem.out.println(\"Both children has been processed\");\\n\\t\\t\\t} else if(top.visited == 1) {\\n\\t\\t\\t   System.out.println(\"Left children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t} else {\\n              System.out.println(\"No children has been processed\");\\n\\t\\t\\t   top.visited++;\\n\\t\\t\\t   stack.push(node);\\n\\t\\t\\t   //do something\\n\\t\\t\\t}\\n        }\\n    }\\n```\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 2) {\\n                ans.add(top.treeNode.val);\\n            } else if (top.visited == 1) {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top); \\n                stack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n public List<Integer> inorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if (top.visited == 1) {\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n            } else {\\n                top.visited++;\\n                stack.push(top);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n        Deque<Pair> stack = new LinkedList<>();\\n        stack.push(new Pair(root, 0));\\n        List<Integer> ans = new LinkedList<>();\\n        while (!stack.isEmpty()) {\\n            Pair top = stack.pop();\\n            if (top.treeNode == null) {\\n                continue;\\n            }\\n            if(top.visited == 0) { // it is not necessary for pre-order to have this check, but here is for the integrity of template\\n                ans.add(top.treeNode.val);\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.right, 0));\\n\\t\\t\\t\\tstack.push(new Pair(top.treeNode.left, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333347,
                "title": "java-solution",
                "content": "**Iterative:**\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode cur = stack.pop();\\n            list.add(0, cur.val);\\n            if(cur.left != null)\\n                stack.push(cur.left);\\n            if(cur.right != null)\\n                stack.push(cur.right);\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 62.10% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 35.2 MB, less than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    List<Integer> resultList = new ArrayList<>();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if (root != null) {\\n            postorderTraversal(root.left);\\n            postorderTraversal(root.right);\\n            resultList.add(root.val);\\n        }\\n        return resultList;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Binary Tree Postorder Traversal.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode cur = stack.pop();\\n            list.add(0, cur.val);\\n            if(cur.left != null)\\n                stack.push(cur.left);\\n            if(cur.right != null)\\n                stack.push(cur.right);\\n        }\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    List<Integer> resultList = new ArrayList<>();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        if (root != null) {\\n            postorderTraversal(root.left);\\n            postorderTraversal(root.right);\\n            resultList.add(root.val);\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248025,
                "title": "super-easy-to-understand-java-code-via-using-stack-with-detailed-comments-without-tricks",
                "content": "```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if(root == null) return res;\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.peek(); // to get the reference of the node on top of stack\\n            if(node.left == null && node.right == null){ // if it is a leaf, add its value to result\\n                res.add(node.val);\\n                stack.pop();\\n            }else{\\n                // if it has children, do not remove it from stack\\n                // now we\\'ve got its reference, then it\\'s easy to visit its children\\n                if(node.right != null) stack.push(node.right);\\n                if(node.left != null) stack.push(node.left);\\n                // after adding its children to stack, cut off its leaves.\\n                // otherwise, the non-leaf nodes will never enter to the if branch\\n                node.right = null; \\n                node.left = null;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        if(root == null) return res;\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode node = stack.peek(); // to get the reference of the node on top of stack\\n            if(node.left == null && node.right == null){ // if it is a leaf, add its value to result\\n                res.add(node.val);\\n                stack.pop();\\n            }else{\\n                // if it has children, do not remove it from stack\\n                // now we\\'ve got its reference, then it\\'s easy to visit its children\\n                if(node.right != null) stack.push(node.right);\\n                if(node.left != null) stack.push(node.left);\\n                // after adding its children to stack, cut off its leaves.\\n                // otherwise, the non-leaf nodes will never enter to the if branch\\n                node.right = null; \\n                node.left = null;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191791,
                "title": "one-line-javascript-solution",
                "content": "```\\nvar postorderTraversal = function(root) {\\n    return !root ? [] : postorderTraversal(root.left).concat(postorderTraversal(root.right), root.val);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar postorderTraversal = function(root) {\\n    return !root ? [] : postorderTraversal(root.left).concat(postorderTraversal(root.right), root.val);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45677,
                "title": "pre-order-in-order-post-order-summary",
                "content": "These three traversals are very similar if written in recursive way.  But it is not the case when trying to implement in the iterative way.  Still there are some similarities, so I've gathered the solutions to the 3 traversals as the following.  Hope this would be of some help.\\n\\nPre-order:\\n```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                result.add(p.val);\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                p = p.right;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\nIn-order\\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                result.add(p.val);\\n                p = p.right;\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n```\\nPost-order\\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n        List<Integer> result = new LinkedList<>();\\n\\n        if (root == null) {\\n            return result;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        TreeNode visited = null;\\n\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.peek();\\n                if (p.right != null && p.right != visited) {\\n                    p = p.right;\\n                } else {\\n                    result.add(p.val);\\n                    visited = p;\\n                    stack.pop();\\n                    p = null;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                result.add(p.val);\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                p = p.right;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        List<Integer> result = new LinkedList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        \\n        while (p != null || !stack.isEmpty()) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.pop();\\n                result.add(p.val);\\n                p = p.right;\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n```\n```\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n        List<Integer> result = new LinkedList<>();\\n\\n        if (root == null) {\\n            return result;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode p = root;\\n        TreeNode visited = null;\\n\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(p);\\n                p = p.left;\\n            } else {\\n                p = stack.peek();\\n                if (p.right != null && p.right != visited) {\\n                    p = p.right;\\n                } else {\\n                    result.add(p.val);\\n                    visited = p;\\n                    stack.pop();\\n                    p = null;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45696,
                "title": "o-n-time-o-1-space-with-morris-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        TreeNode *curr = root, *prev = NULL;\\n        \\n        while (curr)\\n        {\\n            if (curr->right)\\n            {\\n                prev = curr->right;\\n                while (prev->left && prev->left != curr)\\n                {\\n                    prev = prev->left;\\n                }\\n                \\n                if (prev->left)\\n                {\\n                    prev->left = NULL;\\n                    curr = curr->left;\\n                }\\n                else\\n                {\\n                    prev->left = curr;\\n                    result.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n            else\\n            {\\n                result.push_back(curr->val);\\n                curr = curr->left;\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\\n\\nCombination of Morris Traversal and a creative postorder traversal from this post: https://discuss.leetcode.com/topic/44387/preorder-inorder-postorder-iterative-solution-by-c",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        TreeNode *curr = root, *prev = NULL;\\n        \\n        while (curr)\\n        {\\n            if (curr->right)\\n            {\\n                prev = curr->right;\\n                while (prev->left && prev->left != curr)\\n                {\\n                    prev = prev->left;\\n                }\\n                \\n                if (prev->left)\\n                {\\n                    prev->left = NULL;\\n                    curr = curr->left;\\n                }\\n                else\\n                {\\n                    prev->left = curr;\\n                    result.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n            else\\n            {\\n                result.push_back(curr->val);\\n                curr = curr->left;\\n            }\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45755,
                "title": "c-iterative-solution-0ms-with-a-stack",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            if(root==NULL)return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            while(!st.empty())\\n            {\\n                TreeNode *curr=st.top();\\n                st.pop();\\n                if(curr->left)st.push(curr->left);\\n                if(curr->right)st.push(curr->right);\\n                ret.push_back(curr->val);\\n            }\\n            reverse(ret.begin(),ret.end());\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            if(root==NULL)return ret;\\n            stack<TreeNode*> st;\\n            st.push(root);\\n            while(!st.empty())\\n            {\\n                TreeNode *curr=st.top();\\n                st.pop();\\n                if(curr->left)st.push(curr->left);\\n                if(curr->right)st.push(curr->right);\\n                ret.push_back(curr->val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45799,
                "title": "my-python-accepted-solution-with-only-1-stack-simple-and-concise-doesn-t-need-to-reverse",
                "content": "We know that a node is visited immediately after it's right child node be visited, \\n\\nor it's left child node when it has no right child.\\n\\nSo:\\n\\n1. Push root in stack. \\n\\n2. While the stack is not empty:\\n\\n  If the top node of the stack is a leaf node, or the last visited node \\n\\n  is his right child (or his left child), than pop this node, and visit it.\\n\\n  Else, push this node's right child and left child into stack.\\n\\n3. Loop to 2.\\n\\nThe code:\\n\\n        def postorderTraversal(self, root):\\n        if root is None: return []\\n        \\n        s, lastVist, ret = [root], root, []\\n        while s:\\n            top = s[-1]\\n            if (top.left is None and top.right is None) or \\\\\\n                    (top.right == lastVist or top.left == lastVist):\\n                lastVist = s.pop()\\n                ret.append(lastVist.val)\\n            else:\\n                if top.right: s.append(top.right)\\n                if top.left:  s.append(top.left)\\n        \\n        return ret",
                "solutionTags": [],
                "code": "We know that a node is visited immediately after it's right child node be visited, \\n\\nor it's left child node when it has no right child.\\n\\nSo:\\n\\n1. Push root in stack. \\n\\n2. While the stack is not empty:\\n\\n  If the top node of the stack is a leaf node, or the last visited node \\n\\n  is his right child (or his left child), than pop this node, and visit it.\\n\\n  Else, push this node's right child and left child into stack.\\n\\n3. Loop to 2.\\n\\nThe code:\\n\\n        def postorderTraversal(self, root):\\n        if root is None: return []\\n        \\n        s, lastVist, ret = [root], root, []\\n        while s:\\n            top = s[-1]\\n            if (top.left is None and top.right is None) or \\\\\\n                    (top.right == lastVist or top.left == lastVist):\\n                lastVist = s.pop()\\n                ret.append(lastVist.val)\\n            else:\\n                if top.right: s.append(top.right)\\n                if top.left:  s.append(top.left)\\n        \\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3509970,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return \\n        a=[root]\\n        ans=[]\\n        while a:\\n            t=a.pop()\\n            ans.append(t.val)\\n            if t.left:\\n                a.append(t.left)\\n            if t.right:\\n                a.append(t.right)\\n        return ans[::-1]\\n```\\n**Recursive Solution:**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    \\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.Traversal(root.right)\\n        self.ans.append(root.val)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return \\n        a=[root]\\n        ans=[]\\n        while a:\\n            t=a.pop()\\n            ans.append(t.val)\\n            if t.left:\\n                a.append(t.left)\\n            if t.right:\\n                a.append(t.right)\\n        return ans[::-1]\\n```\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    \\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.Traversal(root.right)\\n        self.ans.append(root.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201638,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        postorder(root->left, nodes);\\n        postorder(root->right, nodes); \\n        nodes.push_back(root->val);   \\n    }        \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> postorder;\\n        if (root == NULL)\\n            return postorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            postorder.push_back(curr->val);\\n            if (curr->left != NULL)\\n                st.push(curr->left);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n        }   \\n        reverse(postorder.begin(), postorder.end()); \\n        return postorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        postorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void postorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        postorder(root->left, nodes);\\n        postorder(root->right, nodes); \\n        nodes.push_back(root->val);   \\n    }        \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> postorder;\\n        if (root == NULL)\\n            return postorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            postorder.push_back(curr->val);\\n            if (curr->left != NULL)\\n                st.push(curr->left);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n        }   \\n        reverse(postorder.begin(), postorder.end()); \\n        return postorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575743,
                "title": "simple-recursion-golang-go",
                "content": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t\\tr.Res = append(r.Res, node.Val)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t\\tr.Res = append(r.Res, node.Val)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2466951,
                "title": "python-simple-solution-beats-91",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.postOrder = []\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        if root:\\n            self.postorderTraversal(root.left)\\n            self.postorderTraversal(root.right)\\n            self.postOrder.append(root.val)\\n        return self.postOrder\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.postOrder = []\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        if root:\\n            self.postorderTraversal(root.left)\\n            self.postorderTraversal(root.right)\\n            self.postOrder.append(root.val)\\n        return self.postOrder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248165,
                "title": "java-standard-iterative-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n    if(root == null) return ans;\\n      \\n    Stack<TreeNode> st = new Stack<>();\\n    st.push(root);\\n    while(!st.empty()){\\n        root = st.pop();\\n        ans.add(0, root.val);\\n        if(root.left != null) st.push(root.left);\\n        if(root.right != null) st.push(root.right);\\n    }\\n    return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n    if(root == null) return ans;\\n      \\n    Stack<TreeNode> st = new Stack<>();\\n    st.push(root);\\n    while(!st.empty()){\\n        root = st.pop();\\n        ans.add(0, root.val);\\n        if(root.left != null) st.push(root.left);\\n        if(root.right != null) st.push(root.right);\\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245063,
                "title": "easy-recursive-solution-postorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void postorder(TreeNode* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        postorder(root->left,ans);\\n        postorder(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void postorder(TreeNode* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        postorder(root->left,ans);\\n        postorder(root->right,ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056621,
                "title": "binary-tree-postorder-traversal-javascript-using-recursion-or-iteration-stack",
                "content": "More about binary tree: https://sneeit.com/binary-trees-and-algorithms/?tab=documentation\\n# Approach 1: Recursion / DP\\nThe most intuitive approach is using recursion. You can read and understand the code easily\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let ans = [];\\n    let traverse = node => {\\n        if (node.left) traverse(node.left)\\n        if (node.right) traverse(node.right)\\n        ans.push(node.val)\\n    }\\n\\n    traverse(root);\\n    return ans;\\n};\\n```\\n\\n# Approach 2: Iteration + Stack\\nI don\\'t like the solutions that reverse the answer from pre-order traversal because sometimes you will be asked to do some task following the post-order, not only about adding value to an array.\\n\\nWe will separate our trip into 3 steps:\\n1. Keep traveling on the left nodes as far as we can\\n2. If the node is a leaf, process it. Otherwise, it may be a parent node of a right node, so we need to check its right node before we processing it\\n3. If the right node of this parent node had not been processed, just repeat the step 1 and 2 from the right node. Otherwise, we processed all left and right nodes of this parent node so we just process this parent node\\n\\n```\\n\\n// stack version\\nvar postorderTraversal = function(root) {\\n    if (!root) {\\n        return [];\\n    }\\n\\n    let ans = [];\\n    let stack = [];    \\n    cur = root;\\n    pre = null;\\n    while (cur || stack.length) {      \\n        // step 1          \\n        // move along the left edges as far as we can\\n        if (cur) {\\n            stack.push(cur);\\n            cur = cur.left;\\n            continue;\\n        }\\n        \\n        // step 2\\n        // if the node is the parent of any right chid-node\\n        let last = stack[stack.length - 1];\\n        if (last.right && last.right != pre) {\\n            cur = last.right;\\n            continue;\\n        }        \\n        \\n        // step 3\\n        // most left / right nodes will be processed here first\\n        // then parents nodes\\n        ans.push(last.val);\\n\\n        // marked this node as processed \\n        // so it\\'s parent cannot add it again from the step 2\\n        pre = stack.pop();\\n    }\\n\\n    return ans;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    if (!root) return [];\\n    let ans = [];\\n    let traverse = node => {\\n        if (node.left) traverse(node.left)\\n        if (node.right) traverse(node.right)\\n        ans.push(node.val)\\n    }\\n\\n    traverse(root);\\n    return ans;\\n};\\n```\n```\\n\\n// stack version\\nvar postorderTraversal = function(root) {\\n    if (!root) {\\n        return [];\\n    }\\n\\n    let ans = [];\\n    let stack = [];    \\n    cur = root;\\n    pre = null;\\n    while (cur || stack.length) {      \\n        // step 1          \\n        // move along the left edges as far as we can\\n        if (cur) {\\n            stack.push(cur);\\n            cur = cur.left;\\n            continue;\\n        }\\n        \\n        // step 2\\n        // if the node is the parent of any right chid-node\\n        let last = stack[stack.length - 1];\\n        if (last.right && last.right != pre) {\\n            cur = last.right;\\n            continue;\\n        }        \\n        \\n        // step 3\\n        // most left / right nodes will be processed here first\\n        // then parents nodes\\n        ans.push(last.val);\\n\\n        // marked this node as processed \\n        // so it\\'s parent cannot add it again from the step 2\\n        pre = stack.pop();\\n    }\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1965782,
                "title": "c-100-iterative-solution-o-n",
                "content": "```\\nint* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL};\\n    int idx = 0;\\n    // get elems in reverse order\\n    while(idx || root) {\\n        if (root) {\\n            stack[idx++] = root;\\n            res[(*returnSize)++] = root->val;\\n            root = root->right;\\n        } else {\\n            struct TreeNode* node = stack[--idx];\\n            root = node->left;\\n        }\\n    }\\n\\t// reverse array\\n    for (int i = 0, j = *returnSize - 1; i < j; i++, j--) {\\n        int t = res[j];\\n        res[j] = res[i];\\n        res[i] = t;\\n    }\\n    return res;\\n}\\n``` \\n***If this was helpful, don\\'t hesitate to upvote! :)***\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* postorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    int *res = malloc(100 * sizeof(int));\\n    *returnSize = 0;\\n    struct TreeNode* stack[100] = {NULL};\\n    int idx = 0;\\n    // get elems in reverse order\\n    while(idx || root) {\\n        if (root) {\\n            stack[idx++] = root;\\n            res[(*returnSize)++] = root->val;\\n            root = root->right;\\n        } else {\\n            struct TreeNode* node = stack[--idx];\\n            root = node->left;\\n        }\\n    }\\n\\t// reverse array\\n    for (int i = 0, j = *returnSize - 1; i < j; i++, j--) {\\n        int t = res[j];\\n        res[j] = res[i];\\n        res[i] = t;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1964358,
                "title": "python-recursive-iterative-with-last-visited-node-no-cheating",
                "content": "**Recursive**\\n```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\tdef postorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\tpostorder(root.left)\\n\\t\\tpostorder(root.right)\\n\\t\\tres.append(root.val)\\n\\n\\tpostorder(root)\\n```\\n\\n**Iterative with stack and last_visited_node:**\\nSubtree nodes visit sequence: Left-Right-Process Node (post-order)\\n![image](https://assets.leetcode.com/users/images/cb430b62-e30d-46e7-8b99-7203bb6b2d2f_1650385773.740851.png)\\nWhen we traverse the tree we need to take care about 3 cases:\\n\\n1. Node 5 **without right subtree**. We got here from 2. We check in \"visited nodes stack\" if the right subtree is missing -> remember last visited node 5 and pop it, return to parent node 2.\\n2. **Right subtree was visited**: Node 3 we got here from 1. This one is interesting: in order to avoid entering a never ending loop (1 -> 3 -> 1 -> 3) we need to check if we visited the node 3 last time ->  remember last visited node 3 and pop it, return to parent node 1. If we had visited 3, pop node 1 - remember last visited node 1 and pop it\\n3. **Right subtree was not visited**: visit right subtree\\n\\n```\\nstack = deque()\\nnode = root\\nlast_visited_node = None\\nwhile node or stack:\\n\\twhile node:\\n\\t\\tstack.append(node)\\n\\t\\tnode = node.left\\n\\t# no right subtree, right subtree was visited\\n\\tif stack[-1].right in [None, last_visited_node]:\\n\\t\\tres.append(stack[-1].val)\\n\\t\\tlast_visited_node = stack.pop()\\n\\t# right subtree was not visited\\n\\telse:\\n\\t\\tnode = stack[-1].right\\n\\nreturn res\\n```\\n\\nP.S. After years of Java, Python is such fun (with crutches, but it is still fun)\\nP.P.S. How to remember iterative pre/in order?\\n```\\nclass Solution:\\n    def traversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = deque()\\n        node = root\\n        res = []\\n        while node or stack:\\n            while node:\\n                res.append(node.val) # <--- pre order\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n\\t\\t\\tres.append(node.val) # <--- in order\\n            node = node.right\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\tdef postorder(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\tpostorder(root.left)\\n\\t\\tpostorder(root.right)\\n\\t\\tres.append(root.val)\\n\\n\\tpostorder(root)\\n```\n```\\nstack = deque()\\nnode = root\\nlast_visited_node = None\\nwhile node or stack:\\n\\twhile node:\\n\\t\\tstack.append(node)\\n\\t\\tnode = node.left\\n\\t# no right subtree, right subtree was visited\\n\\tif stack[-1].right in [None, last_visited_node]:\\n\\t\\tres.append(stack[-1].val)\\n\\t\\tlast_visited_node = stack.pop()\\n\\t# right subtree was not visited\\n\\telse:\\n\\t\\tnode = stack[-1].right\\n\\nreturn res\\n```\n```\\nclass Solution:\\n    def traversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = deque()\\n        node = root\\n        res = []\\n        while node or stack:\\n            while node:\\n                res.append(node.val) # <--- pre order\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n\\t\\t\\tres.append(node.val) # <--- in order\\n            node = node.right\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948311,
                "title": "python-easy-to-understand-iterative-solution-using-visited",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if not root:\\n            return []\\n        \\n        res=[]\\n        stack=[(root,False)]\\n        \\n        while stack:\\n            node,visited=stack.pop()\\n            if visited:\\n                res.append(node.val)\\n            else:\\n                stack.append((node,True))\\n                if node.right:\\n                    stack.append((node.right,False))\\n                if node.left:\\n                    stack.append((node.left,False))\\n            \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if not root:\\n            return []\\n        \\n        res=[]\\n        stack=[(root,False)]\\n        \\n        while stack:\\n            node,visited=stack.pop()\\n            if visited:\\n                res.append(node.val)\\n            else:\\n                stack.append((node,True))\\n                if node.right:\\n                    stack.append((node.right,False))\\n                if node.left:\\n                    stack.append((node.left,False))\\n            \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684118,
                "title": "easy-python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def postorder(root):\\n            if root!=None:\\n                postorder(root.left)\\n                postorder(root.right)\\n                arr.append(root.val)\\n            return arr\\n        arr = []\\n        return postorder(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def postorder(root):\\n            if root!=None:\\n                postorder(root.left)\\n                postorder(root.right)\\n                arr.append(root.val)\\n            return arr\\n        arr = []\\n        return postorder(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633799,
                "title": "java-morris-traversal-time-o-n-space-o-1-postorder",
                "content": "The Idea here is to follow similar approach as we follow in inorder with minor changes. First lets have a dummy node and make whole tree as left child of dummy node and make right child empty. [ why? Bec if we assume there is no right child of root then prinitng left child and then root become postorder traversal. Now what next? Are we finished, No... only performing inorder on new tree does not make any sense, it still printing inorder traversal of original tree followed by dummy node.\\n\\nNow closely observe inner else block, this the piece of code which require attention. Since this temporarily extended tree is the subject of traversal as in in-order traversal except that in the inner else clause, after finding a temporary parent, nodes between curr.left (included) and curr (excluded) extended to the right in a modified tree are processed in the reverse order. To process them in constant time, the chain of nodes is scanned down and right references are reversed to refer to parents of nodes. Then the same chain is scanned upward, each node is visited, and the right references are restored to their original setting.\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n   //taking dummy node and assigning it\\'s left subtree to the original tree     \\n        TreeNode dummy = new TreeNode(-1);\\n        dummy.left = root;\\n        \\n        TreeNode curr = dummy;\\n        \\n        while(curr!=null) {\\n            if(curr.left == null){\\n\\t\\t\\t// If there is no left subtree then we are moving to right subtree\\n                curr = curr.right;\\n            } else{\\n                TreeNode pred = curr.left;\\n\\t\\t\\t\\t//finding predeccsor of curr node\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n\\t\\t\\t\\t// if predeccsor\\'s right was not pointing to curr then assigning it\\'s right to curr and moving left\\n                if(pred.right == null){\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }else{\\n                    TreeNode prev = curr;\\n                    TreeNode middle = prev.left;\\n                    // reversing the nodes between prev.left to pred (both incl)\\n                    while(middle != curr){\\n                       TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n                    // restoring the nodes between prev.left to pred (both incl) and adding them one by one to result list\\n                    middle = pred;\\n                    prev = curr;\\n                    while(middle != curr){\\n                        ans.add(middle.val);\\n                        TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    pred.right = null;\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        dummy.left = null;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n   //taking dummy node and assigning it\\'s left subtree to the original tree     \\n        TreeNode dummy = new TreeNode(-1);\\n        dummy.left = root;\\n        \\n        TreeNode curr = dummy;\\n        \\n        while(curr!=null) {\\n            if(curr.left == null){\\n\\t\\t\\t// If there is no left subtree then we are moving to right subtree\\n                curr = curr.right;\\n            } else{\\n                TreeNode pred = curr.left;\\n\\t\\t\\t\\t//finding predeccsor of curr node\\n                while(pred.right != null && pred.right != curr){\\n                    pred = pred.right;\\n                }\\n\\t\\t\\t\\t// if predeccsor\\'s right was not pointing to curr then assigning it\\'s right to curr and moving left\\n                if(pred.right == null){\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }else{\\n                    TreeNode prev = curr;\\n                    TreeNode middle = prev.left;\\n                    // reversing the nodes between prev.left to pred (both incl)\\n                    while(middle != curr){\\n                       TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n                    // restoring the nodes between prev.left to pred (both incl) and adding them one by one to result list\\n                    middle = pred;\\n                    prev = curr;\\n                    while(middle != curr){\\n                        ans.add(middle.val);\\n                        TreeNode last = middle.right;\\n                        middle.right = prev;\\n                        prev = middle;\\n                        middle = last;\\n                    }\\n\\t\\t\\t\\t\\t\\n                    pred.right = null;\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        dummy.left = null;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570079,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n        nodeVec.push_back(temp->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n        nodeVec.push_back(temp->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441602,
                "title": "python-iterative-explained",
                "content": "## IterativeSolution\\nTo traverse a binary list in postOrder using iteration, you need two lists:\\n1.  todo_stack: list of nodes that have not yet been added to the value list\\n2.  tree_vals: list of results\\n\\n### Steps:\\nThe steps section details the logic behind the code. \\n\\nFirst, instantiate two lists, and add rootNode to todo_stack. Then:\\n1. Repeat until todo_stack is empty\\n1. node = todo_stack.pop()\\n1. If node.left == None and node.right == None:\\n\\t1. tree_vals.append(node.val)\\n1. else:\\n\\t1. todo_stack += [node, node.right, node.left]\\n    \\n\\n#### Notes on each step\\n    1. Will continue through all nodes\\n    2. Take the last node from the stack - because pop() takes the last element, order adding to the list is important\\n    3. If the node has no children, or its children have already been accessed, add value to results\\n    4. If the node has children, add all nodes back to the stack. \\n        - Set the root pointers to None. Otherwise there will be an infinite loop\\n        - Order is important here, it must go: root -> right -> left\\n\\n### Complexity analysis\\n\\n#### Time complexity\\nO(N) - must read each value in the binary tree\\n\\n#### Space complexity\\nO(N) - the todo_stack may technically hold all nodes in some binary trees, e.g., all nodes are left children.\\n\\n## Python code\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> list:\\n\\t\\tif not root: return [] \\n        \\n        tree_vals, todo_stack = [], [root]\\n\\n        while todo_stack:\\n            node = todo_stack.pop()\\n\\n            if node.left == None and node.right == None:\\n                tree_vals.append(node.val)\\n            else:\\n                left, right, node.left, node.right = node.left, node.right, None, None\\n                todo_stack += [x for x in [node, right, left] if x != None]  \\n        \\n        return tree_vals\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> list:\\n\\t\\tif not root: return [] \\n        \\n        tree_vals, todo_stack = [], [root]\\n\\n        while todo_stack:\\n            node = todo_stack.pop()\\n\\n            if node.left == None and node.right == None:\\n                tree_vals.append(node.val)\\n            else:\\n                left, right, node.left, node.right = node.left, node.right, None, None\\n                todo_stack += [x for x in [node, right, left] if x != None]  \\n        \\n        return tree_vals\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 327899,
                "title": "c-100-beat-koderz-kamp-o-n-time-complexity-o-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> aResult;\\n        stack<TreeNode*> aStack;\\n        TreeNode *aNode = root;\\n        while (aStack.size() > 0 || aNode != NULL) {\\n            if (aNode == NULL) {\\n                aNode = aStack.top()->left;\\n                aStack.pop();\\n            } else {\\n                aStack.push(aNode);\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            }\\n        }\\n        reverse(aResult.begin(), aResult.end());\\n        return aResult;\\n    }\\n};\\n```\\n\\nThis is the fastest way to do it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> aResult;\\n        stack<TreeNode*> aStack;\\n        TreeNode *aNode = root;\\n        while (aStack.size() > 0 || aNode != NULL) {\\n            if (aNode == NULL) {\\n                aNode = aStack.top()->left;\\n                aStack.pop();\\n            } else {\\n                aStack.push(aNode);\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            }\\n        }\\n        reverse(aResult.begin(), aResult.end());\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45538,
                "title": "here-is-my-java-solution-which-don-t-need-to-reverse",
                "content": "    \\n  The only extra way different with Inorder or preorder way , is how to treat current node. In that two ways, we directly store current node into list, but in postorder, we need to peek current node first, to see whether it has right node, if it is, we process right node first , and then come back.\\n      So we need extra variable peek  to record current node( we will go back , but now we need to go right first),  and varaible last to see whether right node is treated, so when we go back to its parent, we don't need to go back right node again.\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        if(root == null) {return result;}\\n        TreeNode node = root;\\n        TreeNode last = null;\\n        while(node != null || !stack.isEmpty()) {\\n            while(node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            } \\n                TreeNode peek = stack.peek();\\n               if(peek.right != null && last != peek.right) { //Turning into right node\\n                   node = peek.right;\\n               } else {\\n                  peek = stack.pop();\\n                   result.add(peek.val);\\n                   last = peek;\\n               }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        if(root == null) {return result;}\\n        TreeNode node = root;\\n        TreeNode last = null;\\n        while(node != null || !stack.isEmpty()) {\\n            while(node != null) {\\n                stack.push(node);\\n                node = node.left;\\n            } \\n                TreeNode peek = stack.peek();\\n               if(peek.right != null && last != peek.right) { //Turning into right node\\n                   node = peek.right;\\n               } else {\\n                  peek = stack.pop();\\n                   result.add(peek.val);\\n                   last = peek;\\n               }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45552,
                "title": "the-simplest-iterative-morris-solutions-postorder-is-symmetric-to-the-preorder",
                "content": "I have noticed that the postorder traversal is left-right symmetric to the preorder traversal!\\nThus, when conducting postorder traversal, you first visit parent node, then the right child tree, last the left child tree.\\nHowever, to get a right answer,  you need to inverse the result!\\nI have tested the code on OJ, they are accepted!\\n\\nIterative Traversal\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n    vector<int> nums;\\n    stack<TreeNode* > stnode;\\n    while (root || !stnode.empty()) {\\n        if (!root) {\\n            root = stnode.top();\\n            stnode.pop();\\n        }\\n        nums.push_back(root->val);\\n        if (root->left) stnode.push(root->left);\\n        root = root->right;\\n    }\\n    return vector<int>(nums.rbegin(), nums.rend()) \\n} \\n```\\n\\nMorris Traversal\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nums;\\n        TreeNode* cur = nullptr;\\n\\n        while (root) {\\n            if (root->right) {\\n                cur = root->right;\\n                while (cur->left && cur->left != root) {\\n                    cur = cur->left;\\n                }\\n                if (cur->left == root) {\\n                    cur->left = nullptr;\\n                    root = root->left;\\n                } else {\\n                    nums.push_back(root->val);\\n                    cur->left = root;\\n                    root = root->right;\\n                }\\n            } else {\\n                nums.push_back(root->val);\\n                root = root->left;\\n            }\\n        }\\n        return vector<int>(nums.rbegin(), nums.rend());\\n    } \\n}\\n```\\n\\nYou can see the summary of all methods at here: http://blog.csdn.net/yc461515457/article/details/78082042",
                "solutionTags": [],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n    vector<int> nums;\\n    stack<TreeNode* > stnode;\\n    while (root || !stnode.empty()) {\\n        if (!root) {\\n            root = stnode.top();\\n            stnode.pop();\\n        }\\n        nums.push_back(root->val);\\n        if (root->left) stnode.push(root->left);\\n        root = root->right;\\n    }\\n    return vector<int>(nums.rbegin(), nums.rend()) \\n} \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> nums;\\n        TreeNode* cur = nullptr;\\n\\n        while (root) {\\n            if (root->right) {\\n                cur = root->right;\\n                while (cur->left && cur->left != root) {\\n                    cur = cur->left;\\n                }\\n                if (cur->left == root) {\\n                    cur->left = nullptr;\\n                    root = root->left;\\n                } else {\\n                    nums.push_back(root->val);\\n                    cur->left = root;\\n                    root = root->right;\\n                }\\n            } else {\\n                nums.push_back(root->val);\\n                root = root->left;\\n            }\\n        }\\n        return vector<int>(nums.rbegin(), nums.rend());\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45697,
                "title": "c-tree-traversals-simple-and-easy-to-understand-preorder-inorder-and-postorder",
                "content": "Preorder :\\n \\n\\n    \\u200bvector<int> preorderTraversal(TreeNode* root) {\\n                stack<TreeNode* > S;\\n                vector<int> V;\\n                if(!root)\\n                    return V;\\n                S.push(root);\\n                while(!S.empty()){\\n                    TreeNode* temp = S.top();\\n                    V.push_back(temp->val);\\n                    S.pop();\\n                    if(temp->right)\\n                        S.push(temp->right);\\n                    if(temp->left)\\n                        S.push(temp->left);\\n                }\\n                return V;\\n            }\\n\\n\\n\\u200b\\n\\u200bInorder :\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n            stack<TreeNode*> S;\\n            vector<int> V;\\n            while(root || !S.empty()){\\n                while(root){\\n                    S.push(root);\\n                    root = root->left;\\n                }\\n                root = S.top();\\n                S.pop();\\n                V.push_back(root->val);\\n                root = root->right;\\n            }\\n            return V;\\n        }\\u200b\\n\\n \\n\\u200bPostorder :\\u200b\\n\\n    \\u200bvector<int> postorderTraversal(TreeNode* root) {\\n                stack<TreeNode*> S;\\n                vector<int> V;\\n                TreeNode *lastNode = NULL, *topNode;\\n                while(root || !S.empty()){\\n                    while(root){\\n                        S.push(root);\\n                        root = root->left;\\n                    }\\n                    topNode = S.top();\\n                    if(topNode->right && topNode->right != lastNode){\\n                        root = topNode->right;\\n                    }\\n                    else{\\n                        V.push_back(topNode->val);\\n                        lastNode = S.top();\\n                        S.pop();\\n                    }\\n                }\\n                return V;\\n            }\\u200b",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "Preorder :\\n \\n\\n    \\u200bvector<int> preorderTraversal(TreeNode* root) {\\n                stack<TreeNode* > S;\\n                vector<int> V;\\n                if(!root)\\n                    return V;\\n                S.push(root);\\n                while(!S.empty()){\\n                    TreeNode* temp = S.top();\\n                    V.push_back(temp->val);\\n                    S.pop();\\n                    if(temp->right)\\n                        S.push(temp->right);\\n                    if(temp->left)\\n                        S.push(temp->left);\\n                }\\n                return V;\\n            }\\n\\n\\n\\u200b\\n\\u200bInorder :\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n            stack<TreeNode*> S;\\n            vector<int> V;\\n            while(root || !S.empty()){\\n                while(root){\\n                    S.push(root);\\n                    root = root->left;\\n                }\\n                root = S.top();\\n                S.pop();\\n                V.push_back(root->val);\\n                root = root->right;\\n            }\\n            return V;\\n        }\\u200b\\n\\n \\n\\u200bPostorder :\\u200b\\n\\n    \\u200bvector<int> postorderTraversal(TreeNode* root) {\\n                stack<TreeNode*> S;\\n                vector<int> V;\\n                TreeNode *lastNode = NULL, *topNode;\\n                while(root || !S.empty()){\\n                    while(root){\\n                        S.push(root);\\n                        root = root->left;\\n                    }\\n                    topNode = S.top();\\n                    if(topNode->right && topNode->right != lastNode){\\n                        root = topNode->right;\\n                    }\\n                    else{\\n                        V.push_back(topNode->val);\\n                        lastNode = S.top();\\n                        S.pop();\\n                    }\\n                }\\n                return V;\\n            }\\u200b",
                "codeTag": "Unknown"
            },
            {
                "id": 45698,
                "title": "python-simple-iterative-solution-no-reversal-easy-to-understand-44ms",
                "content": "<br>\\n`stack` contains the node and the visited status of this node `[node, status]`. (only valid nodes will be added to the stack) <br><br>\\nThere are three different `status` when we see a node: <br><br>\\n`-1`: haven't visited the left child yet  => add its left child to stack (if it has one) <br>\\n`0`: already visited its left child => add its right child to stack (if it has one)<br>\\n`1`: already visited both its left and right child  => pop and append it to the result <br>\\n<br>\\nIn each loop, we use `stack[-1][1] += 1` to update the status of this node\\n\\n<br>\\n\\n\\n    def postorderTraversal(self, root):\\n        if not root:\\n            return []\\n        ans, stack = [], [[root, -1]]\\n\\n        while stack:\\n            node, status = stack[-1]\\n            stack[-1][1] += 1\\n            if status == -1 and node.left:\\n                stack.append([node.left, -1])\\n            elif status == 0 and node.right:\\n                stack.append([node.right, -1])\\n            elif status == 1:\\n                ans.append(stack.pop()[0].val)\\n\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "<br>\\n`stack` contains the node and the visited status of this node `[node, status]`. (only valid nodes will be added to the stack) <br><br>\\nThere are three different `status` when we see a node: <br><br>\\n`-1`: haven't visited the left child yet  => add its left child to stack (if it has one) <br>\\n`0`: already visited its left child => add its right child to stack (if it has one)<br>\\n`1`: already visited both its left and right child  => pop and append it to the result <br>\\n<br>\\nIn each loop, we use `stack[-1][1] += 1` to update the status of this node\\n\\n<br>\\n\\n\\n    def postorderTraversal(self, root):\\n        if not root:\\n            return []\\n        ans, stack = [], [[root, -1]]\\n\\n        while stack:\\n            node, status = stack[-1]\\n            stack[-1][1] += 1\\n            if status == -1 and node.left:\\n                stack.append([node.left, -1])\\n            elif status == 0 and node.right:\\n                stack.append([node.right, -1])\\n            elif status == 1:\\n                ans.append(stack.pop()[0].val)\\n\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 45722,
                "title": "share-my-c-solution-with-no-flag-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            \\n            if (root == NULL)\\n                return ret;\\n            \\n            TreeNode *cur = root;\\n            TreeNode *pre = NULL;\\n            s.push(cur);\\n            \\n            while (!s.empty())\\n            {\\n                cur = s.top();\\n                if ( (cur->left == NULL && cur->right == NULL) || (pre != NULL && (pre == cur->right || pre == cur->left)) )\\n                {\\n                    ret.push_back(cur->val);\\n                    s.pop();\\n                    pre = cur;\\n                }\\n                else\\n                {\\n                    if (cur->right != NULL)\\n                        s.push(cur->right);\\n                    if (cur->left != NULL)\\n                        s.push(cur->left);\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> postorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            \\n            if (root == NULL)\\n                return ret;\\n            \\n            TreeNode *cur = root;\\n            TreeNode *pre = NULL;\\n            s.push(cur);\\n            \\n            while (!s.empty())\\n            {\\n                cur = s.top();\\n                if ( (cur->left == NULL && cur->right == NULL) || (pre != NULL && (pre == cur->right || pre == cur->left)) )\\n                {\\n                    ret.push_back(cur->val);\\n                    s.pop();\\n                    pre = cur;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 45719,
                "title": "java-solution-no-need-to-reverse-the-list",
                "content": "    public class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> R = new LinkedList<Integer>();\\n        if (root == null) return R;\\n        Stack<TreeNode> S = new Stack();\\n        S.push(root);\\n        while (!S.empty()) {\\n            TreeNode node = S.pop();\\n            R.add(0, node.val);\\n            if (node.left != null) S.push(node.left);\\n            if (node.right != null) S.push(node.right);\\n        }\\n        return R;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> R = new LinkedList<Integer>();\\n        if (root == null) return R;\\n        Stack<TreeNode> S = new Stack();\\n        S.push(root);\\n        while (!S.empty()) {\\n            TreeNode node = S.pop();\\n            R.add(0, node.val);\\n            if (node.left != null) S.push(node.left);\\n            if (node.right != null) S.push(node.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45756,
                "title": "simple-javascript-why-is-this-problem-marked-as-hard",
                "content": "This problem is the symetrical of binary-tree-preorder-traversal/ , a question  marked as \"medium\"\\n\\nin consequence here is a simple solution in JS :\\n\\n    var postorderTraversal = function(root) {\\n        var to_visit = [];\\n        var visited = [];\\n        to_visit.push(root);\\n            while(to_visit.length > 0) {\\n                var current = to_visit.pop();\\n                if(current !==null) {\\n                    visited.push(current.val);\\n                    to_visit.push(current.left);\\n                    to_visit.push(current.right);\\n                   \\n                }\\n            }\\n        visited.reverse();\\n        return visited;\\n    };",
                "solutionTags": [],
                "code": "This problem is the symetrical of binary-tree-preorder-traversal/ , a question  marked as \"medium\"\\n\\nin consequence here is a simple solution in JS :\\n\\n    var postorderTraversal = function(root) {\\n        var to_visit = [];\\n        var visited = [];\\n        to_visit.push(root);\\n            while(to_visit.length > 0) {\\n                var current = to_visit.pop();\\n                if(current !==null) {\\n                    visited.push(current.val);\\n                    to_visit.push(current.left);\\n                    to_visit.push(current.right);\\n                   \\n                }\\n            }\\n        visited.reverse();\\n        return visited;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 45757,
                "title": "postorder-traversal-java-solution-both-recursion-and-iteration",
                "content": "    // recursive\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            postordtree(result, root);\\n            return result;\\n        }\\n        private void postordtree(List<Integer> result, TreeNode node){\\n            if (node.left != null) postordtree(result, node.left);\\n            if (node.right != null) postordtree(result, node.right);\\n            result.add(node.val);\\n        }\\n    }\\n    \\n    // iterative\\n    public class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            // https://en.wikipedia.org/wiki/Tree_traversal\\n            // iterative\\n            List<Integer> result = new ArrayList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            TreeNode last = null;\\n            TreeNode peeknode = null;\\n            while (!stack.isEmpty() || root != null){\\n                if (root != null){\\n                    stack.push(root);\\n                    root = root.left;\\n                    // traverse to the leftmost\\n                }\\n                else{\\n                    peeknode = stack.peek();\\n                    if(peeknode.right != null && last != peeknode.right) root = peeknode.right;\\n                    else{\\n                        result.add(peeknode.val);\\n                        last = stack.pop();\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> postorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            postordtree(result, root);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45759,
                "title": "the-key-is-to-reversely-add-element",
                "content": "The key to simply this problem is to always add number to the beginning of the list. Then postorder becomes very similar to preorder. (becomes head->right->left).\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new LinkedList<Integer>();\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\n\\t\\tstack.push(root);\\n\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode current = stack.pop();\\n\\t\\t\\tans.add(0, current.val);\\n\\t\\t\\tif (current.left != null)\\n\\t\\t\\t\\tstack.push(current.left);\\n\\t\\t\\tif (current.right != null)\\n\\t\\t\\t\\tstack.push(current.right);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "solutionTags": [],
                "code": "The key to simply this problem is to always add number to the beginning of the list. Then postorder becomes very similar to preorder. (becomes head->right->left).\\n\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new LinkedList<Integer>();\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tDeque<TreeNode> stack = new LinkedList<TreeNode>();\\n\\n\\t\\tstack.push(root);\\n\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tTreeNode current = stack.pop();\\n\\t\\t\\tans.add(0, current.val);\\n\\t\\t\\tif (current.left != null)\\n\\t\\t\\t\\tstack.push(current.left);\\n\\t\\t\\tif (current.right != null)\\n\\t\\t\\t\\tstack.push(current.right);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 45760,
                "title": "python-o-1-and-o-n-space-solutions-morris-traversal-and-stack",
                "content": " \\nTravers the tree with right-to-left preorder traversal and just reverse the result:\\n\\n    def postorderTraversal(self, root):\\n        ans = []\\n        while root:\\n            ans.append(root.val)\\n            if root.right:\\n                dum = root.right\\n                while dum.left:\\n                    dum = dum.left\\n                dum.left = root.left\\n                root = root.right\\n            else:\\n                root = root.left\\n        return ans[::-1]\\n\\n\\n----------\\n\\nThe same idea using stack:\\n\\n    def postorderTraversal(self, root):\\n        ans, stack = [], [root]\\n        while stack:\\n            tmp = stack.pop()\\n            if tmp:\\n                ans.append(tmp.val)\\n                stack.append(tmp.left)\\n                stack.append(tmp.right)\\n        return ans[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": " \\nTravers the tree with right-to-left preorder traversal and just reverse the result:\\n\\n    def postorderTraversal(self, root):\\n        ans = []\\n        while root:\\n            ans.append(root.val)\\n            if root.right:\\n                dum = root.right\\n                while dum.left:\\n                    dum = dum.left\\n                dum.left = root.left\\n                root = root.right\\n            else:\\n                root = root.left\\n        return ans[::-1]\\n\\n\\n----------\\n\\nThe same idea using stack:\\n\\n    def postorderTraversal(self, root):\\n        ans, stack = [], [root]\\n        while stack:\\n            tmp = stack.pop()\\n            if tmp:\\n                ans.append(tmp.val)\\n                stack.append(tmp.left)\\n                stack.append(tmp.right)\\n        return ans[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3264420,
                "title": "c-solution-using-recursion-run-time-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // LRN\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // LRN\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n        ans.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202483,
                "title": "c-easy-solution-recursion-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void postorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        postorder(root->left,vct);\\n        postorder(root->right,vct);\\n        vct.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        postorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void postorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        postorder(root->left,vct);\\n        postorder(root->right,vct);\\n        vct.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        postorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053484,
                "title": "c-short-simple-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid postorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        postorder(root->left);\\n        postorder(root->right);\\n        v.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root);\\n        return v;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid postorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        postorder(root->left);\\n        postorder(root->right);\\n        v.push_back(root->val);\\n    }\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        postorder(root);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032261,
                "title": "beats-100-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void postorder(ArrayList<Integer>ans,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        postorder(ans,root.left);\\n        postorder(ans,root.right);\\n        ans.add(root.val);\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n\\n        postorder(ans,root);\\n\\n        return ans; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void postorder(ArrayList<Integer>ans,TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        postorder(ans,root.left);\\n        postorder(ans,root.right);\\n        ans.add(root.val);\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n\\n        postorder(ans,root);\\n\\n        return ans; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882770,
                "title": "java-iterative-postorder-traversal-with-detailed-thought-process",
                "content": "# Intuition\\nAt first glance, this is similar to iterative implementation of preorder and inorder traversal. \\n\\nWe use a stack to temporarily store the nodes that we\\'ve **not yet finished visiting**, and pop it off from stack when we ***fully finished*** visiting it. \\n\\nSince **postorder** traversal is defined as ***Left -> Right -> Root***,  we consider a node as being ***fully visited*** only after we finish visiting both its left and right subtree. \\n\\nInitially, when we encounter a node ```N```, we push it onto stack and start visiting its left subtree by moving as far left as possible. One important observation is that, the moment when we finish visiting ```N```\\'s left subtree, node ```N``` **must be on the stack top**. At this time, however, we\\'re not yet ready to pop it from stack since we haven\\'t visited its right subtree yet. \\nWe start visiting its right subtree. Once we\\'re done, node ```N``` **must appear on the stack top once again**. At this point, we know we\\'ve ***fully visited*** node ```N```, so we can pop it from stack and record its value in the result list. \\n\\nA problem is, when we see node ```N``` on the stack top (via ```stack.peek()```), how can we tell if this is the **first time** we see it (case 1, meaning we\\'ve just visited its left subtree, case 2), or the **second time** (case 2, meaning we\\'ve finishing visiting both its left and right subtree)? This is crucial to know, since:\\n- **Case 1**: we still need to continue visiting its right subtree, whereas\\n- **Case 2**: we can finish visiting it and pop it from stack.\\n\\nTo do so, we use a ```HashSet``` to keep track of the nodes that have been ***peeked***. Since the ```add()``` method of hashset returns false when the element we try to add is already in the set, we can exploit this fact to distinguish between case 1 and 2 when we peek a node from stack, and thus determine what to do next. \\n\\nThe illustration below may help understanding:\\n\\n```\\n     1\\n   /   \\\\\\n  2     3\\n / \\\\\\n.. ..\\n```\\n\\nImporant timestamps:\\n```\\n- t1: [1] //start visiting 1\\n- t2: [1 2] //push 2 (i.e., 1\\'s left child) onto stack\\n\\n... //move as far left as possible from 2\\n\\n- ta: [1 2 <left children of 2...>]\\n\\n... \\n\\n- tb: [1 2] //finish visiting left subtree of 2\\n            //note that 2 is on stack top\\n            //we add it to the set of peeked nodes (case 1)\\n\\n- t(b+1): [1 2 <right children of 2...>] //visiting right subtree of 2\\n\\n...\\n\\n- td: [1 2] //finish visiting right subtree of 2\\n            //note that 2 is on stack top again\\n            //we also find it in the peeked nodes set (case 2)\\n            //so we know we finished visiting it and pop it from stack\\n\\n- t(d+1): [1] \\n//continue to visit right subtree of 1...\\n...\\n```\\n\\n# Approach\\n\\n1. Create an empty stack and a empty hashset.\\n2. Keep moving down to the left (```curr = curr.left```) and push ```curr``` node onto stack, until ```curr``` becomes null.\\n3. Peek the node on the stack top (```stack.peek()```)\\n    - If the node already exists in the peeked nodes set (```peeked.add(curr)``` returns false), pop it from stack and add it to the result list. Set ```curr = null``` to avoid revisiting the right subtree)\\n    - Else, add the node to the peeked set and start visiting its right subtree ```curr = curr.right```\\n\\n4. Repeat Step 2 and 3 while ```stack``` is not empty and ```curr``` is not ```null```.\\n\\n# Complexity\\n- Time complexity: *O(n)*\\n\\n- Space complexity: *O(n)*\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n          List<Integer> res = new ArrayList<>();\\n          Stack<TreeNode> stack = new Stack<>();\\n          Set<TreeNode> peeked = new HashSet<>();\\n          TreeNode curr = root;\\n\\n          while (curr != null || !stack.isEmpty()) {\\n             //visiting the left subtree of node N\\n              while (curr != null) {\\n                  stack.push(curr);\\n                  curr = curr.left;\\n              }        \\n\\n              //at this point we\\'ve finished visiting the left subtree\\n              //of node N, and we\\'re sure N must be on the stack top \\n              //i.e., stack.peek() must return node N\\n              curr = stack.peek();\\n              \\n              //check if we\\'ve already visited the right subtree\\n              //of node N\\n              if (!peeked.add(curr)) {\\n              //right subtree of node N has already been visited, \\n              //meaning we\\'ve \"fully visited\" curr and can pop it \\n              //from stack and add its value to the result list\\n                  res.add(stack.pop().val);    \\n                  curr = null; //avoid revisiting the right subtree\\n              } else {\\n              //right subtree of N hasn\\'t been visited yet\\n              //so we start visiting it\\n                  curr = curr.right;\\n              }\\n          }\\n          return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```N```\n```N```\n```N```\n```N```\n```N```\n```N```\n```stack.peek()```\n```HashSet```\n```add()```\n```\\n     1\\n   /   \\\\\\n  2     3\\n / \\\\\\n.. ..\\n```\n```\\n- t1: [1] //start visiting 1\\n- t2: [1 2] //push 2 (i.e., 1\\'s left child) onto stack\\n\\n... //move as far left as possible from 2\\n\\n- ta: [1 2 <left children of 2...>]\\n\\n... \\n\\n- tb: [1 2] //finish visiting left subtree of 2\\n            //note that 2 is on stack top\\n            //we add it to the set of peeked nodes (case 1)\\n\\n- t(b+1): [1 2 <right children of 2...>] //visiting right subtree of 2\\n\\n...\\n\\n- td: [1 2] //finish visiting right subtree of 2\\n            //note that 2 is on stack top again\\n            //we also find it in the peeked nodes set (case 2)\\n            //so we know we finished visiting it and pop it from stack\\n\\n- t(d+1): [1] \\n//continue to visit right subtree of 1...\\n...\\n```\n```curr = curr.left```\n```curr```\n```curr```\n```stack.peek()```\n```peeked.add(curr)```\n```curr = null```\n```curr = curr.right```\n```stack```\n```curr```\n```null```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> postorderTraversal(TreeNode root) {\\n          List<Integer> res = new ArrayList<>();\\n          Stack<TreeNode> stack = new Stack<>();\\n          Set<TreeNode> peeked = new HashSet<>();\\n          TreeNode curr = root;\\n\\n          while (curr != null || !stack.isEmpty()) {\\n             //visiting the left subtree of node N\\n              while (curr != null) {\\n                  stack.push(curr);\\n                  curr = curr.left;\\n              }        \\n\\n              //at this point we\\'ve finished visiting the left subtree\\n              //of node N, and we\\'re sure N must be on the stack top \\n              //i.e., stack.peek() must return node N\\n              curr = stack.peek();\\n              \\n              //check if we\\'ve already visited the right subtree\\n              //of node N\\n              if (!peeked.add(curr)) {\\n              //right subtree of node N has already been visited, \\n              //meaning we\\'ve \"fully visited\" curr and can pop it \\n              //from stack and add its value to the result list\\n                  res.add(stack.pop().val);    \\n                  curr = null; //avoid revisiting the right subtree\\n              } else {\\n              //right subtree of N hasn\\'t been visited yet\\n              //so we start visiting it\\n                  curr = curr.right;\\n              }\\n          }\\n          return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850155,
                "title": "easy-clear-and-recursive-solution-javascript",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    postorderTraversalHelper(root, result)\\n    return result;\\n   \\n};\\n\\nconst postorderTraversalHelper = (root, result) => {\\n    if(!root) return;\\n    postorderTraversalHelper(root.left, result)\\n    postorderTraversalHelper(root.right, result)\\n    result.push(root.val)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    const result = [];\\n    postorderTraversalHelper(root, result)\\n    return result;\\n   \\n};\\n\\nconst postorderTraversalHelper = (root, result) => {\\n    if(!root) return;\\n    postorderTraversalHelper(root.left, result)\\n    postorderTraversalHelper(root.right, result)\\n    result.push(root.val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2827140,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716345,
                "title": "js-2-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/binary-tree-postorder-traversal.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    let res = []; // use res as another stack\\n    // empty tree case:\\n    if (root === null) return res;\\n    let stack = [];\\n    \\n    // postorder visit: left, right, root\\n    stack.push(root);\\n    while (stack.length !== 0) { \\n        let cur = stack.pop();\\n        // treat it as stack, store them in reverse order:\\n        // i.e root, left, right\\n        res.push(cur.val); \\n        if (cur.left) stack.push(cur.left);\\n        if (cur.right) stack.push(cur.right);\\n    }\\n    \\n    // we can pop all elements one by one, or just reverse them\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function(root) {\\n    let res = []; // use res as another stack\\n    // empty tree case:\\n    if (root === null) return res;\\n    let stack = [];\\n    \\n    // postorder visit: left, right, root\\n    stack.push(root);\\n    while (stack.length !== 0) { \\n        let cur = stack.pop();\\n        // treat it as stack, store them in reverse order:\\n        // i.e root, left, right\\n        res.push(cur.val); \\n        if (cur.left) stack.push(cur.left);\\n        if (cur.right) stack.push(cur.right);\\n    }\\n    \\n    // we can pop all elements one by one, or just reverse them\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547496,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Iterative Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(log(N))***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        // res will store the reverse postorder traversal of the tree\\n        \\n        vector<int> res;\\n        \\n        // stack will store the address of the node\\n        \\n        stack<TreeNode*> st;\\n        \\n        TreeNode* curr = root;\\n        \\n        while(!st.empty() || curr)\\n        {\\n            while(curr)\\n            {\\n                res.push_back(curr -> val);\\n                \\n                st.push(curr);\\n                \\n                curr = curr -> right;\\n            }\\n            \\n            // move the curr to the left\\n            \\n            if(!st.empty())\\n            {\\n                curr = st.top();\\n                \\n                st.pop();\\n                \\n                curr = curr -> left;\\n            }\\n        }\\n        \\n        // reverse the res array\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        \\n        // res will store the reverse postorder traversal of the tree\\n        \\n        vector<int> res;\\n        \\n        // stack will store the address of the node\\n        \\n        stack<TreeNode*> st;\\n        \\n        TreeNode* curr = root;\\n        \\n        while(!st.empty() || curr)\\n        {\\n            while(curr)\\n            {\\n                res.push_back(curr -> val);\\n                \\n                st.push(curr);\\n                \\n                curr = curr -> right;\\n            }\\n            \\n            // move the curr to the left\\n            \\n            if(!st.empty())\\n            {\\n                curr = st.top();\\n                \\n                st.pop();\\n                \\n                curr = curr -> left;\\n            }\\n        }\\n        \\n        // reverse the res array\\n        \\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447514,
                "title": "3-different-approaches-c-solution-recursion-two-stacks-single-stack",
                "content": "**1. Recursive approach:**\\n\\n```\\nvoid postorder(TreeNode* root, vector<int> &result){\\n\\tif(root == NULL)\\n\\t\\treturn;\\n\\telse{\\n\\t\\tpostorder(root->left,result);\\n\\t\\tpostorder(root->right,result);\\n\\t\\tresult.push_back(root->val);\\n\\t}\\n}\\nvector<int> postorderTraversal(TreeNode* root) {\\n\\tvector<int> result;\\n\\tpostorder(root, result);\\n\\treturn result;\\n}\\n```\\n\\n**2. Iterative approach (Using 2 stacks):**\\n\\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st1, st2;\\n\\tst1.push(root);\\n\\tTreeNode* node;\\n\\twhile(!st1.empty()){\\n\\t\\tnode = st1.top();\\n\\t\\tst1.pop();\\n\\t\\tst2.push(node);\\n\\t\\tif(node->left != NULL)\\n\\t\\t\\tst1.push(node->left);\\n\\t\\tif(node->right != NULL)\\n\\t\\t\\tst1.push(node->right);\\n\\t}\\n\\twhile(!st2.empty()){\\n\\t\\tnode = st2.top();\\n\\t\\tres.push_back(node->val);\\n\\t\\tst2.pop();\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**3. Iterative approach (Using 1 stack):**\\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st;\\n\\tst.push(root);\\n\\twhile(!st.empty()){\\n\\t\\tTreeNode* temp = st.top();\\n\\t\\tres.push_back(temp->val);\\n\\t\\tst.pop();\\n\\t\\tif(temp->left)\\n\\t\\t\\tst.push(temp->left);\\n\\t\\tif(temp->right)\\n\\t\\t\\tst.push(temp->right);\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n```\\n<br></br>\\n**Please upvote if helpful.**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid postorder(TreeNode* root, vector<int> &result){\\n\\tif(root == NULL)\\n\\t\\treturn;\\n\\telse{\\n\\t\\tpostorder(root->left,result);\\n\\t\\tpostorder(root->right,result);\\n\\t\\tresult.push_back(root->val);\\n\\t}\\n}\\nvector<int> postorderTraversal(TreeNode* root) {\\n\\tvector<int> result;\\n\\tpostorder(root, result);\\n\\treturn result;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st1, st2;\\n\\tst1.push(root);\\n\\tTreeNode* node;\\n\\twhile(!st1.empty()){\\n\\t\\tnode = st1.top();\\n\\t\\tst1.pop();\\n\\t\\tst2.push(node);\\n\\t\\tif(node->left != NULL)\\n\\t\\t\\tst1.push(node->left);\\n\\t\\tif(node->right != NULL)\\n\\t\\t\\tst1.push(node->right);\\n\\t}\\n\\twhile(!st2.empty()){\\n\\t\\tnode = st2.top();\\n\\t\\tres.push_back(node->val);\\n\\t\\tst2.pop();\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root){\\n\\tvector<int> res;\\n\\tif(root == NULL)\\n\\t\\treturn res;\\n\\tstack<TreeNode*> st;\\n\\tst.push(root);\\n\\twhile(!st.empty()){\\n\\t\\tTreeNode* temp = st.top();\\n\\t\\tres.push_back(temp->val);\\n\\t\\tst.pop();\\n\\t\\tif(temp->left)\\n\\t\\t\\tst.push(temp->left);\\n\\t\\tif(temp->right)\\n\\t\\t\\tst.push(temp->right);\\n\\t}\\n\\treverse(res.begin(), res.end());\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050084,
                "title": "python-100-easy-solution",
                "content": "\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            self.dfs(node.right, res)\\n            res.append(node.val)\\n\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            self.dfs(node.right, res)\\n            res.append(node.val)\\n\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2026593,
                "title": "java-iterative",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new LinkedList();\\n        Stack<TreeNode> stack = new Stack();\\n        \\n        TreeNode current = root;\\n        \\n        if (current != null) {\\n            stack.push(current);\\n        }\\n        \\n        while(!stack.isEmpty()) {\\n            current = stack.pop();\\n            result.add(0, current.val);\\n            \\n            if (current.left != null) stack.push(current.left);\\n            if (current.right != null) stack.push(current.right);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new LinkedList();\\n        Stack<TreeNode> stack = new Stack();\\n        \\n        TreeNode current = root;\\n        \\n        if (current != null) {\\n            stack.push(current);\\n        }\\n        \\n        while(!stack.isEmpty()) {\\n            current = stack.pop();\\n            result.add(0, current.val);\\n            \\n            if (current.left != null) stack.push(current.left);\\n            if (current.right != null) stack.push(current.right);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955798,
                "title": "java-recursive-dfs-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        postorder(root, result);\\n        return result;\\n    }\\n    \\n    public void postorder(TreeNode root, List<Integer> result){\\n        if(root == null){\\n            return;\\n        }\\n        postorder(root.left, result);\\n        postorder(root.right, result);\\n        result.add(root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        postorder(root, result);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1848791,
                "title": "iterative-w-thinking-process-easy-understanding",
                "content": "**Thinking Process:**\\nWe have done #144 preOrderTraversal.\\nIt gave us hint that if mid is the first one, the problem is easy to deal with.\\nPostOrder print left right middle, therefore we reverse the output order => mid right left\\nIn the end, we reverse the vector and get the right answer!\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<int> postorderTraversal(TreeNode *root) {\\n    vector<int> res;\\n    stack<TreeNode *> todo;\\n    if (root)\\n      todo.push(root);\\n    // l r m -> reverse m r l\\n    while (todo.size()) {\\n      root = todo.top();\\n      todo.pop();\\n      res.push_back(root->val);\\n      if (root->left)\\n        todo.push(root->left);\\n      if (root->right)\\n        todo.push(root->right);\\n    }\\n    return reverse(res.begin(), res.end());\\n  }\\n};\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 8.2 MB, less than 98.57% of C++ online submissions for Binary Tree Postorder Traversal.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  vector<int> postorderTraversal(TreeNode *root) {\\n    vector<int> res;\\n    stack<TreeNode *> todo;\\n    if (root)\\n      todo.push(root);\\n    // l r m -> reverse m r l\\n    while (todo.size()) {\\n      root = todo.top();\\n      todo.pop();\\n      res.push_back(root->val);\\n      if (root->left)\\n        todo.push(root->left);\\n      if (root->right)\\n        todo.push(root->right);\\n    }\\n    return reverse(res.begin(), res.end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629702,
                "title": "iterative-postorder-traversal-using-stack-c-in-o-n-and-efficient",
                "content": "## Postorder Iterative\\nPostorder traversal is first left then right then parent i.e. **L R P**\\nL --> Left\\nR --> Right\\nP --> Parent\\n* We have to get **L R P** but we can get **P R L** easily then we can reverse the **ans vector** we will get **L R P**.\\n* In **stack** push first **root** then run **while loop** till **stack** is **not empty**. Inside while every iteration take top of stack node i.e. **curr = stk.top()** and then **pop** stack.\\n* First **push_back** value of **curr** in **ans** vector then **push left** in stack after that **push right** in stack if left and right are **not NULL**.\\n* *Why are we pushing left then right ?* Ans: Because when we **pop** from **stack** it will give **right** then **left** and our desire is **P R L** only. If we push **L** then **R** stack will give reverse **R** then **L**.\\n\\n```\\n\\tvector<int> postorderTraversal(TreeNode* root) {\\n\\t\\tvector<int> ans;\\n\\t\\tif(root==NULL)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tTreeNode* curr;\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tst.push(root);\\n\\t\\twhile(!st.empty()){\\n\\t\\t\\tcurr = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tans.push_back(curr->val); // Take ans\\n\\t\\t\\tif(curr->left)  // Push left first\\n\\t\\t\\t\\tst.push(curr->left);\\n\\t\\t\\tif(curr->right)  // Push right first\\n\\t\\t\\t\\tst.push(curr->right);\\n\\t\\t}\\n\\t\\treverse(ans.begin(),ans.end()); // reverse ans to get L R P\\n\\t\\treturn ans;\\n\\t}\\n```\\n\\n## Preorder Iterative\\n* Preorder is **P L R**.\\n* For this we first take ans of curr then we can push right (**R**) in stack then push left (**L**) in **stack** that makes pop in reverse order that is **L** then **R**.\\n* Here no need to reverse ans because our desire goal is **P L R** only.\\n\\nDo it by yourself.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\tvector<int> postorderTraversal(TreeNode* root) {\\n\\t\\tvector<int> ans;\\n\\t\\tif(root==NULL)\\n\\t\\t\\treturn ans;\\n\\n\\t\\tTreeNode* curr;\\n\\t\\tstack<TreeNode*> st;\\n\\t\\tst.push(root);\\n\\t\\twhile(!st.empty()){\\n\\t\\t\\tcurr = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tans.push_back(curr->val); // Take ans\\n\\t\\t\\tif(curr->left)  // Push left first\\n\\t\\t\\t\\tst.push(curr->left);\\n\\t\\t\\tif(curr->right)  // Push right first\\n\\t\\t\\t\\tst.push(curr->right);\\n\\t\\t}\\n\\t\\treverse(ans.begin(),ans.end()); // reverse ans to get L R P\\n\\t\\treturn ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576853,
                "title": "java-morris-iterator-o-n-time-o-1-space",
                "content": "Actrually, the post order traversal is very similar to the preorder traversal. We can modify the morris iterator of the preorder, use head insertion to build the path.\\n```\\npublic List<Integer> postTraversal(TreeNode root) {\\n  LinkedList<Integer> re = new LinkedList<>();\\n  if(root == null) return re;\\n  \\n  TreeNode cur = root;\\n  while(cur != null) {\\n    if(cur.right != null) {\\n      TreeNode p = cur.right;\\n      while(p.left != null) p = p.left;\\n      p.left = cur.left;\\n      cur.left = cur.right;\\n      cur.right = null;\\n    }\\n    else {\\n      re.addFirst(cur.val);\\n      cur = cur.left;\\n    }\\n  }\\n  \\n  return re;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postTraversal(TreeNode root) {\\n  LinkedList<Integer> re = new LinkedList<>();\\n  if(root == null) return re;\\n  \\n  TreeNode cur = root;\\n  while(cur != null) {\\n    if(cur.right != null) {\\n      TreeNode p = cur.right;\\n      while(p.left != null) p = p.left;\\n      p.left = cur.left;\\n      cur.left = cur.right;\\n      cur.right = null;\\n    }\\n    else {\\n      re.addFirst(cur.val);\\n      cur = cur.left;\\n    }\\n  }\\n  \\n  return re;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566245,
                "title": "3-approach-c-easy-solution-recursive-100-faster-iterative",
                "content": "**Two Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st1;\\n        stack<TreeNode*> st2;\\n        \\n        st1.push(root);\\n        while(!st1.empty()){\\n            TreeNode* node=st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left)st1.push(node->left);\\n            if(node->right)st1.push(node->right);\\n        }\\n        while(!st2.empty()){\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n       return v;\\n    }\\n};\\n```\\n\\n**One Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st;\\n        TreeNode* node=root;\\n        while(node || !st.empty()){\\n            while(node){\\n                st.push(node);\\n                node=node->left;\\n            }\\n            auto t=st.top()->right;\\n            if(t)node=t;\\n            else{\\n                auto t=st.top();\\n                st.pop();\\n                v.push_back(t->val);\\n                while(!st.empty() and t==st.top()->right){\\n                    t=st.top();\\n                    st.pop();\\n                    v.push_back(t->val);\\n                }\\n            }\\n        }\\n       return v;\\n    }\\n};\\n```\\n\\n\\n\\n**Recursive** \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==NULL)return v;\\n        \\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st1;\\n        stack<TreeNode*> st2;\\n        \\n        st1.push(root);\\n        while(!st1.empty()){\\n            TreeNode* node=st1.top();\\n            st1.pop();\\n            st2.push(node);\\n            if(node->left)st1.push(node->left);\\n            if(node->right)st1.push(node->right);\\n        }\\n        while(!st2.empty()){\\n            v.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n       return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n          vector<int> v;\\n        if(!root)return v;\\n        stack<TreeNode*> st;\\n        TreeNode* node=root;\\n        while(node || !st.empty()){\\n            while(node){\\n                st.push(node);\\n                node=node->left;\\n            }\\n            auto t=st.top()->right;\\n            if(t)node=t;\\n            else{\\n                auto t=st.top();\\n                st.pop();\\n                v.push_back(t->val);\\n                while(!st.empty() and t==st.top()->right){\\n                    t=st.top();\\n                    st.pop();\\n                    v.push_back(t->val);\\n                }\\n            }\\n        }\\n       return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(root==NULL)return v;\\n        \\n        postorderTraversal(root->left);\\n        postorderTraversal(root->right);\\n        v.push_back(root->val);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517885,
                "title": "preorder-postorder-inorder-iterative-with-few-lines-changed-easy-to-remember",
                "content": "**Pre Order**\\n\\n```\\nvector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n\\t\\t\\t// Order - Root Left Right\\n\\t\\t\\t// i.e Push current root and go the its  left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            root = root->right;\\n        }\\n        return ans;\\n}\\n```\\n\\n**Post Order**\\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n            // Through this while loop the order we will get -> Root Right Left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->right; // In preorder we go to left of root, but here we go to the right\\n            }\\n            root = s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n\\t\\t// Current order in vector -> Root Right Left\\n        // Reverse the vector, so the order becomes -> Left Right Root\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n}\\n```\\n\\n**In Order**\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root||!s.empty()){\\n            while(root){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n\\t\\t\\t// We are pushing the value not in the above while loop because Left comes first then Root will come\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> preorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n\\t\\t\\t// Order - Root Left Right\\n\\t\\t\\t// i.e Push current root and go the its  left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            root = root->right;\\n        }\\n        return ans;\\n}\\n```\n```\\nvector<int> postorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root || !s.empty()){\\n            // Through this while loop the order we will get -> Root Right Left\\n            while(root){\\n                ans.push_back(root->val);\\n                s.push(root);\\n                root=root->right; // In preorder we go to left of root, but here we go to the right\\n            }\\n            root = s.top();\\n            s.pop();\\n            root=root->left;\\n        }\\n\\t\\t// Current order in vector -> Root Right Left\\n        // Reverse the vector, so the order becomes -> Left Right Root\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n}\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        vector<int> ans;\\n        while(root||!s.empty()){\\n            while(root){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n\\t\\t\\t// We are pushing the value not in the above while loop because Left comes first then Root will come\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401746,
                "title": "easy-fast-python-recursive-solution-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335737,
                "title": "java-postorder-traversal-using-stack-iterative-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root!=null) stack.push(root);\\n        while(!stack.isEmpty())\\n        {\\n             TreeNode temp = stack.peek();\\n             if(temp.left!=null){\\n                     TreeNode temp1 = temp.left;\\n                    \\n                     stack.push(temp1); \\n                      temp.left=null;\\n             }else if(temp.right!=null){\\n                     TreeNode temp2 = temp.right;\\n                    \\n                     stack.push(temp2); \\n                      temp.right=null;\\n             }\\n                else{\\n                       stack.pop();\\n                        ans.add(temp.val);\\n                }\\n                \\n        }\\n            return ans; \\n        }\\n           \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root!=null) stack.push(root);\\n        while(!stack.isEmpty())\\n        {\\n             TreeNode temp = stack.peek();\\n             if(temp.left!=null){\\n                     TreeNode temp1 = temp.left;\\n                    \\n                     stack.push(temp1); \\n                      temp.left=null;\\n             }else if(temp.right!=null){\\n                     TreeNode temp2 = temp.right;\\n                    \\n                     stack.push(temp2); \\n                      temp.right=null;\\n             }\\n                else{\\n                       stack.pop();\\n                        ans.add(temp.val);\\n                }\\n                \\n        }\\n            return ans; \\n        }\\n           \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305124,
                "title": "simple-cpp-iterative-solution",
                "content": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n       vector<int> v;\\n        if(!root)\\n            return v;\\n        stack<TreeNode*> s;\\n        \\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            v.push_back(root->val);\\n            if(root->left)\\n                s.push(root->left);\\n            if(root->right)\\n                s.push(root->right);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> postorderTraversal(TreeNode* root) {\\n       vector<int> v;\\n        if(!root)\\n            return v;\\n        stack<TreeNode*> s;\\n        \\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            v.push_back(root->val);\\n            if(root->left)\\n                s.push(root->left);\\n            if(root->right)\\n                s.push(root->right);\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270415,
                "title": "c-iterative-solution-faster-than-100-0",
                "content": "class Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* curr=NULL;\\n        vector<int>v;\\n       if(!root)\\n           return v;\\n        curr=root;\\n        stack<TreeNode*>s;\\n       \\n        while(1){\\n            if(curr){\\n                 s.push(curr);\\n                 curr=curr->left;\\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                else{\\n                    if(s.top()->right==NULL){\\n                        curr = s.top();\\n                        s.pop();\\n                        v.push_back(curr->val);\\n                    while(s.size()>0 && s.top()->right==curr){\\n                      curr=s.top();\\n                      v.push_back(curr->val);\\n                      s.pop();\\n                     }\\n                    }\\n                    if(!s.empty()){\\n                    curr=s.top()->right;\\n                    }\\n                    else\\n                    curr=NULL;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        TreeNode* curr=NULL;\\n        vector<int>v;\\n       if(!root)\\n           return v;\\n        curr=root;\\n        stack<TreeNode*>s;\\n       \\n        while(1){\\n            if(curr){\\n                 s.push(curr);\\n                 curr=curr->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1267947,
                "title": "iterative-recursive-solution-in-java",
                "content": "Recursive Solution\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 37 MB, less than 79.83% of Java online submissions for Binary Tree Postorder Traversal.**\\n```\\nclass Solution {\\n    private List<Integer> arr = new ArrayList();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        postOrder(root);\\n        return arr;\\n    }\\n    public void postOrder(TreeNode root){\\n        if(root!=null){\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            arr.add(root.val);\\n        }\\n    }\\n}\\n```\\nIterative Solution\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 37.1 MB, less than 67.17% of Java online submissions for Binary Tree Postorder Traversal.**\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {        \\n        Stack<TreeNode> stk1 = new Stack();\\n        Stack<TreeNode> stk2 = new Stack();\\n        ArrayList<Integer> result = new ArrayList();\\n        \\n        if(root == null) return result;\\n\\n        stk1.push(root);\\n        TreeNode temp = root;\\n        \\n        while(!stk1.isEmpty()){\\n            temp = stk1.pop();\\n            if(temp.left != null)stk1.push(temp.left);\\n            if(temp.right != null)stk1.push(temp.right);\\n            stk2.push(temp);\\n        }\\n        \\n        while(!stk2.isEmpty()){\\n            result.add(stk2.pop().val);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private List<Integer> arr = new ArrayList();\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        postOrder(root);\\n        return arr;\\n    }\\n    public void postOrder(TreeNode root){\\n        if(root!=null){\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            arr.add(root.val);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {        \\n        Stack<TreeNode> stk1 = new Stack();\\n        Stack<TreeNode> stk2 = new Stack();\\n        ArrayList<Integer> result = new ArrayList();\\n        \\n        if(root == null) return result;\\n\\n        stk1.push(root);\\n        TreeNode temp = root;\\n        \\n        while(!stk1.isEmpty()){\\n            temp = stk1.pop();\\n            if(temp.left != null)stk1.push(temp.left);\\n            if(temp.right != null)stk1.push(temp.right);\\n            stk2.push(temp);\\n        }\\n        \\n        while(!stk2.isEmpty()){\\n            result.add(stk2.pop().val);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971392,
                "title": "iterative-5-line-python-3-8-solution-w-stack",
                "content": "* Leading `None` in `stack` prevents `IndexError` throwed by `.pop()` on empty list\\n* Generator expression in `extend` filters out `None` (could be made using `filter` but GE looks cleaner)\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\tstack, result = [None, root], []\\n\\n\\twhile cur := stack.pop():\\n\\t\\tresult.append(cur.val)\\n\\t\\tstack.extend(x for x in (cur.left, cur.right) if x)\\n\\n\\treturn result[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\tstack, result = [None, root], []\\n\\n\\twhile cur := stack.pop():\\n\\t\\tresult.append(cur.val)\\n\\t\\tstack.extend(x for x in (cur.left, cur.right) if x)\\n\\n\\treturn result[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961894,
                "title": "extremely-simple-post-morris-traversal-pre-in-post-order-summary",
                "content": "There are a lot of introductions about how Morris Traversal works. It is a beautiful algorithm which takes only O(1) space complexity while still maintaining O(n) time complexity. Here I summarized how Morris Traversal is implemented w.r.t. all three orders. \\n\\n**Pre-Order:**\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**In-Order**: \\n\\nCompared to Pre-Order implementation, the change is just one line as maked \"***\"\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**Post-Order:**\\n\\nI saw many implementations for the Post-Order to be very complex and hard to remember. Here I provide a simple version. It is very similar to the pre-order one, except that now we are doing everything reversely. By this I mean we go along the direction of right child and link the leftmost child on the right sub tree to the root. Then we leftappend the val to the result. \\n\\nTHAT`S IT!!\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```\\n\\nHope you like it. Cheers.",
                "solutionTags": [],
                "code": "```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 912195,
                "title": "java-100-fast-iterative-and-recursive",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n**Iterative Solution**\\n```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res= new ArrayList<>();\\n        if(root==null) return res;\\n        Stack<TreeNode> st= new Stack<>();\\n        \\n        st.push(root);\\n        while(!st.isEmpty()){\\n            TreeNode curr= st.pop();\\n        //Take a node and put it in the front of the array\\n            res.add(0,curr.val);\\n            if(curr.left!=null)\\n                st.push(curr.left);\\n            if(curr.right!=null)\\n                st.push(curr.right);\\n        }\\n        return res;\\n    }\\n```\\n\\t\\n\\t\\n**Recursive Solution**\\n```\\n\\tprivate void postorder(TreeNode root, List<Integer> result) {\\n\\t\\tif(root== null)\\n\\t\\t\\treturn;\\n\\n\\t\\t//First traverse left, then right\\n\\t\\tpostorder(root.left, result);\\n\\t\\tpostorder(root.right, result);\\n\\t\\t//Add the root value\\n\\t\\tresult.add(root.val);\\n\\t\\t\\n\\t}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> res= new ArrayList<>();\\n        if(root==null) return res;\\n        Stack<TreeNode> st= new Stack<>();\\n        \\n        st.push(root);\\n        while(!st.isEmpty()){\\n            TreeNode curr= st.pop();\\n        //Take a node and put it in the front of the array\\n            res.add(0,curr.val);\\n            if(curr.left!=null)\\n                st.push(curr.left);\\n            if(curr.right!=null)\\n                st.push(curr.right);\\n        }\\n        return res;\\n    }\\n```\n```\\n\\tprivate void postorder(TreeNode root, List<Integer> result) {\\n\\t\\tif(root== null)\\n\\t\\t\\treturn;\\n\\n\\t\\t//First traverse left, then right\\n\\t\\tpostorder(root.left, result);\\n\\t\\tpostorder(root.right, result);\\n\\t\\t//Add the root value\\n\\t\\tresult.add(root.val);\\n\\t\\t\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 886844,
                "title": "python-16ms-classic-implementation",
                "content": "Runtime: 16 ms, faster than 99.67% of Python3 online submissions for Binary Tree Postorder Traversal.\\nMemory Usage: 14.1 MB, less than 99.98% of Python3 online submissions for Binary Tree Postorder Traversal.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def postorder(root):\\n            if root is None:\\n                return\\n            postorder(root.left)\\n            postorder(root.right)\\n            self.ans.append(root.val)\\n        postorder(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def postorder(root):\\n            if root is None:\\n                return\\n            postorder(root.left)\\n            postorder(root.right)\\n            self.ans.append(root.val)\\n        postorder(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853214,
                "title": "simple-golang-iterative-solution",
                "content": "```\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tvar res []int\\n\\tif root == nil {\\n\\t\\treturn res\\n\\t}\\n\\n\\tstack := list.New()\\n\\tstack.PushFront(root)\\n\\tfor stack.Len() > 0 {\\n\\t\\te := stack.Front()\\n\\t\\tstack.Remove(e)\\n\\t\\tnode := e.Value.(*TreeNode)\\n\\t\\tres = append([]int{node.Val}, res...)\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tstack.PushFront(node.Left)\\n\\t\\t}\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tstack.PushFront(node.Right)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc postorderTraversal(root *TreeNode) []int {\\n\\tvar res []int\\n\\tif root == nil {\\n\\t\\treturn res\\n\\t}\\n\\n\\tstack := list.New()\\n\\tstack.PushFront(root)\\n\\tfor stack.Len() > 0 {\\n\\t\\te := stack.Front()\\n\\t\\tstack.Remove(e)\\n\\t\\tnode := e.Value.(*TreeNode)\\n\\t\\tres = append([]int{node.Val}, res...)\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tstack.PushFront(node.Left)\\n\\t\\t}\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tstack.PushFront(node.Right)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801658,
                "title": "c-using-two-stacks",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(!root)return vector<int>{};\\n        stack<TreeNode*> s1,s2;\\n        s1.push(root);\\n        while(s1.size()!=0){\\n            TreeNode* t=s1.top();s1.pop();\\n            s2.push(t);\\n            if(t->left)s1.push(t->left);\\n            if(t->right)s1.push(t->right);\\n        }\\n        vector<int> ans;\\n        while(s2.size()!=0){\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        if(!root)return vector<int>{};\\n        stack<TreeNode*> s1,s2;\\n        s1.push(root);\\n        while(s1.size()!=0){\\n            TreeNode* t=s1.top();s1.pop();\\n            s2.push(t);\\n            if(t->left)s1.push(t->left);\\n            if(t->right)s1.push(t->right);\\n        }\\n        vector<int> ans;\\n        while(s2.size()!=0){\\n            ans.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717360,
                "title": "an-easy-to-understand-method-by-recording-the-counter-of-how-many-times-we-saw-current-node",
                "content": "The intuition is that when we first meet one node, we need to push it into the stack(meanwhile we create a counter initialized at zero) , and the second time is when we get back from the left subtree, we increase the counter. When we encounter it the third, we got to traverse this node. \\nSo each time we encounter one node, we can check the counter, if it is 0, we go to the right subtree. Or if it is 1, this is the time that we need to visit current node. \\n```\\nclass Solution {\\n    class TreeNodeWithCount {\\n        public final TreeNode node;\\n        public int count;\\n        public TreeNodeWithCount(TreeNode p) {\\n            node = p;\\n            count = 0;\\n        }\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode p = root;\\n        Deque<TreeNodeWithCount> stack = new ArrayDeque<>();\\n        List<Integer> ans = new ArrayList<>();\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(new TreeNodeWithCount(p));\\n                p = p.left;\\n            } else {\\n                if (stack.peek().count == 1) {\\n                    p = stack.pop().node;\\n                    ans.add(p.val);\\n                    p = null;\\n                } else if (stack.peek().count == 0) {\\n                    stack.peek().count++;\\n                    p = stack.peek().node.right;\\n                } \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeNodeWithCount {\\n        public final TreeNode node;\\n        public int count;\\n        public TreeNodeWithCount(TreeNode p) {\\n            node = p;\\n            count = 0;\\n        }\\n    }\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        TreeNode p = root;\\n        Deque<TreeNodeWithCount> stack = new ArrayDeque<>();\\n        List<Integer> ans = new ArrayList<>();\\n        while (!stack.isEmpty() || p != null) {\\n            if (p != null) {\\n                stack.push(new TreeNodeWithCount(p));\\n                p = p.left;\\n            } else {\\n                if (stack.peek().count == 1) {\\n                    p = stack.pop().node;\\n                    ans.add(p.val);\\n                    p = null;\\n                } else if (stack.peek().count == 0) {\\n                    stack.peek().count++;\\n                    p = stack.peek().node.right;\\n                } \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713506,
                "title": "python-3-two-liner-fast-and-simple",
                "content": "```\\n        if not root: return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n        if not root: return []\\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662042,
                "title": "python-91-4-speed-with-two-stacks",
                "content": "```\\n  def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root] if root else None\\n        res = []\\n        \\n        while stack:\\n\\t\\t\\t# pop top of first stack and push it to the second\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            \\n\\t\\t\\t# traverse\\n            if curr.left:\\n                stack.append(curr.left)\\n                \\n            if curr.right:\\n                stack.append(curr.right)\\n\\t\\t\\t\\t\\n        # reversed second stack gives us our answer        \\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n  def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = [root] if root else None\\n        res = []\\n        \\n        while stack:\\n\\t\\t\\t# pop top of first stack and push it to the second\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            \\n\\t\\t\\t# traverse\\n            if curr.left:\\n                stack.append(curr.left)\\n                \\n            if curr.right:\\n                stack.append(curr.right)\\n\\t\\t\\t\\t\\n        # reversed second stack gives us our answer        \\n        return res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490751,
                "title": "python-easy-iterative-stack-solution-can-be-generalized-to-inorder-preorder-postorder",
                "content": "InOrder\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        inorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    inorder.append(node.val)\\n                else:\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return inorder\\n```\\n\\nPreOrder\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        preorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if not node:\\n                continue\\n            if visited:\\n                preorder.append(node.val)\\n            else:\\n                stack.append((node.right, False))\\n                stack.append((node.left, False))\\n                stack.append((node, True))\\n        return preorder\\n```\\n\\nPostOrder\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        postorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    postorder.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return postorder\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        inorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    inorder.append(node.val)\\n                else:\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return inorder\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        preorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if not node:\\n                continue\\n            if visited:\\n                preorder.append(node.val)\\n            else:\\n                stack.append((node.right, False))\\n                stack.append((node.left, False))\\n                stack.append((node, True))\\n        return preorder\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        postorder, stack = [], [(root, False)]\\n        while stack:\\n            (node, visited) = stack.pop()\\n            if node:\\n                if visited:\\n                    postorder.append(node.val)\\n                else:\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return postorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327919,
                "title": "swift-o-n-speed-o-n-memory-non-recursive-in-place-solution-koderz-kamp-memorize",
                "content": "```\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        \\n        var stack = [TreeNode]()\\n        var node = root\\n        var result = [Int]()\\n        \\n        while node != nil || stack.count > 0 {\\n            if node === nil {\\n                node = stack.removeLast().left\\n            } else {   \\n                result.append(node!.val)\\n                stack.append(node!)\\n                node = node!.right\\n            }\\n        }\\n        \\n        result.reverse()\\n        return result\\n    }\\n}\\n```\\n\\nMemorize this algorithm. That\\'s it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\\n        \\n        var stack = [TreeNode]()\\n        var node = root\\n        var result = [Int]()\\n        \\n        while node != nil || stack.count > 0 {\\n            if node === nil {\\n                node = stack.removeLast().left\\n            } else {   \\n                result.append(node!.val)\\n                stack.append(node!)\\n                node = node!.right\\n            }\\n        }\\n        \\n        result.reverse()\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290375,
                "title": "c-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> PostorderTraversal(TreeNode root) {\\n        var result = new List<int>();\\n\\n        if (root == null) return result;\\n\\n        var stack = new Stack<TreeNode>();\\n        stack.Push(root);\\n\\n        while (stack.Any()) {\\n            var cur = stack.Pop();\\n            result.Add(cur.val);\\n\\n            if (cur.left != null) {\\n                stack.Push(cur.left);\\n            }\\n\\n            if (cur.right != null) {\\n                stack.Push(cur.right);\\n            }\\n        }\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> PostorderTraversal(TreeNode root) {\\n        var result = new List<int>();\\n\\n        if (root == null) return result;\\n\\n        var stack = new Stack<TreeNode>();\\n        stack.Push(root);\\n\\n        while (stack.Any()) {\\n            var cur = stack.Pop();\\n            result.Add(cur.val);\\n\\n            if (cur.left != null) {\\n                stack.Push(cur.left);\\n            }\\n\\n            if (cur.right != null) {\\n                stack.Push(cur.right);\\n            }\\n        }\\n\\n        result.Reverse();\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568691,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568044,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1565965,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1569268,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568036,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1573165,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568968,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1749801,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1575279,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572894,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568691,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568044,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1565965,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1569268,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568036,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1573165,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1568968,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1749801,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1575279,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572894,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bc0a62ba-0fa2-4933-9418-b8216cc6a923_1640080567.957755.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3a408b7-42c2-4ae7-bfd4-19807eff66fd_1640080570.5411482.png)\\n\\n![image](https://assets.leetcode.com/users/images/71f9ac42-b609-4b38-b54a-adba69bfb34c_1640080581.2918482.png)\\n\\nmorris traversal\\n\\n![image](https://assets.leetcode.com/users/images/4799e810-afdc-484f-a658-4a4ce219e39b_1640080593.179912.png)\\n"
                    },
                    {
                        "username": "Azuer",
                        "content": "Why the level of preorder traversal and inorder traversal are medium but postorder is hard???"
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "Now it shows all three easy lol"
                    },
                    {
                        "username": "Msey",
                        "content": "I wish I could go back in time to 2018 and get an interview with such \"hard questions\" lol"
                    },
                    {
                        "username": "qiushile",
                        "content": "the level had changed"
                    },
                    {
                        "username": "himanshu_d2611",
                        "content": "maybe cuz it comes late haha"
                    },
                    {
                        "username": "jc-denton",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "wilmol",
                        "content": "Hi just curious why this one is hard, while n-ary is easy?\\nAlso same issue with preorder question :)."
                    },
                    {
                        "username": "raees_aamir",
                        "content": "Why is this classed as hard?\\n\\nThere are easy questions that are harder than this one."
                    },
                    {
                        "username": "MiKueen",
                        "content": "While many other hard problems on Leetcode are tagged as easy-medium level, I don\\'t understand why this problem is hard. \\nDoes any one else think this problem should be of medium level?"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is easy for recursion. Easy to Medium for iterative solutions "
                    },
                    {
                        "username": "paul7",
                        "content": "That would be cool to have a problem to implement an iterator over a binary tree in post order.\\nChallenge is to do only required work on each `getNext()` call - because traversing the whole tree and playing with the result set is not very useful in practice.\\n\\nAnyone got a solution?"
                    },
                    {
                        "username": "johnazedo",
                        "content": "Where is the official solution by leetcode?"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(145)Binary%20Tree%20Postorder%20Traversal"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "Why this question is hard and Binary Tree Preorder Traversal is medium? Implementation wise they are kind of same. Right ? I think this should be also medium."
                    }
                ]
            },
            {
                "id": 1572373,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1572034,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1571311,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1575997,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1567214,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 2040516,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1962979,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1958174,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1801932,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            },
            {
                "id": 1762364,
                "content": [
                    {
                        "username": "wen_han",
                        "content": "Almost all solutions with high votes use `addFisrt()` trick. Is it acceptable in interviews? These solutions are NOT visiting the tree in post-order."
                    },
                    {
                        "username": "yliang12",
                        "content": "really easy problem difficulty should be easy not hard!!!"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here is the link for my detail explanation:\\n->Recursive\\n->Iterative\\n->Morris\\n[LeetCode Solution 145](https://techgeekyan.blogspot.ca/2017/08/leetcode-145-binary-tree-postorder.html)"
                    },
                    {
                        "username": "Foras",
                        "content": "The thought about iterative and very interesting."
                    },
                    {
                        "username": "jackcaptain",
                        "content": "Author could make some mistake to put the tag here. \\xabHard\\xbb tag may be wrong here"
                    },
                    {
                        "username": "makakamax",
                        "content": "Examples...\\nAs always, uninformative"
                    },
                    {
                        "username": "user7105D",
                        "content": "\\nBy using Stacks:\\nvector<int> postorderTraversal(TreeNode* root) {\\n         if(root==NULL){\\n            return {};\\n        }\\n        stack<TreeNode*> S1;\\n        stack<int> S2;\\n        TreeNode* temp=root;\\n        S1.push(root);\\n        while (!S1.empty()) {\\n            temp=S1.top();\\n            S1.pop();\\n            S2.push(temp->val);\\n            if(temp->left){\\n                S1.push(temp->left);\\n            }\\n            if(temp->right){\\n                S1.push(temp->right);\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        while(!S2.empty()){\\n            ans.push_back(S2.top());\\n            S2.pop();\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Ashutosh_Sharma_123",
                        "content": "Can someone explain what is the problem in this solution. I am getting TLE error.\\n\\n\\npublic List<Integer> postorderTraversal(TreeNode root) {\\n \\n        ArrayList<Integer> ans = new ArrayList<>();\\n        if(root == null){\\n            return ans;\\n        }\\n        Stack<TreeNode> st = new Stack<TreeNode>();\\n        st.push(root);\\n\\n        while(!st.isEmpty()){\\n            TreeNode curr = st.peek();\\n            if(curr.left==null && curr.right==null){\\n                ans.add(curr.val);\\n                st.pop();\\n                curr = null;\\n            }\\n            else if(curr.left!=null){\\n                st.push(curr.left);\\n            }\\n            else{\\n                st.push(curr.right);\\n            }\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "code-vel",
                        "content": "Hi [@Ashutosh Sharma](/Ashutosh_Sharma_123), Your code never terminates from while loop that's the reason you are getting TLE.\n\nLet's take an example. you have a tree like\n 1 (root), 2(left), 3 (right)\n\nRead all the Steps to understand the mistake:\n1. As per your code you are pushing ROOT (which is 1) into STACK \n2. Try to iterate the STACK if its NOT EMPTY\n3. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n4. now checking if LEFT is NOT NULL (condition TRUE -> PUSH into STACK). \n5. now STACK is NOT EMPTY (has 2 & 1), loop starts once again\n6. checking LEFT & RIGHT equals to NULL (now condition is TRUE -> storing the 2 into result and POP from STACK)\n7. now STACK is NOT EMPTY (has 1), loop starts once again\n8. checking LEFT & RIGHT equals to NULL (condition FALSE -> as per the above tree)\n---here is why you are going wrong... you already processed LEFT node which is 2) there is no way to know 2 is processed so its going in infinite loop.\n\nIn step 3,6 & 8... you are using peek().\n\nI hope explanation is clear. Thanks\nfor an Iterative version of Post-Order Traversal please refer my solution\n\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3726735/iterative-post-order-traversal/"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Root Function"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tip: In postorder (Left Right Root)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Word Distance III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569241,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1836417,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1850148,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            },
            {
                "id": 1991700,
                "content": [
                    {
                        "username": "sukrutha",
                        "content": "why is distance between \"makes\" and \"makes\" 3 ? and not 2 ? Since, distance between \"makes\" and \"coding\" is 1 , in the example"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "This illustration tries to clear the air.\\n\\n![makes](https://user-images.githubusercontent.com/81853910/229451322-e05498d0-a413-4628-b389-9938ec53ae97.png)\\n"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Because it takes the minimum distance between \"makes\" and \"coding\". They are two \"makes\" in the wordsDict and in the first example it takes \"coding\" and the last \"makes\" (indice 4 - indice 3 = 1)"
                    },
                    {
                        "username": "human292",
                        "content": "agreed, having trouble making any sense of this problem"
                    },
                    {
                        "username": "sanjayts",
                        "content": "Isn't the constraint `1 <= wordsDict.length <= 105` incorrect (the length can never be 1) given that we can't have repeated words with a single word wordsDict?"
                    },
                    {
                        "username": "user7363AQ",
                        "content": "If you are struggling with how the distance work, remember distance is the length between two points. The first example returns \"coding\" and the \"makes\" at the last index, so the distance is 4-3 = 1. The second example returns 4 - 1 = 3."
                    },
                    {
                        "username": "el_rookie",
                        "content": "This should be an easy. The solution is almost identical to Shortest Distance I."
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Vowels of a String",
        "question_content": "<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>\n\n<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"hello\"\n<strong>Output:</strong> \"holle\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"leetcode\"\n<strong>Output:</strong> \"leotcede\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 81225,
                "title": "java-standard-two-pointer-solution",
                "content": "In the inner while loop, don't forget the condition \"start less than end\" while incrementing start  and decrementing end. This is my friend's google phone interview question. Cheers!\\n// update! May use a HashSet<Character> to reduce the look up time to O(1)\\n\\n    public class Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length()==0) return s;\\n        String vowels = \"aeiouAEIOU\";\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<end){\\n            \\n            while(start<end && !vowels.contains(chars[start]+\"\")){\\n                start++;\\n            }\\n            \\n            while(start<end && !vowels.contains(chars[end]+\"\")){\\n                end--;\\n            }\\n            \\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        return new String(chars);\\n    }\\n   }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length()==0) return s;\\n        String vowels = \"aeiouAEIOU\";\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length()-1;\\n        while(start<end){\\n            \\n            while(start<end && !vowels.contains(chars[start]+\"\")){\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 81240,
                "title": "super-clean-c-solution-using-find-first-of-and-find-last-of",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while (i < j) {\\n                i = s.find_first_of(\"aeiouAEIOU\", i);\\n                j = s.find_last_of(\"aeiouAEIOU\", j);\\n                if (i < j) {\\n                    swap(s[i++], s[j--]);\\n                }\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while (i < j) {\\n                i = s.find_first_of(\"aeiouAEIOU\", i);\\n                j = s.find_last_of(\"aeiouAEIOU\", j);\\n                if (i < j) {\\n                    swap(s[i++], s[j--]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3723102,
                "title": "easy-solution-with-simple-explanation-using-two-pointer",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal of the problem is to reverse the order of vowels in a given string while keeping the non-vowel characters in their original positions. To achieve this, we can use two pointers technique: one pointer starting from the beginning of the string and another starting from the end. We will move these pointers towards each other, swapping the vowels they point to until they meet in the middle of the string.\\n\\n# Approach\\n1. Convert the input string s to an array of characters word. This step is necessary because strings are immutable in Java, and we need to modify the vowels\\' positions.\\n\\n1. Initialize two pointers, start and end, to the first and last characters of the string, respectively.\\n\\n1. Create a String variable vowels containing all the vowel characters (both lowercase and uppercase).\\n\\n1. Use a while loop to iterate until start is no longer less than end. This loop ensures that the pointers will not cross each other, and we process the characters in the middle of the string only once.\\n\\n**Inside the loop:**\\n1. Move the start pointer towards the end of the string until it points to a vowel character. We do this by using the indexOf method to find the index of the character in the vowels string. If the character is not a vowel, we keep moving the start pointer.\\n\\n1. Similarly, move the end pointer towards the beginning of the string until it points to a vowel character. Again, we use the indexOf method to check if the character is a vowel and keep moving the end pointer if it is not.\\n\\n1. Swap the vowels found at the start and end positions in the word array.\\n\\n1. Move the start pointer one step ahead and the end pointer one step back to continue searching for more vowels.\\n\\nAfter the loop finishes, the word array will contain the string with the reversed vowels. Convert the character array back to a String and return the result.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$, where n is the length of the input string s. The two pointers start and end move towards each other, and each character is processed once.\\n\\n- Space complexity:\\nThe space complexity of this solution is $$O(n)$$ because we create a character array word to store the characters of the input string. The space used is proportional to the length of the input string. Other than that, we use a constant amount of extra space for the vowels string and a few integer variables, which doesn\\'t depend on the input size.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] word = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n        \\n        while (start < end) {\\n            // Move start pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[start]) == -1) {\\n                start++;\\n            }\\n            \\n            // Move end pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[end]) == -1) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels\\n            char temp = word[start];\\n            word[start] = word[end];\\n            word[end] = temp;\\n            \\n            // Move the pointers towards each other\\n            start++;\\n            end--;\\n        }\\n        \\n        String answer = new String(word);\\n        return answer;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        # Convert the input string to a character array.\\n        word = list(s)\\n        start = 0\\n        end = len(s) - 1\\n        vowels = \"aeiouAEIOU\"\\n        \\n        # Loop until the start pointer is no longer less than the end pointer.\\n        while start < end:\\n            # Move the start pointer towards the end until it points to a vowel.\\n            while start < end and vowels.find(word[start]) == -1:\\n                start += 1\\n            \\n            # Move the end pointer towards the start until it points to a vowel.\\n            while start < end and vowels.find(word[end]) == -1:\\n                end -= 1\\n            \\n            # Swap the vowels found at the start and end positions.\\n            word[start], word[end] = word[end], word[start]\\n            \\n            # Move the pointers towards each other for the next iteration.\\n            start += 1\\n            end -= 1\\n        \\n        # Convert the character array back to a string and return the result.\\n        return \"\".join(word)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        // Convert the input string to a character array.\\n        string word = s;\\n        int start = 0;\\n        int end = s.length() - 1;\\n        string vowels = \"aeiouAEIOU\";\\n        \\n        // Loop until the start pointer is no longer less than the end pointer.\\n        while (start < end) {\\n            // Move the start pointer towards the end until it points to a vowel.\\n            while (start < end && vowels.find(word[start]) == string::npos) {\\n                start++;\\n            }\\n            \\n            // Move the end pointer towards the start until it points to a vowel.\\n            while (start < end && vowels.find(word[end]) == string::npos) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels found at the start and end positions.\\n            swap(word[start], word[end]);\\n            \\n            // Move the pointers towards each other for the next iteration.\\n            start++;\\n            end--;\\n        }\\n        \\n        // Return the modified string.\\n        return word;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/acf12ce9-4139-4e80-a219-5d02f3d054bf_1688572264.1963482.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] word = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n        \\n        while (start < end) {\\n            // Move start pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[start]) == -1) {\\n                start++;\\n            }\\n            \\n            // Move end pointer until it points to a vowel\\n            while (start < end && vowels.indexOf(word[end]) == -1) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels\\n            char temp = word[start];\\n            word[start] = word[end];\\n            word[end] = temp;\\n            \\n            // Move the pointers towards each other\\n            start++;\\n            end--;\\n        }\\n        \\n        String answer = new String(word);\\n        return answer;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        # Convert the input string to a character array.\\n        word = list(s)\\n        start = 0\\n        end = len(s) - 1\\n        vowels = \"aeiouAEIOU\"\\n        \\n        # Loop until the start pointer is no longer less than the end pointer.\\n        while start < end:\\n            # Move the start pointer towards the end until it points to a vowel.\\n            while start < end and vowels.find(word[start]) == -1:\\n                start += 1\\n            \\n            # Move the end pointer towards the start until it points to a vowel.\\n            while start < end and vowels.find(word[end]) == -1:\\n                end -= 1\\n            \\n            # Swap the vowels found at the start and end positions.\\n            word[start], word[end] = word[end], word[start]\\n            \\n            # Move the pointers towards each other for the next iteration.\\n            start += 1\\n            end -= 1\\n        \\n        # Convert the character array back to a string and return the result.\\n        return \"\".join(word)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        // Convert the input string to a character array.\\n        string word = s;\\n        int start = 0;\\n        int end = s.length() - 1;\\n        string vowels = \"aeiouAEIOU\";\\n        \\n        // Loop until the start pointer is no longer less than the end pointer.\\n        while (start < end) {\\n            // Move the start pointer towards the end until it points to a vowel.\\n            while (start < end && vowels.find(word[start]) == string::npos) {\\n                start++;\\n            }\\n            \\n            // Move the end pointer towards the start until it points to a vowel.\\n            while (start < end && vowels.find(word[end]) == string::npos) {\\n                end--;\\n            }\\n            \\n            // Swap the vowels found at the start and end positions.\\n            swap(word[start], word[end]);\\n            \\n            // Move the pointers towards each other for the next iteration.\\n            start++;\\n            end--;\\n        }\\n        \\n        // Return the modified string.\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81262,
                "title": "1-2-lines-python-ruby",
                "content": "**Ruby**\\n\\n    def reverse_vowels(s)\\n      vowels = s.scan(/[aeiou]/i)\\n      s.gsub(/[aeiou]/i) { vowels.pop }\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def reverseVowels(self, s):\\n        vowels = re.findall('(?i)[aeiou]', s)\\n        return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s)\\n\\n---\\n\\nIt's possible in one line, but I don't really like it:\\n\\n    def reverseVowels(self, s):\\n        return re.sub('(?i)[aeiou]', lambda m, v=re.findall('(?i)[aeiou]', s): v.pop(), s)\\n\\n---\\n\\nAnother version, finding replacement vowels on the fly instead of collecting all in advance:\\n\\n    def reverseVowels(self, s):\\n        vowels = (c for c in reversed(s) if c in 'aeiouAEIOU')\\n        return re.sub('(?i)[aeiou]', lambda m: next(vowels), s)",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "**Ruby**\\n\\n    def reverse_vowels(s)\\n      vowels = s.scan(/[aeiou]/i)\\n      s.gsub(/[aeiou]/i) { vowels.pop }\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def reverseVowels(self, s):\\n        vowels = re.findall('(?i)[aeiou]', s)\\n        return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s)\\n\\n---\\n\\nIt's possible in one line, but I don't really like it:\\n\\n    def reverseVowels(self, s):\\n        return re.sub('(?i)[aeiou]', lambda m, v=re.findall('(?i)[aeiou]', s): v.pop(), s)\\n\\n---\\n\\nAnother version, finding replacement vowels on the fly instead of collecting all in advance:\\n\\n    def reverseVowels(self, s):\\n        vowels = (c for c in reversed(s) if c in 'aeiouAEIOU')\\n        return re.sub('(?i)[aeiou]', lambda m: next(vowels), s)",
                "codeTag": "Python3"
            },
            {
                "id": 81233,
                "title": "python-2-pointers-solution",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            vowels = set(list(\"aeiouAEIOU\"))\\n            s = list(s)\\n            ptr_1, ptr_2 = 0, len(s) - 1\\n            while ptr_1 < ptr_2:\\n                if s[ptr_1] in vowels and s[ptr_2] in vowels:\\n                    s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1]\\n                    ptr_1 += 1\\n                    ptr_2 -= 1\\n                if s[ptr_1] not in vowels:\\n                    ptr_1 += 1\\n                if s[ptr_2] not in vowels:\\n                    ptr_2 -= 1\\n            return ''.join(s)\\n\\nThe idea is really simple. But I think my code is somewhat ugly in two ways:\\n\\n 1. Convert string to list then convert back \\n 2. Pointer processing is verbose.\\n\\nAny suggestion? Thanks.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            vowels = set(list(\"aeiouAEIOU\"))\\n            s = list(s)\\n            ptr_1, ptr_2 = 0, len(s) - 1\\n            while ptr_1 < ptr_2:\\n                if s[ptr_1] in vowels and s[ptr_2] in vowels:\\n                    s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1]\\n                    ptr_1 += 1\\n                    ptr_2 -= 1\\n                if s[ptr_1] not in vowels:\\n                    ptr_1 += 1\\n                if s[ptr_2] not in vowels:\\n                    ptr_2 -= 1\\n            return ''.join(s)\\n\\nThe idea is really simple. But I think my code is somewhat ugly in two ways:\\n\\n 1. Convert string to list then convert back \\n 2. Pointer processing is verbose.\\n\\nAny suggestion? Thanks.",
                "codeTag": "Java"
            },
            {
                "id": 81326,
                "title": "simple-java-solution-one-line-hashset-init",
                "content": "```\\npublic class Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length - 1;\\n        while (left < right) {\\n            if (!set.contains(arr[left])) {\\n                left++;\\n            } else if (!set.contains(arr[right])) {\\n                right--;\\n            } else {\\n                char tmp = arr[left];\\n                arr[left] = arr[right];\\n                arr[right] = tmp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length - 1;\\n        while (left < right) {\\n            if (!set.contains(arr[left])) {\\n                left++;\\n            } else if (!set.contains(arr[right])) {\\n                right--;\\n            } else {\\n                char tmp = arr[left];\\n                arr[left] = arr[right];\\n                arr[right] = tmp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775357,
                "title": "python3-two-pointers-reverse-and-replace-2-approaches-o-n",
                "content": "**Algorithm 1 - Two Pointers:**\\nLet\\'s use a left pointer and a right pointer starting from the two ends of the string and moving toward each other. When both ```s[left]``` and ```s[right]``` are vowels, sweep them, and move both pointers forward by 1 position. If any pointer is not on a vowel position, move it forward by 1 position. Note that we need to convert the input string to a list for fast O(1) sweep.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n\\n        ### Convert s to list for fast sweep\\n        s = list(s)\\n\\n        ### initialize two pointers at the two ends\\n        left = 0\\n        right = len(s)-1\\n\\n        ### left and right are moving toward each other\\n        ### but they should\\'t cross each other\\n        while left<right:\\n\\n        \\t### if both pointers are on vowels, sweep them.\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left],s[right] = s[right],s[left]\\n                right -= 1\\n                left += 1\\n\\n            ### if any pointer is not on a vowel, move it by 1.\\n            elif s[left] not in vowels:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        ### join the modified list as a string and return it\\n        return \\'\\'.join(s)\\n```\\nWe can also use two while loop to move left and right to the next vowel positions.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n\\n        while left<right:\\n            \\n            ### move left and right to the next vowel positions.\\n            while left < right and s[left] not in vowels:\\n                left += 1\\n            while left < right and s[right] not in vowels:\\n                right -= 1\\n        \\t\\n            ### sweep and move the pointers one more time.\\n            s[left],s[right] = s[right],s[left]\\n            right -= 1\\n            left += 1\\n\\n        return \\'\\'.join(s)\\n```\\n**Algorithm 2 - Reverse and Replace:**\\nThe idea is to first extract all vowels from s and then reverse it. Next, replace the vowels in the original s with the extracted and reversed vowels.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n        ### reverse the extracted vowels\\n        reversedVowel = vowelInS[::-1]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = reversedVowel.pop(0)\\n\\n        return \\'\\'.join(s)\\n```\\n\\nWe can also skip the reverse step and simply pop from the end of the ```vowelInS```\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = vowelInS.pop(-1)\\n\\n        return \\'\\'.join(s)\\n```\\n\\nAlso check out the iterator version from [@alvin-777](https://leetcode.com/alvin-777/) [HERE](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775366/python-iterator-simple-2-lines)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s[left]```\n```s[right]```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n\\n        ### Convert s to list for fast sweep\\n        s = list(s)\\n\\n        ### initialize two pointers at the two ends\\n        left = 0\\n        right = len(s)-1\\n\\n        ### left and right are moving toward each other\\n        ### but they should\\'t cross each other\\n        while left<right:\\n\\n        \\t### if both pointers are on vowels, sweep them.\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left],s[right] = s[right],s[left]\\n                right -= 1\\n                left += 1\\n\\n            ### if any pointer is not on a vowel, move it by 1.\\n            elif s[left] not in vowels:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n        ### join the modified list as a string and return it\\n        return \\'\\'.join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n\\n        while left<right:\\n            \\n            ### move left and right to the next vowel positions.\\n            while left < right and s[left] not in vowels:\\n                left += 1\\n            while left < right and s[right] not in vowels:\\n                right -= 1\\n        \\t\\n            ### sweep and move the pointers one more time.\\n            s[left],s[right] = s[right],s[left]\\n            right -= 1\\n            left += 1\\n\\n        return \\'\\'.join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n        ### reverse the extracted vowels\\n        reversedVowel = vowelInS[::-1]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = reversedVowel.pop(0)\\n\\n        return \\'\\'.join(s)\\n```\n```vowelInS```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = {\\'a\\',\\'A\\',\\'e\\',\\'E\\',\\'i\\',\\'I\\',\\'o\\',\\'O\\',\\'u\\',\\'U\\'}\\n        s = list(s)\\n\\n        ### extract all vowels from s\\n        vowelInS = [c for c in s if c in vowels]\\n\\n        ### replace the vowels in s with the reversed ones\\n        for i in range(len(s)):\\n            if s[i] in vowels:\\n                s[i] = vowelInS.pop(-1)\\n\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164745,
                "title": "python-solution-99-58-faster-86-96-less-memory",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        left = 0\\n        right = len(s) - 1\\n        m = \\'aeiouAEIOU\\'\\n        while left < right:\\n            if s[left] in m and s[right] in m:\\n                \\n                s[left], s[right] = s[right], s[left]\\n                \\n                left += 1; right -= 1\\n            \\n            elif s[left] not in m:\\n                left += 1\\n            \\n            elif s[right] not in m:\\n                right -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        left = 0\\n        right = len(s) - 1\\n        m = \\'aeiouAEIOU\\'\\n        while left < right:\\n            if s[left] in m and s[right] in m:\\n                \\n                s[left], s[right] = s[right], s[left]\\n                \\n                left += 1; right -= 1\\n            \\n            elif s[left] not in m:\\n                left += 1\\n            \\n            elif s[right] not in m:\\n                right -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81261,
                "title": "c-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int dict[256] = {0};\\n            dict['a'] = 1, dict['A'] = 1;\\n            dict['e'] = 1, dict['E'] = 1;\\n            dict['i'] = 1, dict['I'] = 1;\\n            dict['o'] = 1, dict['O'] = 1;\\n            dict['u'] = 1, dict['U'] = 1;\\n            int start = 0, end = (int)s.size() - 1;\\n            while(start < end){\\n                while(start < end && dict[s[start]] == 0) start++;\\n                while(start < end && dict[s[end]] == 0) end--;\\n                swap(s[start],s[end]);\\n                start++;end--;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            int dict[256] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2775693,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/oSFnTxi9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Two Pointers"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/oSFnTxi9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 81221,
                "title": "one-pass-java-solution-13ms",
                "content": "    public class Solution {\\n        public String reverseVowels(String s) {\\n            char[] list=s.toCharArray();\\n            Set<Character> set=new HashSet<>();\\n            set.add('a');\\n            set.add('e');\\n            set.add('i');\\n            set.add('o');\\n            set.add('u');\\n            set.add('A');\\n            set.add('E');\\n            set.add('I');\\n            set.add('O');\\n            set.add('U');\\n            for (int i=0, j=list.length-1; i<j; ) {\\n                if (!set.contains(list[i])) {\\n                    i++;\\n                    continue;\\n                }\\n                if (!set.contains(list[j])) {\\n                    j--;\\n                    continue;\\n                }\\n                char temp=list[i];\\n                list[i]=list[j];\\n                list[j]=temp;\\n                i++;\\n                j--;\\n            }\\n            return String.valueOf(list);\\n        }\\n    }\\nWe could also initilize the set like this:\\n```\\nSet<Character> vowels = new HashSet<>(Arrays.asList(new Character[]{'a','e','i','o','u','A','E','I','O','U'}));\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nSet<Character> vowels = new HashSet<>(Arrays.asList(new Character[]{'a','e','i','o','u','A','E','I','O','U'}));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81355,
                "title": "beat-99-7-using-python-two-pointers",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\\n            L = list(s)\\n            i = 0\\n            j = len(L) - 1\\n            while i < j:\\n                while i < j and L[i] not in vowels:\\n                    i += 1\\n                while j > i and L[j] not in vowels:\\n                    j -= 1\\n                L[i], L[j] = L[j], L[i] \\n                i += 1\\n                j -= 1\\n            return ''.join(L)",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
                "codeTag": "Java"
            },
            {
                "id": 1371985,
                "title": "very-simple-lc-says-your-runtime-beats-97-12-of-cpp-submissions",
                "content": "**Approch:** \\nIdea is to use two pointers. Let say one point at the start index (0) of the string and a second at the last (s.size()-1)  of the string.\\n\\nNow if both the pointers are pointing at vowels simply swap the values. And if not increment or decrement them accordingly (check code for more explanation)\\n\\n```\\nclass Solution \\n{\\n\\t\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            bool flag1 = false, flag2 = false;   // to check if we are pointing to a vowel or not\\n            \\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            flag1 = true;\\n            \\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\' || s[j]==\\'A\\' || s[j]==\\'E\\' || s[j]==\\'I\\' || s[j]==\\'O\\' || s[j]==\\'U\\')\\n            flag2 = true;\\n            \\n            if(flag1 && flag2)   // if both are pointing to vowels just swap them\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--; \\n            }\\n            \\n            if(!flag1)    // if i is not pointing to a vowel, move the pointer forward\\n            i++;\\n            if(!flag2)    // if j is not pointing to a vowel, move the pointer backwards\\n            j--;\\n        }\\n        \\n        return s;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n\\t\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            bool flag1 = false, flag2 = false;   // to check if we are pointing to a vowel or not\\n            \\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            flag1 = true;\\n            \\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\' || s[j]==\\'A\\' || s[j]==\\'E\\' || s[j]==\\'I\\' || s[j]==\\'O\\' || s[j]==\\'U\\')\\n            flag2 = true;\\n            \\n            if(flag1 && flag2)   // if both are pointing to vowels just swap them\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--; \\n            }\\n            \\n            if(!flag1)    // if i is not pointing to a vowel, move the pointer forward\\n            i++;\\n            if(!flag2)    // if j is not pointing to a vowel, move the pointer backwards\\n            j--;\\n        }\\n        \\n        return s;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81247,
                "title": "2-line-javascript-o-n-solution-using-stack-and-regex",
                "content": "The standard solution for comparison:\\n```\\nvar reverseVowels = function(s) {\\n    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };\\n    const arr = s.split('');\\n    let i = 0, j = arr.length - 1;\\n    while (i < j) {\\n        if (VOWELS[arr[i]] && VOWELS[arr[j]]) {\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n            i++;\\n            j--;\\n        } else if (VOWELS[arr[i]]) {\\n            j--;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return arr.join('');\\n};\\n```\\nAnd here is the fancy solution:\\n```\\nvar reverseVowels = function(s) {\\n    const vowels = s.split('').filter(a => /[aeiou]/i.test(a));\\n    return s.split(/[aeiou]/i).reduce((res, a) => res + a + (vowels.pop() || ''), '');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };\\n    const arr = s.split('');\\n    let i = 0, j = arr.length - 1;\\n    while (i < j) {\\n        if (VOWELS[arr[i]] && VOWELS[arr[j]]) {\\n            [arr[i], arr[j]] = [arr[j], arr[i]];\\n            i++;\\n            j--;\\n        } else if (VOWELS[arr[i]]) {\\n            j--;\\n        } else {\\n            i++;\\n        }\\n    }\\n    return arr.join('');\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n    const vowels = s.split('').filter(a => /[aeiou]/i.test(a));\\n    return s.split(/[aeiou]/i).reduce((res, a) => res + a + (vowels.pop() || ''), '');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775770,
                "title": "python-c-java-rust-2-pointers-stack-reverse-consonants-too-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a two-pointer strategy to swap vowels. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** Sorting of just vowels in reverse order is equivalent to swapping first vowel with last vowel, second vowel with the last but one, and so on. Thus, to detect vowels from both ends (and swap them), we employ a strategy with two converging pointers.\\n\\n**For the BONUS to reverse BOTH vowels and consonants simultaneously, please scroll down.**\\n\\n**Python.**\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = set(list(\"aeiouAEIOU\"))) -> str:\\n        \\n        l, r, s = 0, len(s) - 1, list(s)\\n        while l < r:                           \\n            while l < r and s[l] not in vwls: l += 1     # [1] move pointers until\\n            while l < r and s[r] not in vwls: r -= 1     #     two vowels are found \\n            s[l], s[r] = s[r], s[l]                      # [2] swap vowels and move\\n            l, r = l + 1, r - 1                          #     pointers further\\n        return \"\".join(s)\\n```\\nHere is a two-pass solution with stack.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        stack = [v for v in s if v in vwls]\\n        return \"\".join(c if c not in vwls else stack.pop() for c in s)\\n```\\n\\nThere is an even better approach that was originally proposed [**here**](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775366/python-iterator-simple-2-lines). I modified it a bit...\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        it = (v for v in reversed(s) if v in vwls)\\n        return \"\".join(next(it) if c in vwls else c for c in s)\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/AwxaByBF/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>\\n\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\nAs a **BONUS**, I provide an upgrade to this problem, namely, a solution to reverse both vowels and consonant *simutaneously* using deque. Here, deque is a convenient data structure for two independent stacks. *(For this problem, all characters should be english letters with no other symbols. Otherwise, this algorithm should check for vovels, consonants and non-letters, however, still using deque to store vowels and consonants.)*\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        dq = deque()\\n        for c in s:\\n            if c in vwls : dq.append(c)\\n            else         : dq.appendleft(c)\\n        \\n        return \"\".join(dq.pop() if c in vwls else dq.popleft() for c in s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = set(list(\"aeiouAEIOU\"))) -> str:\\n        \\n        l, r, s = 0, len(s) - 1, list(s)\\n        while l < r:                           \\n            while l < r and s[l] not in vwls: l += 1     # [1] move pointers until\\n            while l < r and s[r] not in vwls: r -= 1     #     two vowels are found \\n            s[l], s[r] = s[r], s[l]                      # [2] swap vowels and move\\n            l, r = l + 1, r - 1                          #     pointers further\\n        return \"\".join(s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        stack = [v for v in s if v in vwls]\\n        return \"\".join(c if c not in vwls else stack.pop() for c in s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        it = (v for v in reversed(s) if v in vwls)\\n        return \"\".join(next(it) if c in vwls else c for c in s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str, vwls = list(\"aeiouAEIOU\")) -> str:\\n        \\n        dq = deque()\\n        for c in s:\\n            if c in vwls : dq.append(c)\\n            else         : dq.appendleft(c)\\n        \\n        return \"\".join(dq.pop() if c in vwls else dq.popleft() for c in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620822,
                "title": "python-two-pointer-approach-set-runtime-o-n",
                "content": "The idea is to have two pointers (one starting from the left and another one starting from the right). \\n\\n**CASE 1**\\nBoth pointers will move one place each. Left pointer will move one place to the right and right pointer will move one place to the left: \\n* IF both letters that the pointers are pointing at **are vowels**\\n\\t* IF this is the case, *swap the letters*\\n* IF both letters that the pointers are pointing at are **not vowels**\\n\\n**CASE 2**\\nIf one pointer is pointing to a vowel but another one is not:\\n* Move the pointer either one place to right (if it is left pointer) or one place to left (if it is right pointer) WHILE keeping the pointer pointing at a vowel at the same position.\\n\\t* Eventually, you will reach CASE 1 or you will never reach CASE 1 (in this case left == right and basically the swap is just one the same letter)\\n\\n``` python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowels = set(\\'aeiouAEIOU\\')\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n        \\n        while left <= right:\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left], s[right] = s[right], s[left]\\n            elif s[right] not in vowels:\\n                right -= 1\\n                continue\\n            elif s[left] not in vowels:\\n                left += 1\\n                continue\\n            left += 1\\n            right -= 1\\n        \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "``` python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowels = set(\\'aeiouAEIOU\\')\\n        s = list(s)\\n        left = 0\\n        right = len(s)-1\\n        \\n        while left <= right:\\n            if s[left] in vowels and s[right] in vowels:\\n                s[left], s[right] = s[right], s[left]\\n            elif s[right] not in vowels:\\n                right -= 1\\n                continue\\n            elif s[left] not in vowels:\\n                left += 1\\n                continue\\n            left += 1\\n            right -= 1\\n        \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81435,
                "title": "c-12ms-two-pointers-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            auto p1 = s.begin(), p2 = s.end() - 1;\\n            string vowels = \"aeiouAEIOU\";\\n            while(p1 < p2) {\\n                while((vowels.find(*p1) == string::npos) && (p1 < p2)) p1++;\\n                while((vowels.find(*p2) == string::npos) && (p1 < p2)) p2--;\\n                if(p1 < p2) swap(*p1, *p2);\\n                p1++;\\n                p2--;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            auto p1 = s.begin(), p2 = s.end() - 1;\\n            string vowels = \"aeiouAEIOU\";\\n            while(p1 < p2) {\\n                while((vowels.find(*p1) == string::npos) && (p1 < p2)) p1++;\\n                while((vowels.find(*p2) == string::npos) && (p1 < p2)) p2--;\\n                if(p1 < p2) swap(*p1, *p2);\\n                p1++;\\n                p2--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 567723,
                "title": "two-pointers-technique-python-o-n-time-and-space",
                "content": "Hello, everyone! \\uD83D\\uDC4B Here is my solution to this problem.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(\"AaEeIiOoUu\")\\n        data = list(s)\\n        p1, p2 = 0, len(data) - 1\\n        while p1 < p2:\\n            if data[p1] in vowels and data[p2] in vowels:\\n                data[p1], data[p2] = data[p2], data[p1]\\n                p1 += 1\\n                p2 -= 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p1] not in vowels:\\n                p1 += 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p2] not in vowels:\\n                p2 -= 1\\n\\n        return \"\".join(data)\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n).*\\n*Space complexity: O(n).*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(\"AaEeIiOoUu\")\\n        data = list(s)\\n        p1, p2 = 0, len(data) - 1\\n        while p1 < p2:\\n            if data[p1] in vowels and data[p2] in vowels:\\n                data[p1], data[p2] = data[p2], data[p1]\\n                p1 += 1\\n                p2 -= 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p1] not in vowels:\\n                p1 += 1\\n\\t\\t\\t\\n\\t\\t\\tif data[p2] not in vowels:\\n                p2 -= 1\\n\\n        return \"\".join(data)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320125,
                "title": "python-solution",
                "content": "Python strings are immutable so convert s to a list to reduce time complexity from n^2 to n.\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] not in vowels:\\n                i += 1\\n                continue\\n                \\n            if s[j] not in vowels:\\n                j -= 1\\n                continue\\n                \\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] not in vowels:\\n                i += 1\\n                continue\\n                \\n            if s[j] not in vowels:\\n                j -= 1\\n                continue\\n                \\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n            \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775649,
                "title": "java-explained-in-detail-simple-fast-solution-two-pointers",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n## Approach\\nUse two pointers to traverse from left and right towards to center.\\n\\nSwap when both position contains vowels \"aeiouAEIOU\".\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n  where $$n$$ is the length of the String.\\n\\n- Space complexity: $$O(n)$$\\n  due to the toCharArray( ) function.\\n\\n---\\n\\n### Java (Clean Code)\\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !isVowel(chars[left]))\\n                left++;\\n            while (left < right && !isVowel(chars[right]))\\n                right--;\\n\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\\n\\n### Java (With Explanation)\\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Use two pointers to traverse from left and right towards to center.\\n    // Swap when both position contains vowels \"aeiouAEIOU\".\\n\\n    public String reverseVowels(String s) {\\n\\n        // Convert the string to charArray.\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        // When both pointers meet, we know all the vowels are swapped.\\n        while (left < right) {\\n            // If chars[left] is not vowel, continue to move right.\\n            while (left < right && !isVowel(chars[left])) {\\n                left++;\\n            }\\n            // If chars[right] is not vowel, continue to move left.\\n            while (left < right && !isVowel(chars[right])) {\\n                right--;\\n            }\\n\\n            // Swap the vowels.\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    // Return true if char is a vowel.\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        while (left < right) {\\n            while (left < right && !isVowel(chars[left]))\\n                left++;\\n            while (left < right && !isVowel(chars[right]))\\n                right--;\\n\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    // Approach:\\n    // Use two pointers to traverse from left and right towards to center.\\n    // Swap when both position contains vowels \"aeiouAEIOU\".\\n\\n    public String reverseVowels(String s) {\\n\\n        // Convert the string to charArray.\\n        char[] chars = s.toCharArray();\\n\\n        int left = 0;\\n        int right = s.length() - 1;\\n\\n        // When both pointers meet, we know all the vowels are swapped.\\n        while (left < right) {\\n            // If chars[left] is not vowel, continue to move right.\\n            while (left < right && !isVowel(chars[left])) {\\n                left++;\\n            }\\n            // If chars[right] is not vowel, continue to move left.\\n            while (left < right && !isVowel(chars[right])) {\\n                right--;\\n            }\\n\\n            // Swap the vowels.\\n            if (left < right) {\\n                char temp = chars[left];\\n                chars[left++] = chars[right];\\n                chars[right--] = temp;\\n            }\\n        }\\n        return new String(chars);\\n    }\\n\\n    // Return true if char is a vowel.\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218626,
                "title": "c-beats-99-detailed-explaination",
                "content": "Basic Idea is to store the index of the vowels in the array \\n\\nLets take an example \\n\"**leetcode**\" here the vowel has an index --> **[1,2,5,7]** we store this in a vector array and then we can apply swap from start and end in the vector.\\n```\\n string reverseString(string &s){\\n         vector<int> v;\\n        for(int i=0 ; i<s.size();i++){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || \\n               s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                v.push_back(i);\\n        }\\n        for(int start=0, end = v.size()-1; start < end; start++, end--){\\n            swap(s[v[start]] , s[v[end ]]);\\n        }\\n        return s;\\n    }\\n    string reverseVowels(string s) {\\n       reverseString(s);\\n        return s;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Basic Idea is to store the index of the vowels in the array \\n\\nLets take an example \\n\"**leetcode**\" here the vowel has an index --> **[1,2,5,7]** we store this in a vector array and then we can apply swap from start and end in the vector.\\n```\\n string reverseString(string &s){\\n         vector<int> v;\\n        for(int i=0 ; i<s.size();i++){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || \\n               s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                v.push_back(i);\\n        }\\n        for(int start=0, end = v.size()-1; start < end; start++, end--){\\n            swap(s[v[start]] , s[v[end ]]);\\n        }\\n        return s;\\n    }\\n    string reverseVowels(string s) {\\n       reverseString(s);\\n        return s;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2775366,
                "title": "python-iterator-simple-2-lines",
                "content": "# Approach\\n- create an iterator that iterates all the vowels backwards\\n- create the string with each vowel replaced by the one from the iterator\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        it = (ch for ch in s[::-1] if ch.lower() in \\'aeiou\\')\\n        return \\'\\'.join(next(it) if ch.lower() in \\'aeiou\\' else ch for ch in s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        it = (ch for ch in s[::-1] if ch.lower() in \\'aeiou\\')\\n        return \\'\\'.join(next(it) if ch.lower() in \\'aeiou\\' else ch for ch in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776920,
                "title": "c-5-different-approaches-two-passes-stack-two-pointers-and-more",
                "content": "Please let me know if you have a different approach or a suggestion for one of the approaches blow. For all the the approaches we need to decide if a character is a vowel, which I did with the following code:\\n\\n```cpp\\n    static bool isVowel(char ch) {\\n        return\\n            ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n            ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\';\\n    }\\n```\\n\\nOther implementations could use a lookup in the a bit / bool vector and avoid the branching, and do something like\\n\\n```cpp\\n    static constexpr bool is_vowel[256] = {\\n        [\\'a\\'] = true, [\\'e\\'] = true, [\\'i\\'] = true, [\\'o\\'] = true, [\\'u\\'] = true,\\n        [\\'A\\'] = true, [\\'E\\'] = true, [\\'I\\'] = true, [\\'O\\'] = true, [\\'U\\'] = true,        \\n    };\\n\\t\\n\\t// We would likley drop this wrapper\\n\\tstatic constexpr bool isVowel(char ch) {\\n\\t\\treturn is_vowel[ch];\\n\\t}\\n```\\n\\nCompiler are pure magic! It\\'s kinda mind blowing that clang generates branchless code for the first version as well, see https://godbolt.org/z/bhErrjEq1\\n\\n# Approach 1: extract, reverse, update\\n\\nWe extract all the vowels, reverse them, and then update the string.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        copy_if(begin(s), end(s), back_inserter(vowels), isVowel);\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0, v = 0; i < size(s); ++i)\\n            if (isVowel(s[i])) s[i] = vowels[v++];\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(n)$$\\n\\n# Approach 2: extract w/ index, reverse, update\\n\\nSimilar to approach 1, but instead of scanning the full string again, we keep track where we found the vowels and just update these positions. This approach is faster than approach 1 if there are only very few vowels in a long string.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        vector<int> idx;\\n        idx.reserve(size(s));\\n        for (int i = 0; i < size(s); ++i) {\\n            if (isVowel(s[i])) {\\n                vowels.push_back(s[i]);\\n                idx.push_back(i);\\n            }\\n        }\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[i]] = vowels[i];\\n        return s;\\n    }\\n```\\n\\nInstead of reversing ```vowels``` we could just read the vowels or the index from the back, i.e. do something like:\\n\\n```cpp\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[size(idx) - 1 - i]] = vowels[i];\\n```\\n\\n**Complexity Analysis**\\nLike approach 1, but the constant factors are different.\\n\\n# Approach 3: stack\\nThis is based on [a post](https://leetcode.com/problems/reverse-vowels-of-a-string/discuss/2775879/Very-easy-solution-using-Stack) by @kalashpatil which is kinda neat. Runtime wise this is similar to approach 1. ... and yeah,  ```string``` or a ```vector``` are a perfectly fine stack, but obviously we could use a ```stack<char>``` too.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        string st;\\n        st.reserve(size(s));\\n        for (char ch : s)\\n            if (isVowel(ch)) st.push_back(ch);\\n        for (char& ch : s)\\n            if (isVowel(ch)) {\\n                ch = st.back();\\n                st.pop_back();\\n            }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(n)$$\\n\\n\\n# Approach 4: two pointers\\n\\nIMO this is the best approach. Btw. doing ```swap(s[l++], s[r--]);``` instead of ```if (l < r) swap(s[l++], s[r--]);``` will swap a character with itself at the end, but that doesn\\'t matter.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            while (l < r && !isVowel(s[l])) ++l;\\n            while (l < r && !isVowel(s[r])) --r;\\n            swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$ if we don\\'t count the output, but we are just modifying the input.\\n\\n# Approach 5: string::find_first_of, string::find_last_of\\n\\nThis approach which is similar to approach 4 is based on [a solution](Super-clean-C%2B%2B-solution-using-find_first_of-and-find_last_of) by @ChowTaiFok.\\n\\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            l = s.find_first_of(\"aeiouAEIOU\", l);\\n            r = s.find_last_of(\"aeiouAEIOU\", r);\\n            if (l < r) swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\\n\\n**Complexity Analysis**\\nThis is basically the same as solution 4.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static bool isVowel(char ch) {\\n        return\\n            ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n            ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\';\\n    }\\n```\n```cpp\\n    static constexpr bool is_vowel[256] = {\\n        [\\'a\\'] = true, [\\'e\\'] = true, [\\'i\\'] = true, [\\'o\\'] = true, [\\'u\\'] = true,\\n        [\\'A\\'] = true, [\\'E\\'] = true, [\\'I\\'] = true, [\\'O\\'] = true, [\\'U\\'] = true,        \\n    };\\n\\t\\n\\t// We would likley drop this wrapper\\n\\tstatic constexpr bool isVowel(char ch) {\\n\\t\\treturn is_vowel[ch];\\n\\t}\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        copy_if(begin(s), end(s), back_inserter(vowels), isVowel);\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0, v = 0; i < size(s); ++i)\\n            if (isVowel(s[i])) s[i] = vowels[v++];\\n        return s;\\n    }\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        string vowels;\\n        vowels.reserve(size(s));\\n        vector<int> idx;\\n        idx.reserve(size(s));\\n        for (int i = 0; i < size(s); ++i) {\\n            if (isVowel(s[i])) {\\n                vowels.push_back(s[i]);\\n                idx.push_back(i);\\n            }\\n        }\\n        reverse(begin(vowels), end(vowels));\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[i]] = vowels[i];\\n        return s;\\n    }\\n```\n```vowels```\n```cpp\\n        for (int i = 0; i < size(idx); ++i)\\n            s[idx[size(idx) - 1 - i]] = vowels[i];\\n```\n```string```\n```vector```\n```stack<char>```\n```cpp\\n    static string reverseVowels(string s) {\\n        string st;\\n        st.reserve(size(s));\\n        for (char ch : s)\\n            if (isVowel(ch)) st.push_back(ch);\\n        for (char& ch : s)\\n            if (isVowel(ch)) {\\n                ch = st.back();\\n                st.pop_back();\\n            }\\n        return s;\\n    }\\n```\n```swap(s[l++], s[r--]);```\n```if (l < r) swap(s[l++], s[r--]);```\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            while (l < r && !isVowel(s[l])) ++l;\\n            while (l < r && !isVowel(s[r])) --r;\\n            swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```\n```cpp\\n    static string reverseVowels(string s) {\\n        for (int l = 0, r = size(s) - 1; l < r; ) {\\n            l = s.find_first_of(\"aeiouAEIOU\", l);\\n            r = s.find_last_of(\"aeiouAEIOU\", r);\\n            if (l < r) swap(s[l++], s[r--]);\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057077,
                "title": "java-two-pointer-2ms-beats-99-81",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve reversing the vowels in a given string while keeping the consonants and other characters in their original positions. To achieve this, I would iterate through the string using two pointers, one starting from the beginning and the other from the end. When both pointers point to vowels, I will swap them to reverse the vowels.\\n\\n# Approach\\nI will start by converting the input string s into a character array to make it easier to manipulate. Then, I\\'ll initialize two pointers, start and end, pointing to the beginning and end of the string, respectively.\\n\\nI\\'ll use a while loop to traverse the string. In each iteration, I\\'ll use inner while loops to advance start and end until they point to vowels (or until start crosses end). When both pointers are on vowels, I\\'ll swap the characters at their positions to reverse the vowels. After the loop completes, I\\'ll return the modified character array as a string.\\n\\nTo determine whether a character is a vowel, I\\'ll define a helper function isVowel that checks if the character is one of the vowel characters (both lowercase and uppercase).\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the length of the input string s. This is because we traverse the string once with two pointers, and each character is examined only once.\\n\\nSpace complexity: The space complexity is O(n) as well, primarily due to the character array used to store the modified string.\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0 ;\\n\\n        int end = s.length()-1;\\n\\n        while (start<end){\\n            while (start < end && !isVowel(chars[start])) {\\n                start++;\\n            }\\n\\n            while (start < end && !isVowel(chars[end])) {\\n                end--;\\n            }\\n\\n            if (start < end) {\\n                swap(chars, start, end);\\n                start++;\\n                end--;\\n            }\\n\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    private void swap(char[] word, int start, int end){\\n        char temp = word[start];\\n        word[start] = word[end];\\n        word[end] = temp;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```\\n![87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg](https://assets.leetcode.com/users/images/8e036e7a-8854-4426-bf26-d01253a36b73_1694976337.0712368.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n\\n        char[] chars = s.toCharArray();\\n\\n        int start = 0 ;\\n\\n        int end = s.length()-1;\\n\\n        while (start<end){\\n            while (start < end && !isVowel(chars[start])) {\\n                start++;\\n            }\\n\\n            while (start < end && !isVowel(chars[end])) {\\n                end--;\\n            }\\n\\n            if (start < end) {\\n                swap(chars, start, end);\\n                start++;\\n                end--;\\n            }\\n\\n        }\\n\\n        return new String(chars);\\n    }\\n\\n    private void swap(char[] word, int start, int end){\\n        char temp = word[start];\\n        word[start] = word[end];\\n        word[end] = temp;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n                || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775348,
                "title": "daily-leetcoding-challenge-november-day-4",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-vowels-of-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-vowels-of-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 4011156,
                "title": "easy-python-solution",
                "content": "# Intuition\\nTwo pointer approach\\n\\n# Approach\\nSwapping left and right if they are vowels.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        n=len(s)\\n        left=0\\n        right=n-1\\n        vowels=set(\\'AEIOUaeiou\\')\\n        while left<right:\\n            while left<right and s[left] not in vowels:\\n                left+=1\\n            while left<right and s[right] not in vowels:\\n                right-=1\\n            s[left],s[right]=s[right],s[left]\\n            left+=1\\n            right-=1\\n        s=\\'\\'.join(s)\\n        return s\\n\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        n=len(s)\\n        left=0\\n        right=n-1\\n        vowels=set(\\'AEIOUaeiou\\')\\n        while left<right:\\n            while left<right and s[left] not in vowels:\\n                left+=1\\n            while left<right and s[right] not in vowels:\\n                right-=1\\n            s[left],s[right]=s[right],s[left]\\n            left+=1\\n            right-=1\\n        s=\\'\\'.join(s)\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81409,
                "title": "simple-java-solution-using-stringbuilder",
                "content": "    public class Solution {\\n    public String reverseVowels(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int j = s.length() - 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1)\\n            {\\n                while (j >= 0 && \"AEIOUaeiou\".indexOf(s.charAt(j)) == -1)\\n                {\\n                    j--;\\n                }\\n                sb.append(s.charAt(j));\\n                j--;\\n            }\\n            else\\n                sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int j = s.length() - 1;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1)\\n            {\\n                while (j >= 0 && \"AEIOUaeiou\".indexOf(s.charAt(j)) == -1)\\n                {\\n                    j--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2776456,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n          int strt = 0, end = s.size() - 1;\\n        char vow[256] = {0};\\n        vow[\\'a\\'] = 1, vow[\\'A\\'] = 1, vow[\\'e\\'] = 1, vow[\\'E\\'] = 1, vow[\\'i\\'] = 1, vow[\\'I\\'] = 1, vow[\\'o\\'] = 1, vow[\\'O\\'] = 1, vow[\\'u\\'] = 1, vow[\\'U\\'] = 1;\\n      \\n        while(strt < end){\\n            while(strt < end && vow[s[strt]] == 0) \\n                strt++;\\n            while(strt < end && vow[s[end]] == 0) \\n                end--;\\n            \\n            swap(s[strt],s[end]);\\n            strt++;end--;\\n        }\\n        return s;\\n    }\\n};\\n\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n          int strt = 0, end = s.size() - 1;\\n        char vow[256] = {0};\\n        vow[\\'a\\'] = 1, vow[\\'A\\'] = 1, vow[\\'e\\'] = 1, vow[\\'E\\'] = 1, vow[\\'i\\'] = 1, vow[\\'I\\'] = 1, vow[\\'o\\'] = 1, vow[\\'O\\'] = 1, vow[\\'u\\'] = 1, vow[\\'U\\'] = 1;\\n      \\n        while(strt < end){\\n            while(strt < end && vow[s[strt]] == 0) \\n                strt++;\\n            while(strt < end && vow[s[end]] == 0) \\n                end--;\\n            \\n            swap(s[strt],s[end]);\\n            strt++;end--;\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775879,
                "title": "very-easy-solution-using-stack",
                "content": "```\\n```\\n\\n```\\n```class Solution\\n{\\npublic:\\n \\xA0   string reverseVowels(string s)\\n    {\\n        stack<int> st;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n                st.push(s[i]);\\n        }\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\nComment if you have any doubt.Suggestions and feedback are welcomed.Happy Coding !!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2503097,
                "title": "python-easy-solution",
                "content": "Solution 1:\\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_vowel = [v for v in s if v in vowel] # [\\'e\\', \\'e\\', \\'o\\', \\'e\\']\\n        j=len(s_vowel)-1\\n        s_list = list(s)\\n        for i in range(len(s_list)):\\n            if s_list[i] in vowel:\\n                s_list[i] = s_vowel[j]\\n                j -=1\\n        return \"\".join(s_list)\\n```\\nSolution 2 (faster than 92%):\\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_list = list(s)\\n        start = 0\\n        last = len(s_list) - 1\\n        while start < last:\\n            if s_list[start] in vowel and s_list[last] in vowel:\\n                s_list[start], s_list[last] = s_list[last], s_list[start]\\n                start += 1\\n                last -= 1\\n            else:\\n                if s_list[start] not in vowel:\\n                    start += 1\\n                if s_list[last] not in vowel:\\n                    last -= 1\\n        return \"\".join(s_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_vowel = [v for v in s if v in vowel] # [\\'e\\', \\'e\\', \\'o\\', \\'e\\']\\n        j=len(s_vowel)-1\\n        s_list = list(s)\\n        for i in range(len(s_list)):\\n            if s_list[i] in vowel:\\n                s_list[i] = s_vowel[j]\\n                j -=1\\n        return \"\".join(s_list)\\n```\n```\\ndef reverseVowels(self, s: str) -> str: # s = \"leetcode\"\\n        vowel = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s_list = list(s)\\n        start = 0\\n        last = len(s_list) - 1\\n        while start < last:\\n            if s_list[start] in vowel and s_list[last] in vowel:\\n                s_list[start], s_list[last] = s_list[last], s_list[start]\\n                start += 1\\n                last -= 1\\n            else:\\n                if s_list[start] not in vowel:\\n                    start += 1\\n                if s_list[last] not in vowel:\\n                    last -= 1\\n        return \"\".join(s_list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130442,
                "title": "python-73ms",
                "content": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowel = {\\'a\\', \\'e\\', \\'i\\' ,\\'o\\',\\'u\\', \\'A\\', \\'E\\', \\'I\\' , \\'O\\', \\'U\\'}\\n        \\n        s = list(s)\\n        \\n        vpos=[]\\n        vword=[]\\n        \\n        for index, char in enumerate(s):\\n            if char in vowel:\\n                vpos.append(index)\\n                vword.append(char)\\n            \\n        for i in vpos:\\n            s[i]=vword.pop()\\n            \\n        return \"\".join(s)\\n            \\n            ",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowel = {\\'a\\', \\'e\\', \\'i\\' ,\\'o\\',\\'u\\', \\'A\\', \\'E\\', \\'I\\' , \\'O\\', \\'U\\'}",
                "codeTag": "Java"
            },
            {
                "id": 81377,
                "title": "my-4ms-solution-in-java-beats-98-20",
                "content": "        public static boolean isVowel(char a){\\n    \\t    switch(a){\\n    \\t         case ('a') : return true;\\n    \\t         case ('e') : return true;\\n    \\t         case ('i') : return true;\\n    \\t         case ('o') : return true;\\n    \\t         case ('u') : return true;\\n    \\t         case ('A') : return true;\\n    \\t         case ('E') : return true;\\n    \\t         case ('I') : return true;\\n    \\t         case ('O') : return true;\\n    \\t         case ('U') : return true;\\n    \\t         default : return false;\\n    \\t    }\\n        }\\n    \\n        public static String reverseVowels(String s) {\\n    \\t     if (s.length()<2) return s;\\n    \\t\\n    \\t     char[] tab = s.toCharArray();\\n    \\t     int j = tab.length - 1;\\n    \\t     int i = 0;\\n    \\t\\n    \\t     while( i < j ) {\\n\\n    \\t\\tif (!isVowel(tab[i]))\\n    \\t\\t\\ti++;\\t\\n    \\t\\telse {\\n    \\t\\t\\twhile (j!=i && !isVowel(tab[j]))\\n    \\t\\t\\t\\tj--;\\n    \\t\\t\\t\\n    \\t\\t\\tchar temp = tab[i];\\n    \\t\\t\\ttab[i] = tab[j];\\n    \\t\\t\\ttab[j] = temp;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn new String(tab);\\n    }",
                "solutionTags": [],
                "code": "        public static boolean isVowel(char a){\\n    \\t    switch(a){\\n    \\t         case ('a') : return true;\\n    \\t         case ('e') : return true;\\n    \\t         case ('i') : return true;\\n    \\t         case ('o') : return true;\\n    \\t         case ('u') : return true;\\n    \\t         case ('A') : return true;\\n    \\t         case ('E') : return true;\\n    \\t         case ('I') : return true;\\n    \\t         case ('O') : return true;\\n    \\t         case ('U') : return true;\\n    \\t         default : return false;\\n    \\t    }\\n        }\\n    \\n        public static String reverseVowels(String s) {\\n    \\t     if (s.length()<2) return s;\\n    \\t\\n    \\t     char[] tab = s.toCharArray();\\n    \\t     int j = tab.length - 1;\\n    \\t     int i = 0;\\n    \\t\\n    \\t     while( i < j ) {\\n\\n    \\t\\tif (!isVowel(tab[i]))\\n    \\t\\t\\ti++;\\t\\n    \\t\\telse {\\n    \\t\\t\\twhile (j!=i && !isVowel(tab[j]))\\n    \\t\\t\\t\\tj--;\\n    \\t\\t\\t\\n    \\t\\t\\tchar temp = tab[i];\\n    \\t\\t\\ttab[i] = tab[j];\\n    \\t\\t\\ttab[j] = temp;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn new String(tab);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1249797,
                "title": "simple-java-solution",
                "content": "```\\n public String reverseVowels(String s) {\\n        int x=0;\\n        int y=s.length()-1;\\n        \\n        List<Character> list=Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n       \\n        char[] arr=s.toCharArray();\\n        while(x<y){\\n            if(!list.contains(arr[x])){\\n                x++;\\n            }\\n            if(!list.contains(arr[y])){\\n                y--;\\n            }\\n            if(list.contains(arr[x]) && list.contains(arr[y])){\\n                char temp=arr[x];\\n                arr[x]=arr[y];\\n                arr[y]=temp;\\n                x++;\\n                y--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n public String reverseVowels(String s) {\\n        int x=0;\\n        int y=s.length()-1;\\n        \\n        List<Character> list=Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n       \\n        char[] arr=s.toCharArray();\\n        while(x<y){\\n            if(!list.contains(arr[x])){\\n                x++;\\n            }\\n            if(!list.contains(arr[y])){\\n                y--;\\n            }\\n            if(list.contains(arr[x]) && list.contains(arr[y])){\\n                char temp=arr[x];\\n                arr[x]=arr[y];\\n                arr[y]=temp;\\n                x++;\\n                y--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81388,
                "title": "5ms-java-two-pointer-solution",
                "content": "    public class Solution {\\n        public String reverseVowels(String s) {\\n            if (s == null) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (s.length() <= 1) {\\n                return s;\\n            }\\n            char[] str = s.toCharArray();\\n            for (int i = 0, j = str.length - 1; i < j; i++, j--) {\\n                while (i < j && !isVowel(str[i])) i++;\\n                while (i < j && !isVowel(str[j])) j--;\\n                if (i <= j) swap(str, i, j);\\n            }\\n            return new String(str);\\n        }\\n        private boolean isVowel(char ch) {\\n            char c = Character.toLowerCase(ch);\\n            return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n        }\\n        private void swap(char[] str, int i, int j) {\\n            char tmp = str[i];\\n            str[i] = str[j];\\n            str[j] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n        public String reverseVowels(String s) {\\n            if (s == null) {\\n                throw new IllegalArgumentException();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3602504,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe given problem is to reverse only the vowels in a given string. The vowels are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\', and they can appear in both lower and upper case.\\n\\n\\n# Approach\\nThe provided solution uses a two-pointer approach to reverse the vowels in the string. It initializes two pointers, start and end, at the beginning and end of the string, respectively. It also creates a list, vowels, that contains all the vowels (both lowercase and uppercase).\\n\\nThe solution converts the input string into a list, s, for easier manipulation. It then enters a while loop that continues until the start pointer surpasses the end pointer. Inside the loop, it checks if the character at s[start] is a vowel. If it is, it enters another nested while loop that moves the end pointer towards the start until it finds a vowel at s[end]. This helps in finding the corresponding vowel from the end of the string to swap with the vowel at the start.\\n\\nOnce a vowel is found at both the start and end pointers, the solution swaps them by using a temporary variable, aux. After the swap, both pointers are adjusted accordingly. The end pointer moves towards the start, and the start pointer moves towards the end.\\n\\nFinally, after the while loop, the solution reconstructs the modified list, s, into a string, res, by iterating over each character in s and appending it to res. This modified string is then returned as the output.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n The solution iterates through the string using two pointers, so the while loop runs until the pointers meet or cross each other. This takes O(n/2) time, where n is the length of the string. The process of swapping the vowels takes constant time. The reconstruction of the modified list into a string also takes O(n) time. Therefore, the overall time complexity of the solution is O(n).\\n\\n\\n- Space complexity:\\nThe solution uses additional space to store the modified list, s, and the final string, res. Both have a maximum size of n, where n is the length of the input string. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, word: str) -> str:\\n        start=0\\n        end=len(word)-1\\n        vowels= [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s=[word[i] for i in range(len(word))]\\n        while start<end:\\n            if s[start] in vowels:\\n                while start<end and s[end] not in vowels:\\n                    end-=1\\n                aux=s[start]\\n                s[start]=s[end]\\n                s[end]=aux\\n                end-=1\\n            start+=1\\n        res=\"\"\\n        for i in s:\\n            res+=i\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, word: str) -> str:\\n        start=0\\n        end=len(word)-1\\n        vowels= [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s=[word[i] for i in range(len(word))]\\n        while start<end:\\n            if s[start] in vowels:\\n                while start<end and s[end] not in vowels:\\n                    end-=1\\n                aux=s[start]\\n                s[start]=s[end]\\n                s[end]=aux\\n                end-=1\\n            start+=1\\n        res=\"\"\\n        for i in s:\\n            res+=i\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010246,
                "title": "javascript-two-pointer-approach",
                "content": "```\\nvar reverseVowels = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    let arr = s.split(\"\")\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \"I\", \\'O\\', \\'U\\']\\n    \\n    while(left < right){\\n        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1)\\n            {\\n                [arr[left], arr[right]] = [arr[right], arr[left]]\\n                ++left;\\n                --right;\\n            }\\n        if(vowels.indexOf(arr[left]) == -1){\\n            ++left\\n        }\\n        if(vowels.indexOf(arr[right]) == -1){\\n            --right\\n        }\\n    }\\n    return arr.join(\"\")\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    let arr = s.split(\"\")\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \"I\", \\'O\\', \\'U\\']\\n    \\n    while(left < right){\\n        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1)\\n            {\\n                [arr[left], arr[right]] = [arr[right], arr[left]]\\n                ++left;\\n                --right;\\n            }\\n        if(vowels.indexOf(arr[left]) == -1){\\n            ++left\\n        }\\n        if(vowels.indexOf(arr[right]) == -1){\\n            --right\\n        }\\n    }\\n    return arr.join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669092,
                "title": "easy-solution-with-stack",
                "content": "\\n# Complexity\\n\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        var str = new StringBuilder();\\n        var l = new Stack<char>();\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                l.Push(i);\\n        }\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                str.Append(l.Pop());\\n            else\\n                str.Append(i);\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        var str = new StringBuilder();\\n        var l = new Stack<char>();\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                l.Push(i);\\n        }\\n\\n        foreach(var i in s){\\n            if(\"aeiouAEIOU\".Contains(i))\\n                str.Append(l.Pop());\\n            else\\n                str.Append(i);\\n        }\\n        \\n        return str.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777180,
                "title": "c-two-pointers-clean-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nWe simply used two pointers to swap the vowels from left and right . \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool vowel(char c)\\n   {\\n       return (c==\\'a\\' || c==\\'A\\' || c==\\'E\\' || c==\\'e\\' || c==\\'i\\' || c==\\'I\\' || c==\\'o\\' || c==\\'O\\' ||c==\\'u\\' || c==\\'U\\');\\n   }\\n    string reverseVowels(string s) {\\n        int l=0 , r=s.length()-1;\\n        while(l<r)\\n        {\\n            while(l<r && !vowel(s[l])) l++;\\n            while(l<r && !vowel(s[r])) r--;\\n            if(l<r) swap(s[l++],s[r--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool vowel(char c)\\n   {\\n       return (c==\\'a\\' || c==\\'A\\' || c==\\'E\\' || c==\\'e\\' || c==\\'i\\' || c==\\'I\\' || c==\\'o\\' || c==\\'O\\' ||c==\\'u\\' || c==\\'U\\');\\n   }\\n    string reverseVowels(string s) {\\n        int l=0 , r=s.length()-1;\\n        while(l<r)\\n        {\\n            while(l<r && !vowel(s[l])) l++;\\n            while(l<r && !vowel(s[r])) r--;\\n            if(l<r) swap(s[l++],s[r--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776192,
                "title": "intuitive-two-pointer-approach-o-n-o-1",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- We have to reverse the vowels present in the string, so we\\'ll  -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo reverse the vowels of the given string, we\\'ll follow two pointers approach. We\\'ll keep the two pointers `i=0` and `j=s.length()-1`; we\\'ll search for the vowels by incrementing `i` and decrementing `j`; if found, swap. We\\'ll perform this action while `i<j`. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we\\'ll go through the whole string once.\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere we are using only `unordered_set<char> st` to store vowels and perform a better search independent of the size of `string s` so space complexity is of constant order.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        unordered_set<char> st = {\\'a\\',\\'A\\', \\'e\\', \\'E\\', \\'i\\', \\'I\\', \\'o\\', \\'O\\', \\'u\\', \\'U\\'};\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            while(!st.count(s[i]) && i<j){\\n                i++;\\n            }\\n            while(!st.count(s[j]) && i<j) j--;\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        unordered_set<char> st = {\\'a\\',\\'A\\', \\'e\\', \\'E\\', \\'i\\', \\'I\\', \\'o\\', \\'O\\', \\'u\\', \\'U\\'};\\n        int i=0, j=s.length()-1;\\n        while(i<j){\\n            while(!st.count(s[i]) && i<j){\\n                i++;\\n            }\\n            while(!st.count(s[j]) && i<j) j--;\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775402,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        char currCh = tolower(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (currCh == \\'a\\' || currCh == \\'e\\' || currCh == \\'i\\' || currCh == \\'o\\' || currCh == \\'u\\') return true;\\n        return false;\\n    }\\n    string reverseVowels(string s)\\n    {\\n        int n = s.size();\\n        int low = 0, high = n - 1;\\n        while(low < high)\\n        {\\n            bool isLowVowel = isVowel(s[low]);\\n            bool isHighVowel = isVowel(s[high]);\\n            if (isLowVowel && isHighVowel) //consider swapping only when both s[low] and s[high] are vowels\\n            {\\n                swap(s[low], s[high]);\\n                low++; high--; //move low to right, high to left as we have swapped them\\n            }\\n            else if (!isLowVowel) low++; //if s[low] is not a vowel keep traversing to right in search of a vowel\\n            else if (!isHighVowel) high--; //if s[high] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        char currCh = tolower(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (currCh == \\'a\\' || currCh == \\'e\\' || currCh == \\'i\\' || currCh == \\'o\\' || currCh == \\'u\\') return true;\\n        return false;\\n    }\\n    string reverseVowels(string s)\\n    {\\n        int n = s.size();\\n        int low = 0, high = n - 1;\\n        while(low < high)\\n        {\\n            bool isLowVowel = isVowel(s[low]);\\n            bool isHighVowel = isVowel(s[high]);\\n            if (isLowVowel && isHighVowel) //consider swapping only when both s[low] and s[high] are vowels\\n            {\\n                swap(s[low], s[high]);\\n                low++; high--; //move low to right, high to left as we have swapped them\\n            }\\n            else if (!isLowVowel) low++; //if s[low] is not a vowel keep traversing to right in search of a vowel\\n            else if (!isHighVowel) high--; //if s[high] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445341,
                "title": "javascript-solution-with-a-stack",
                "content": "```\\nvar reverseVowels = function(s) {\\n  let vowels = [\"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"]\\n  let stack = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      stack.push(s[i])\\n    }\\n  }\\n  let ans = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      ans.push(stack.pop())\\n    } else {\\n      ans.push(s[i])\\n    }\\n  }\\n  return ans.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n  let vowels = [\"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"]\\n  let stack = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      stack.push(s[i])\\n    }\\n  }\\n  let ans = []\\n  for (let i = 0; i < s.length; i++) {\\n    if (vowels.indexOf(s[i]) !== -1) {\\n      ans.push(stack.pop())\\n    } else {\\n      ans.push(s[i])\\n    }\\n  }\\n  return ans.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607705,
                "title": "easy-java-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity : O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String t = \"\";\\n        String e = \"\";\\n        for(int i=0;i<s.length();i++){\\n         char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n              e = ch+e;\\n        }\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n        char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n               t+=e.charAt(j);\\n               j++;\\n            }\\n            else\\n            t+=ch;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String t = \"\";\\n        String e = \"\";\\n        for(int i=0;i<s.length();i++){\\n         char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n              e = ch+e;\\n        }\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n        char ch = s.charAt(i);\\n        if(ch ==\\'a\\'||ch == \\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\'){\\n               t+=e.charAt(j);\\n               j++;\\n            }\\n            else\\n            t+=ch;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523609,
                "title": "java-solution-for-reverse-vowels-of-a-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to reverse the vowels in the input string s. The intuition is to use two pointers, i and j, to traverse the string from both ends, swapping the vowels as they are encountered.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an ArrayList vowList containing all the vowels (both lowercase and uppercase).\\n2. Convert the input string s to a character array arr.\\n3. Initialize two pointers, i at the beginning of the array and j at the end.\\n4. Traverse the array using the two pointers: a. If the character at i is not a vowel, increment i. b. If the character at j is not a vowel, decrement j. c. If both characters at i and j are vowels, swap them and update i and j.\\n5. Continue the traversal until i and j meet or cross each other.\\n6. Convert the modified character array back to a string and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string s. The algorithm iterates through the string once, with each character being visited at most twice (once by i and once by j).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for the character array arr created from the input string s. The space required for the vowList ArrayList is constant, as it only contains a fixed number of vowels\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowList = new ArrayList<Character>();\\n        vowList.add(\\'a\\');\\n        vowList.add(\\'e\\');\\n        vowList.add(\\'i\\');\\n        vowList.add(\\'o\\');\\n        vowList.add(\\'u\\');\\n        vowList.add(\\'A\\');\\n        vowList.add(\\'E\\');\\n        vowList.add(\\'I\\');\\n        vowList.add(\\'O\\');\\n        vowList.add(\\'U\\');\\n        char[] arr = s.toCharArray();\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(!vowList.contains(arr[i]))\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(!vowList.contains(arr[j]))\\n            {\\n                j--;\\n                continue;\\n            }\\n        char t = arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        i++;\\n        j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowList = new ArrayList<Character>();\\n        vowList.add(\\'a\\');\\n        vowList.add(\\'e\\');\\n        vowList.add(\\'i\\');\\n        vowList.add(\\'o\\');\\n        vowList.add(\\'u\\');\\n        vowList.add(\\'A\\');\\n        vowList.add(\\'E\\');\\n        vowList.add(\\'I\\');\\n        vowList.add(\\'O\\');\\n        vowList.add(\\'U\\');\\n        char[] arr = s.toCharArray();\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(!vowList.contains(arr[i]))\\n            {\\n                i++;\\n                continue;\\n            }\\n            if(!vowList.contains(arr[j]))\\n            {\\n                j--;\\n                continue;\\n            }\\n        char t = arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        i++;\\n        j--;\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777575,
                "title": "simple-two-pointer-solution-easy-to-understand",
                "content": "\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake Two pointers i, j.\\nMove i from start and j from end and kept on moving both the pointers until consonents are there, stop when vowels are found.\\nSwap the vowels and do i++ and j-- . \\nMove until i<j .\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) for creating char array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i<j){\\n            while(i<j){\\n            if(contains(arr[i])) break;\\n            i++;\\n            }\\n            while(j>i){\\n            if(contains(arr[j])) break;\\n                j--; \\n            }\\n            if(i >= j) return String.valueOf(arr);\\n            swap(arr,i,j);\\n            i++;j--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n    public void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public boolean contains(char c){\\n       char[] vowels = new char[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n       for(int i = 0; i<10; i++){\\n           if(c == vowels[i]) return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i<j){\\n            while(i<j){\\n            if(contains(arr[i])) break;\\n            i++;\\n            }\\n            while(j>i){\\n            if(contains(arr[j])) break;\\n                j--; \\n            }\\n            if(i >= j) return String.valueOf(arr);\\n            swap(arr,i,j);\\n            i++;j--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n    public void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    public boolean contains(char c){\\n       char[] vowels = new char[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'};\\n       for(int i = 0; i<10; i++){\\n           if(c == vowels[i]) return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118355,
                "title": "java-simple-solution",
                "content": "JAVA CODE IS:\\n#   \\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char arr[]=s.toCharArray();\\n        Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int l=0,r=s.length()-1;\\n        while(l<r){\\n          if(vowel.contains(arr[l])&&vowel.contains(arr[r])){\\n              char t=arr[l];\\n              arr[l++]=arr[r];\\n              arr[r--]=t;\\n          }\\n          else if(!vowel.contains(arr[l])&&!vowel.contains(arr[r])){\\n              l++;\\n              r--;\\n          }\\n          else if(!vowel.contains(arr[l])&&vowel.contains(arr[r])) l++;\\n          else r--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1)\\n*****PLEASE,UPVOTE IF THIS IS HELPFUL*****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char arr[]=s.toCharArray();\\n        Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int l=0,r=s.length()-1;\\n        while(l<r){\\n          if(vowel.contains(arr[l])&&vowel.contains(arr[r])){\\n              char t=arr[l];\\n              arr[l++]=arr[r];\\n              arr[r--]=t;\\n          }\\n          else if(!vowel.contains(arr[l])&&!vowel.contains(arr[r])){\\n              l++;\\n              r--;\\n          }\\n          else if(!vowel.contains(arr[l])&&vowel.contains(arr[r])) l++;\\n          else r--;\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296384,
                "title": "one-liner-efficient-python-solution-beats-99-97-explained",
                "content": "\\n\\n# SOLUTION\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'[aeiouAEIOU]\\', s)\\n        return re.sub(\\'[aeiouAEIOU]\\', lambda _ : vowels.pop(), s)\\n\\n\\n```\\n# STEP-BY-STEP EXPLANATION \\n1. The \"re.findall()\" method is used to find all the vowels in the input string s using a regular expression pattern. The pattern [aeiouAEIOU] matches any lowercase or uppercase vowel.\\n\\n2. The resulting list of vowels is stored in the variable \"vowels\".\\n\\n3. The \"re.sub()\" method is used to replace all vowels in the input string s with a replacement string that is generated using a lambda function.\\n\\n4. The lambda function takes a match object \"_\" as its argument and returns the next vowel from the vowels list using the \"pop()\" method. The pop() method removes the last element from the list and returns it.\\n\\n5.  \"re.sub()\" method replaces each vowel in s with the corresponding vowel from the vowels list in reverse order, effectively reversing the order of the vowels in the string.\\n\\n6. The modified string is returned by the reverseVowels method.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'[aeiouAEIOU]\\', s)\\n        return re.sub(\\'[aeiouAEIOU]\\', lambda _ : vowels.pop(), s)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777208,
                "title": "c-most-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        stack<char> stack;    // stores all the vowels in the order they are present in the string\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            \\n        }\\n        string ans; // will  store the answer string\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                ans.push_back(stack.top()); // whenever any vowels come in the string , we put the stack\\'s top most element which will the last vowels from opposite side of the string\\n                stack.pop(); // after putting the string --> removing the top most element\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if it\\'s not a vowels then we just push the element into out ans string\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        stack<char> stack;    // stores all the vowels in the order they are present in the string\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                stack.push(s[i]);\\n            }\\n            \\n        }\\n        string ans; // will  store the answer string\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                ans.push_back(stack.top()); // whenever any vowels come in the string , we put the stack\\'s top most element which will the last vowels from opposite side of the string\\n                stack.pop(); // after putting the string --> removing the top most element\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if it\\'s not a vowels then we just push the element into out ans string\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776937,
                "title": "short-and-easy-one-pass-solution",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string ReverseVowels(string s)\\n    {\\n        var vowels = \"aeiouAEIOU\";\\n        var extract = s.Where(c => vowels.Contains(c)).Reverse().ToArray();\\n        var res = s.ToCharArray();\\n\\n        int v = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (vowels.Contains(s[i]))\\n            {\\n                res[i] = extract[v++];\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```\\n1. Extract the vowels from the input string and put them in the reversed order.\\n2. Iterate over the characters in the input string and replace each vowel with the vowel from Step 1.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string ReverseVowels(string s)\\n    {\\n        var vowels = \"aeiouAEIOU\";\\n        var extract = s.Where(c => vowels.Contains(c)).Reverse().ToArray();\\n        var res = s.ToCharArray();\\n\\n        int v = 0;\\n\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (vowels.Contains(s[i]))\\n            {\\n                res[i] = extract[v++];\\n            }\\n        }\\n\\n        return new string(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775427,
                "title": "daily-leetcode-solution-one-pass-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        if(n==0||n==1) return s;\\n        if(s==\" \") return s;\\n        while(i<=j&&i!=n&&j!=-1)\\n        {\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[i])) i++;\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[j])) j--;\\n            if(i<=j&&i!=n&&j!=-1)\\n            {\\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'||ch==\\'A\\'||ch==\\'E\\'||ch==\\'I\\'||ch==\\'O\\'||ch==\\'U\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        if(n==0||n==1) return s;\\n        if(s==\" \") return s;\\n        while(i<=j&&i!=n&&j!=-1)\\n        {\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[i])) i++;\\n            while(i!=n&&j!=-1&&i<=j&&!isVowel(s[j])) j--;\\n            if(i<=j&&i!=n&&j!=-1)\\n            {\\n                swap(s[i],s[j]);\\n            }\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449971,
                "title": "typescript-beats-100-two-pointers",
                "content": "```\\nfunction reverseVowels(s: string): string {\\n  let start = 0;\\n  let end = s.length - 1;\\n  const VOWELS = new Set([\"a\", \"i\", \"u\", \"e\", \"o\",\"A\", \"I\", \"U\", \"E\", \"O\"])\\n  const ans = [...s];\\n  while(start < end){\\n    if(!VOWELS.has(ans[start]))\\n      start++;\\n    if(!VOWELS.has(ans[end]))\\n      end--;\\n    if(VOWELS.has(ans[start]) && VOWELS.has(ans[end])){\\n      const temp = ans[start];\\n      ans[start] = ans[end];\\n      ans[end] = temp;\\n      start++\\n      end--;\\n    }\\n  }\\n  return ans.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction reverseVowels(s: string): string {\\n  let start = 0;\\n  let end = s.length - 1;\\n  const VOWELS = new Set([\"a\", \"i\", \"u\", \"e\", \"o\",\"A\", \"I\", \"U\", \"E\", \"O\"])\\n  const ans = [...s];\\n  while(start < end){\\n    if(!VOWELS.has(ans[start]))\\n      start++;\\n    if(!VOWELS.has(ans[end]))\\n      end--;\\n    if(VOWELS.has(ans[start]) && VOWELS.has(ans[end])){\\n      const temp = ans[start];\\n      ans[start] = ans[end];\\n      ans[end] = temp;\\n      start++\\n      end--;\\n    }\\n  }\\n  return ans.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81356,
                "title": "javascript-solution",
                "content": "```\\nvar reverseVowels = function(s) {\\n    if(s === null || s.length === 0) {\\n        return s;\\n    }\\n    var chars = s.split('');\\n    var low = 0;\\n    var high = s.length - 1;\\n    var vowels = \"aeiouAEIOU\";\\n    var tmp;\\n    while(low < high) {\\n        while(low < high && vowels.indexOf(chars[low]) === -1) {\\n            low++;\\n        }\\n        \\n        while(low < high && vowels.indexOf(chars[high]) === -1) {\\n            high--;\\n        }\\n        \\n        tmp = chars[high];\\n        chars[high] = chars[low];\\n        chars[low] = tmp;\\n        low++;\\n        high--;\\n    }\\n    \\n    return chars.join('');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseVowels = function(s) {\\n    if(s === null || s.length === 0) {\\n        return s;\\n    }\\n    var chars = s.split('');\\n    var low = 0;\\n    var high = s.length - 1;\\n    var vowels = \"aeiouAEIOU\";\\n    var tmp;\\n    while(low < high) {\\n        while(low < high && vowels.indexOf(chars[low]) === -1) {\\n            low++;\\n        }\\n        \\n        while(low < high && vowels.indexOf(chars[high]) === -1) {\\n            high--;\\n        }\\n        \\n        tmp = chars[high];\\n        chars[high] = chars[low];\\n        chars[low] = tmp;\\n        low++;\\n        high--;\\n    }\\n    \\n    return chars.join('');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057153,
                "title": "easy-c-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n## **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe reverseVowels function takes a string s as input and returns a new string where only the vowels in the input string are reversed, while the consonants remain in their original positions.\\n\\nHere\\'s an approach to understand how this code works:\\n\\nisVowel Function:\\n\\n- This function takes a character c as input and checks whether it is a vowel.\\n- It does this by comparing c to a list of lowercase and uppercase vowel characters (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\') using logical OR (||) operators.\\n- If c matches any of these characters, the function returns true, indicating that c is a vowel; otherwise, it returns false.\\nreverseVowels Function:\\n\\n- This function takes a string s as input and aims to reverse the order of vowels within the string.\\n- It initializes two pointers, i and j, to the beginning and end of the string, respectively.\\n- It enters a while loop that continues as long as i is less than j, indicating that there are more characters to process.\\n- Inside the loop:\\n-  It advances the pointer i to the right (towards the end of the string) until it finds a vowel using the isVowel function.\\n- It advances the pointer j to the left (towards the beginning of the string) until it finds a vowel using the isVowel function.\\n- Once both i and j have found vowels or i is no longer less than j, the loop continues.\\n- It then swaps the vowels found at positions i and j in the string s to reverse their order.\\n- After the swap, it increments i and decrements j to move the pointers closer to each other.\\n- The loop continues until i is no longer less than j, at which point all the vowels in the string have been reversed.\\n- Finally, the modified string s is returned as the result.\\nOverall, this code efficiently reverses the order of vowels in a given string while keeping the consonants in their original positions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n                c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\');\\n    }\\n    string reverseVowels(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i < j) {\\n            while (i < j && !isVowel(s[i])) {\\n                i++;\\n            }\\n            while (i < j && !isVowel(s[j])) {\\n                j--;\\n            }\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n                c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\');\\n    }\\n    string reverseVowels(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while (i < j) {\\n            while (i < j && !isVowel(s[i])) {\\n                i++;\\n            }\\n            while (i < j && !isVowel(s[j])) {\\n                j--;\\n            }\\n            swap(s[i], s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909601,
                "title": "easiest-two-pointer-approach-to-reverse-vowels-of-a-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution involves using a two-pointer approach to reverse the vowels in the given string. The idea is to find pairs of vowels from both ends of the string and swap them until the pointers meet in the middle. By swapping only the vowel characters, the non-vowel characters will remain in their original positions.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, l and r, pointing to the start and end of the string respectively.\\n2. Create a list of vowel characters, both lowercase and uppercase.\\n3. Convert the input string into a list of characters for ease of swapping.\\n4. Iterate through the string using the two-pointer approach:\\n    - If the character at position l is not a vowel, increment l.\\n    - If the character at position r is not a vowel, decrement r.\\n    - If both characters at positions l and r are vowels, swap them and then increment l and decrement r.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe two-pointer approach iterates through the string once, so the time complexity is O(n), where n is the length of the input string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses additional space to store the list of characters, which takes O(n) space, where n is the length of the input string.\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l = 0\\n        r = len(s) - 1\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        s = list(s)\\n        while (l < r):\\n            if s[l].lower() not in vowels:\\n                l += 1\\n            elif s[r].lower() not in vowels:\\n                r -= 1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l += 1\\n                r -= 1\\n        return \"\".join(s)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l = 0\\n        r = len(s) - 1\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        s = list(s)\\n        while (l < r):\\n            if s[l].lower() not in vowels:\\n                l += 1\\n            elif s[r].lower() not in vowels:\\n                r -= 1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l += 1\\n                r -= 1\\n        return \"\".join(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646561,
                "title": "the-shortest-solution",
                "content": "# Code\\n```\\nconst reverseVowels = function(s) {\\n    const vow = s.match(/[aeiou]/gi);\\n    return s.replace(/[aeiou]/ig, el=> vow.pop());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseVowels = function(s) {\\n    const vow = s.match(/[aeiou]/gi);\\n    return s.replace(/[aeiou]/ig, el=> vow.pop());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546210,
                "title": "python-solution-beats-72-38-60ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe traverse the list from left and right till we find a vowel from both the directions \\nthen we swap them and search for the next pair of vowels \\nthis process repeats till left crosses right\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        left,right=0,len(s)-1\\n        v=\\'aeiouAEIOU\\'\\n        s=list(s)\\n        while left<right:\\n            if s[left] not in v:\\n                left+=1\\n            if s[right] not in v:\\n                right-=1    \\n            if s[left] in v  and s[right] in v :\\n                s[left],s[right]=s[right],s[left]\\n\\n                left+=1\\n                right-=1\\n        return \\'\\'.join(s) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        left,right=0,len(s)-1\\n        v=\\'aeiouAEIOU\\'\\n        s=list(s)\\n        while left<right:\\n            if s[left] not in v:\\n                left+=1\\n            if s[right] not in v:\\n                right-=1    \\n            if s[left] in v  and s[right] in v :\\n                s[left],s[right]=s[right],s[left]\\n\\n                left+=1\\n                right-=1\\n        return \\'\\'.join(s) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246282,
                "title": "345-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe reverseVowels function takes a string s as input and returns a new string with all the vowels in s reversed.\\n\\nFirst, a set of all vowels is created, including both lowercase and uppercase vowels. Then, the input string s is converted to a list of characters using the list() function, since strings are immutable in Python.\\n\\nTwo pointers, left and right, are used to iterate through the list from both ends towards the middle. If both characters at the current positions are vowels, they are swapped. If only the character at left is a vowel, right is decremented. If only the character at right is a vowel, left is incremented. If neither character is a vowel, both pointers are moved towards the middle. This process continues until left >= right.\\n\\nFinally, the modified list is converted back into a string using the \"\".join() method and returned as the output of the function.\\n\\n# Complexity\\n- Time complexity:\\n86.71%\\n\\n- Space complexity:\\n80.34%\\n\\n# Code\\n```\\nclass Solution:\\n  def reverseVowels(self, s: str) -> str:\\n    vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n    # Convert string to list since string is immutable in Python\\n    s_list = list(s)\\n    left, right = 0, len(s_list) - 1\\n    while left < right:\\n        if s_list[left] in vowels and s_list[right] in vowels:\\n        # Swap the vowels\\n            s_list[left], s_list[right] = s_list[right], s_list[left]\\n            left += 1\\n            right -= 1\\n        elif s_list[left] in vowels:\\n            right -= 1\\n        elif s_list[right] in vowels:\\n            left += 1\\n        else:\\n            left += 1\\n            right -= 1\\n        # Convert the list back to string and return\\n    return \"\".join(s_list)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def reverseVowels(self, s: str) -> str:\\n    vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n    # Convert string to list since string is immutable in Python\\n    s_list = list(s)\\n    left, right = 0, len(s_list) - 1\\n    while left < right:\\n        if s_list[left] in vowels and s_list[right] in vowels:\\n        # Swap the vowels\\n            s_list[left], s_list[right] = s_list[right], s_list[left]\\n            left += 1\\n            right -= 1\\n        elif s_list[left] in vowels:\\n            right -= 1\\n        elif s_list[right] in vowels:\\n            left += 1\\n        else:\\n            left += 1\\n            right -= 1\\n        # Convert the list back to string and return\\n    return \"\".join(s_list)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171202,
                "title": "c-4-line-code-easiest-solution-for-this-problem",
                "content": "Please upvote if you found this helpful ;)\\n```\\nstring reverseVowels(string s) {\\n        for(int i=0,j=s.size()-1;i<j;){\\n            while(s[i]!=\\'a\\'&&s[i]!=\\'e\\'&&s[i]!=\\'i\\'&&s[i]!=\\'o\\'&&s[i]!=\\'u\\'&&s[i]!=\\'A\\'&&s[i]!=\\'E\\'&&s[i]!=\\'I\\'&&s[i]!=\\'O\\'&&s[i]!=\\'U\\'&&i<j) i++;\\n            while(s[j]!=\\'a\\'&&s[j]!=\\'e\\'&&s[j]!=\\'i\\'&&s[j]!=\\'o\\'&&s[j]!=\\'u\\'&&s[j]!=\\'A\\'&&s[j]!=\\'E\\'&&s[j]!=\\'I\\'&&s[j]!=\\'O\\'&&s[j]!=\\'U\\'&&j>i) j--;\\n            swap(s[i++],s[j--]);     \\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please upvote if you found this helpful ;)\\n```\\nstring reverseVowels(string s) {\\n        for(int i=0,j=s.size()-1;i<j;){\\n            while(s[i]!=\\'a\\'&&s[i]!=\\'e\\'&&s[i]!=\\'i\\'&&s[i]!=\\'o\\'&&s[i]!=\\'u\\'&&s[i]!=\\'A\\'&&s[i]!=\\'E\\'&&s[i]!=\\'I\\'&&s[i]!=\\'O\\'&&s[i]!=\\'U\\'&&i<j) i++;\\n            while(s[j]!=\\'a\\'&&s[j]!=\\'e\\'&&s[j]!=\\'i\\'&&s[j]!=\\'o\\'&&s[j]!=\\'u\\'&&s[j]!=\\'A\\'&&s[j]!=\\'E\\'&&s[j]!=\\'I\\'&&s[j]!=\\'O\\'&&s[j]!=\\'U\\'&&j>i) j--;\\n            swap(s[i++],s[j--]);     \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2950475,
                "title": "fastest-solution-two-pointers-o-n-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isVowel(char c)\\n    {\\n        return (c == \\'a\\' || c == \\'A\\' || c == \\'e\\'\\n                || c == \\'E\\' || c == \\'i\\' || c == \\'I\\'\\n                || c == \\'o\\' || c == \\'O\\' || c == \\'u\\'\\n                || c == \\'U\\');\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        int start=0,end=s.length()-1;\\n        String st = \"aeiouAEIOU\";\\n        char[] str=s.toCharArray();\\n        \\n        while(start<end)\\n        {\\n            if (!isVowel(str[start]))\\n            {\\n                start++;\\n                continue;\\n            }\\n            if (!isVowel(str[end]))\\n            {\\n                end--;\\n                continue;\\n            }\\n            char temp = str[start];\\n            str[start]= str[end];\\n            str[end]= temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        String str2 = String.copyValueOf(str);\\n        return str2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public boolean isVowel(char c)\\n    {\\n        return (c == \\'a\\' || c == \\'A\\' || c == \\'e\\'\\n                || c == \\'E\\' || c == \\'i\\' || c == \\'I\\'\\n                || c == \\'o\\' || c == \\'O\\' || c == \\'u\\'\\n                || c == \\'U\\');\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        int start=0,end=s.length()-1;\\n        String st = \"aeiouAEIOU\";\\n        char[] str=s.toCharArray();\\n        \\n        while(start<end)\\n        {\\n            if (!isVowel(str[start]))\\n            {\\n                start++;\\n                continue;\\n            }\\n            if (!isVowel(str[end]))\\n            {\\n                end--;\\n                continue;\\n            }\\n            char temp = str[start];\\n            str[start]= str[end];\\n            str[end]= temp;\\n            \\n            start++;\\n            end--;\\n        }\\n        String str2 = String.copyValueOf(str);\\n        return str2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778770,
                "title": "python-2-liner-no-regex",
                "content": "Use `iter` to get a generator for the vowels in reverse order. When you reach a vowel, ask for the next element. Since the number of vowels won\\'t change, `vowels` will always have the character you need.\\n```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = iter(c for c in s[::-1] if c.lower() in \\'aeiou\\')\\n        return \"\".join(next(vowels) if c.lower() in \\'aeiou\\' else c for c in s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = iter(c for c in s[::-1] if c.lower() in \\'aeiou\\')\\n        return \"\".join(next(vowels) if c.lower() in \\'aeiou\\' else c for c in s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777029,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        if(s.empty()) return s;\\n        set<char>v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        string a = \"\";\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(v.count(s[i])) a+=s[i];\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(v.count(s[i])) s[i] = a[x++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        if(s.empty()) return s;\\n        set<char>v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        string a = \"\";\\n        int x = 0;\\n        for(int i = s.size() - 1; i >= 0; i--){\\n            if(v.count(s[i])) a+=s[i];\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(v.count(s[i])) s[i] = a[x++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776205,
                "title": "one-pass-o-1-space-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust like we use two pointer in reverse a string problem. Start pointers from start and end , if we find vowels on both indices , exchange the characters. I used unordered set to check if a char is vowel in O(1).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        int i =0,j= s.size()-1;\\n        unordered_set<char> v({\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'});\\n        \\n        while(i<j){\\n           if(v.find(s[i])!=v.end() && v.find(s[j])!=v.end()){ \\n               char x = s[i];\\n               s[i]=s[j],s[j]=x;\\n               i++,j--;\\n           }\\n           else if(v.find(s[i])==v.end())i++;\\n           else\\n               j--;\\n        }\\n\\n        return s;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        int i =0,j= s.size()-1;\\n        unordered_set<char> v({\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'});\\n        \\n        while(i<j){\\n           if(v.find(s[i])!=v.end() && v.find(s[j])!=v.end()){ \\n               char x = s[i];\\n               s[i]=s[j],s[j]=x;\\n               i++,j--;\\n           }\\n           else if(v.find(s[i])==v.end())i++;\\n           else\\n               j--;\\n        }\\n\\n        return s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776072,
                "title": "java-easy-and-clean-soln-using-hashset-and-2-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        HashSet<Character> set=new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n        set.add(\\'A\\');\\n        set.add(\\'E\\');\\n        set.add(\\'I\\');\\n        set.add(\\'O\\');\\n        set.add(\\'U\\');\\n        while(i<j){\\n           // System.out.println(sb);\\n            char a=s.charAt(i);\\n            char b=s.charAt(j);\\n            if(set.contains(a) ){\\n                if(set.contains(b)){\\n                    sb.replace(i,i+1,\"\"+b);\\n                    sb.replace(j,j+1,\"\"+a);\\n                    i++;\\n                } \\n                j--;\\n            }\\n            else if(set.contains(b)){\\n                i++;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        HashSet<Character> set=new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n        set.add(\\'A\\');\\n        set.add(\\'E\\');\\n        set.add(\\'I\\');\\n        set.add(\\'O\\');\\n        set.add(\\'U\\');\\n        while(i<j){\\n           // System.out.println(sb);\\n            char a=s.charAt(i);\\n            char b=s.charAt(j);\\n            if(set.contains(a) ){\\n                if(set.contains(b)){\\n                    sb.replace(i,i+1,\"\"+b);\\n                    sb.replace(j,j+1,\"\"+a);\\n                    i++;\\n                } \\n                j--;\\n            }\\n            else if(set.contains(b)){\\n                i++;\\n            }\\n            else{\\n                i++;\\n                j--;\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775900,
                "title": "java-beats-100-easy-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate isVowel function which will accept char as argument and will tell it is vowel or not.\\nuse Two pointers concept and initialize pointers start=0 and end=length-1. swap first vowel with last, second vowel with second last and so on... till star<end\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity:O(N) as we are using extra char array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String str) {\\n        int n=str.length();\\n        char [] ch=str.toCharArray();\\n\\n        int start=0,end=n-1;\\n        while(start<end){\\n            while(start<end && !isVowel(ch[start])){\\n                start++;\\n            }\\n            while(start<end && !isVowel(ch[end])){\\n                end--;\\n            }\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowel(char chr){\\n        if(chr==\\'a\\' || chr==\\'e\\' || chr==\\'i\\' || chr==\\'o\\' ||chr==\\'u\\' \\n        || chr==\\'A\\' || chr==\\'E\\' || chr==\\'I\\' || chr==\\'O\\' || chr==\\'U\\'){\\n                return true;\\n            }\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String str) {\\n        int n=str.length();\\n        char [] ch=str.toCharArray();\\n\\n        int start=0,end=n-1;\\n        while(start<end){\\n            while(start<end && !isVowel(ch[start])){\\n                start++;\\n            }\\n            while(start<end && !isVowel(ch[end])){\\n                end--;\\n            }\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowel(char chr){\\n        if(chr==\\'a\\' || chr==\\'e\\' || chr==\\'i\\' || chr==\\'o\\' ||chr==\\'u\\' \\n        || chr==\\'A\\' || chr==\\'E\\' || chr==\\'I\\' || chr==\\'O\\' || chr==\\'U\\'){\\n                return true;\\n            }\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775583,
                "title": "using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char>st;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                char c = st.top();\\n                st.pop();\\n                s[i] = c;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char>st;\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0; i < s.size(); ++i){\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\'){\\n                char c = st.top();\\n                st.pop();\\n                s[i] = c;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962990,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn reverse_vowels(s: String) -> String {\\n        let is_vowel = |b: u8| matches!(b, b\\'a\\' | b\\'e\\' | b\\'i\\' | b\\'o\\' | b\\'u\\' | b\\'A\\' | b\\'E\\' | b\\'I\\' | b\\'O\\' | b\\'U\\');\\n        let mut vb = s.into_bytes();\\n        let (mut i, mut j) = (0, vb.len() - 1);\\n        while i < j {\\n            while i < j && !is_vowel(vb[i]) {\\n                i += 1;\\n            }\\n            while i < j && !is_vowel(vb[j]) {\\n                j -= 1;\\n            }\\n            if i < j {\\n                vb.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        }\\n        String::from_utf8(vb).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_vowels(s: String) -> String {\\n        let is_vowel = |b: u8| matches!(b, b\\'a\\' | b\\'e\\' | b\\'i\\' | b\\'o\\' | b\\'u\\' | b\\'A\\' | b\\'E\\' | b\\'I\\' | b\\'O\\' | b\\'U\\');\\n        let mut vb = s.into_bytes();\\n        let (mut i, mut j) = (0, vb.len() - 1);\\n        while i < j {\\n            while i < j && !is_vowel(vb[i]) {\\n                i += 1;\\n            }\\n            while i < j && !is_vowel(vb[j]) {\\n                j -= 1;\\n            }\\n            if i < j {\\n                vb.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        }\\n        String::from_utf8(vb).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903510,
                "title": "c-0ms-faster-than-100-simple-clean-readable",
                "content": "It should be pretty straightforward here. We have to traverse from both ends of the string until we encounter vowels from both sides. Once we do, we can then swap it and proceed to do so for the rest of the string.\\n\\nLet us use 2 pointers named ```beg``` and ```end```  traverse from the left and right ends respectively. There are 3 things that can occur as you traverse from both ends. You may encounter:\\n- A vowel at the left side (at ```s[beg]```) & a consonant at the right (at ```s[end]```)\\n\\t- If so, we keep the ```beg``` pointer as it is, and move the ```end``` pointer a step towards the left.\\n- A consonant at the left side & a vowel at the right\\n\\t- We keep the ```end``` pointer as it is, and move the ```beg``` pointer a step to the right\\n- Vowels at both positions of ```beg``` and ```end```.\\n\\t- We swap the vowels\\n\\nWe carry this out until we\\'re done scanning all the characters. The condition ```beg < end``` is to verify the same, since you know that you\\'ve traversed all the characters when the pointers meet at a position where ```beg == end```.\\n\\n**C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int beg = 0, end = s.size() - 1;\\n        string s1 = s;\\n        \\n        while (beg < end) {\\n            if (isVowel(s1[beg]) && isVowel(s1[end])) {\\n                swap(s1[beg], s1[end]);\\n                beg++; end--;\\n            } else if (isVowel(s1[beg])) {\\n                end--;\\n            } else if (isVowel(s1[end])) {\\n                beg++;\\n            } else {\\n                beg++;\\n                end--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```beg```\n```end```\n```s[beg]```\n```s[end]```\n```beg```\n```end```\n```end```\n```beg```\n```beg```\n```end```\n```beg < end```\n```beg == end```\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int beg = 0, end = s.size() - 1;\\n        string s1 = s;\\n        \\n        while (beg < end) {\\n            if (isVowel(s1[beg]) && isVowel(s1[end])) {\\n                swap(s1[beg], s1[end]);\\n                beg++; end--;\\n            } else if (isVowel(s1[beg])) {\\n                end--;\\n            } else if (isVowel(s1[end])) {\\n                beg++;\\n            } else {\\n                beg++;\\n                end--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135893,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string reverseVowels(string s)\\n    {\\n        vector<int>v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.empty())\\n        {\\n            return s;\\n        }\\n        int i=0,j=v.size()-1;\\n        while(j>i)\\n        {\\n            swap(s[v[i]],s[v[j]]);\\n            j--;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string reverseVowels(string s)\\n    {\\n        vector<int>v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\' || s[i]==\\'A\\' || s[i]==\\'E\\' || s[i]==\\'I\\' || s[i]==\\'O\\' || s[i]==\\'U\\')\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.empty())\\n        {\\n            return s;\\n        }\\n        int i=0,j=v.size()-1;\\n        while(j>i)\\n        {\\n            swap(s[v[i]],s[v[j]]);\\n            j--;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088089,
                "title": "probably-the-easiest-one-to-understand-with-comments",
                "content": "```\\nvar reverseVowels = function(s) {\\n   let b = [],\\n    v = [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n    arr = s.split(\"\");\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// pushing all the vowels\\n      b.push(s[i]);\\n    }\\n  }\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// by pop() we are placing the last vowel of the array at the place of first vowel of given string(which means we are reversing the position)\\n      arr[i] = b.pop();\\n    }\\n  }\\n    \\n  return arr.join(\"\");\\n};\\n```\\n```\\nvar reverseVowels = function(s) {\\n    const vowels=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    const revVowels=[]\\n    for(let ch of s){\\n        if(vowels.includes(ch.toLowerCase())){\\n            revVowels.push(ch)\\n        }\\n    }\\n    s=s.split(\\'\\')\\n    let last=revVowels.length-1\\n    for(let i=0;i<s.length;i++){\\n        if(vowels.includes(s[i].toLowerCase())){\\n            s[i]=revVowels[last--]\\n        }\\n    }\\n    return s.join(\\'\\')\\n};\\n```\\n2 pointer approach(No additional memory to store vowels)\\n```\\nvar reverseVowels = function(s) {\\n  const set=new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])  \\n    s=s.split(\\'\\')\\n    let i=0;\\n    let j=s.length-1\\n    while(i<j){\\n\\t\\t// move the pointers until they\\'re not pointing at vowels\\n        while(i<j && !set.has(s[i].toLowerCase()))i++\\n        while(i<j && !set.has(s[j].toLowerCase()))j--\\n\\t\\t // when both pointers are pointing at vowel, swap them using array destructuring\\n        [s[i],s[j]] = [s[j],s[i]];\\n        i++\\n        j--\\n    }\\n    return s.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseVowels = function(s) {\\n   let b = [],\\n    v = [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n    arr = s.split(\"\");\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// pushing all the vowels\\n      b.push(s[i]);\\n    }\\n  }\\n    \\n  for (let i = 0; i < s.length; i++) {\\n    if (v.includes(s[i].toLowerCase())) {\\n\\t// by pop() we are placing the last vowel of the array at the place of first vowel of given string(which means we are reversing the position)\\n      arr[i] = b.pop();\\n    }\\n  }\\n    \\n  return arr.join(\"\");\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n    const vowels=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    const revVowels=[]\\n    for(let ch of s){\\n        if(vowels.includes(ch.toLowerCase())){\\n            revVowels.push(ch)\\n        }\\n    }\\n    s=s.split(\\'\\')\\n    let last=revVowels.length-1\\n    for(let i=0;i<s.length;i++){\\n        if(vowels.includes(s[i].toLowerCase())){\\n            s[i]=revVowels[last--]\\n        }\\n    }\\n    return s.join(\\'\\')\\n};\\n```\n```\\nvar reverseVowels = function(s) {\\n  const set=new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])  \\n    s=s.split(\\'\\')\\n    let i=0;\\n    let j=s.length-1\\n    while(i<j){\\n\\t\\t// move the pointers until they\\'re not pointing at vowels\\n        while(i<j && !set.has(s[i].toLowerCase()))i++\\n        while(i<j && !set.has(s[j].toLowerCase()))j--\\n\\t\\t // when both pointers are pointing at vowel, swap them using array destructuring\\n        [s[i],s[j]] = [s[j],s[i]];\\n        i++\\n        j--\\n    }\\n    return s.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806132,
                "title": "99-faster-simplest-solution",
                "content": "\\tdef reverseVowels(self, s: str) -> str:\\n\\t\\t\\tvowels = set({\"a\", \"e\", \"i\", \"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"})\\n\\t\\t\\ts = list(s)\\n\\t\\t\\ti,j = 0, len(s) - 1\\n\\t\\t\\twhile i<j:\\n\\t\\t\\t\\tif s[i] not in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] in vowels:\\n\\t\\t\\t\\t\\ts[i], s[j] = s[j], s[i]\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\treturn \\'\\'.join(s)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "\\tdef reverseVowels(self, s: str) -> str:\\n\\t\\t\\tvowels = set({\"a\", \"e\", \"i\", \"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"})\\n\\t\\t\\ts = list(s)\\n\\t\\t\\ti,j = 0, len(s) - 1\\n\\t\\t\\twhile i<j:\\n\\t\\t\\t\\tif s[i] not in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] in vowels:\\n\\t\\t\\t\\t\\ts[i], s[j] = s[j], s[i]\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telif s[i] in vowels and s[j] not in vowels:\\n\\t\\t\\t\\t\\tj = j - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ti = i + 1\\n\\t\\t\\treturn \\'\\'.join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 400736,
                "title": "go-golang-two-solutions",
                "content": "```go\\nfunc reverseVowels(s string) string {\\n\\n    tmp := []byte(s)\\n    i := 0\\n    j := len(s)-1\\n    \\n    for i < j {\\n        if !isVowel(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isVowel(s[j]) {\\n            j--\\n            continue\\n        }\\n        tmp[i], tmp[j] = tmp[j], tmp[i]\\n        i++\\n        j--\\n    }\\n    return string(tmp)\\n}\\n\\nfunc isVowel(c byte) bool {\\n    if c < \\'a\\' { c += 32 }\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n}\\n```\\n\\n```go\\nfunc reverseVowels(s string) string {\\n    tmp := []byte(s)\\n    vowels := map[byte]bool{\\n        \\'a\\':true,\\n        \\'e\\':true,\\n        \\'i\\':true,\\n        \\'o\\':true,\\n        \\'u\\':true,\\n        \\'A\\':true,\\n        \\'E\\':true,\\n        \\'I\\':true,\\n        \\'O\\':true,\\n        \\'U\\':true,\\n    }\\n    for l, r := 0, len(s) - 1; l < r; {\\n        if vowels[tmp[l]] && vowels[tmp[r]] {\\n            tmp[l], tmp[r] = tmp[r], tmp[l]\\n            l++\\n            r--\\n        }\\n        if !vowels[tmp[l]] { l++ }\\n        if !vowels[tmp[r]] { r-- }\\n    }\\n    return string(tmp)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc reverseVowels(s string) string {\\n\\n    tmp := []byte(s)\\n    i := 0\\n    j := len(s)-1\\n    \\n    for i < j {\\n        if !isVowel(s[i]) {\\n            i++\\n            continue\\n        }\\n        if !isVowel(s[j]) {\\n            j--\\n            continue\\n        }\\n        tmp[i], tmp[j] = tmp[j], tmp[i]\\n        i++\\n        j--\\n    }\\n    return string(tmp)\\n}\\n\\nfunc isVowel(c byte) bool {\\n    if c < \\'a\\' { c += 32 }\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'\\n}\\n```\n```go\\nfunc reverseVowels(s string) string {\\n    tmp := []byte(s)\\n    vowels := map[byte]bool{\\n        \\'a\\':true,\\n        \\'e\\':true,\\n        \\'i\\':true,\\n        \\'o\\':true,\\n        \\'u\\':true,\\n        \\'A\\':true,\\n        \\'E\\':true,\\n        \\'I\\':true,\\n        \\'O\\':true,\\n        \\'U\\':true,\\n    }\\n    for l, r := 0, len(s) - 1; l < r; {\\n        if vowels[tmp[l]] && vowels[tmp[r]] {\\n            tmp[l], tmp[r] = tmp[r], tmp[l]\\n            l++\\n            r--\\n        }\\n        if !vowels[tmp[l]] { l++ }\\n        if !vowels[tmp[r]] { r-- }\\n    }\\n    return string(tmp)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389902,
                "title": "python-3-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef reverseVowels(self, s: str) -> str:        \\n\\t\\t\\tvowels = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":                \\n\\t\\t\\t\\t\\tvowels.append(i)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":\\n\\t\\t\\t\\t\\tres += vowels.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef reverseVowels(self, s: str) -> str:        \\n\\t\\t\\tvowels = []\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":                \\n\\t\\t\\t\\t\\tvowels.append(i)\\n\\t\\t\\tfor i in s:\\n\\t\\t\\t\\tif i in \"aeiouAEIOU\":\\n\\t\\t\\t\\t\\tres += vowels.pop()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 81423,
                "title": "12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n    string reverseVowels(string s) {\\n        string s1=s;\\n        int n= s1.length();\\n        int i=0,j=n-1;\\n        while(i<j){\\n            while((!isVovel(s1[i]))&&i<j)i++;\\n            while((!isVovel(s1[j]))&&i<j)j--;\\n            swap(s1[i],s1[j]);\\n            i++;j--;\\n        }\\n        return s1;\\n    }\\n    private:\\n    bool isVovel(char &ch)\\n    {\\n        bool flag=false;\\n        if((ch=='a')||(ch=='e')||(ch=='i')||(ch=='o')||(ch=='u')\\n        ||(ch=='A')||(ch=='E')||(ch=='I')||(ch=='O')||(ch=='U'))\\n            flag = true;\\n        return flag;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    string reverseVowels(string s) {\\n        string s1=s;\\n        int n= s1.length();\\n        int i=0,j=n-1;\\n        while(i<j){\\n            while((!isVovel(s1[i]))&&i<j)i++;\\n            while((!isVovel(s1[j]))&&i<j)j--;\\n            swap(s1[i],s1[j]);\\n            i++;j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3768204,
                "title": "simplest-solution-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n= s.length();\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }else {\\n                char t = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = t;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n    public boolean isVowel(char temp) {\\n        if(temp == \\'a\\'|| temp == \\'e\\' || temp == \\'i\\' || temp == \\'o\\' || temp == \\'u\\' || temp == \\'A\\'|| temp == \\'E\\' || temp == \\'I\\' || temp == \\'O\\' || temp == \\'U\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n= s.length();\\n        char[] ch = s.toCharArray();\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }else {\\n                char t = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = t;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return new String(ch);\\n    }\\n    public boolean isVowel(char temp) {\\n        if(temp == \\'a\\'|| temp == \\'e\\' || temp == \\'i\\' || temp == \\'o\\' || temp == \\'u\\' || temp == \\'A\\'|| temp == \\'E\\' || temp == \\'I\\' || temp == \\'O\\' || temp == \\'U\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565745,
                "title": "simplest-2-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        v = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] not in v and s[r] not in v:\\n                l+=1\\n                r-=1\\n            elif s[l] not in v:\\n                l+=1\\n            elif s[r] not in v:\\n                r-=1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l+=1\\n                r-=1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        v = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] not in v and s[r] not in v:\\n                l+=1\\n                r-=1\\n            elif s[l] not in v:\\n                l+=1\\n            elif s[r] not in v:\\n                r-=1\\n            else:\\n                s[l], s[r] = s[r], s[l]\\n                l+=1\\n                r-=1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123597,
                "title": "beginner-friendly-90-fast-o-n-time-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\' || s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')\\n            v.push_back(i);\\n        }\\n        for(int i=0;i<v.size()/2;i++){\\n            swap(s[v[i]],s[v[v.size()-1-i]]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\' || s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')\\n            v.push_back(i);\\n        }\\n        for(int i=0;i<v.size()/2;i++){\\n            swap(s[v[i]],s[v[v.size()-1-i]]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778018,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int dict[256] = {0};\\n        dict[\\'a\\'] = 1, dict[\\'A\\'] = 1;\\n        dict[\\'e\\'] = 1, dict[\\'E\\'] = 1;\\n        dict[\\'i\\'] = 1, dict[\\'I\\'] = 1;\\n        dict[\\'o\\'] = 1, dict[\\'O\\'] = 1;\\n        dict[\\'u\\'] = 1, dict[\\'U\\'] = 1;\\n        int start = 0, end = (int)s.size() - 1;\\n        while(start < end){\\n            while(start < end && dict[s[start]] == 0) start++;\\n            while(start < end && dict[s[end]] == 0) end--;\\n            swap(s[start],s[end]);\\n            start++;end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int dict[256] = {0};\\n        dict[\\'a\\'] = 1, dict[\\'A\\'] = 1;\\n        dict[\\'e\\'] = 1, dict[\\'E\\'] = 1;\\n        dict[\\'i\\'] = 1, dict[\\'I\\'] = 1;\\n        dict[\\'o\\'] = 1, dict[\\'O\\'] = 1;\\n        dict[\\'u\\'] = 1, dict[\\'U\\'] = 1;\\n        int start = 0, end = (int)s.size() - 1;\\n        while(start < end){\\n            while(start < end && dict[s[start]] == 0) start++;\\n            while(start < end && dict[s[end]] == 0) end--;\\n            swap(s[start],s[end]);\\n            start++;end--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777068,
                "title": "java-solution-without-2-pointer",
                "content": "\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowels = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                vowels.add(s.charAt(i));\\n            }\\n        } \\n        // System.out.println(vowels);   \\n        for(int i=0,j=vowels.size()-1;i<s.length();i++){\\n                if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                    s=s.substring(0,i)+vowels.get(j)+s.substring(i+1);\\n                    //  System.out.println(s);   \\n                    j--;\\n                 }\\n        }\\n       return s; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        ArrayList<Character> vowels = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                vowels.add(s.charAt(i));\\n            }\\n        } \\n        // System.out.println(vowels);   \\n        for(int i=0,j=vowels.size()-1;i<s.length();i++){\\n                if(s.charAt(i)==\\'a\\'||s.charAt(i)==\\'e\\'||s.charAt(i)==\\'i\\'||s.charAt(i)==\\'o\\'||s.charAt(i)==\\'u\\' || s.charAt(i)==\\'A\\' || s.charAt(i)==\\'E\\' || s.charAt(i)==\\'I\\' || s.charAt(i)==\\'O\\' || s.charAt(i)==\\'U\\'){\\n                    s=s.substring(0,i)+vowels.get(j)+s.substring(i+1);\\n                    //  System.out.println(s);   \\n                    j--;\\n                 }\\n        }\\n       return s; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776495,
                "title": "c-solution-two-pointer-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string str) {\\n        unordered_set<char> s;\\n        s.insert(\\'a\\');\\n        s.insert(\\'e\\');\\n        s.insert(\\'i\\');\\n        s.insert(\\'o\\');\\n        s.insert(\\'u\\');\\n        s.insert(\\'A\\');\\n        s.insert(\\'E\\');\\n        s.insert(\\'I\\');\\n        s.insert(\\'O\\');\\n        s.insert(\\'U\\');\\n\\n        int i=0, j=str.size()-1;\\n\\n        while(i < j) {\\n            if(s.find(str[i]) != s.end() && s.find(str[j]) != s.end()) {\\n                swap(str[i], str[j]);\\n                i++;\\n                j--;\\n            }\\n            else if(s.find(str[i]) != s.end()) {\\n                j--;                \\n            }\\n            else if(s.find(str[j]) != s.end()) {\\n                i++;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string str) {\\n        unordered_set<char> s;\\n        s.insert(\\'a\\');\\n        s.insert(\\'e\\');\\n        s.insert(\\'i\\');\\n        s.insert(\\'o\\');\\n        s.insert(\\'u\\');\\n        s.insert(\\'A\\');\\n        s.insert(\\'E\\');\\n        s.insert(\\'I\\');\\n        s.insert(\\'O\\');\\n        s.insert(\\'U\\');\\n\\n        int i=0, j=str.size()-1;\\n\\n        while(i < j) {\\n            if(s.find(str[i]) != s.end() && s.find(str[j]) != s.end()) {\\n                swap(str[i], str[j]);\\n                i++;\\n                j--;\\n            }\\n            else if(s.find(str[i]) != s.end()) {\\n                j--;                \\n            }\\n            else if(s.find(str[j]) != s.end()) {\\n                i++;\\n            }\\n            else {\\n                i++;\\n                j--;\\n            }\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776380,
                "title": "java-o-n-solution-with-explanation-two-pointers",
                "content": "**JAVA SOLUTION USING TWO-POINTERS**\\n\\n*If-else if statements cover up all possible senarios that we may encounter during iteration. We use Two-Pointers i & j to figure out whether its vowel or not and accordingly do the necessary operations. In some cases the ith character may not be included in the character array hence a check for whether the char[i]==\\'\\\\u000\\' is required at the end.*\\n\\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n=s.length();\\n        char []a =new char[n];\\n        int i=0;int j=n-1;\\n       \\n        if(n==1){return s;}  // if only 1 character present in String\\n      \\n        while(i<j){\\n            int l=Character.getNumericValue(s.charAt(i)); \\n            int r=Character.getNumericValue(s.charAt(j));\\n            \\n            if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n                 a[j]=(char)s.charAt(j);\\n                --j;\\n                \\n            }\\n              else  if((l==10||l==14||l==18||l==24||l==30) && (r==10||r==14||r==18||r==24||r==30)) {\\n                  a[i]=s.charAt(j);\\n                  a[j]=s.charAt(i);\\n                  ++i;--j;\\n              }\\n           \\n          else  if((l==10||l==14||l==18||l==24||l==30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[j]=(char)s.charAt(j);\\n                --j;\\n            }\\n          else  if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r==10||r==14||r==18||r==24||r==30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n            }\\n        }\\n     \\n         if(a[i]==\\'\\\\u0000\\') //checking if the i-th character is not null(i.e left out)Example i/p:\"axyz\" here i will never increment in above loop hence this check is required!\\n             a[i]=s.charAt(i);       \\n        \\n        return new String(a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int n=s.length();\\n        char []a =new char[n];\\n        int i=0;int j=n-1;\\n       \\n        if(n==1){return s;}  // if only 1 character present in String\\n      \\n        while(i<j){\\n            int l=Character.getNumericValue(s.charAt(i)); \\n            int r=Character.getNumericValue(s.charAt(j));\\n            \\n            if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n                 a[j]=(char)s.charAt(j);\\n                --j;\\n                \\n            }\\n              else  if((l==10||l==14||l==18||l==24||l==30) && (r==10||r==14||r==18||r==24||r==30)) {\\n                  a[i]=s.charAt(j);\\n                  a[j]=s.charAt(i);\\n                  ++i;--j;\\n              }\\n           \\n          else  if((l==10||l==14||l==18||l==24||l==30) && (r!=10&&r!=14&&r!=18&&r!=24&&r!=30)){\\n                a[j]=(char)s.charAt(j);\\n                --j;\\n            }\\n          else  if((l!=10&&l!=14&&l!=18&&l!=24&&l!=30) && (r==10||r==14||r==18||r==24||r==30)){\\n                a[i]=(char)s.charAt(i);\\n                ++i;\\n            }\\n        }\\n     \\n         if(a[i]==\\'\\\\u0000\\') //checking if the i-th character is not null(i.e left out)Example i/p:\"axyz\" here i will never increment in above loop hence this check is required!\\n             a[i]=s.charAt(i);       \\n        \\n        return new String(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776118,
                "title": "c-solution-with-explanation",
                "content": "Here is the code with explanations:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n\\n        // we\\'re going to store the positions of the vowels here\\n        vector<int> positions;\\n\\n        // We\\'re using stack as it follows FILO, whoch means the vowels we put in first\\n        // are going to come out of the stack at last, ie. in opposite order\\n        stack<char> vowels;\\n\\n        // vowels list\\n        vector<char> v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n        for (int i{0}; i<s.length(); ++i) {\\n            for (char x:v) {\\n\\n                // we check if the character is equal to the lowercase vowels or not\\n                // we also check with x-32 as in ascii, subtracting 32 will get you the upper case\\n                // for eg, ascii code for \\'a\\' is 97. 97-32=65 which is ascii code for \\'A\\' and so on\\n                // You might think characters & numbers are supposed to be treated separately, right?\\n                // But we can actually subtract numbers from characters as if we\\'re dealing with their ascii code!\\n                if (x==s[i] || x-32==s[i]) {\\n                    // inserting the positions of vowels in positions list\\n                    positions.push_back(i);\\n                    // vowels being pushed into stack\\n                    vowels.push(s[i]);\\n                }\\n            }\\n        }\\n\\n        for (int x:positions) {\\n            // for the first position in the vector, the last inserted vowel from stack is inserted\\n            // that\\'s because the last thing inserted in stack comes out first! [FILO - First In Last Out]\\n            s[x] = vowels.top();\\n            // Let\\'s remove the topmost element from the stack as it is used up\\n            vowels.pop();\\n        }\\n\\n        return s;        \\n    }\\n};\\n```\\n\\n*If the explanation helped you, please upvote this solution*\\n*Happy coding* :)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n\\n        // we\\'re going to store the positions of the vowels here\\n        vector<int> positions;\\n\\n        // We\\'re using stack as it follows FILO, whoch means the vowels we put in first\\n        // are going to come out of the stack at last, ie. in opposite order\\n        stack<char> vowels;\\n\\n        // vowels list\\n        vector<char> v{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n        for (int i{0}; i<s.length(); ++i) {\\n            for (char x:v) {\\n\\n                // we check if the character is equal to the lowercase vowels or not\\n                // we also check with x-32 as in ascii, subtracting 32 will get you the upper case\\n                // for eg, ascii code for \\'a\\' is 97. 97-32=65 which is ascii code for \\'A\\' and so on\\n                // You might think characters & numbers are supposed to be treated separately, right?\\n                // But we can actually subtract numbers from characters as if we\\'re dealing with their ascii code!\\n                if (x==s[i] || x-32==s[i]) {\\n                    // inserting the positions of vowels in positions list\\n                    positions.push_back(i);\\n                    // vowels being pushed into stack\\n                    vowels.push(s[i]);\\n                }\\n            }\\n        }\\n\\n        for (int x:positions) {\\n            // for the first position in the vector, the last inserted vowel from stack is inserted\\n            // that\\'s because the last thing inserted in stack comes out first! [FILO - First In Last Out]\\n            s[x] = vowels.top();\\n            // Let\\'s remove the topmost element from the stack as it is used up\\n            vowels.pop();\\n        }\\n\\n        return s;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775963,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Two Pointer Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775859,
                "title": "c-two-pointer-easy-and-short",
                "content": "```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n# Intuition\\nAsking to reverse the vowels in the string. So we will be swapping 1st vowel with last vowel. So will need to keep a look at both front and back side of array. Therefore need two pointers.\\n\\n# Approach\\nCreate two pointers and iterate one pointer from front and one from end. Check if current char is a vowel or not. If a vowel then wait for another pointer to also get a vowel. Else if not a vowel then move to next char.\\n\\nIf both pointers get vowels swap both the chars and move the pointers to respective next position. Here running criteria will be till when end pointer is greater than start pointer.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n\\n- Space complexity:  O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int str = 0, end = n-1;\\n\\n        map<char,int> vow;\\n        vow[\\'a\\'] = 1, vow[\\'e\\'] = 1, vow[\\'o\\'] = 1, vow[\\'i\\'] = 1, vow[\\'u\\'] = 1;\\n\\n        while(str < end){\\n            if(vow[tolower(s[end])] == 1 && vow[tolower(s[str])] == 1){\\n                swap(s[str], s[end]);\\n                str++;\\n                end--;\\n                continue;\\n            }\\n\\n            if(vow[tolower(s[str])] == 0)\\n                str++;\\n            if(vow[tolower(s[end])] == 0)\\n                end--;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int str = 0, end = n-1;\\n\\n        map<char,int> vow;\\n        vow[\\'a\\'] = 1, vow[\\'e\\'] = 1, vow[\\'o\\'] = 1, vow[\\'i\\'] = 1, vow[\\'u\\'] = 1;\\n\\n        while(str < end){\\n            if(vow[tolower(s[end])] == 1 && vow[tolower(s[str])] == 1){\\n                swap(s[str], s[end]);\\n                str++;\\n                end--;\\n                continue;\\n            }\\n\\n            if(vow[tolower(s[str])] == 0)\\n                str++;\\n            if(vow[tolower(s[end])] == 0)\\n                end--;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n```\\nIf you learned/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775520,
                "title": "javascript-linear-loop-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRun through both the ends of the string, keep finding vowels from both front and back. Stop when you find vowels from both the ends. Pause, swap them and move ahead!!!\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- o(n):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- o(1):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst VOWELS = \\'aeiouAEIOU\\';\\nvar reverseVowels = function(s) {\\n    const arr = [...s];\\n\\n    for(let i = 0, j = arr.length - 1; i < j; i++, j--) {\\n        while (!VOWELS.includes(arr[i]) && i < j) {\\n            i++;\\n        }\\n\\n        while (!VOWELS.includes(arr[j]) && i < j) {\\n            j--;\\n        }\\n\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst VOWELS = \\'aeiouAEIOU\\';\\nvar reverseVowels = function(s) {\\n    const arr = [...s];\\n\\n    for(let i = 0, j = arr.length - 1; i < j; i++, j--) {\\n        while (!VOWELS.includes(arr[i]) && i < j) {\\n            i++;\\n        }\\n\\n        while (!VOWELS.includes(arr[j]) && i < j) {\\n            j--;\\n        }\\n\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n    }\\n\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2775428,
                "title": "python-3-8-lines-two-pointer-w-explanation-t-m-96-60",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)                                     # string --> list\\n\\n        l,r, vowels = 0, len(s) - 1, \\'aeiouAEIOU\\'\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowels: l += 1  # Increment each pointer l and r until\\n            while l < r and s[r] not in vowels: r -= 1  # each is pointing at a vowel or l >= r.\\n\\n            s[l], s[r] = s[r], s[l]                     # Swap the pointed vowels and increment\\n            l += 1   ;   r -= 1                         # each pointer.\\n\\n        return \\'\\'.join(s)                               # list --> string\\n```\\n[https://leetcode.com/submissions/detail/613726669/](http://)\\n\\nI think it\\'s *O*(*n*) / *O*(1), but I could be wrong... maybe *O*(*n*) / *O*(*n*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)                                     # string --> list\\n\\n        l,r, vowels = 0, len(s) - 1, \\'aeiouAEIOU\\'\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowels: l += 1  # Increment each pointer l and r until\\n            while l < r and s[r] not in vowels: r -= 1  # each is pointing at a vowel or l >= r.\\n\\n            s[l], s[r] = s[r], s[l]                     # Swap the pointed vowels and increment\\n            l += 1   ;   r -= 1                         # each pointer.\\n\\n        return \\'\\'.join(s)                               # list --> string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773516,
                "title": "java-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        List<Character> list=Arrays.asList(\\'a\\', \\'e\\', \\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\n        char[] ch=s.toCharArray();\\n\\n        System.out.println(Arrays.toString(ch));\\n        int i=0;\\n        int j=ch.length-1;\\n\\n        while(i<j){\\n\\n            if(list.contains(ch[i]) && list.contains(ch[j])){\\n                char temp=ch[i];\\n                ch[i]=ch[j];\\n                ch[j]=temp;\\n                i++;\\n                j--;\\n            }else if(list.contains(ch[i]) && !list.contains(ch[j])){\\n                j--;\\n            }else if(!list.contains(ch[i]) && list.contains(ch[j])){\\n                i++;\\n            }else if(!list.contains(ch[i]) && !list.contains(ch[j])){\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n\\n        String res=String.valueOf(ch);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        List<Character> list=Arrays.asList(\\'a\\', \\'e\\', \\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\n        char[] ch=s.toCharArray();\\n\\n        System.out.println(Arrays.toString(ch));\\n        int i=0;\\n        int j=ch.length-1;\\n\\n        while(i<j){\\n\\n            if(list.contains(ch[i]) && list.contains(ch[j])){\\n                char temp=ch[i];\\n                ch[i]=ch[j];\\n                ch[j]=temp;\\n                i++;\\n                j--;\\n            }else if(list.contains(ch[i]) && !list.contains(ch[j])){\\n                j--;\\n            }else if(!list.contains(ch[i]) && list.contains(ch[j])){\\n                i++;\\n            }else if(!list.contains(ch[i]) && !list.contains(ch[j])){\\n                i++;\\n                j--;\\n            }\\n\\n        }\\n\\n        String res=String.valueOf(ch);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672130,
                "title": "reverse-vowels-of-string-python-easy-solution",
                "content": "# Easy and Simple Approach:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        def swap(a,b):\\n            s[a],s[b]=s[b],s[a]\\n        vowels=\"aeiouAEIOU\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            if s[l] in vowels and s[r] in vowels:\\n                swap(l,r)\\n                l+=1\\n                r-=1\\n            elif s[l] in vowels:\\n                r-=1\\n            elif s[r] in vowels:\\n                l+=1\\n            else:\\n                l+=1\\n                r-=1\\n        return \"\".join(s)",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Easy and Simple Approach:\\n    def reverseVowels(self, s: str) -> str:\\n        s=list(s)\\n        def swap(a,b):\\n            s[a],s[b]=s[b],s[a]\\n        vowels=\"aeiouAEIOU\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            if s[l] in vowels and s[r] in vowels:\\n                swap(l,r)\\n                l+=1\\n                r-=1\\n            elif s[l] in vowels:\\n                r-=1\\n            elif s[r] in vowels:\\n                l+=1\\n            else:\\n                l+=1\\n                r-=1\\n        return \"\".join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 2608640,
                "title": "java-2-approaches-easy",
                "content": "### **Please Upvote !!! (\\u25E0\\u203F\\u25E0)**\\n##### 1. Two-pointer approach:\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\t\\t\\n        int i = 0, j = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n\\n        while (i < j) {\\n            while (i < j && !set.contains(chars[i])) i++;\\n            while (i < j && !set.contains(chars[j])) j--;\\n\\n            // swap\\n            char temp = chars[i];\\n            chars[i++] = chars[j];\\n            chars[j--] = temp;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. Using Queue:\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        Set<Character> set = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        \\n        for (int i = s.length() - 1; i >= 0; i--){\\n            char c =  Character.toLowerCase(s.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                q.add(s.charAt(i));\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n                \\n        for (int i = 0; i < sb.length(); i++){\\n            char c = Character.toLowerCase(sb.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                sb.setCharAt(i, q.poll());\\n            }\\n        }\\n                \\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> set = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n\\t\\t\\n        int i = 0, j = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n\\n        while (i < j) {\\n            while (i < j && !set.contains(chars[i])) i++;\\n            while (i < j && !set.contains(chars[j])) j--;\\n\\n            // swap\\n            char temp = chars[i];\\n            chars[i++] = chars[j];\\n            chars[j--] = temp;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Queue<Character> q = new LinkedList<>();\\n        Set<Character> set = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        \\n        for (int i = s.length() - 1; i >= 0; i--){\\n            char c =  Character.toLowerCase(s.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                q.add(s.charAt(i));\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n                \\n        for (int i = 0; i < sb.length(); i++){\\n            char c = Character.toLowerCase(sb.charAt(i));\\n            \\n            if (set.contains(c)) {\\n                sb.setCharAt(i, q.poll());\\n            }\\n        }\\n                \\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447060,
                "title": "javascipt-too-easy-with-two-pointers-100",
                "content": "```\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nvar reverseVowels = function(s) {\\n    let output = s.split(\\'\\');\\n    let cursor1 = 0;\\n    let cursor2 = s.length - 1;\\n\\n    while (cursor1 < cursor2) {\\n        if (vowels.includes(s[cursor1].toLowerCase()) && vowels.includes(s[cursor2].toLowerCase())) {\\n            [output[cursor1], output[cursor2]] = [output[cursor2], output[cursor1]];\\n            cursor1++;\\n            cursor2--;\\n        }\\n        if (!vowels.includes(s[cursor1].toLowerCase())) {\\n            cursor1++;\\n        }\\n        if (!vowels.includes(s[cursor2].toLowerCase())) {\\n            cursor2--;\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nconst vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\nvar reverseVowels = function(s) {\\n    let output = s.split(\\'\\');\\n    let cursor1 = 0;\\n    let cursor2 = s.length - 1;\\n\\n    while (cursor1 < cursor2) {\\n        if (vowels.includes(s[cursor1].toLowerCase()) && vowels.includes(s[cursor2].toLowerCase())) {\\n            [output[cursor1], output[cursor2]] = [output[cursor2], output[cursor1]];\\n            cursor1++;\\n            cursor2--;\\n        }\\n        if (!vowels.includes(s[cursor1].toLowerCase())) {\\n            cursor1++;\\n        }\\n        if (!vowels.includes(s[cursor2].toLowerCase())) {\\n            cursor2--;\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396242,
                "title": "python-two-pointer-solution-with-98-27-speed",
                "content": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(list(\"aeiouAEIOU\"))\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[j] not in vowels:\\n                j -=1\\n            elif s[i] not in vowels:\\n                i +=1\\n            else:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set(list(\"aeiouAEIOU\"))\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[j] not in vowels:\\n                j -=1\\n            elif s[i] not in vowels:\\n                i +=1\\n            else:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229329,
                "title": "java-easy-to-understand-3ms-two-pointers",
                "content": "This approach uses two pointer and inspired by quick sort.\\nPlease upvote if you found helpful.\\n```\\npublic String reverseVowels(String s) \\n{\\n\\tint i = 0 , j = s.length() - 1 ;\\n\\tchar temp ;\\n\\tHashSet<Character> vowels=new HashSet<>();\\n\\tvowels.add(\\'a\\'); vowels.add(\\'A\\');\\n\\tvowels.add(\\'e\\'); vowels.add(\\'E\\');\\n\\tvowels.add(\\'i\\'); vowels.add(\\'I\\');\\n\\tvowels.add(\\'o\\'); vowels.add(\\'O\\');\\n\\tvowels.add(\\'u\\'); vowels.add(\\'U\\');\\n\\tchar[] c = s.toCharArray() ;\\n\\twhile( i < j )\\n\\t{        \\n\\t\\twhile( i < j && !vowels.contains(c[i]))\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile( i < j && !vowels.contains(c[j]))\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\ttemp = c[i];\\n\\t\\tc[i++] = c[j];\\n\\t\\tc[j--] = temp;\\n\\t}        \\n\\treturn new String(c) ;        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic String reverseVowels(String s) \\n{\\n\\tint i = 0 , j = s.length() - 1 ;\\n\\tchar temp ;\\n\\tHashSet<Character> vowels=new HashSet<>();\\n\\tvowels.add(\\'a\\'); vowels.add(\\'A\\');\\n\\tvowels.add(\\'e\\'); vowels.add(\\'E\\');\\n\\tvowels.add(\\'i\\'); vowels.add(\\'I\\');\\n\\tvowels.add(\\'o\\'); vowels.add(\\'O\\');\\n\\tvowels.add(\\'u\\'); vowels.add(\\'U\\');\\n\\tchar[] c = s.toCharArray() ;\\n\\twhile( i < j )\\n\\t{        \\n\\t\\twhile( i < j && !vowels.contains(c[i]))\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile( i < j && !vowels.contains(c[j]))\\n\\t\\t{\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\ttemp = c[i];\\n\\t\\tc[i++] = c[j];\\n\\t\\tc[j--] = temp;\\n\\t}        \\n\\treturn new String(c) ;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144933,
                "title": "python-2-pointer-easy-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']\\n        s = list(s)\\n        l, h = 0, len(s) - 1\\n        while l < h:\\n            if s[l] not in vowels: l += 1\\n            elif s[h] not in vowels: h -= 1\\n            else:\\n                s[l], s[h] = s[h], s[l]\\n                l += 1\\n                h -= 1\\n        return \"\".join(s)\\n```\\nFor more such problems: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']\\n        s = list(s)\\n        l, h = 0, len(s) - 1\\n        while l < h:\\n            if s[l] not in vowels: l += 1\\n            elif s[h] not in vowels: h -= 1\\n            else:\\n                s[l], s[h] = s[h], s[l]\\n                l += 1\\n                h -= 1\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112683,
                "title": "java-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char ch[] = s.toCharArray();\\n        String vowels = \"aeiouAEIOU\";\\n        int i=0, j=ch.length-1;\\n        char temp;\\n        \\n        while(i<j){\\n            if(!vowels.contains(ch[i]+\"\")) i++;\\n            else if(!vowels.contains(ch[j]+\"\")) j--;\\n            else{\\n                temp = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = temp;\\n                \\n                i++; j--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char ch[] = s.toCharArray();\\n        String vowels = \"aeiouAEIOU\";\\n        int i=0, j=ch.length-1;\\n        char temp;\\n        \\n        while(i<j){\\n            if(!vowels.contains(ch[i]+\"\")) i++;\\n            else if(!vowels.contains(ch[j]+\"\")) j--;\\n            else{\\n                temp = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = temp;\\n                \\n                i++; j--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077031,
                "title": "swift-solution",
                "content": "We\\'ll use two pointers here. One pointing to the first unchanged vowel, the second one to the last one. Everytime both of them are pointing to a vowel we\\'ll swap them. \\n\\n```\\nfunc reverseVowels(_ s: String) -> String {\\n            \\n\\tvar p1 = 0\\n\\tvar p2 = s.count-1\\n\\n\\tlet vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n\\n\\tvar chars = Array(s)\\n\\n\\twhile p1 < p2 {\\n\\t\\tif !vowels.contains(chars[p1].lowercased()) { p1+=1;continue }\\n\\t\\tif !vowels.contains(chars[p2].lowercased()) { p2-=1;continue }\\n\\n\\t\\tchars.swapAt(p1, p2)\\n\\t\\tp1+=1;p2-=1\\n\\t}\\n\\treturn String(chars)\\n            \\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc reverseVowels(_ s: String) -> String {\\n            \\n\\tvar p1 = 0\\n\\tvar p2 = s.count-1\\n\\n\\tlet vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n\\n\\tvar chars = Array(s)\\n\\n\\twhile p1 < p2 {\\n\\t\\tif !vowels.contains(chars[p1].lowercased()) { p1+=1;continue }\\n\\t\\tif !vowels.contains(chars[p2].lowercased()) { p2-=1;continue }\\n\\n\\t\\tchars.swapAt(p1, p2)\\n\\t\\tp1+=1;p2-=1\\n\\t}\\n\\treturn String(chars)\\n            \\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009087,
                "title": "java-easy-to-understand",
                "content": "# Please upvote if helpful\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length-1;\\n        \\n        while(left <= right) {\\n            if(isVowel(arr[left]) && isVowel(arr[right])) {\\n                swap(arr, left, right);\\n                left++; \\n                right--;\\n            } else if(!isVowel(arr[left])) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n                      \\n        return String.valueOf(arr);\\n    }\\n                      \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    \\n    private void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0, right = arr.length-1;\\n        \\n        while(left <= right) {\\n            if(isVowel(arr[left]) && isVowel(arr[right])) {\\n                swap(arr, left, right);\\n                left++; \\n                right--;\\n            } else if(!isVowel(arr[left])) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n                      \\n        return String.valueOf(arr);\\n    }\\n                      \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    \\n    private void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997121,
                "title": "python-solution-using-stack",
                "content": "1. In stack store all the vowels\\n2. Append the consonants in result list directly and vowels from stack while iterating over string. \\n \\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        stack = [i for i in s if i in \"aeiouAEIOU\"]\\n        res = []\\n        for i in s:\\n            if(i in \"aeiouAEIOU\"):\\n                res.append(stack.pop())\\n            else:\\n                res.append(i)\\n        return(\"\".join(res))\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        stack = [i for i in s if i in \"aeiouAEIOU\"]\\n        res = []\\n        for i in s:\\n            if(i in \"aeiouAEIOU\"):\\n                res.append(stack.pop())\\n            else:\\n                res.append(i)\\n        return(\"\".join(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972401,
                "title": "python3-standard-two-pointer-with-a-set-data-structure",
                "content": "```\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s = list(s)\\n        left, right = 0, len(s)-1\\n        \\n        while left < right:\\n            if s[left] not in vowels:\\n                left +=1\\n                continue\\n                \\n            elif s[right] not in vowels:\\n                right -=1\\n                continue\\n            else:\\n                s[left],s[right] = s[right],s[left]\\n                left +=1\\n                right -=1\\n        return \"\".join(s)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "```\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = {\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"}\\n        s = list(s)\\n        left, right = 0, len(s)-1\\n        \\n        while left < right:\\n            if s[left] not in vowels:\\n                left +=1\\n                continue\\n                \\n            elif s[right] not in vowels:\\n                right -=1\\n                continue\\n            else:\\n                s[left],s[right] = s[right],s[left]\\n                left +=1\\n                right -=1\\n        return \"\".join(s)",
                "codeTag": "Python3"
            },
            {
                "id": 635819,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        \\n        char[] ltrs = s.toCharArray();\\n        \\n        // two pointers\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            \\n            boolean leftV = isVowel(s.charAt(left)), rightV = isVowel(s.charAt(right));\\n            \\n            if (leftV && rightV)\\n                swap(ltrs, left, right);\\n            else if (leftV)\\n                left--;\\n            else if (rightV)\\n                right++;\\n            \\n            left++;\\n            right--;\\n        }\\n        \\n        return new String(ltrs);\\n    }\\n    \\n    public void swap(char[] ltrs, int left, int right) {\\n        char tmp = ltrs[left];\\n        ltrs[left] = ltrs[right];\\n        ltrs[right] = tmp;\\n    } \\n    \\n    public boolean isVowel(char c) {\\n        char[] vowels = new char[]{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        \\n        for (char vow : vowels)\\n            if (c == vow)\\n                return true;\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        char[] ltrs = s.toCharArray();\\n        \\n        // two pointers\\n        int left = 0, right = s.length() - 1;\\n        while (left < right) {\\n            \\n            boolean leftV = isVowel(s.charAt(left)), rightV = isVowel(s.charAt(right));\\n            \\n            if (leftV && rightV)\\n                swap(ltrs, left, right);\\n            else if (leftV)\\n                left--;\\n            else if (rightV)\\n                right++;\\n            \\n            left++;\\n            right--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 574697,
                "title": "java-o-n-simple-with-explaination-faster-85-lighter-80",
                "content": "If the string is smaller than size 2, no need to swap in any case.\\nAdd constant number of characters to a set to avoid checking ten times in an OR condition string.\\nConvert string to char array for easier faster access.\\nLoop with two pointers, and when both of them have found vowels, and they haven\\'t crossed each other, swap.\\nExit the loop when the pointers meet because any swap after that is just reversing our work so far.\\nconvert char array to string and return.\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length() < 2) return s;\\n        char[] ch = s.toCharArray();\\n        int left = 0;\\n        int right = ch.length-1;\\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        vowels.add(\\'A\\');\\n        vowels.add(\\'E\\');\\n        vowels.add(\\'I\\');\\n        vowels.add(\\'O\\');\\n        vowels.add(\\'U\\');\\n        \\n        while(left < right){\\n            if(!vowels.contains(ch[left])) left++;\\n            else if(!vowels.contains(ch[right])) right--;\\n            else{ //(left < right){\\n                char temp = ch[left];\\n                ch[left] = ch[right];\\n                ch[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        if(s == null || s.length() < 2) return s;\\n        char[] ch = s.toCharArray();\\n        int left = 0;\\n        int right = ch.length-1;\\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        vowels.add(\\'A\\');\\n        vowels.add(\\'E\\');\\n        vowels.add(\\'I\\');\\n        vowels.add(\\'O\\');\\n        vowels.add(\\'U\\');\\n        \\n        while(left < right){\\n            if(!vowels.contains(ch[left])) left++;\\n            else if(!vowels.contains(ch[right])) right--;\\n            else{ //(left < right){\\n                char temp = ch[left];\\n                ch[left] = ch[right];\\n                ch[right] = temp;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551222,
                "title": "python-3-simple-re-solution-beats-92-77",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'(?i)[aeiou]\\', s)\\n        return re.sub(\\'(?i)[aeiou]\\', lambda x:vowels.pop(), s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = re.findall(\\'(?i)[aeiou]\\', s)\\n        return re.sub(\\'(?i)[aeiou]\\', lambda x:vowels.pop(), s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516532,
                "title": "several-python-sol-sharing-80-with-hint-and-explanation",
                "content": "---\\n\\nMethod_#1\\nBy *two-pointers*\\n\\nMethod_#2\\nBy self-made *generator*\\n\\nMethod_#3\\nBy *stack* and two-pass *linear scan*\\n\\n---\\n\\n**Hint**:\\n\\nFor Method_#1, by two-potiners.\\n\\nThink of **two-pointers** algorithm framework.\\n\\nRemember that [**python string** is **immutable**](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str)( swap character is not allowed), but [**python list** is **mutable**](https://docs.python.org/3/library/stdtypes.html#list) (support  swap element). \\nThus, we need a python list for swap operation\\n\\nLet *i*, *j* denote two pointers we use,\\n*i* traverse from head to tail (i.e., left to right), while *j* traverse from tail to head (i.e., right to left).\\n\\n**Swap list_str[i]** and **list_str[j]** if **vowel is met**\\n\\nFinally convert list_str back to python string by [\"\".join( list_str )](https://docs.python.org/3/library/stdtypes.html?highlight=join%20str#str.join).\\n\\n---\\n**Implementation**:\\nMethod_#1, by two-potiners.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        \\n\\t\\tnew_s = list(s)                 # use python list as buffer for element swap\\n        last_index = len(s)-1\\n        left, right = 0, last_index     # initialization for two pointers\\n        \\n        while left <= right:\\n            \\n            while left <= right and s[left] not in vowel: left +=1\\n            while left <= right and s[right] not in vowel: right -=1\\n            \\n            if left > right:\\n                break\\n            \\n\\t\\t\\t# swap vowel\\n            new_s[ left ], new_s[ right ] = new_s[ right ], new_s[ left ]\\n            \\n            left, right = left+1, right-1\\n            \\n        return \\'\\'.join(new_s)\\n```\\n\\n---\\n\\n**Hint**:\\nFor Method_#2, by self-made *generator*.\\n\\nThink of [yield statement and generator](https://docs.python.org/3/reference/expressions.html?highlight=yield#yield-expressions).\\n\\nIamgine the generator as a machine scan from the tail to head, and output a vowel once it is met.\\n\\n---\\n**Implementation**:\\nMethod_#2, by self-made generator.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        \\n        def rev_vowel( s:str):\\n\\t\\t\\n            # Support function to collect vowel in reverse direction\\n\\t\\t\\t\\n            for char in reversed(s):\\n                if char in vowel:\\n                    yield char\\n        \\n        vowel_gen = rev_vowel(s)\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += next( vowel_gen )\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\\n\\n---\\n\\n**Hint**:\\nFor Method_#3, by *stack* and two-pass *linear scan*.\\n\\nThink of [**stack** and **Last-in First out** (aka LIFO)](https://docs.python.org/3/tutorial/datastructures.html?highlight=stack#using-lists-as-stacks) property\\n\\nUse first-pass linear scan to **store vowels in stack**.\\n\\nThen, in secon-pass, once we met a vowel in original string, pop a character from stack, which yields the vowel with reversed order, based on last-in first out property of stack.\\n\\n---\\n\\n**Implementation**:\\nMethod_#3, by stack and two-pass linear scan.\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        v_stack = []\\n        \\n        size = len(s)-1\\n        \\n        # Step_#1:\\n        # Collect vowels in stack\\n        for char in s:\\n            \\n            if char in vowel:\\n                v_stack.append( char )\\n                \\n        # Step_#2:\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += v_stack.pop()\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        \\n\\t\\tnew_s = list(s)                 # use python list as buffer for element swap\\n        last_index = len(s)-1\\n        left, right = 0, last_index     # initialization for two pointers\\n        \\n        while left <= right:\\n            \\n            while left <= right and s[left] not in vowel: left +=1\\n            while left <= right and s[right] not in vowel: right -=1\\n            \\n            if left > right:\\n                break\\n            \\n\\t\\t\\t# swap vowel\\n            new_s[ left ], new_s[ right ] = new_s[ right ], new_s[ left ]\\n            \\n            left, right = left+1, right-1\\n            \\n        return \\'\\'.join(new_s)\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        \\n        def rev_vowel( s:str):\\n\\t\\t\\n            # Support function to collect vowel in reverse direction\\n\\t\\t\\t\\n            for char in reversed(s):\\n                if char in vowel:\\n                    yield char\\n        \\n        vowel_gen = rev_vowel(s)\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += next( vowel_gen )\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        \\n        vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\',\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'}\\n        new_s = \\'\\'\\n        v_stack = []\\n        \\n        size = len(s)-1\\n        \\n        # Step_#1:\\n        # Collect vowels in stack\\n        for char in s:\\n            \\n            if char in vowel:\\n                v_stack.append( char )\\n                \\n        # Step_#2:\\n        # Generate string with reversed vowels\\n        for char in s:\\n            \\n            if char in vowel:\\n                new_s += v_stack.pop()\\n            else:\\n                new_s += char\\n                \\n        return new_s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81382,
                "title": "python-solution",
                "content": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels='aeiouAEIOU'\\n            vpos=[i for i,j in enumerate(s) if j in vowels]\\n            svrev=list(s)\\n            i,j=0,len(vpos)-1\\n            while i<j:\\n                svrev[vpos[i]],svrev[vpos[j]]=svrev[vpos[j]],svrev[vpos[i]]\\n                i+=1\\n                j-=1\\n            return ''.join(svrev)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseVowels(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            vowels='aeiouAEIOU'\\n            vpos=[i for i,j in enumerate(s) if j in vowels]\\n            svrev=list(s)\\n            i,j=0,len(vpos)-1\\n            while i<j:\\n                svrev[vpos[i]],svrev[vpos[j]]=svrev[vpos[j]],svrev[vpos[i]]\\n                i+=1\\n                j-=1\\n            return ''.join(svrev)",
                "codeTag": "Java"
            },
            {
                "id": 81405,
                "title": "my-12ms-c-simple-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            if (s.length() < 2) return s;\\n\\t    string vowels=\"aeiouAEIOU\";\\n            int i = 0, j = s.length()-1;\\n\\n            while (i < j)\\n            {\\n                while (vowels.find(s[i])==string::npos && i<j) i++;\\n                while (vowels.find(s[j])==string::npos && i<j) j--;\\n                swap(s[i++],s[j--]);\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            if (s.length() < 2) return s;\\n\\t    string vowels=\"aeiouAEIOU\";\\n            int i = 0, j = s.length()-1;\\n\\n            while (i < j)\\n            {\\n                while (vowels.find(s[i])==string::npos && i<j) i++;\\n                while (vowels.find(s[j])==string::npos && i<j) j--;\\n                swap(s[i++],s[j--]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 81413,
                "title": "my-clear-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        bool isVowel(char c)\\n        {\\n            return c=='a' || c=='e' || c=='i' || c=='o' || c=='u'\\n                || c=='A' || c=='E' || c=='I' || c=='O' || c=='U';\\n        }\\n    \\n        string reverseVowels(string s) \\n        {\\n            int i=0, j=s.size()-1;\\n            while(1)\\n            {\\n                while(i < j && !isVowel(s[i]))\\n                    i++;\\n                while(i < j && !isVowel(s[j]))\\n                    j--;\\n                \\n                if(i >= j) break;\\n                \\n                std::swap(s[i++], s[j--]);\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isVowel(char c)\\n        {\\n            return c=='a' || c=='e' || c=='i' || c=='o' || c=='u'\\n                || c=='A' || c=='E' || c=='I' || c=='O' || c=='U';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 81450,
                "title": "clean-c-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\\n            int i = 0, j = s.length() - 1;\\n            while (i < j) {\\n                if (!vowels.count(s[i]))\\n                    ++i;\\n                else if (!vowels.count(s[j]))\\n                    --j;\\n                else\\n                    swap(s[i++], s[j--]);\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseVowels(string s) {\\n            unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
                "codeTag": "Java"
            },
            {
                "id": 81470,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    \\tbool isVowel (char c) {\\n    \\t\\treturn (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \\n    \\t\\t        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\\n    \\t}\\n    \\n    \\tstring reverseVowels (string s) {\\n    \\t\\tif (s.size() <= 1) return s;\\n    \\t\\tint i = 0, j = s.size() - 1;\\n    \\t\\twhile (i < j) {\\n    \\t\\t\\tif (isVowel(s[i]) && isVowel(s[j]))\\n    \\t\\t\\t\\tswap(s[i++], s[j--]);\\n    \\t\\t\\telse {\\n    \\t\\t\\t\\tif (!isVowel(s[i])) ++i;\\n    \\t\\t\\t\\tif (!isVowel(s[j])) --j;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn s;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tbool isVowel (char c) {\\n    \\t\\treturn (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \\n    \\t\\t        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 4048699,
                "title": "easy-c-solution-with-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We should just care about the pairs from left of the string and the right of the string which are vowel characters. As an example for the second input:\\nleetcode =>  \\n1. left vowel is \\'e\\' right vowel is \\'e\\' swap them. result --> leetcode\\n2. left vowel is \\'e\\' right vowel is \\'o\\' swap them. result --> leotcede\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Approach is simply using two pointers for left index and write index while the left index is smaller than the right index. When a vowel encountered ,say, at left index, we should not increment the left index until we find a pair for that character at right index. Finally, if we find a pair of vowels, we swap them and continue the process.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), n is the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), we just store the vowels and constant variables.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int size = s.length();\\n        int left = 0;\\n        int right = size - 1;\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        bool left_found, right_found;\\n        left_found = false;\\n        right_found = false;\\n\\n        while(left < right){\\n            if(vowels.find(s[left]) != vowels.end()){\\n                left_found = true;\\n            }\\n            if(vowels.find(s[right]) != vowels.end()){\\n                right_found = true;\\n            }\\n            if(left_found && right_found){\\n                char temp = s[right];\\n                s[right] = s[left];\\n                s[left] = temp;\\n                left_found = false;\\n                right_found = false;\\n            }\\n            if(!left_found){\\n                left++;\\n            }\\n            if(!right_found){\\n                right--;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int size = s.length();\\n        int left = 0;\\n        int right = size - 1;\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'};\\n        bool left_found, right_found;\\n        left_found = false;\\n        right_found = false;\\n\\n        while(left < right){\\n            if(vowels.find(s[left]) != vowels.end()){\\n                left_found = true;\\n            }\\n            if(vowels.find(s[right]) != vowels.end()){\\n                right_found = true;\\n            }\\n            if(left_found && right_found){\\n                char temp = s[right];\\n                s[right] = s[left];\\n                s[left] = temp;\\n                left_found = false;\\n                right_found = false;\\n            }\\n            if(!left_found){\\n                left++;\\n            }\\n            if(!right_found){\\n                right--;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048447,
                "title": "day-28-reverse-vowels-of-a-string-java-solution",
                "content": "# Approach\\n1. Firstly I created an HashSet containing all the lower and upper case vowels.\\n2. As I used two pointer technique and Strings are immutable in Java so here I converted the String s to an array.\\n3. Initialized left and right pointers with `left = 0;` and `right = s.length() - 1;`\\n4. Simply traverse through the char array and while left and right both pointers are pointing at a vowel swap them and increment left and decrement right.\\n5. Coming to the last step, as in the question it is clearly mentioned that we have to return String s, `return s=String.valueOf(characters);` this line converts the array to string, and returns it.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n    O(n) \\uD83D\\uDD50\\n\\n- Space complexity:\\n    O(n) \\uD83D\\uDD24\\n\\n---\\n# Request\\n>     If you find this post helpful, please up-vote.\\uD83D\\uDE4F\\uD83C\\uDFFC\\uD83D\\uDE4F\\uD83C\\uDFFC\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> vowels = new HashSet<>();\\n\\t\\tvowels.add(\\'A\\');\\n\\t\\tvowels.add(\\'a\\');\\n\\t\\tvowels.add(\\'E\\');\\n\\t\\tvowels.add(\\'e\\');\\n\\t\\tvowels.add(\\'I\\');\\n\\t\\tvowels.add(\\'i\\');\\n\\t\\tvowels.add(\\'O\\');\\n\\t\\tvowels.add(\\'o\\');\\n\\t\\tvowels.add(\\'U\\');\\n\\t\\tvowels.add(\\'u\\');\\n\\t\\t\\n\\t\\tchar[] characters = s.toCharArray();\\n\\t\\t\\n\\t\\tint left=0, right=s.length()-1;\\n\\t\\t\\n\\t\\twhile(left<right){\\n\\t\\t\\tif(vowels.contains(characters[left]))\\n\\t\\t\\t\\tif(vowels.contains(characters[right])){\\n\\t\\t\\t\\t\\tcharacters[left] = (char)(characters[left] + characters[right] - (characters[right] = characters[left]));\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t\\treturn s=String.valueOf(characters);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> vowels = new HashSet<>();\\n\\t\\tvowels.add(\\'A\\');\\n\\t\\tvowels.add(\\'a\\');\\n\\t\\tvowels.add(\\'E\\');\\n\\t\\tvowels.add(\\'e\\');\\n\\t\\tvowels.add(\\'I\\');\\n\\t\\tvowels.add(\\'i\\');\\n\\t\\tvowels.add(\\'O\\');\\n\\t\\tvowels.add(\\'o\\');\\n\\t\\tvowels.add(\\'U\\');\\n\\t\\tvowels.add(\\'u\\');\\n\\t\\t\\n\\t\\tchar[] characters = s.toCharArray();\\n\\t\\t\\n\\t\\tint left=0, right=s.length()-1;\\n\\t\\t\\n\\t\\twhile(left<right){\\n\\t\\t\\tif(vowels.contains(characters[left]))\\n\\t\\t\\t\\tif(vowels.contains(characters[right])){\\n\\t\\t\\t\\t\\tcharacters[left] = (char)(characters[left] + characters[right] - (characters[right] = characters[left]));\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t\\treturn s=String.valueOf(characters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030591,
                "title": "reverse-vowels-of-string-java-solution-video-available",
                "content": "# if any doubt in solution and you neeed a detailed explaination and soution Watch this video :-\\nhttps://youtu.be/491jQJcmTrY?si=fZeZRMENqPpTD_f3\\n\\n# Problem :-\\nGiven a string s, reverse only all the vowels in the string and return it.\\nThe vowels are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\', and they can appear in both lower and upper cases, more than once.\\n\\nExample :\\nInput: s = \"hello\"\\nOutput: \"holle\"\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Two pointer aproach is used.\\n- keep one pointer on first index and one on last index .\\n- until both of them points on vowels keep moving them towards each other. \\n- if both points on vowel , swap them .\\n- keep moving pointers towards each other till firt index is smaller than last index .\\n\\n\\n# Time complexity :-\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int lengthOfString = s.length();\\n        char ch[] = s.toCharArray();\\n        int start = 0;\\n        int end = lengthOfString - 1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }\\n            else {\\n                char temp = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n        \\n    }\\n     public static boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\') {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int lengthOfString = s.length();\\n        char ch[] = s.toCharArray();\\n        int start = 0;\\n        int end = lengthOfString - 1;\\n        while(start < end) {\\n            if(!isVowel(ch[start])) {\\n                start++;\\n            }\\n            else if(!isVowel(ch[end])) {\\n                end--;\\n            }\\n            else {\\n                char temp = ch[start];\\n                ch[start] = ch[end];\\n                ch[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n        \\n    }\\n     public static boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' || ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\') {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960373,
                "title": "python3-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo swap the positions, need to save the position and reverse the position list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nval stores the value at the index and pos stores the position, next only one of the two lists is reversed. Next reconstruct the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAssume len(s) = n and len(val) = m\\nthen time complexity:\\n$$O(n+m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIDK\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        v = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        val = []\\n        pos = []\\n        for i in range(len(s)):\\n            if s[i].lower() in v:\\n                val.append(s[i])\\n                pos.append(i)\\n        val = val[::-1]\\n        for i in range(len(pos)):\\n            s[pos[i]] = val[i] \\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s = list(s)\\n        v = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        val = []\\n        pos = []\\n        for i in range(len(s)):\\n            if s[i].lower() in v:\\n                val.append(s[i])\\n                pos.append(i)\\n        val = val[::-1]\\n        for i in range(len(pos)):\\n            s[pos[i]] = val[i] \\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958594,
                "title": "o-n-beginner-friendly-100-beats-fully-explained",
                "content": "# Approach\\n\\n**Problem Statement:**\\nGiven a string `s`, you need to reverse the order of only the vowels in the string and return the modified string.\\n\\n**Approach:**\\nTo solve this problem, we can use a two-pointer approach. We\\'ll maintain two pointers, one starting from the beginning of the string (`left`) and the other starting from the end of the string (`right`). We\\'ll move these pointers towards each other, swapping the vowels they point to until they meet in the middle.\\n\\n**Logic:**\\n1. Convert the input string `s` into a character array to make it mutable (`char[] arr = s.toCharArray();`).\\n\\n2. Initialize two pointers: `left = 0` (starting from the beginning of the array) and `right = arr.length - 1` (starting from the end of the array).\\n\\n3. Iterate while `left` is less than `right`:\\n   - Check if the character at index `left` is a vowel using the `isVowel` function.\\n     - If it\\'s a vowel, move the `right` pointer towards the left until a vowel is found using the inner `while` loop.\\n     - Swap the vowels at index `left` and index `right` using the `swap` function.\\n     - Move the `right` pointer one step to the left (`right--`).\\n   - Move the `left` pointer one step to the right (`left++`).\\n\\n4. After the loop completes, the character array `arr` will have the vowels reversed in the string.\\n\\n5. Convert the character array `arr` back to a string using `new String(arr)` and return the modified string.\\n\\n**Vowel Check (isVowel function):**\\nThe `isVowel` function checks whether a given character is a vowel (either lowercase or uppercase) using a simple condition that compares the character against a list of vowel characters.\\n\\n**Swap Function:**\\nThe `swap` function swaps two characters in the character array `arr` using a temporary variable to hold one of the characters while swapping.\\n\\n**Time Complexity:**\\nThe time complexity of this approach is O(n), where n is the length of the input string. The two pointers traverse the string once, and for each character, we either move the `right` pointer leftward or swap two characters, both of which are constant time operations.\\n\\n**Space Complexity:**\\nThe space complexity is O(n) due to the character array `arr` and the constant space used by the `left` and `right` pointers.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0;\\n        int right = arr.length - 1;\\n\\n        while(left < right) {\\n            if(isVowel(arr[left])) {\\n                while(left < right && !isVowel(arr[right])) {\\n                    right--;\\n                }\\n                if(isVowel(arr[right])) {\\n                    swap(arr, left, right);\\n                    right--;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return new String(arr);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    private void swap(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int left = 0;\\n        int right = arr.length - 1;\\n\\n        while(left < right) {\\n            if(isVowel(arr[left])) {\\n                while(left < right && !isVowel(arr[right])) {\\n                    right--;\\n                }\\n                if(isVowel(arr[right])) {\\n                    swap(arr, left, right);\\n                    right--;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return new String(arr);\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ||\\n            c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\';\\n    }\\n\\n    private void swap(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948582,
                "title": "just-2-checks-simplified-one",
                "content": "# Approach\\n*Step-1 -> Convert given string to char array and intialize start = 0 and end = array.length-1 (last element of char array)\\nStep-2 -> Need a helper method to check whether char is vowel or not.\\nStep-3 -> Loop until start less than end\\n    - check if char at start is not vowel if so start++ , \\n    - check if char at end is not vowel if so end-- , \\n    - if both are vowels time to swap them and move start++ and end--\\nStep-4 -> Just return char array in string form using valueOf()*\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start < end){\\n            if(!isVowel(arr[start])){\\n                start++;\\n            }else if(!isVowel(arr[end])){\\n                end--;\\n            }else{\\n                char temp = arr[start];\\n                arr[start] = arr[end];\\n                arr[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n    boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] arr = s.toCharArray();\\n        int start = 0;\\n        int end = arr.length-1;\\n        while(start < end){\\n            if(!isVowel(arr[start])){\\n                start++;\\n            }else if(!isVowel(arr[end])){\\n                end--;\\n            }else{\\n                char temp = arr[start];\\n                arr[start] = arr[end];\\n                arr[end] = temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(arr);\\n    }\\n    boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948578,
                "title": "2-pointer-easy-approach-with-easy-explanation",
                "content": "# Approach\\n1) First we have to convert the string in to char array(toCharArray)\\n2) With the help of two pointer approach we declare start and end variables and we do this problem.\\n3) If the first character is not the vowel means move the start pointer to forward i.e., start++\\n4) Similarly if the end character is not vowel means move the end pointer to backward i.e., end--\\n5) Finally if we found the vowel means swap the characters and make start++ and end--\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] ch=s.toCharArray();\\n        int start=0;\\n        int end=ch.length-1;\\n        while(start<end){\\n            if(!isVowels(ch[start])){\\n                start++;\\n            }\\n            else if(!isVowels(ch[end])){\\n                end--;\\n            }\\n            else{\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowels(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' ||ch==\\'A\\' ||     ch==\\'E\\' ||  ch==\\'I\\' ||ch==\\'O\\' ||ch==\\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] ch=s.toCharArray();\\n        int start=0;\\n        int end=ch.length-1;\\n        while(start<end){\\n            if(!isVowels(ch[start])){\\n                start++;\\n            }\\n            else if(!isVowels(ch[end])){\\n                end--;\\n            }\\n            else{\\n                char temp=ch[start];\\n                ch[start]=ch[end];\\n                ch[end]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n        return String.valueOf(ch);\\n    }\\n    public boolean isVowels(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' ||ch==\\'A\\' ||     ch==\\'E\\' ||  ch==\\'I\\' ||ch==\\'O\\' ||ch==\\'U\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762681,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers easy\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        ch=tolower(ch);\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'o\\' || ch==\\'i\\' || ch==\\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.length();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            if(!isvowel(s[i])) i++;\\n            else if(!isvowel(s[j])) j--;\\n            else if(i<j){\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n             \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        ch=tolower(ch);\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'o\\' || ch==\\'i\\' || ch==\\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int n=s.length();\\n        int i=0;\\n        int j=n-1;\\n        while(i<j){\\n            if(!isvowel(s[i])) i++;\\n            else if(!isvowel(s[j])) j--;\\n            else if(i<j){\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n             \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762507,
                "title": "two-approach-beat-100-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) brute force\\n2) Two Pointer \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer:\\n1) Take two variable p1 and p2;\\n2) On each iteration p1 will increament and p2 will decreament\\n3) check weather the they vowel or not if yes swap that value\\n4) return the same string \\n\\nmy Bruteforce code you also help you  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code Two pointer Approach\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char a){\\n        if(a==\\'a\\' || a == \\'A\\' || a == \\'E\\' || a == \\'e\\' ||a==\\'i\\' || a == \\'I\\' || a == \\'o\\' || a == \\'O\\' ||a==\\'U\\' || a == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int p1 = 0;\\n        int p2 = n-1;\\n\\n        while(p1<=p2){\\n            if(isVowel(s[p1]) && isVowel(s[p2])){\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                p2--;\\n            }\\n            else if(isVowel(s[p1])){\\n                p2--;\\n\\n            }\\n            else if(isVowel(s[p2])){\\n                p1++;\\n            }\\n            else{\\n                p2--;\\n                p1++;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```\\n# BruteForce Approach\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        vector<char>v;\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                v.push_back(s[i]);\\n            }\\n        }\\n        int m = v.size();\\n        reverse(v.begin(), v.end());\\n        int k = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                s[i] = v[k];\\n                k++;\\n            }\\n\\n        }\\n\\n        return s;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char a){\\n        if(a==\\'a\\' || a == \\'A\\' || a == \\'E\\' || a == \\'e\\' ||a==\\'i\\' || a == \\'I\\' || a == \\'o\\' || a == \\'O\\' ||a==\\'U\\' || a == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int p1 = 0;\\n        int p2 = n-1;\\n\\n        while(p1<=p2){\\n            if(isVowel(s[p1]) && isVowel(s[p2])){\\n                swap(s[p1], s[p2]);\\n                p1++;\\n                p2--;\\n            }\\n            else if(isVowel(s[p1])){\\n                p2--;\\n\\n            }\\n            else if(isVowel(s[p2])){\\n                p1++;\\n            }\\n            else{\\n                p2--;\\n                p1++;\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        vector<char>v;\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                v.push_back(s[i]);\\n            }\\n        }\\n        int m = v.size();\\n        reverse(v.begin(), v.end());\\n        int k = 0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'a\\' || s[i] ==\\'A\\' || s[i] == \\'E\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i] == \\'I\\' || s[i] == \\'o\\' || s[i] == \\'O\\' || s[i] == \\'u\\' || s[i] == \\'U\\'){\\n                s[i] = v[k];\\n                k++;\\n            }\\n\\n        }\\n\\n        return s;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665019,
                "title": "dart-replace-reversed-vowels-list",
                "content": "# Approach\\nReverse the vowels in the sentence and later replace them in the base sentance.\\n\\n\\n# Code\\n```\\nclass Solution {\\n  String reverseVowels(String s) {\\n    String vowels = \\'aeiouAEIOU\\';\\n    List<String> sVowels =\\n        s.split(\\'\\').reversed.where((char) => vowels.contains(char)).toList();\\n\\n    List<String> newS =\\n        s.split(\\'\\').map((char) => vowels.contains(char) ? \\'_\\' : char).toList();\\n\\n    for (int i = 0, j = 0; i < newS.length; i++) {\\n      if (newS[i] == \\'_\\') {\\n        newS[i] = sVowels[j];\\n        j++;\\n      }\\n    }\\n\\n    return newS.join();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  String reverseVowels(String s) {\\n    String vowels = \\'aeiouAEIOU\\';\\n    List<String> sVowels =\\n        s.split(\\'\\').reversed.where((char) => vowels.contains(char)).toList();\\n\\n    List<String> newS =\\n        s.split(\\'\\').map((char) => vowels.contains(char) ? \\'_\\' : char).toList();\\n\\n    for (int i = 0, j = 0; i < newS.length; i++) {\\n      if (newS[i] == \\'_\\') {\\n        newS[i] = sVowels[j];\\n        j++;\\n      }\\n    }\\n\\n    return newS.join();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357200,
                "title": "c-stack-linq-2-lines",
                "content": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        Stack<char> stack = new(s.Where(\"aeiouAEIOU\".Contains));\\n        return string.Concat(s.Select(c => \"aeiouAEIOU\".Contains(c) ? stack.Pop() : c));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseVowels(string s) {\\n        Stack<char> stack = new(s.Where(\"aeiouAEIOU\".Contains));\\n        return string.Concat(s.Select(c => \"aeiouAEIOU\".Contains(c) ? stack.Pop() : c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210279,
                "title": "reverse-only-vowels-in-a-string-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use two pointers approach. We can use one pointer to traverse the string from the beginning and another pointer to traverse the string from the end. Whenever we encounter a vowel at the first pointer and another vowel at the second pointer, we swap them. We continue doing this until the two pointers meet in the middle.\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[i] in vowels and s[j] in vowels:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n            elif s[i] in vowels:\\n                j -= 1\\n            else:\\n                i += 1\\n        return \"\".join(s)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, we first create a set of vowels to check whether a character is a vowel or not. We then convert the string to a list so that we can modify its characters.\\n\\nWe initialize two pointers i and j to point to the first and last characters of the string, respectively. We then move the two pointers towards each other until they meet in the middle.\\n\\nFor each pair of characters, if both are vowels, we swap them. If the character at i is a vowel but the character at j is not, we move j towards the beginning of the string. Similarly, if the character at j is a vowel but the character at i is not, we move i towards the end of the string.\\n\\nFinally, we convert the modified list back to a string and return it.\\n# Complexity\\n- Time complexity: The time complexity of this code is $$ O(n)$$, where $$n$$ is the length of the string. This is because we only traverse the string once from both ends and perform constant time operations on each character.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this code is also $$O(n)$$, since we create a list to store the modified string. However, we can modify the string in place, which would reduce the space complexity to $$O(1)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nOverall, your code is well-written and easy to understand. It should work correctly for any valid input string.",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'])\\n        s = list(s)\\n        i, j = 0, len(s) - 1\\n        while i < j:\\n            if s[i] in vowels and s[j] in vowels:\\n                s[i], s[j] = s[j], s[i]\\n                i += 1\\n                j -= 1\\n            elif s[i] in vowels:\\n                j -= 1\\n            else:\\n                i += 1\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848343,
                "title": "beginner-friendly-o-n-time-complexity-code",
                "content": "# Intuition\\nCreate a seperate string to store all the vowels in order.\\n\\n# Approach\\nThe string holding all the vowels of the string(say, temp) will be iterated in reverse manner(j = temp.size() - 1) and whenever we will find a vowel in origginal stirng we will replace it with temp[j] and decrement j. This way we will replace all the vowels in reverse order. The code is attached for reference.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        string ans = \"\", temp = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                temp += s[i];\\n            }\\n        }\\n        int j = temp.size() - 1;\\n        for(int i= 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' \\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                ans += temp[j];\\n                j--;\\n            }\\n            else\\n            {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        string ans = \"\", temp = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                temp += s[i];\\n            }\\n        }\\n        int j = temp.size() - 1;\\n        for(int i= 0; i < n; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\' \\n               || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'I\\' || s[i] == \\'O\\' || s[i] == \\'U\\')\\n            {\\n                ans += temp[j];\\n                j--;\\n            }\\n            else\\n            {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782043,
                "title": "java-most-possible-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        HashSet<Character> vowels = new HashSet<Character>();\\n        Collections.addAll(vowels, \\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int left = 0, right = s.length() - 1;\\n        char[] result = s.toCharArray();\\n        while (left < right) {\\n            if (!vowels.contains(result[left])) {\\n                left ++;\\n                continue;\\n            }\\n            if (!vowels.contains(result[right])) {\\n                right --;\\n                continue;\\n            }\\n            char temp = result[left];\\n            result[left] = result[right];\\n            result[right] = temp;\\n            left ++;\\n            right --;\\n        }\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        HashSet<Character> vowels = new HashSet<Character>();\\n        Collections.addAll(vowels, \\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\');\\n        int left = 0, right = s.length() - 1;\\n        char[] result = s.toCharArray();\\n        while (left < right) {\\n            if (!vowels.contains(result[left])) {\\n                left ++;\\n                continue;\\n            }\\n            if (!vowels.contains(result[right])) {\\n                right --;\\n                continue;\\n            }\\n            char temp = result[left];\\n            result[left] = result[right];\\n            result[right] = temp;\\n            left ++;\\n            right --;\\n        }\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779022,
                "title": "python-simple-python-solution-97-ms",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l=\"aeiouAEIOU\"\\n        s=list(s)\\n        i,j=0,len(s)-1\\n        while(i<j):\\n            if s[i] in l and s[j] in l:\\n                s[i],s[j]=s[j],s[i]\\n                i+=1\\n                j-=1\\n            elif s[i] not in l:\\n                i+=1\\n            elif s[j] not in l:\\n                j-=1\\n        return \\'\\'.join(s)\\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        l=\"aeiouAEIOU\"\\n        s=list(s)\\n        i,j=0,len(s)-1\\n        while(i<j):\\n            if s[i] in l and s[j] in l:\\n                s[i],s[j]=s[j],s[i]\\n                i+=1\\n                j-=1\\n            elif s[i] not in l:\\n                i+=1\\n            elif s[j] not in l:\\n                j-=1\\n        return \\'\\'.join(s)\\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778713,
                "title": "kotlin-two-pointers",
                "content": "Solution [kotlin]\\n```\\n    fun reverseVowels(s: String): String {\\n        val vowels = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n        var chrs = s.toCharArray()\\n        var l = 0\\n        var r = chrs.lastIndex\\n        while(l < r) {\\n            while(l<r && chrs[l] !in vowels) l++\\n            while(l<r && chrs[r] !in vowels) r--\\n            if (l < r) chrs[l] = chrs[r].also { chrs[r] = chrs[l] }\\n            r--\\n            l++\\n        }\\n        return String(chrs)\\n    }\\n```\\nExplanation:\\nStraightforward solution : use two pointers method and scan from the both sides.\\n\\nSpeed: O(N), Memory O(N)\\n\\nBtw, I post my daily leetcode here https://dmitrysamoylenko.com/2022/10/31/leetcode_daily.html and in the telegram channel https://t.me/leetcode_daily_unstoppable",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\n    fun reverseVowels(s: String): String {\\n        val vowels = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\')\\n        var chrs = s.toCharArray()\\n        var l = 0\\n        var r = chrs.lastIndex\\n        while(l < r) {\\n            while(l<r && chrs[l] !in vowels) l++\\n            while(l<r && chrs[r] !in vowels) r--\\n            if (l < r) chrs[l] = chrs[r].also { chrs[r] = chrs[l] }\\n            r--\\n            l++\\n        }\\n        return String(chrs)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778519,
                "title": "c-just-checking-the-new-ui",
                "content": "# Intuition\\n- check for each character from front and end using 2 variables left and right \\n- if both characters are vowel swap left and right values\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int l=0, r=s.size()-1;\\n        while(l<r){\\n            while (l < r && !isVowel(s[l])) l++;\\n            while (r > l && !isVowel(s[r])) r--;\\n            swap(s[l], s[r]);\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    string reverseVowels(string s) {\\n        int l=0, r=s.size()-1;\\n        while(l<r){\\n            while (l < r && !isVowel(s[l])) l++;\\n            while (r > l && !isVowel(s[r])) r--;\\n            swap(s[l], s[r]);\\n            l++, r--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777623,
                "title": "c-simple-using-only-loop",
                "content": "bool isvowel(char c)\\n        {\\n            if(c>=97)\\n                c-=32;\\n            if(c==\\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' ||c==\\'U\\')\\n                return true;\\n            return false;\\n        }\\n    \\n    string reverseVowels(string s) {\\n            for(int i=0,j=s.size()-1;i<j;i++,j--)\\n            {\\n                while(i<j && isvowel(s[i])==0)\\n                    i++;\\n                while(i<j && isvowel(s[j])==0)\\n                    j--;\\n                if(i<j)\\n                    swap(s[i],s[j]);\\n            }\\n                return s;\\n    }",
                "solutionTags": [],
                "code": "bool isvowel(char c)\\n        {\\n            if(c>=97)\\n                c-=32;\\n            if(c==\\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' ||c==\\'U\\')\\n                return true;\\n            return false;\\n        }\\n    \\n    string reverseVowels(string s) {\\n            for(int i=0,j=s.size()-1;i<j;i++,j--)\\n            {\\n                while(i<j && isvowel(s[i])==0)\\n                    i++;\\n                while(i<j && isvowel(s[j])==0)\\n                    j--;\\n                if(i<j)\\n                    swap(s[i],s[j]);\\n            }\\n                return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2777164,
                "title": "easy-method-without-using-reverse-function-10-lines-code-c",
                "content": "class Solution {\\npublic:\\n#    string reverseVowels(string s)\\n    {\\n        vector<char>ch;\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               ch.push_back(s[i]);  }}\\n        int t=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               s[i]=ch[t];\\n                t++;}}\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n#    string reverseVowels(string s)\\n    {\\n        vector<char>ch;\\n       for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n               ch.push_back(s[i]);  }",
                "codeTag": "Java"
            },
            {
                "id": 2777140,
                "title": "stack-usage-c-beats-80-super-easy-for-beginners-starting-dsa",
                "content": "# Intuition\\nIntuition tells us to store into a vector and then to reverse it, however this is perfect question for stack implementation\\n# Approach\\nUsing stack to reverse\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char> ss;\\n        for(auto x:s)if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')ss.push(x);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x=s[i];\\n            if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')\\n                {\\n                    s[i]=ss.top();\\n                    ss.pop();\\n                }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        stack<char> ss;\\n        for(auto x:s)if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')ss.push(x);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            auto x=s[i];\\n            if(x==\\'a\\'|| x==\\'e\\'||x==\\'i\\'||x==\\'o\\'|| x==\\'u\\'||x==\\'A\\'||x==\\'E\\'|| x==\\'I\\'||x==\\'O\\'||x==\\'U\\')\\n                {\\n                    s[i]=ss.top();\\n                    ss.pop();\\n                }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776981,
                "title": "python-two-pointer-approach-o-n",
                "content": "# Two Pointer:\\nFirst we\\'ll convert the string into list. Applying the two pointer approach here, first we take the ```start``` pointer and the ```end``` pointer. When both have same values we swap their values and move both by 1. ```start += 1``` and ```end -=1```. If any value is not vowels move the pointer forward by 1.\\n\\n# Time Complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s_list = list(s)\\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        start = 0\\n        end = len(s_list) - 1\\n\\n        while start < end:\\n            if (s_list[start] not in vowels):\\n                start +=1\\n            if (s_list[end] not in vowels):\\n                end -= 1\\n            \\n            if s_list[start] in vowels and s_list[end] in vowels:\\n                s_list[start], s_list[end] = s_list[end], s_list[start]\\n                start +=1\\n                end -= 1\\n\\n        return \"\".join(s_list)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```start```\n```end```\n```start += 1```\n```end -=1```\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        s_list = list(s)\\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        start = 0\\n        end = len(s_list) - 1\\n\\n        while start < end:\\n            if (s_list[start] not in vowels):\\n                start +=1\\n            if (s_list[end] not in vowels):\\n                end -= 1\\n            \\n            if s_list[start] in vowels and s_list[end] in vowels:\\n                s_list[start], s_list[end] = s_list[end], s_list[start]\\n                start +=1\\n                end -= 1\\n\\n        return \"\".join(s_list)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776686,
                "title": "o-n-c-easy-understanding-two-pointer-approach-top-99-2-time-96-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nswapping elements when we se a vovel \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake 2 pointers one at start other at end index if both are vovel swap then and increment si and decrement ed,if si is vovel the reduce ed samilarly for ed if both are not vovel incease si end decrease ed.\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int si=0;\\n        int ed=s.size()-1;\\n\\n        while(si<ed){\\n            if((s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\')&&(s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\')){\\n                char temp=s[si];\\n                s[si]=s[ed];\\n                s[ed]=temp;\\n                si++;\\n                ed--;\\n            }else if(s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\'){\\n                ed--;\\n            }else if (s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\'){\\n                si++;\\n            }else{\\n                si++;\\n                ed--;\\n            }\\n\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int si=0;\\n        int ed=s.size()-1;\\n\\n        while(si<ed){\\n            if((s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\')&&(s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\')){\\n                char temp=s[si];\\n                s[si]=s[ed];\\n                s[ed]=temp;\\n                si++;\\n                ed--;\\n            }else if(s[si]==\\'a\\'||s[si]==\\'e\\'||s[si]==\\'i\\'||s[si]==\\'o\\'||s[si]==\\'u\\'||s[si]==\\'A\\'||s[si]==\\'E\\'||s[si]==\\'I\\'||s[si]==\\'O\\'||s[si]==\\'U\\'){\\n                ed--;\\n            }else if (s[ed]==\\'a\\'||s[ed]==\\'e\\'||s[ed]==\\'i\\'||s[ed]==\\'o\\'||s[ed]==\\'u\\'||s[ed]==\\'A\\'||s[ed]==\\'E\\'||s[ed]==\\'I\\'||s[ed]==\\'O\\'||s[ed]==\\'U\\'){\\n                si++;\\n            }else{\\n                si++;\\n                ed--;\\n            }\\n\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776568,
                "title": "c-easy-solution-easy-understanding-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.length();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            while(s[i]!=\\'a\\' && s[i]!=\\'i\\' && s[i]!=\\'e\\' && s[i]!=\\'o\\' && s[i]!=\\'u\\' && s[i]!=\\'A\\' && s[i]!=\\'I\\' && s[i]!=\\'E\\' && s[i]!=\\'O\\' && s[i]!=\\'U\\'&& i<j)\\n            {\\n                i++;\\n            }\\n            while(s[j]!=\\'a\\' && s[j]!=\\'i\\' && s[j]!=\\'e\\' && s[j]!=\\'o\\' && s[j]!=\\'u\\' && s[j]!=\\'A\\' && s[j]!=\\'I\\' && s[j]!=\\'E\\' && s[j]!=\\'O\\' && s[j]!=\\'U\\' && i<j)\\n            {\\n                 j--;\\n            }\\n            \\n            if(i<j)swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int n = s.length();\\n        int i=0,j=n-1;\\n        while(i<j)\\n        {\\n            while(s[i]!=\\'a\\' && s[i]!=\\'i\\' && s[i]!=\\'e\\' && s[i]!=\\'o\\' && s[i]!=\\'u\\' && s[i]!=\\'A\\' && s[i]!=\\'I\\' && s[i]!=\\'E\\' && s[i]!=\\'O\\' && s[i]!=\\'U\\'&& i<j)\\n            {\\n                i++;\\n            }\\n            while(s[j]!=\\'a\\' && s[j]!=\\'i\\' && s[j]!=\\'e\\' && s[j]!=\\'o\\' && s[j]!=\\'u\\' && s[j]!=\\'A\\' && s[j]!=\\'I\\' && s[j]!=\\'E\\' && s[j]!=\\'O\\' && s[j]!=\\'U\\' && i<j)\\n            {\\n                 j--;\\n            }\\n            \\n            if(i<j)swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776516,
                "title": "faster-than-100-0ms-c-submission",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool IsVowel(char x) // check if character is vowel or not.\\n    { \\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\' || x==\\'A\\' || x==\\'E\\'|| x==\\'I\\'|| x==\\'O\\'|| x==\\'U\\') return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n       int low=0,high=s.size()-1; \\n       while(low<high)  \\n       {\\n          if(IsVowel(s[low]) && !IsVowel(s[high])) high--; // s[low] is vowel and s[high] is not then high--.\\n\\n          else if(!IsVowel(s[low]) && IsVowel(s[high])) low++; // else low++.\\n\\n          else if(IsVowel(s[low]) && IsVowel(s[high]))swap(s[low++],s[high--]); // if both are vowel than swap them and low++,high-- as well.\\n\\n          else high--,++low; // if both are not vowel simply ignore and low++,high--.\\n       }\\n       return s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool IsVowel(char x) // check if character is vowel or not.\\n    { \\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\' || x==\\'A\\' || x==\\'E\\'|| x==\\'I\\'|| x==\\'O\\'|| x==\\'U\\') return true;\\n        return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n       int low=0,high=s.size()-1; \\n       while(low<high)  \\n       {\\n          if(IsVowel(s[low]) && !IsVowel(s[high])) high--; // s[low] is vowel and s[high] is not then high--.\\n\\n          else if(!IsVowel(s[low]) && IsVowel(s[high])) low++; // else low++.\\n\\n          else if(IsVowel(s[low]) && IsVowel(s[high]))swap(s[low++],s[high--]); // if both are vowel than swap them and low++,high-- as well.\\n\\n          else high--,++low; // if both are not vowel simply ignore and low++,high--.\\n       }\\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775934,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }\\n    \\n    string reverseVowels(string s) {\\n        \\n        int start = 0;\\n        int end = s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(isvowel(s[start]) and isvowel(s[end]))\\n            {\\n                swap(s[start],s[end]);\\n                start++;\\n                end--;\\n            }\\n            else if(isvowel(s[start]))\\n            {\\n                end--;\\n            }\\n            else\\n                start++;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isvowel(char x)\\n    {\\n        if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2775895,
                "title": "o-n-c-solution-using-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to swap the positons of the vowels in order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will use two pointers; start & end, then if we find vowels at start & end positions then swap; other wise increment and/or decrement pointers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)-we only need to iterate over the string only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)- constant space for swaping purpose.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isVowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\'|| c==\\'i\\' || c==\\'o\\' || c==\\'u\\'|| \\n           c==\\'A\\'|| c==\\'E\\'|| c==\\'I\\' || c==\\'O\\'|| c==\\'U\\')\\n           return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n   \\n    int start,end;\\n    start=0;\\n    end=s.size()-1;\\n    while(start<=end){\\n\\n        if(isVowel(s[start]) && isVowel(s[end])){\\n            char ch=s[start];\\n            s[start]=s[end];\\n            s[end]=ch;\\n            start++;\\n            end--;\\n        }\\n        else if(isVowel(s[start])) end--;\\n\\n        else if(isVowel(s[end])) start++;\\n\\n        else {\\n            start++;\\n            end--;\\n        }\\n    }\\n    return s;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isVowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\'|| c==\\'i\\' || c==\\'o\\' || c==\\'u\\'|| \\n           c==\\'A\\'|| c==\\'E\\'|| c==\\'I\\' || c==\\'O\\'|| c==\\'U\\')\\n           return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n   \\n    int start,end;\\n    start=0;\\n    end=s.size()-1;\\n    while(start<=end){\\n\\n        if(isVowel(s[start]) && isVowel(s[end])){\\n            char ch=s[start];\\n            s[start]=s[end];\\n            s[end]=ch;\\n            start++;\\n            end--;\\n        }\\n        else if(isVowel(s[start])) end--;\\n\\n        else if(isVowel(s[end])) start++;\\n\\n        else {\\n            start++;\\n            end--;\\n        }\\n    }\\n    return s;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775761,
                "title": "java-reverse-vowels-of-a-string",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        String str=\"aeiouAEIOU\";\\n        String dummy=\"\";\\n        for(char c:s.toCharArray())\\n        {\\n            if(str.contains(\"\"+c))dummy+=c;\\n        }\\n        char c[]=s.toCharArray();\\n        int j=dummy.length()-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.contains(\"\"+s.charAt(i))){c[i]=dummy.charAt(j);j--;}\\n        }\\n\\t\\t\\n        return String.valueOf(c);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        String str=\"aeiouAEIOU\";\\n        String dummy=\"\";\\n        for(char c:s.toCharArray())\\n        {\\n            if(str.contains(\"\"+c))dummy+=c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2775438,
                "title": "java-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    boolean isVowel(char ch)\\n    {\\n        ch = Character.toLowerCase(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') return true;\\n        return false;\\n    }\\n    void swap(StringBuilder s, int i, int j)\\n    {\\n        char ch1 = s.charAt(i), ch2 = s.charAt(j);\\n        s.setCharAt(i, ch2);\\n        s.setCharAt(j, ch1);\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        StringBuilder str = new StringBuilder(s);\\n        int i = 0, j = str.length() - 1;\\n        while(i <= j)\\n        {\\n            char ch1 = str.charAt(i), ch2 = str.charAt(j);\\n            if (isVowel(ch1) && isVowel(ch2)) //consider swapping only when both s[i] and s[j] are vowels\\n            {\\n                swap(str, i, j);\\n                i++; j--; //move i to right, j to left as we have swapped  \\n                continue;\\n            }\\n            \\n            if (!isVowel(ch1)) i++; //if s[i] is not a vowel keep traversing to right in search of a vowel\\n            if (!isVowel(ch2)) j--; //if s[j] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    boolean isVowel(char ch)\\n    {\\n        ch = Character.toLowerCase(ch); //lower all the characters to reduce checking for upppercase vowels\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') return true;\\n        return false;\\n    }\\n    void swap(StringBuilder s, int i, int j)\\n    {\\n        char ch1 = s.charAt(i), ch2 = s.charAt(j);\\n        s.setCharAt(i, ch2);\\n        s.setCharAt(j, ch1);\\n    }\\n    public String reverseVowels(String s) \\n    {\\n        StringBuilder str = new StringBuilder(s);\\n        int i = 0, j = str.length() - 1;\\n        while(i <= j)\\n        {\\n            char ch1 = str.charAt(i), ch2 = str.charAt(j);\\n            if (isVowel(ch1) && isVowel(ch2)) //consider swapping only when both s[i] and s[j] are vowels\\n            {\\n                swap(str, i, j);\\n                i++; j--; //move i to right, j to left as we have swapped  \\n                continue;\\n            }\\n            \\n            if (!isVowel(ch1)) i++; //if s[i] is not a vowel keep traversing to right in search of a vowel\\n            if (!isVowel(ch2)) j--; //if s[j] is not a vowel keep traversing to left in search of vowel\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775411,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int j = 0;\\n        char[] str = s.toCharArray();\\n        String vowel = \"\";\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] == \\'a\\' || str[i] == \\'A\\' || str[i] == \\'e\\'\\n                    || str[i] == \\'E\\' || str[i] == \\'i\\' || str[i] == \\'I\\'\\n                    || str[i] == \\'o\\' || str[i] == \\'O\\' || str[i] == \\'u\\'\\n                    || str[i] == \\'U\\') {\\n                j++;\\n                vowel += str[i];\\n            }\\n        }\\n        for (int k = 0; k < str.length; k++) {\\n            if (str[k] == \\'a\\' || str[k] == \\'A\\' || str[k] == \\'e\\'\\n                    || str[k] == \\'E\\' || str[k] == \\'i\\' || str[k] == \\'I\\'\\n                    || str[k] == \\'o\\' || str[k] == \\'O\\' || str[k] == \\'u\\'\\n                    || str[k] == \\'U\\') {\\n                str[k] = vowel.charAt(--j);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String reverseVowels(String s) {\\n        int j = 0;\\n        char[] str = s.toCharArray();\\n        String vowel = \"\";\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] == \\'a\\' || str[i] == \\'A\\' || str[i] == \\'e\\'\\n                    || str[i] == \\'E\\' || str[i] == \\'i\\' || str[i] == \\'I\\'\\n                    || str[i] == \\'o\\' || str[i] == \\'O\\' || str[i] == \\'u\\'\\n                    || str[i] == \\'U\\') {\\n                j++;\\n                vowel += str[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2748292,
                "title": "cpp-simple-o-n-solution-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){      //function to check if given charachter is charcter is vowel\\n        ch=tolower(ch);\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int i=0,k=s.size()-1;\\n        while(i<k){                              //stop after swapping left side vowels with right side\\n            if(isVowel(s[i])){ \\n                while(k>=0 && !isVowel(s[k]))    //till we find a vowel from right side of string and k is not less than 0\\n                    k--;\\n                int temp=s[i];                   //swap vowel from lest side of string to right side\\n                s[i]=s[k];\\n                s[k--]=temp;\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){      //function to check if given charachter is charcter is vowel\\n        ch=tolower(ch);\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    string reverseVowels(string s) {\\n        int i=0,k=s.size()-1;\\n        while(i<k){                              //stop after swapping left side vowels with right side\\n            if(isVowel(s[i])){ \\n                while(k>=0 && !isVowel(s[k]))    //till we find a vowel from right side of string and k is not less than 0\\n                    k--;\\n                int temp=s[i];                   //swap vowel from lest side of string to right side\\n                s[i]=s[k];\\n                s[k--]=temp;\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641586,
                "title": "python-solution-99-fast",
                "content": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        vowellist = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'])\\n        \\n        s = list(s)\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowellist:\\n                l += 1\\n            while r > l and s[r] not in vowellist:\\n                r -= 1\\n            \\n            s[l],s[r] = s[r],s[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(s)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "class Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        vowellist = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'])\\n        \\n        s = list(s)\\n        l = 0\\n        r = len(s) - 1\\n        \\n        while l < r:\\n            while l < r and s[l] not in vowellist:\\n                l += 1\\n            while r > l and s[r] not in vowellist:\\n                r -= 1\\n            \\n            s[l],s[r] = s[r],s[l]\\n            l += 1\\n            r -= 1\\n        \\n        return \"\".join(s)",
                "codeTag": "Java"
            },
            {
                "id": 2478678,
                "title": "simple-java-solution-with-explanation-2-pointers",
                "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char[] arr = s.toCharArray();\\n        while (i < j) {\\n            if (isVowel(arr[i]) && isVowel(arr[j])) { // if both forward and backward pointer are at vowel\\'s then swap\\n                char temp = arr[i];\\n                arr[i++] = arr[j];\\n                arr[j--] = temp;\\n            } else if (!isVowel(arr[i])) { // if non-vowel then increment forward pointer\\n                i++;\\n            } else if (!isVowel(arr[j])) { // if non-vowel then decrement backward pointer\\n                j--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    \\n    boolean isVowel(char c) { // check if character is vowel\\n        return ((c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') ||\\n                (c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\'));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        char[] arr = s.toCharArray();\\n        while (i < j) {\\n            if (isVowel(arr[i]) && isVowel(arr[j])) { // if both forward and backward pointer are at vowel\\'s then swap\\n                char temp = arr[i];\\n                arr[i++] = arr[j];\\n                arr[j--] = temp;\\n            } else if (!isVowel(arr[i])) { // if non-vowel then increment forward pointer\\n                i++;\\n            } else if (!isVowel(arr[j])) { // if non-vowel then decrement backward pointer\\n                j--;\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    \\n    boolean isVowel(char c) { // check if character is vowel\\n        return ((c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') ||\\n                (c == \\'A\\' || c == \\'E\\' || c == \\'I\\' || c == \\'O\\' || c == \\'U\\'));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455759,
                "title": "easy-fast-solution-two-pointer",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n    public String reverseVowels(String s) {\\n        int i = 0, j = s.length() - 1;\\n        char[] carr = s.toCharArray();\\n        while (i < j){\\n            if (!isVowel(carr[i])) i++;\\n            if (!isVowel(carr[j])) j--;\\n\\n            if (isVowel(carr[i]) && isVowel(carr[j])){\\n                char temp = carr[i];\\n                carr[i++] = carr[j];\\n                carr[j--] = temp;\\n            }\\n        }\\n        return new String(carr);\\n    }\\n\\n    private boolean isVowel(char c){\\n        switch (c){\\n            case \\'A\\':\\n            case \\'a\\':\\n            case \\'E\\':\\n            case \\'e\\':\\n            case \\'I\\':\\n            case \\'i\\':\\n            case \\'O\\':\\n            case \\'o\\':\\n            case \\'U\\': \\n            case \\'u\\': return true;\\n            default: return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474263,
                "title": "simple-javascript-solution",
                "content": "```\\n// function to swap two chars\\nfunction swap(arr, idx1, idx2) {\\n    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\\n}\\n\\n// reverse vowel function\\nvar reverseVowels = function(s) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'];\\n    s = s.split(\\'\\');\\n    let start = 0;\\n    let end = s.length-1;\\n    while(start < end) {\\n        if(vowels.includes(s[start]) && vowels.includes(s[end])) {\\n            swap(s, start, end);\\n            start++;\\n            end--;\\n        }else if(!vowels.includes(s[start])){\\n            start++;\\n        } else if(!vowels.includes(s[end])) {\\n            end--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// function to swap two chars\\nfunction swap(arr, idx1, idx2) {\\n    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\\n}\\n\\n// reverse vowel function\\nvar reverseVowels = function(s) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\'];\\n    s = s.split(\\'\\');\\n    let start = 0;\\n    let end = s.length-1;\\n    while(start < end) {\\n        if(vowels.includes(s[start]) && vowels.includes(s[end])) {\\n            swap(s, start, end);\\n            start++;\\n            end--;\\n        }else if(!vowels.includes(s[start])){\\n            start++;\\n        } else if(!vowels.includes(s[end])) {\\n            end--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1322317,
                "title": "easy-c-solution-using-two-pointer-o-n",
                "content": "Two Pointer Approach\\n\\n\\n**Time complexity - O(N)** \\n**Space complexity - O(N)** \\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isvowel( char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' || \\n               ch==\\'A\\' || ch==\\'E\\' || ch==\\'I\\' || ch==\\'O\\' || ch==\\'U\\';  \\n    }\\n        \\n    string reverseVowels(string s) {\\n        int n = s.size();\\n        int left =0;\\n        int right = n-1;\\n        while(left < right){\\n            \\n            while(left< right && !isvowel(s[left]))left++;\\n            while(left < right && !isvowel(s[right])) right--;\\n            swap(s[left], s[right]);\\n            left++;\\n            right--;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvowel( char ch){\\n        return ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\' || \\n               ch==\\'A\\' || ch==\\'E\\' || ch==\\'I\\' || ch==\\'O\\' || ch==\\'U\\';  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1247882,
                "title": "python-not-fast-but-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        k=list(s)\\n        v=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        vs=[] #Vowels list from the strig\\n        for i in k:\\n            if i in v:\\n                vs.append(i)\\n        for i in range(len(k)):\\n            if k[i] in v:\\n                k[i]=vs[len(vs)-1] #Taking vowels from back and replacing\\n                vs.pop()\\n        t=\"\".join(k)\\n        return(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        k=list(s)\\n        v=[\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        vs=[] #Vowels list from the strig\\n        for i in k:\\n            if i in v:\\n                vs.append(i)\\n        for i in range(len(k)):\\n            if k[i] in v:\\n                k[i]=vs[len(vs)-1] #Taking vowels from back and replacing\\n                vs.pop()\\n        t=\"\".join(k)\\n        return(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147660,
                "title": "python-3-using-list-pop",
                "content": "Intuition\\n(1) Keep vowels in stack with reverse order\\n(2) loop the string and only replace the vowels.\\n\\n```\\n\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = \"aeiouAEIOU\"\\n        stack = [x for x in s if x in vowels]\\n        ans = [stack.pop() if v in vowels else v for v in s]\\n\\n        return \"\".join(ans)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    def reverseVowels(self, s: str) -> str:\\n\\n        vowels = \"aeiouAEIOU\"\\n        stack = [x for x in s if x in vowels]\\n        ans = [stack.pop() if v in vowels else v for v in s]\\n\\n        return \"\".join(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121020,
                "title": "java-two-pointers-time-o-n",
                "content": "**Two-Pointers Approch:**\\n4 Possible Cases are there that left and right Pointers are Pointing to:\\n**1.vowel and vowel** `[swap and l++ and r--]`\\n**2.vowel and non-vowel** `[find other vowel on right side . Decrease right pointer (r--) only]`\\n**3.non-vowel and vowe**l `[find other vowel on left side . Increase left pointer (l++) only]`\\n**4.non-vowel and non-vowel** `[no swap and l++ and r--](because want to swap vowels only)`\\n```\\n    public String reverseVowels(String s) {\\n        int l=0;\\n        int r=s.length()-1;\\n        char[] words=s.toCharArray();\\n        HashSet<Character> vowels=new HashSet<>();\\n        vowels.add(\\'a\\'); vowels.add(\\'A\\');\\n        vowels.add(\\'e\\'); vowels.add(\\'E\\');\\n        vowels.add(\\'i\\'); vowels.add(\\'I\\');\\n        vowels.add(\\'o\\'); vowels.add(\\'O\\');\\n        vowels.add(\\'u\\'); vowels.add(\\'U\\');\\n        \\n        while(l<r){\\n            char ch1=words[l];\\n            char ch2=words[r];\\n            if(vowels.contains(ch1) && vowels.contains(ch2)){\\n               swap(words,l,r);\\n                l++;\\n                r--;\\n            }else if(vowels.contains(ch1)){\\n                r--;\\n            }else if(vowels.contains(ch2)){\\n                l++;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        String ans=new String(words);\\n        return ans;\\n    }\\n    \\n    private void swap(char[] arr,int i,int j){\\n         char temp=arr[i];\\n          arr[i]=arr[j];\\n          arr[j]=temp;\\n    }\\n```\\t\\nTime:O(N) \\nSpace: constant( we are adding vowels to hashmap which is fix So in Big O notation it is constant)\\n\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n    public String reverseVowels(String s) {\\n        int l=0;\\n        int r=s.length()-1;\\n        char[] words=s.toCharArray();\\n        HashSet<Character> vowels=new HashSet<>();\\n        vowels.add(\\'a\\'); vowels.add(\\'A\\');\\n        vowels.add(\\'e\\'); vowels.add(\\'E\\');\\n        vowels.add(\\'i\\'); vowels.add(\\'I\\');\\n        vowels.add(\\'o\\'); vowels.add(\\'O\\');\\n        vowels.add(\\'u\\'); vowels.add(\\'U\\');\\n        \\n        while(l<r){\\n            char ch1=words[l];\\n            char ch2=words[r];\\n            if(vowels.contains(ch1) && vowels.contains(ch2)){\\n               swap(words,l,r);\\n                l++;\\n                r--;\\n            }else if(vowels.contains(ch1)){\\n                r--;\\n            }else if(vowels.contains(ch2)){\\n                l++;\\n            }else{\\n                l++;\\n                r--;\\n            }\\n        }\\n        String ans=new String(words);\\n        return ans;\\n    }\\n    \\n    private void swap(char[] arr,int i,int j){\\n         char temp=arr[i];\\n          arr[i]=arr[j];\\n          arr[j]=temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995617,
                "title": "python-not-much-but-it-is-honest-work",
                "content": "slow but low space\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels  = \"eoauiEOAUI\"\\n        order = []\\n        k = 0\\n        for i in s:\\n            if i in vowels:\\n                order.append(i)\\n                s = s.replace(i,\\'$\\')\\n        for j in s:\\n            if j == \\'$\\':\\n                k-=1\\n                s = s.replace(j,order[k],1)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels  = \"eoauiEOAUI\"\\n        order = []\\n        k = 0\\n        for i in s:\\n            if i in vowels:\\n                order.append(i)\\n                s = s.replace(i,\\'$\\')\\n        for j in s:\\n            if j == \\'$\\':\\n                k-=1\\n                s = s.replace(j,order[k],1)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987871,
                "title": "swift-simple-solution-by-joshua-puente",
                "content": "```\\nclass Solution {\\n    func reverseVowels(_ s: String) -> String {\\n        let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        \\n        var sArray = Array(s)\\n        var left = 0\\n        var right = sArray.count - 1\\n        while left < right {\\n            if vowels.contains(sArray[left]) && vowels.contains(sArray[right]) {\\n                sArray.swapAt(left, right)\\n                left += 1\\n                right -= 1\\n            } else if vowels.contains(sArray[left]) {\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return String(sArray)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseVowels(_ s: String) -> String {\\n        let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\\n        \\n        var sArray = Array(s)\\n        var left = 0\\n        var right = sArray.count - 1\\n        while left < right {\\n            if vowels.contains(sArray[left]) && vowels.contains(sArray[right]) {\\n                sArray.swapAt(left, right)\\n                left += 1\\n                right -= 1\\n            } else if vowels.contains(sArray[left]) {\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return String(sArray)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911137,
                "title": "c-o-n-with-double-pointers",
                "content": "```\\nclass Solution\\n{\\nprivate:\\n  inline bool m_isVowel(char ch)\\n  {\\n    return (\\n        ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\');\\n  }\\n\\npublic:\\n  string reverseVowels(string s)\\n  {\\n    int len = s.length();\\n    int front = 0, back = len - 1;\\n    char tmp;\\n\\n    while (front < back)\\n    {\\n      if (!m_isVowel(s[front]))\\n      {\\n        front++;\\n      }\\n      else if (!m_isVowel(s[back]))\\n      {\\n        back--;\\n      }\\n      else\\n      {\\n        tmp = s[front];\\n        s[front++] = s[back];\\n        s[back--] = tmp;\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n  inline bool m_isVowel(char ch)\\n  {\\n    return (\\n        ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\' ||\\n        ch == \\'A\\' || ch == \\'E\\' || ch == \\'I\\' || ch == \\'O\\' || ch == \\'U\\');\\n  }\\n\\npublic:\\n  string reverseVowels(string s)\\n  {\\n    int len = s.length();\\n    int front = 0, back = len - 1;\\n    char tmp;\\n\\n    while (front < back)\\n    {\\n      if (!m_isVowel(s[front]))\\n      {\\n        front++;\\n      }\\n      else if (!m_isVowel(s[back]))\\n      {\\n        back--;\\n      }\\n      else\\n      {\\n        tmp = s[front];\\n        s[front++] = s[back];\\n        s[back--] = tmp;\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755897,
                "title": "straightforward-javascript-solution-2-pointers",
                "content": "```\\nconst reverseVowels = (s) => {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']);\\n    s = s.split(\\'\\');\\n    \\n    let l = 0, r = s.length - 1;\\n    \\n    while(l < r){\\n        if(vowels.has(s[l]) && vowels.has(s[r])){\\n            swap(s, l, r);\\n            l++, r--;\\n        }else if(!vowels.has(s[l])){\\n            l++;\\n        }else if(!vowels.has(s[r])){\\n            r--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n\\nconst swap = (arr, l, r) => {\\n    const temp = arr[l];\\n    arr[l] = arr[r];\\n    arr[r] = temp;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverseVowels = (s) => {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']);\\n    s = s.split(\\'\\');\\n    \\n    let l = 0, r = s.length - 1;\\n    \\n    while(l < r){\\n        if(vowels.has(s[l]) && vowels.has(s[r])){\\n            swap(s, l, r);\\n            l++, r--;\\n        }else if(!vowels.has(s[l])){\\n            l++;\\n        }else if(!vowels.has(s[r])){\\n            r--;\\n        }\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n\\nconst swap = (arr, l, r) => {\\n    const temp = arr[l];\\n    arr[l] = arr[r];\\n    arr[r] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671824,
                "title": "c-o-n-short-and-clear-solution-with-2-pointers-80-speed-100-space",
                "content": "I know the function to test vowels might probably be optimised, as in sacrificing some space to build a simple hashmap or the like but I found that trivial and boring.\\n\\nThe solution basically moves `i` and `j` until a vowel is found (if it is found) and until they are so that `i < j`; built-in `swap` just does the rest of the magic for us:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return (c == \\'a\\') || (c == \\'e\\') ||(c == \\'i\\') ||(c == \\'o\\') ||(c == \\'u\\');\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while (i < j) {\\n            while (i < s.size() && !isVowel(s[i])) i++;\\n            while (j && !isVowel(s[j])) j--;\\n            if (i < j) swap(s[i++], s[j--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        c = tolower(c);\\n        return (c == \\'a\\') || (c == \\'e\\') ||(c == \\'i\\') ||(c == \\'o\\') ||(c == \\'u\\');\\n    }\\n    \\n    string reverseVowels(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while (i < j) {\\n            while (i < s.size() && !isVowel(s[i])) i++;\\n            while (j && !isVowel(s[j])) j--;\\n            if (i < j) swap(s[i++], s[j--]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621693,
                "title": "extremely-simple-javascript-solution-video-tutorial",
                "content": "I made a JavaScript video tutorial for anyone who\\'s having difficulty understanding :) Enjoy!\\n\\nhttps://www.youtube.com/watch?v=5d2pRr8TmoE",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "I made a JavaScript video tutorial for anyone who\\'s having difficulty understanding :) Enjoy!\\n\\nhttps://www.youtube.com/watch?v=5d2pRr8TmoE",
                "codeTag": "Unknown"
            },
            {
                "id": 600947,
                "title": "python-easy-solution-2-lines",
                "content": "filter function and list comprehension\\n\\n```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = list(filter(lambda x : x in \\'aeiouAEIOU\\', s))\\n        return \\'\\'.join(x if x not in \\'aeiouAEIOU\\' else vowels.pop() for x in s)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels = list(filter(lambda x : x in \\'aeiouAEIOU\\', s))\\n        return \\'\\'.join(x if x not in \\'aeiouAEIOU\\' else vowels.pop() for x in s)\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1670059,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670419,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670208,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1566085,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670072,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1909009,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1863195,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670584,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670352,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1571618,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670059,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670419,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670208,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1566085,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670072,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1909009,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1863195,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670584,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1670352,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1571618,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "Guys Lowercase AND uppercase."
                    },
                    {
                        "username": "saikrishnachary130",
                        "content": "Acceptance rate is close to 50% for a reason"
                    },
                    {
                        "username": "Architmishr",
                        "content": "I\\'m like............ \"wtf man\""
                    },
                    {
                        "username": "heisenberg280",
                        "content": "yeah"
                    },
                    {
                        "username": "plap1985",
                        "content": "This is a great question. You would be suprised how many senior devs with 10+ years of experience have stuttered and stumbled during a real interview with this question. This may be easy for many of you, but every question teaches us something.  As a batter in cricket, we are taught to respect every ball, same applies to leetcode too, respect every question, it only takes 1 question to bowl us out."
                    },
                    {
                        "username": "vaibhav2012093",
                        "content": "as an  10+ years of experience senior dev I can confirm this is 100% true :-)"
                    },
                    {
                        "username": "BharatUpadhyay",
                        "content": "*Some Cheeky Title*\\n\\nHey there, new interface of Leetcode, so wanted to say Hi to my fellow Leetcoders. \\':P\\nStay strong kings \\uD83D\\uDC51, you\\'ll get to your dream place soon. \\uD83D\\uDCAA\\n\\nAnd as for the question, remember, UpperCase AND Lowercase both need to be checked. "
                    },
                    {
                        "username": "Hannah-Aldor",
                        "content": "There are queens here too :)"
                    },
                    {
                        "username": "Re1nGer",
                        "content": "Thanks for support! May anyone struggling with LC questions eventually land a dream job"
                    },
                    {
                        "username": "Gazoo",
                        "content": "Hello,\\n\\nForgive the cheeky title, but I couldn't resist. I was puzzled at the rejection of my solution when presented with the following Test case:\\n\\n\"yo! Bottoms Up, u.S. Motto, boy!\"\\n\\nwhich is apparently expected to output:\\n\\n\"Yo! Bottoms up, U.S. Motto, boy!\"\\n\\nMy own solution switched the location of the two Y's - which fails to pass the test case.\\n\\nA quick google lead me to find that despite my own schooling, teaching Y as a vowel, it can also be regarded as a consonant. Given this somewhat broad ambiguity, I think the question should be updated to either state that Y is considered a consonant, or specify exactly which letters are considered to be vowels.\\n\\nRegards,\\nGazoo"
                    },
                    {
                        "username": "markjreed",
                        "content": "There are five vowel _letters_ in the Latin alphabet as used for English; however, English has far more than five vowel _sounds_, and doesn't always spell them with one of those five letters.\n\nThe letter Y is not a vowel letter because the primary sound associated with it is a consonant sound: the one at the start of words like \"you\" and \"yuck\". This sound, which is spelled [j] in the International Phonetic Alphabet, is not a vowel, despite being produced with much the same starting mouth configuration as the vowel [i] (English \"ee\"). The missing criterion is that [j] cannot serve as the nucleus of a syllable by itself; it's a very short sound. However, because of the close relationship with [i], it is classed as a \"semivowel\", also called a \"glide\". The same relationship holds between the glide/semivowel [w] and vowel [u] (English \"ooh\").\n\nBut the letter &lt;y&gt; is also used in English to spell an actual vowel; in fact, this might even be the more frequent use of the letter. Unlike French, though, it spells vowels that can also be spelled with other letters, usually &lt;i&gt;. Examples include \"by\" (which has the PRICE diphthong), \"crypt\" (which has [ɪ] as in KIT), and \"lovely\" (which has the happY vowel, either [ɪ] or [i] depending on what regional variety of English you speak).  For this reason, when I was in school, we learned that the vowels were \"A, E, I, O, U, and sometimes Y\". Which is a confusing conflation of spelling and sound, to my mind.  Some teachers even added \"and sometimes W\", because of &lt;w&gt;'s formation of a diphthong – a vowel's job – in words like \"how\", but unlike &lt;y&gt;, &lt;w&gt; is never a vowel by itself in English.  (Although it's a perfectly cromulent one in Welsh.)\n\nAnyway, you would have to encode a lot of extra knowledge into the program to tease out when a &lt;y&gt; in a string was acting as a vowel. At least the specification now says explicitly that it's just the five vowel letters."
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@f50c137y](/f50c137y) apparently y is a vowel... in some situations. And apparently w can be considered a vowel too. And yes, i do remember being taught that y is a vowel in elementary school. However, 7 years later the problem description changed and added the statement of what vowel characters are.  "
                    },
                    {
                        "username": "KrzysztofRozbicki",
                        "content": "[@f50c137y](/f50c137y) in some languages the Y is ONLY the vowel not the consonant (which would be stupid in some group of languages where you write as you speak (like \"y\" is always spelled the same). I am speaking fluently English for over 20 years, but never heard that Y can be consonant in english."
                    },
                    {
                        "username": "f50c137y",
                        "content": "Vowels characters are \"aeiouAEIOU\" FULL STOP. Why did you inadvertently teach yourself that Y/y is a vowel?"
                    },
                    {
                        "username": "anurag629",
                        "content": "Feeling happy considered upper case also in first time!"
                    },
                    {
                        "username": "YuriiMotov",
                        "content": "IMO, it's not quite clear from description, that you have to just swap chars without changing their cases.\nFor example in case 'itE' you have to return 'Eti'.\n\nI understand conditions as 'reverse vowels, but keep case (register) in each place'. i.e. 'itE'->'etI'. But it couses error in one of test cases ."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "just use uppercases as a separate vowel, what\\'s the problem? \\nvowels =  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\', \\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\']"
                    },
                    {
                        "username": "arurahul16",
                        "content": "Input: \"race car\"\\n\\nExpected: \"race car\"\\n\\nOUTPUT : \"reca car\"\\n\\ntest case fails can someone help me ?"
                    },
                    {
                        "username": "mahajansd",
                        "content": "We need to reverse the vowels which are (a, e, a). After reversing the vowels it will be the same as (a, e, a), but considering your solution its currently returning (e, a, a) which is inaccurate."
                    },
                    {
                        "username": "v1kkstar",
                        "content": "[@suku__mar](/suku__mar) bruh as soon as I read this I solved it in 5 minutes, I was stuck on the same case. Thank you"
                    },
                    {
                        "username": "rezdev3",
                        "content": "[@suku__mar](/suku__mar) was wondering this too, thanks this helps"
                    },
                    {
                        "username": "suku__mar",
                        "content": "The question is about reversing the vowels. In \"race car\" vowels order is \"a, e, a\" and after reversing the order must be \"a, e, a\". But you got output like \"e, a, a\" which is not in a reverse order."
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch this video for the better explanation of the code](https://www.youtube.com/watch?v=WwRN59BvSzs)\\nhttps://www.youtube.com/watch?v=WwRN59BvSzs\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems"
                    },
                    {
                        "username": "ratva0717",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n\\n        s = list(s)\\n        vowels = \\'aeiouAEIOU\\'\\n        l, r = 0, len(s) - 1\\n\\n        while (l < r):\\n            while (l < r and s[l] not in vowels):\\n                l += 1\\n            while (r > l and s[r] not in vowels):\\n                r -= 1\\n            s [l], s[r] = s[r], s[l]\\n\\n            l +=1\\n            r -=1\\n            \\n        return \"\".join(s)"
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "[@ManjeetYdv](/ManjeetYdv)  it\\'s not bro . it\\'s sister :)"
                    },
                    {
                        "username": "mahajansd",
                        "content": "s [l], s[r] = s[r], s[l] if I\\'m right then this line is for swapping. Can you please elaborate it more ??\\n"
                    },
                    {
                        "username": "ddvuser",
                        "content": "bro forgot the first rule..."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "bro literally read the first rule of discussion tab !!!"
                    },
                    {
                        "username": "oldxing",
                        "content": "The only thing that prevent me from passing it with only one submission is that you have to consider the uppercases.\\n\\nNo need to share my code at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Great that you were too grumpy to post your solution in comments, cause it doesn;t belong there"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A separate function can be made to check for all vowel characters and then swap their positions "
                    }
                ]
            },
            {
                "id": 1671112,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670924,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670768,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1670733,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 1575979,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2065633,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2063660,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2059257,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2054923,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2049493,
                "content": [
                    {
                        "username": "sahid7",
                        "content": "//Easy Solution\\n//Also consider Uppercase\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char>b;\\n        for(int i=0;i<s.length();i++){\\n if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||\\n    s[i]==\\'O\\'||s[i]==\\'U\\')            {\\n                b.push_back(s[i]);\\n            }\\n        }\\n        int n=b.size();\\n        for(int i=0;i<s.length();i++){\\n               if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\')   {\\n                 s[i]=b[n-1];\\n                 n--;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "Adityamishra3648",
                        "content": "i wrote almost the same code but I was using append instead of push_back and was stuck there for 15 minutes \\uD83D\\uDE02"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Ritik kumar || JAVA SOLUTION\\n\\nclass Solution {\\n    public boolean IsVowel (char c){\\n        if(c == \\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\' || \\n        c == \\'A\\' || c==\\'E\\' || c==\\'I\\' || c==\\'O\\' || c==\\'U\\') return true;\\n        return false;\\n    }\\n    public String reverseVowels(String s) {\\n        \\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            // System.out.println(s.charAt(i));\\n            char c= s.charAt(i);\\n            if(IsVowel(c)) stack.push(c);\\n        }\\n\\n        String str = \"\";\\n        for(int i=0; i< s.length(); i++){\\n            char c= s.charAt(i);\\n            if(!IsVowel(c)) str = str + c;\\n            else {\\n                str = str + stack.pop();\\n            }\\n            // System.out.println(\"str is \"+ str);\\n        }\\n        return str;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "CPP Solution without  using any space\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j)\\n        {\\n            if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             (s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                swap(s[i],s[j]);\\n                i++;j--;\\n            }\\n            else if((s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||\\n            s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\') &&\\n             !(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'||\\n            s[j]==\\'A\\'||s[j]==\\'E\\'||s[j]==\\'I\\'||s[j]==\\'O\\'||s[j]==\\'U\\'))\\n            {\\n                j--;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n}; "
                    },
                    {
                        "username": "loclvt1951999",
                        "content": "how i get a test case \"race car\" my out put is \"reca car\" and it\\'s tell me wrong answer(still \"\\nrace car\")?"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have written down the dry run of the test case u mentioned + the algorithm in my notebook but I find no image tag to upload here.. Kindly check out my solution in the solutions tab. I have updated my solution with the write up there..."
                    },
                    {
                        "username": "user8040zq",
                        "content": "Quite sure \\'Y\\' is a vowel..."
                    },
                    {
                        "username": "linhhlp",
                        "content": "\"Typically, y represents a consonant when it starts off a word or syllable, as in yard, lawyer, or beyond.\"\\nhttps://www.merriam-webster.com/words-at-play/why-y-is-sometimes-a-vowel-usage"
                    },
                    {
                        "username": "tosunm20",
                        "content": "I get Time Limit Exceeded error. Is there anyone who can help? Also, it appears that I passed 479 of 480 tests.\\n\\nclass Solution(object):\\n    def reverseVowels(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\']\\n        s = list(s)\\n        vowels_in_s = [elem for elem in s if elem in vowels]\\n        vowels_in_s.reverse()\\n\\n        i=0\\n        j=0\\n        while i<len(s) and j<len(vowels_in_s):\\n            if (s[i] in vowels_in_s):\\n                s[i] = vowels_in_s[j]\\n                j+=1\\n\\n            i+=1\\n        return (\"\".join(s))\\n"
                    },
                    {
                        "username": "Redwan_Niloy",
                        "content": "DO NOT USE STRING DS here.\\nIt will give a Memory Limit Exceeded Error.\\nUse Vector of char instead."
                    },
                    {
                        "username": "mathamar11",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        vowels=\\'aeiouAEIOU\\'\\n        s_list=list(s)\\n        left,right=0, len(s)-1\\n\\n        while left<right:\\n            while left<right and s_list[left] not in vowels:\\n                left+=1  # left pointer\\n            while left<right and s_list[right] not in vowels:\\n                right-=1 # right pointer\\n\\n            s_list[left], s_list[right]=s_list[right], s_list[left]\\n            left+=1\\n            right-=1\\n        return \\'\\'.join(s_list) # turn the list to a string again "
                    },
                    {
                        "username": "rtti_",
                        "content": "use a hash table (set or dict) to make the lookup time constant as str/list look ups are linear time for ur vowels variable."
                    },
                    {
                        "username": "MrRajput",
                        "content": "Easy solution with proper explanation and good readability - \\n\\n```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        char[] chars = s.toCharArray();\\n        int start = 0;\\n        int end = s.length() - 1;\\n        String vowels = \"aeiouAEIOU\";\\n\\n        while (start < end) {\\n            // Find the first vowel from the start.\\n            while (start < end && vowels.indexOf(chars[start]) == -1) {\\n                start++;\\n            }\\n\\n            // Find the first vowel from the end.\\n            while (start < end && vowels.indexOf(chars[end]) == -1) {\\n                end--;\\n            }\\n\\n            // Swap the vowels.\\n            char temp = chars[start];\\n            chars[start] = chars[end];\\n            chars[end] = temp;\\n\\n            // Move the pointers.\\n            start++;\\n            end--;\\n        }\\n\\n        return new String(chars);\\n    }\\n}\\n```\\n\\n1. Converted the input string s to a character array to make swapping characters easier.\\n2. Used two while loops to find the first vowel from the start and the first vowel from the end.\\n3. While loop condition ensures that start and end won\\'t be equal if the string is empty.\\n4. Created a string vowels to store all vowel characters (both lowercase and uppercase) to simplify the check for vowels.\\n5. Swapped the vowels directly in the character array.\\n6. Returned the result as a new string constructed from the character array. "
                    },
                    {
                        "username": "veranjali2503",
                        "content": "Make a sperate string for vowel."
                    }
                ]
            },
            {
                "id": 2049349,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2022678,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2020375,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 2008649,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1994450,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1990346,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1961857,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1961780,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1951518,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1947106,
                "content": [
                    {
                        "username": "user9157cE",
                        "content": "My european ass learned that \\'Y\\' is (was?) a vowel... not the case here :/"
                    },
                    {
                        "username": "madpoly",
                        "content": "its reversing all vowels, not swapping the first and second and the second and third etc... Made a mistake of thinking that"
                    },
                    {
                        "username": "chaudharyaryanpanwar",
                        "content": "i am not able to solve the testcase in which \nINPUT : \"race car\"\nOUTPUT : \"race car\"\ni am not able to understand its output logic till now i was thinking that the first Vowel is swapped with Second Vowel and the New Second Vowel with Third Vowel and New Third with Fourth and so on but this test case is different.\nHere is my code :-\n `              \nclass Solution {\n    public:\n        string reverseVowels(string s) {\n          int firstVowelIndex ;\n          int secondVowelIndex ;\n          int count = 0 ;\n         char temp;\n         int length= s.length();\n         for (int i  = 0 ; i<length ; i++){\n            if (isVowel(s[i])){\n                count ++;\n                if (count == 1 ){\n                    firstVowelIndex = i;\n                    \n                }\n                if (count == 2 ){\n                    secondVowelIndex = i;\n                    temp = s[secondVowelIndex];\n                    s[secondVowelIndex] = s[firstVowelIndex];\n                    s[firstVowelIndex]=temp;\n                    firstVowelIndex = secondVowelIndex;\n                    count = 1;\n                    \n                    \n                }\n            }\n        }\n        return s;\n    }\n    private:\n    bool isVowel(char c){\n         c = tolower(c);\n         return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n    }\n    \n};`"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "New here. How do you see all testcases so your code doesn\\'t keep failing when you want to submit?"
                    },
                    {
                        "username": "titoadeoye00",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) thanks🙌"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "You can\\'t see all the test cases. Only the sample test cases will be visible to you. Once u submit the code, if ur code isn\\'t correct, it will fail in respective test cases. If u r thinking to see all the hidden test cases, prior to submission, it is not possible as the questions contain thousands of hidden test cases. U can\\'t avoid wrong submission. But don\\'t worry, there is no penalty in doing a wrong submission. "
                    },
                    {
                        "username": "wae57",
                        "content": "Input: \"race car\"\\nExpected: \"race car\"\\nOUTPUT : \"reca car\"\\n\\nThis looks weird, Can someone explain for me."
                    },
                    {
                        "username": "wae57",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Thanks [@Ritabrata Nag](/Ritabrata_1080) that was quite confusing"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Hi wae57. The vowels are reversed as a whole and not word by word. So, for \"race car\" input, the output will be \"race car\"."
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "We can do this problem by implementing a hashmap also"
                    },
                    {
                        "username": "danek1313",
                        "content": "I think the problem definition should also state: \"If the two vowels are different cases, do not swap them.\" I assumed even if they were different to swap them. This is incorrect."
                    },
                    {
                        "username": "9dubs",
                        "content": "DO NOT LOWERCASE THE STRING I REPEAT DO NOT LOWERCASE THE STRING"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can lowercase the string for checking it\\'s vowel or not in the function BUT DO NOT PASS IT BY REFERENCE"
                    },
                    {
                        "username": "LBOA7",
                        "content": "any tips on \"race a car\"?"
                    },
                    {
                        "username": "v1kkstar",
                        "content": "have a pointer at the beginning of the array and one at the end of the array. if the element at the beginning of the array and end of the array are in vowels then replace them, if only beginning is in the array and end of the array isnt then decrement the pointer, and vice versa. "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "just store the vowels in an array and start replacing  the vowels from the top of the array onto your string when you encounter a vowels \neg--->\n\nyour array stores only the vowels present in the string let str = \" this is a cat \"\n\narr = [i , i , a , a ] \n\nstart replacing the strings vowels from the last of the array \n\nstr = \"thas as I cit\";\n\n\nhope this helps ⭐️"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "479 / 480 testcases passed\\nLast test: 17,826 words 106,871 characters"
                    }
                ]
            },
            {
                "id": 1946982,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1941866,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1938873,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1938605,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1912256,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1908778,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1905646,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1900812,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1895506,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1891310,
                "content": [
                    {
                        "username": "bhattanrag123",
                        "content": "is using regex considered fair ?\\n"
                    },
                    {
                        "username": "souyamadebnath",
                        "content": "Case 2 is wrong:\\n\\nfor input \"leetcode\" output should be \"loetcede\" not \"leotcede\""
                    },
                    {
                        "username": "pyush98",
                        "content": "It's not wrong...\n\nvowels = eeoe\nleetcode\nlEEtcOdE\nEEOE\nreversed = eoee\nleotcede\nlEOtcEdE\nEOEE\n"
                    },
                    {
                        "username": "Aranzales8a",
                        "content": "Hi mates! I just have a problem when submitting my problem, it says Time Limit Exceeded when attempting the test 479/480, with a large large input.\n\nThis is my solution:\n ```\nconst reverseVowels = (s) => {\n    const regex = /[aeiou]/gi\n    const stringVowels = s.match(regex);\n    if (!stringVowels) {\n        return s; // No vowels found, return the original string\n    }\n    const reversedVowels = stringVowels.reverse();\n    let i = 0;\n\n    const sortedString = s.split('').map(character => {\n        if (stringVowels.includes(character)) {\n            character = reversedVowels[i]\n            i++;\n            return character\n        } else {\n            return character;\n        }\n    })\n    \n    return sortedString.join('')\n};\n\n```\n\nWhat do you think I can do to solve this problem?"
                    },
                    {
                        "username": "pyush98",
                        "content": "make sure to include capital vowels ROFL well played test caser"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "which is better in this case using an array or a hashset for storing vowels?"
                    },
                    {
                        "username": "poorRican",
                        "content": "For some reason, testcase 480 is failing (in Rust). The line seems to be blank. When I opt to use the testcase, \"Run\" fails because it does not follow the constraints. What is going on?"
                    },
                    {
                        "username": "Saranjen",
                        "content": "Is there a reason why you can\\'t keep it as a string using the two pointer method, and using .replace() to reverse the positions of the pointers at which the vowels are at?"
                    },
                    {
                        "username": "2000031248_Bhargava",
                        "content": "Do not use a stack"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseVowels(self, s):\\n        vowels = [\"A\",\"E\",\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        l = []\\n        [l.append(s[i]) for i in range(len(s))]\\n        for j in range(len(l)):\\n            if l[j] in vowels:\\n                for k in range(j+1, len(l)):\\n                    if l[k] in vowels:\\n                        l[j], l[k] = l[k], l[j]\\n        return \"\".join(l)\\n`"
                    },
                    {
                        "username": "7696928",
                        "content": "s =\\n\"race car\"\\nUse Testcase\\nOutput\\n\"reca car\"\\nExpected\\n\"race car\"\\n\\nwat?"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Because they didn\\'t explain it well. Example:\\nIf you have: \"race car\"\\nThey swapped \"a\" with \"a\"."
                    }
                ]
            },
            {
                "id": 1879175,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1877900,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1877862,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1814018,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1768326,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1695618,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1676407,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1672442,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671302,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671183,
                "content": [
                    {
                        "username": "CodeWithAde",
                        "content": "Using Regex. can anyone explain why it is not valid?\\nvar reverseVowels = function(s){\\n    var vowels = s.match(/[aeiou]/g);\\n    return s.replace(/[aeiou]/g, () => vowels.pop());\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int x=0;\\n       int y=s.size();\\n       while(x<y){\\n        char temp=s[x];\\n        s[x]=s[y-1];\\n        s[y-1]=temp;\\n        x++;y--;\\n\\n       }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "SandeepYadav1",
                        "content": "class Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<int>ar;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                ar.push_back(s[i]);\\n            }\\n        }\\n        int n=ar.size();\\n        for(int i=0;i<s.length();i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                 s[i]=ar[n-1];\\n                 n--;\\n             }\\n\\n        }\\n        return s;\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "clinzer",
                        "content": "simply we first create an bool function to check whether the character are odd or event then we   we use two pointer approach to check if left pointer and right pointer are vowel then swap them.\\n\\nclass Solution {\\npublic:\\n\\n       bool check(char c){\\n    if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' || c == \\'A\\' || c == \\'E\\' || c     == \\'I\\' || c == \\'O\\' || c == \\'U\\') return true;\\n\\n    else return false;\\n    }\\n\\n    string reverseVowels(string s) {\\n        \\n    string vow = \"aeiouAEIOU\";\\n    long long int l = 0;\\n    long long int r = s.length()-1;\\n   \\n    while(l<r){\\n        bool lf = check(s[l]);\\n        bool rh = check(s[r]);\\n\\n   if(lf == false && rh == true){\\n       l++;\\n   }\\n   else if(lf == true && rh == false){\\n       r--;\\n   }\\n\\n  else if(lf == false && rh == false){\\n       l++;\\n       r--;\\n   }\\n   else{\\n        swap(s[l],s[r]);\\n        l++; r--;\\n    }\\n    }\\n     \\nreturn s;\\n    }\\n};"
                    },
                    {
                        "username": "creatorfar",
                        "content": "Extremely frustrating that I can\\'t do a swap in place for Javascript on this question."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def reverseVowels(self, s: str) -> str:\\n        a = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\\n        s = list(s)\\n        \\n        i, j = 0, len(s)-1\\n        while i < j:\\n            while i < j and s[i] not in a:\\n                i += 1\\n            while i < j and s[j] not in a:\\n                j -= 1\\n            s[i], s[j] = s[j], s[i]\\n            i += 1\\n            j -= 1\\n        return \"\".join(s)"
                    },
                    {
                        "username": "shashank1719",
                        "content": "It is just simple approach you can try, make one vector  or string of vowels.\\nthen make one function who checks whether the character is vowel or not?\\nif both character are vowel then swap, else if first vowel then e--, else st++\\n\\n--> Two pointer Approach\\nlong long int st=0;\\nlong long e=s.length()-1;\\n\\n// conditions\\nif(checkvowel(s[st]) && checkVowel(s[e])){\\nswap and update variable\\n}\\nelse if(checkvowel(s[st])){\\nupdate e\\n}else{\\nupdate st\\n} "
                    },
                    {
                        "username": "mahayat",
                        "content": "Guys -> Python strings are immutable"
                    },
                    {
                        "username": "Hardikjain_",
                        "content": "Am I the only ignorant one who missed the uppercase?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can change any char to lower case if its upper case(if its already lower case, then it remains lower case) by performing OR operation of \\' \\' (space character)\\n\\n```\\n   char c = \\'A\\';\\n   char lowerCase = c | \\' \\' ; \\n\\n   char d = \\'a\\';\\n   char upperCase = d & \\'_\\' ;\\n```\\n\\nWondering how does this magic works? Find it out by your own by observing the ASCII values of all lowerCase, upperCase, \\' \\' (space), \\'_\\'(underscore) characters"
                    }
                ]
            },
            {
                "id": 1671138,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671084,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671070,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1671029,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670983,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670977,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670891,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670884,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670881,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670858,
                "content": [
                    {
                        "username": "shwetaa_",
                        "content": "Quite disappointed with the new leetcode editor for mobile version.\\nIt\\'s very very very frustrating to type anything or to move cursor here and there. \\nDon\\'t know why it keeps on pasting lines when we are trying to remove any space or word. \\n\\nAnyone facing same issue? "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "I have seen people posting their queries regarding the same in dicussion forum..What I could suggest is that u can go and upvote there... I open leetcode from my pc only..."
                    },
                    {
                        "username": "rahul9991",
                        "content": "\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        vector<char> v;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' ||s[i]==\\'A\\'  || s[i]==\\'I\\'|| s[i]==\\'O\\'|| s[i]==\\'U\\' ||s[i]==\\'E\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'u\\' || s[i]==\\'o\\'){\\n                v.push_back(s[i]);\\n                s[i]=\\'_\\';\\n            }\\n        }\\n        reverse(v.begin(),v.end());\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'_\\'){\\n                s[i]=v[j++];\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "pruthvish",
                        "content": "Solution I created is just working fine on intellije , but it giving me \"Time limit exceeded\" message every time I try to run or submit it. "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Can you show ur solution plz??"
                    },
                    {
                        "username": "mufassir",
                        "content": "The question does not specifically mentions it, but we have to do the same thing with uppercase vowels as well.\\nSo all the vowels are a, e, i, o, u, A, E, I, O and U."
                    },
                    {
                        "username": "medmoe",
                        "content": "You don\\'t need to convert the string to a list."
                    },
                    {
                        "username": "reversible_82",
                        "content": "I implemented this using a Stack, next attempt I will decrease space complexity\\n `class Solution {\\n    public String reverseVowels(String s) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n\\n        for(int i=0; i<s.length(); i++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(i)) != -1){\\n                stack.push(String.valueOf(s.charAt(i)));\\n            }\\n\\n        }\\n\\n        for(int j=0; j<s.length(); j++){\\n\\n            if(\"AEIOUaeiou\".indexOf(s.charAt(j)) != -1){\\n              StringBuilder sb = new StringBuilder(s);\\n              char character = stack.pop().charAt(0);\\n              sb.setCharAt(j,character); \\n              s=sb.toString();\\n            }\\n\\n        }\\n\\n    return s;\\n    }\\n}`"
                    },
                    {
                        "username": "khushalhecker",
                        "content": "leave  leetcode"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "please don't post any solution or ss here...This section is just for sharing tips or feedback regarding the problem or if any issue is there in solving the problem..Solution section is there to post solutions... :)"
                    },
                    {
                        "username": "ravishankermr",
                        "content": "Lowercase and Uppercase is a bit tricky but treat the vowel string including both \\n\\nHers the simplest solution using 2 pointer solution\\n\\n    public String reverseVowels(String s) {\\n       \\n\\t\\tString vowels = \"aeiouAEIOU\";\\n\\t\\tint i = 0, j = s.length() - 1;\\n\\t\\tchar[] chArr= s.toCharArray();\\n\\t\\t\\n\\t\\twhile (i < j) {\\n\\t\\t\\tchar chI = chArr[i];\\n\\t\\t\\tchar chJ = chArr[j];\\n\\t\\t\\tint indexOfI = vowels.indexOf(chI);\\n\\t\\t\\tint indexOfJ = vowels.indexOf(chJ);\\n\\t\\t\\tif (indexOfI != -1 && indexOfJ != -1) {\\n\\t\\t\\t\\tchar temp = chArr[i];\\n\\t\\t\\t\\tchArr[i] = chArr[j];\\n\\t\\t\\t\\tchArr[j] = temp;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfI == -1) {     \\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\tif (indexOfJ == -1) {  \\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn String.valueOf(chArr); \\n    }\\n"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe\\n"
                    }
                ]
            },
            {
                "id": 1670857,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670856,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670855,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670713,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670686,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670535,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670490,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670461,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670290,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1670268,
                "content": [
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe"
                    },
                    {
                        "username": "kumbhaj",
                        "content": "https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw\\nvisit here solution are available, and do subscribe channel[leetcode](https://leetcode.com)https://www.youtube.com/channel/UCLg2UIBodXfd5Ouwhj7X5bw"
                    },
                    {
                        "username": "fredericodal",
                        "content": "I am not sure how well the runtime calculator works..."
                    },
                    {
                        "username": "abhisek247767",
                        "content": "1.Two pointer + STL concept \n2.And Find two points using \n\n`\nstart=s.find_first_of(\"aeiouAEIOU\",start);\nend=s.find_last_of(\"aeiouAEIOU\",end);`\n\nRequest: Please Don't post here solution or Solution screenshot\nHappy Coding ;)  "
                    },
                    {
                        "username": "devanshu171",
                        "content": "1. Lowercase AND Uppercase both can be present\\n2. Two pointer "
                    },
                    {
                        "username": "Meghna-Bajoria",
                        "content": "JAVA Solution\n\n```\nclass Solution {\n    public String reverseVowels(String s) {\n        int start = 0;\n        int end = s.length() - 1;\n        char[] vowel = new char[] {'a','e','i','o','u'};\n        while(start <= end) {\n            if(contains(vowel, s.charAt(start))) {\n                if(contains(vowel, s.charAt(end))) {\n                    s = swap(s,start,end);\n                    start++;\n                    end--;\n                }\n                else {\n                    end--;\n                }\n            }\n            else {\n                start++;\n            }\n        }\n        return s;\n    }\n\n    private boolean contains(char[] v, char c) {\n        for(char i : v) {\n            if(Character.toLowerCase(i) == Character.toLowerCase(c))\n                return true;\n        }\n\n        return false;\n    }\n\n    private String swap(String s, int start, int end) {\n        StringBuilder string = new StringBuilder(s);\n        char temp = s.charAt(start);\n        string.setCharAt(start, s.charAt(end));\n        //s[start] = s.charAt(end);\n        //s[end] = temp;\n        string.setCharAt(end, temp);\n\n        return string.toString();\n    }\n}\n```"
                    },
                    {
                        "username": "charbelelbateh",
                        "content": "Discussion section is not for solutions"
                    },
                    {
                        "username": "raghav183",
                        "content": "```\\nclass Solution {\\n    public String reverseVowels(String s) {\\n        Set<Character> v = new HashSet<>(Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\',\\'A\\',\\'E\\',\\'I\\',\\'O\\',\\'U\\'));\\n\\n        char[] ch = s.toCharArray();\\n\\n        int left = 0 , right = s.length()-1;\\n        while(left < right){\\n\\n            if(v.contains(ch[left]) && v.contains(ch[right])){\\n                char c = ch[right];\\n                ch[right] = ch[left];\\n                ch[left] = c;\\n                left++;\\n                right--;\\n            }\\n            else{\\n                    if(!v.contains(ch[left])){\\n                        left++;\\n                }\\n                    if(!v.contains(ch[right])){\\n                        right--;\\n                }\\n            } \\n        }\\n        return new String(ch);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "String can contain Uppercase Letters."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "yes"
                    },
                    {
                        "username": "Ash-KODES",
                        "content": "```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) \\n    {\\n        set<char> st;\\n        st.insert(\\'a\\');st.insert(\\'e\\');st.insert(\\'i\\');st.insert(\\'o\\');st.insert(\\'u\\');\\n        st.insert(\\'A\\');st.insert(\\'E\\');st.insert(\\'I\\');st.insert(\\'O\\');st.insert(\\'U\\');\\n        string vowel=\"\";\\n        for(auto val:s)\\n        {\\n            if(st.find(val)!=st.end())\\n            vowel.push_back(val);\\n        }\\n        // cout<<vowel<<endl;\\n        int point=vowel.size()-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.find(s[i])!=st.end())\\n            {\\n                s[i]=vowel[point];\\n                point--;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Add Two Numbers II",
        "question_content": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg\" style=\"width: 523px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,8,0,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [8,0,7]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you solve it without reversing the input lists?</p>\n",
        "solutions": [
            {
                "id": 92623,
                "title": "easy-o-n-java-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack<Integer>();\\n        Stack<Integer> s2 = new Stack<Integer>();\\n        \\n        while(l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        };\\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int sum = 0;\\n        ListNode list = new ListNode(0);\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) sum += s1.pop();\\n            if (!s2.empty()) sum += s2.pop();\\n            list.val = sum % 10;\\n            ListNode head = new ListNode(sum / 10);\\n            head.next = list;\\n            list = head;\\n            sum /= 10;\\n        }\\n        \\n        return list.val == 0 ? list.next : list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack<Integer>();\\n        Stack<Integer> s2 = new Stack<Integer>();\\n        \\n        while(l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        };\\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int sum = 0;\\n        ListNode list = new ListNode(0);\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) sum += s1.pop();\\n            if (!s2.empty()) sum += s2.pop();\\n            list.val = sum % 10;\\n            ListNode head = new ListNode(sum / 10);\\n            head.next = list;\\n            list = head;\\n            sum /= 10;\\n        }\\n        \\n        return list.val == 0 ? list.next : list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687339,
                "title": "java-o-n-solution-with-follow-up-question-no-recursion-no-stacks",
                "content": "**The intuition**\\n1. Since input lists may have different size it make sense to determine the sizes. At this step we also could normalize lists by prepending zero-nodes to the smaller list. But this approach will require additional memory, so we are going to ignore the normalization.\\n\\n2. Iterate over the lists, compute the sum of items and put it into the resulting list. But here are the couple tricks: we are going to build the resulting list in the reversed order and we don\\'t keep the carry value. For example: \\n![image](https://assets.leetcode.com/users/peppered/image_1592152162.png)\\n\\n\\n3. Next we are going to normalize the resulting list. Starting form it\\'s head (which contains the lowest order number) we will iterate over all nodes normalizing the value (`val % 10`), remembering the carry value and reversing the resulting list.\\n\\n4. At the last step the carry value may be greater than 0. In that case we have to create a new node and make it a header of the result. \\n\\n![image](https://assets.leetcode.com/users/peppered/image_1592209145.png)\\n\\n.\\n\\n\\n\\n**The implementation**\\n\\n```\\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n    // We will use sizes to understand which list\\'s nodes should be frozen for a while.\\n    int s1 = size(l1);\\n    int s2 = size(l2);\\n    ListNode resHead = null;\\n    ListNode n = null;\\n    while (l1 != null || l2 != null) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        if (s1 >= s2) {\\n            v1 = l1 != null ? l1.val : 0;\\n            l1 = l1.next;\\n            s1--;\\n        }\\n        // Comparing with s1 + 1 since s1 might be decremented previously\\n        if (s2 >= s1 + 1) {\\n            v2 = l2 != null ? l2.val : 0;\\n            l2 = l2.next;\\n            s2--;\\n        }\\n        // Creating the resulting list in the reversed order.\\n        n = new ListNode(v1 + v2);\\n        n.next = resHead;\\n        resHead = n;\\n    }\\n    int carry = 0;\\n    resHead = null;\\n    // Now, let\\'s perform the normalization.\\n    while (n != null) {\\n        n.val += carry;\\n        if (n.val >= 10) {\\n            n.val = n.val % 10;\\n            carry = 1;\\n        } else {\\n            carry = 0;\\n        }\\n        ListNode buf = n.next;\\n        n.next = resHead;\\n        resHead = n;\\n        n = buf;\\n    }\\n    if (carry > 0) {\\n        n = new ListNode(1);\\n        n.next = resHead;\\n        resHead = n;\\n    }\\n    return resHead;\\n}\\n\\nprivate int size(ListNode l) {\\n    int s = 0;\\n    while (l != null) {\\n        l = l.next;\\n        s++;\\n    }\\n    return s;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n    // We will use sizes to understand which list\\'s nodes should be frozen for a while.\\n    int s1 = size(l1);\\n    int s2 = size(l2);\\n    ListNode resHead = null;\\n    ListNode n = null;\\n    while (l1 != null || l2 != null) {\\n        int v1 = 0;\\n        int v2 = 0;\\n        if (s1 >= s2) {\\n            v1 = l1 != null ? l1.val : 0;\\n            l1 = l1.next;\\n            s1--;\\n        }\\n        // Comparing with s1 + 1 since s1 might be decremented previously\\n        if (s2 >= s1 + 1) {\\n            v2 = l2 != null ? l2.val : 0;\\n            l2 = l2.next;\\n            s2--;\\n        }\\n        // Creating the resulting list in the reversed order.\\n        n = new ListNode(v1 + v2);\\n        n.next = resHead;\\n        resHead = n;\\n    }\\n    int carry = 0;\\n    resHead = null;\\n    // Now, let\\'s perform the normalization.\\n    while (n != null) {\\n        n.val += carry;\\n        if (n.val >= 10) {\\n            n.val = n.val % 10;\\n            carry = 1;\\n        } else {\\n            carry = 0;\\n        }\\n        ListNode buf = n.next;\\n        n.next = resHead;\\n        resHead = n;\\n        n = buf;\\n    }\\n    if (carry > 0) {\\n        n = new ListNode(1);\\n        n.next = resHead;\\n        resHead = n;\\n    }\\n    return resHead;\\n}\\n\\nprivate int size(ListNode l) {\\n    int s = 0;\\n    while (l != null) {\\n        l = l.next;\\n        s++;\\n    }\\n    return s;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92624,
                "title": "c-o-1-extra-space-except-for-output-reverse-output-instead-is-this-cheating",
                "content": "Idea is to reverse output instead of input. Not sure if this is cheating.\\n```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1 = 0, n2 = 0, carry = 0;\\n        ListNode *curr1 = l1, *curr2 = l2, *res = NULL;\\n        while( curr1 ){ curr1=curr1->next; n1++; }\\n        while( curr2 ){ curr2=curr2->next; n2++; } \\n        curr1 = l1; curr2 = l2;\\n        while( n1 > 0 && n2 > 0){\\n            int sum = 0;\\n            if( n1 >= n2 ){ sum += curr1->val; curr1=curr1->next; n1--;}\\n            if( n2 > n1 ){ sum += curr2->val; curr2=curr2->next; n2--;}\\n            res = addToFront( sum, res );\\n        }\\n        curr1 = res; res = NULL;\\n        while( curr1 ){\\n            curr1->val += carry; carry = curr1->val/10;\\n            res = addToFront( curr1->val%10, res );\\n            curr2 = curr1; \\n            curr1 = curr1->next;\\n            delete curr2;\\n        }\\n        if( carry ) res = addToFront( 1, res );\\n        return res;\\n    }\\n    ListNode* addToFront( int val, ListNode* head ){\\n        ListNode* temp = new ListNode(val);\\n        temp->next = head;\\n        return temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1 = 0, n2 = 0, carry = 0;\\n        ListNode *curr1 = l1, *curr2 = l2, *res = NULL;\\n        while( curr1 ){ curr1=curr1->next; n1++; }\\n        while( curr2 ){ curr2=curr2->next; n2++; } \\n        curr1 = l1; curr2 = l2;\\n        while( n1 > 0 && n2 > 0){\\n            int sum = 0;\\n            if( n1 >= n2 ){ sum += curr1->val; curr1=curr1->next; n1--;}\\n            if( n2 > n1 ){ sum += curr2->val; curr2=curr2->next; n2--;}\\n            res = addToFront( sum, res );\\n        }\\n        curr1 = res; res = NULL;\\n        while( curr1 ){\\n            curr1->val += carry; carry = curr1->val/10;\\n            res = addToFront( curr1->val%10, res );\\n            curr2 = curr1; \\n            curr1 = curr1->next;\\n            delete curr2;\\n        }\\n        if( carry ) res = addToFront( 1, res );\\n        return res;\\n    }\\n    ListNode* addToFront( int val, ListNode* head ){\\n        ListNode* temp = new ListNode(val);\\n        temp->next = head;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92627,
                "title": "there-is-no-maximum-of-int-in-python-so",
                "content": "Since there is no maximum of int in python, we can computer the sum and then construct the result link list. Does this count as cheating?\\n~~~~\\ndef addTwoNumbers(self, l1, l2):\\n\\n        x1, x2 = 0, 0\\n        while l1:\\n            x1 = x1*10+l1.val\\n            l1 = l1.next\\n        while l2:\\n            x2 = x2*10+l2.val\\n            l2 = l2.next\\n        x = x1 + x2\\n        \\n        head = ListNode(0)\\n        if x == 0: return head\\n        while x:\\n            v, x = x%10, x//10\\n            head.next, head.next.next = ListNode(v), head.next\\n            \\n        return head.next\\n~~~~",
                "solutionTags": [],
                "code": "Since there is no maximum of int in python, we can computer the sum and then construct the result link list. Does this count as cheating?\\n~~~~\\ndef addTwoNumbers(self, l1, l2):\\n\\n        x1, x2 = 0, 0\\n        while l1:\\n            x1 = x1*10+l1.val\\n            l1 = l1.next\\n        while l2:\\n            x2 = x2*10+l2.val\\n            l2 = l2.next\\n        x = x1 + x2\\n        \\n        head = ListNode(0)\\n        if x == 0: return head\\n        while x:\\n            v, x = x%10, x//10\\n            head.next, head.next.next = ListNode(v), head.next\\n            \\n        return head.next\\n~~~~",
                "codeTag": "Python3"
            },
            {
                "id": 92643,
                "title": "java-o-n-recursive-solution-by-counting-the-difference-of-length",
                "content": "````\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getLength(l1);\\n        int size2 = getLength(l2);\\n        ListNode head = new ListNode(1);\\n        // Make sure l1.length >= l2.length\\n        head.next = size1 < size2 ? helper(l2, l1, size2 - size1) : helper(l1, l2, size1 - size2);\\n        // Handle the first digit\\n        if (head.next.val > 9) {\\n            head.next.val = head.next.val % 10;\\n            return head;\\n        }\\n        return head.next;\\n    }\\n    // get length of the list\\n    public int getLength(ListNode l) {\\n        int count = 0;\\n        while(l != null) {\\n            l = l.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    // offset is the difference of length between l1 and l2\\n    public ListNode helper(ListNode l1, ListNode l2, int offset) {\\n        if (l1 == null) return null;\\n        // check whether l1 becomes the same length as l2\\n        ListNode result = offset == 0 ? new ListNode(l1.val + l2.val) : new ListNode(l1.val);\\n        ListNode post = offset == 0 ? helper(l1.next, l2.next, 0) : helper(l1.next, l2, offset - 1);\\n        // handle carry \\n        if (post != null && post.val > 9) {\\n            result.val += 1;\\n            post.val = post.val % 10;\\n        }\\n        // combine nodes\\n        result.next = post;\\n        return result;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getLength(l1);\\n        int size2 = getLength(l2);\\n        ListNode head = new ListNode(1);\\n        // Make sure l1.length >= l2.length\\n        head.next = size1 < size2 ? helper(l2, l1, size2 - size1) : helper(l1, l2, size1 - size2);\\n        // Handle the first digit\\n        if (head.next.val > 9) {\\n            head.next.val = head.next.val % 10;\\n            return head;\\n        }\\n        return head.next;\\n    }\\n    // get length of the list\\n    public int getLength(ListNode l) {\\n        int count = 0;\\n        while(l != null) {\\n            l = l.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    // offset is the difference of length between l1 and l2\\n    public ListNode helper(ListNode l1, ListNode l2, int offset) {\\n        if (l1 == null) return null;\\n        // check whether l1 becomes the same length as l2\\n        ListNode result = offset == 0 ? new ListNode(l1.val + l2.val) : new ListNode(l1.val);\\n        ListNode post = offset == 0 ? helper(l1.next, l2.next, 0) : helper(l1.next, l2, offset - 1);\\n        // handle carry \\n        if (post != null && post.val > 9) {\\n            result.val += 1;\\n            post.val = post.val % 10;\\n        }\\n        // combine nodes\\n        result.next = post;\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776021,
                "title": "beat-s-100-2-method-s-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe stack-based approach for adding two numbers represented by linked lists involves using stacks to process the digits in reverse order. By pushing the digits of the linked lists onto separate stacks, we can simulate iterating through the numbers from the least significant digit to the most significant digit. We perform digit-wise addition, considering any carry-over, and construct a new linked list to represent the sum. This process continues until both input lists and the carry value are exhausted, resulting in a linked list that represents the sum of the input numbers in the correct order.\\n\\n# Approach 1: (Reverse LL):\\n# Explanation:\\n[2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/solutions/3620367/best-method-100-c-java-python-beginner-friendly/)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        ListNode* dummyHead = new ListNode(0);\\n        ListNode* tail = dummyHead;\\n        int carry = 0;\\n\\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\\n            int digit1 = (l1 != nullptr) ? l1->val : 0;\\n            int digit2 = (l2 != nullptr) ? l2->val : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            tail->next = newNode;\\n            tail = tail->next;\\n\\n            l1 = (l1 != nullptr) ? l1->next : nullptr;\\n            l2 = (l2 != nullptr) ? l2->next : nullptr;\\n        }\\n\\n        ListNode* result = dummyHead->next;\\n        delete dummyHead;\\n        return result;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode* ans = Helper(l1, l2);\\n        return reverseList(ans);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n\\n    public ListNode helper(ListNode l1, ListNode l2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode tail = dummyHead;\\n        int carry = 0;\\n\\n        while (l1 != null || l2 != null || carry != 0) {\\n            int digit1 = (l1 != null) ? l1.val : 0;\\n            int digit2 = (l2 != null) ? l2.val : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode newNode = new ListNode(digit);\\n            tail.next = newNode;\\n            tail = tail.next;\\n\\n            l1 = (l1 != null) ? l1.next : null;\\n            l2 = (l2 != null) ? l2.next : null;\\n        }\\n\\n        ListNode result = dummyHead.next;\\n        return result;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode ans = helper(l1, l2);\\n        return reverseList(ans);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n        return prev\\n\\n    def helper(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        dummyHead = ListNode(0)\\n        tail = dummyHead\\n        carry = 0\\n\\n        while l1 or l2 or carry:\\n            digit1 = l1.val if l1 else 0\\n            digit2 = l2.val if l2 else 0\\n\\n            total = digit1 + digit2 + carry\\n            digit = total % 10\\n            carry = total // 10\\n\\n            newNode = ListNode(digit)\\n            tail.next = newNode\\n            tail = tail.next\\n\\n            l1 = l1.next if l1 else None\\n            l2 = l2.next if l2 else None\\n\\n        result = dummyHead.next\\n        return result\\n\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        l1 = self.reverseList(l1)\\n        l2 = self.reverseList(l2)\\n        ans = self.helper(l1, l2)\\n        return self.reverseList(ans)\\n```\\n\\n# Approach 2: (Using Stack)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        stack<int> stack1, stack2;\\n\\n        while (l1 != nullptr) {\\n            stack1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        while (l2 != nullptr) {\\n            stack2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        ListNode* result = nullptr;\\n        int carry = 0;\\n\\n        while (!stack1.empty() || !stack2.empty() || carry != 0) {\\n            int digit1 = !stack1.empty() ? stack1.top() : 0;\\n            int digit2 = !stack2.empty() ? stack2.top() : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            newNode->next = result;\\n            result = newNode;\\n\\n            if (!stack1.empty())\\n                stack1.pop();\\n            if (!stack2.empty())\\n                stack2.pop();\\n        }\\n\\n        return result;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* ans = Helper(l1, l2);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public ListNode helper(ListNode l1, ListNode l2) {\\n        Stack<Integer> stack1 = new Stack<>();\\n        Stack<Integer> stack2 = new Stack<>();\\n\\n        while (l1 != null) {\\n            stack1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n\\n        while (l2 != null) {\\n            stack2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n\\n        ListNode result = null;\\n        int carry = 0;\\n\\n        while (!stack1.empty() || !stack2.empty() || carry != 0) {\\n            int digit1 = !stack1.empty() ? stack1.pop() : 0;\\n            int digit2 = !stack2.empty() ? stack2.pop() : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode newNode = new ListNode(digit);\\n            newNode.next = result;\\n            result = newNode;\\n        }\\n\\n        return result;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode ans = helper(l1, l2);\\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def helper(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        stack1 = []\\n        stack2 = []\\n\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n\\n        result = None\\n        carry = 0\\n\\n        while stack1 or stack2 or carry:\\n            digit1 = stack1.pop() if stack1 else 0\\n            digit2 = stack2.pop() if stack2 else 0\\n\\n            total = digit1 + digit2 + carry\\n            digit = total % 10\\n            carry = total // 10\\n\\n            newNode = ListNode(digit)\\n            newNode.next = result\\n            result = newNode\\n\\n        return result\\n\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        ans = self.helper(l1, l2)\\n        return ans\\n```\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        ListNode* dummyHead = new ListNode(0);\\n        ListNode* tail = dummyHead;\\n        int carry = 0;\\n\\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\\n            int digit1 = (l1 != nullptr) ? l1->val : 0;\\n            int digit2 = (l2 != nullptr) ? l2->val : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            tail->next = newNode;\\n            tail = tail->next;\\n\\n            l1 = (l1 != nullptr) ? l1->next : nullptr;\\n            l2 = (l2 != nullptr) ? l2->next : nullptr;\\n        }\\n\\n        ListNode* result = dummyHead->next;\\n        delete dummyHead;\\n        return result;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode* ans = Helper(l1, l2);\\n        return reverseList(ans);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n\\n    public ListNode helper(ListNode l1, ListNode l2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode tail = dummyHead;\\n        int carry = 0;\\n\\n        while (l1 != null || l2 != null || carry != 0) {\\n            int digit1 = (l1 != null) ? l1.val : 0;\\n            int digit2 = (l2 != null) ? l2.val : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode newNode = new ListNode(digit);\\n            tail.next = newNode;\\n            tail = tail.next;\\n\\n            l1 = (l1 != null) ? l1.next : null;\\n            l2 = (l2 != null) ? l2.next : null;\\n        }\\n\\n        ListNode result = dummyHead.next;\\n        return result;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode ans = helper(l1, l2);\\n        return reverseList(ans);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n\\n        while curr:\\n            nxt = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nxt\\n        \\n        return prev\\n\\n    def helper(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        dummyHead = ListNode(0)\\n        tail = dummyHead\\n        carry = 0\\n\\n        while l1 or l2 or carry:\\n            digit1 = l1.val if l1 else 0\\n            digit2 = l2.val if l2 else 0\\n\\n            total = digit1 + digit2 + carry\\n            digit = total % 10\\n            carry = total // 10\\n\\n            newNode = ListNode(digit)\\n            tail.next = newNode\\n            tail = tail.next\\n\\n            l1 = l1.next if l1 else None\\n            l2 = l2.next if l2 else None\\n\\n        result = dummyHead.next\\n        return result\\n\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        l1 = self.reverseList(l1)\\n        l2 = self.reverseList(l2)\\n        ans = self.helper(l1, l2)\\n        return self.reverseList(ans)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        stack<int> stack1, stack2;\\n\\n        while (l1 != nullptr) {\\n            stack1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        while (l2 != nullptr) {\\n            stack2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        ListNode* result = nullptr;\\n        int carry = 0;\\n\\n        while (!stack1.empty() || !stack2.empty() || carry != 0) {\\n            int digit1 = !stack1.empty() ? stack1.top() : 0;\\n            int digit2 = !stack2.empty() ? stack2.top() : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            newNode->next = result;\\n            result = newNode;\\n\\n            if (!stack1.empty())\\n                stack1.pop();\\n            if (!stack2.empty())\\n                stack2.pop();\\n        }\\n\\n        return result;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* ans = Helper(l1, l2);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public ListNode helper(ListNode l1, ListNode l2) {\\n        Stack<Integer> stack1 = new Stack<>();\\n        Stack<Integer> stack2 = new Stack<>();\\n\\n        while (l1 != null) {\\n            stack1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n\\n        while (l2 != null) {\\n            stack2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n\\n        ListNode result = null;\\n        int carry = 0;\\n\\n        while (!stack1.empty() || !stack2.empty() || carry != 0) {\\n            int digit1 = !stack1.empty() ? stack1.pop() : 0;\\n            int digit2 = !stack2.empty() ? stack2.pop() : 0;\\n\\n            int sum = digit1 + digit2 + carry;\\n            int digit = sum % 10;\\n            carry = sum / 10;\\n\\n            ListNode newNode = new ListNode(digit);\\n            newNode.next = result;\\n            result = newNode;\\n        }\\n\\n        return result;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode ans = helper(l1, l2);\\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def helper(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        stack1 = []\\n        stack2 = []\\n\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n\\n        result = None\\n        carry = 0\\n\\n        while stack1 or stack2 or carry:\\n            digit1 = stack1.pop() if stack1 else 0\\n            digit2 = stack2.pop() if stack2 else 0\\n\\n            total = digit1 + digit2 + carry\\n            digit = total % 10\\n            carry = total // 10\\n\\n            newNode = ListNode(digit)\\n            newNode.next = result\\n            result = newNode\\n\\n        return result\\n\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        ans = self.helper(l1, l2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926807,
                "title": "python-two-stacks-solution-explained",
                "content": "If we can not reverse our original lists, why not to put them into stack? So, what we do is the following:\\n\\n1. Iterate over the first and the second lists and create two stacks: `st1` and `st2`.\\n2. Iterate over stacks, pop last elements from stack if possible, if not, use `0` for empty stack. Add these two numbers and evaluate next `digit` and `carry`. Create new node with `digit` and attach it before current `head`, update `head`.\\n3. Just return `head` in the end.\\n\\n**Complexity**: time and space complexity is `O(m+n)`, where `m` and `n` lengths of our lists.\\n\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        st1, st2 = [], []\\n        while l1:\\n            st1.append(l1.val)\\n            l1 = l1.next\\n            \\n        while l2:\\n            st2.append(l2.val)\\n            l2 = l2.next\\n        \\n        carry, head = 0, None\\n\\n        while st1 or st2 or carry:\\n            d1, d2 = 0, 0\\n            d1 = st1.pop() if st1 else 0\\n            d2 = st2.pop() if st2 else 0\\n            carry, digit = divmod(d1 + d2 + carry, 10)\\n            head_new = ListNode(digit)\\n            head_new.next = head\\n            head = head_new\\n              \\n        return head\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        st1, st2 = [], []\\n        while l1:\\n            st1.append(l1.val)\\n            l1 = l1.next\\n            \\n        while l2:\\n            st2.append(l2.val)\\n            l2 = l2.next\\n        \\n        carry, head = 0, None\\n\\n        while st1 or st2 or carry:\\n            d1, d2 = 0, 0\\n            d1 = st1.pop() if st1 else 0\\n            d2 = st2.pop() if st2 else 0\\n            carry, digit = divmod(d1 + d2 + carry, 10)\\n            head_new = ListNode(digit)\\n            head_new.next = head\\n            head = head_new\\n              \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138234,
                "title": "simle-o-n-python-solution-recursive",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\n    def addTwoNumbers(self, l1, l2):\\n        len1, len2 = self.getLength(l1), self.getLength(l2)\\n        l1 = self.addLeadingZeros(len2-len1, l1)\\n        l2 = self.addLeadingZeros(len1-len2, l2)\\n        c, ans = self.combineList(l1, l2)\\n        if c>0:\\n            l3 = ListNode(c)\\n            l3.next = ans\\n            ans = l3\\n        return ans\\n\\t\\t\\t\\t\\n    def getLength(self, node):\\n        l = 0\\n        while node:\\n            l += 1\\n            node = node.next\\n        return l\\n    \\n    def addLeadingZeros(self, n, node):\\n        for i in range(n):\\n            new = ListNode(0)\\n            new.next = node\\n            node = new\\n        return node\\n    \\n    def combineList(self, l1, l2):\\n        if (not l1 and not l2):\\n            return (0, None)\\n        c, new = self.combineList(l1.next, l2.next)\\n        s = l1.val+l2.val+c\\n        ans = ListNode(s%10)\\n        ans.next = new\\n        return (s/10, ans)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n\\n    def addTwoNumbers(self, l1, l2):\\n        len1, len2 = self.getLength(l1), self.getLength(l2)\\n        l1 = self.addLeadingZeros(len2-len1, l1)\\n        l2 = self.addLeadingZeros(len1-len2, l2)\\n        c, ans = self.combineList(l1, l2)\\n        if c>0:\\n            l3 = ListNode(c)\\n            l3.next = ans\\n            ans = l3\\n        return ans\\n\\t\\t\\t\\t\\n    def getLength(self, node):\\n        l = 0\\n        while node:\\n            l += 1\\n            node = node.next\\n        return l\\n    \\n    def addLeadingZeros(self, n, node):\\n        for i in range(n):\\n            new = ListNode(0)\\n            new.next = node\\n            node = new\\n        return node\\n    \\n    def combineList(self, l1, l2):\\n        if (not l1 and not l2):\\n            return (0, None)\\n        c, new = self.combineList(l1.next, l2.next)\\n        s = l1.val+l2.val+c\\n        ans = ListNode(s%10)\\n        ans.next = new\\n        return (s/10, ans)\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 798754,
                "title": "easy-c-solution-without-using-stack-or-reversing-the-input-output-list",
                "content": "The idea is to add zeros to the start of the smaller list (which is **allowed** since it doesn\\'t tamper with the original structure of the list) such that both the lists become of equal size and then use recursion to perform digit by digit addition (starting from the last digits, obviously).\\n\\nFor example consider the following lists,\\n```\\nl1: 7->2->4->3\\nl2: 5->6->4\\n```\\n\\nAfter adding zeros to ```l2``` (the smaller list), the lists become,\\n```\\nl1: 7->2->4->3\\nl2: 0->5->6->4\\n```\\n\\nWe now use recursion to dive to the end of both the lists and start addition from the end.\\nAfter each recursion ends, ```l1``` and ```l2``` will be waiting at the previous nodes, so an indirect reverse traversal is obtained without the use of a doubly linked list. \\nThe key is being able to pass ```carry``` from current recursive function to the previous recursive function, for which we can pass the reference variable ```carry``` to function calls so that the changes made to ```carry``` reflect through all the recursive calls made.\\n\\nIf the concept is still not clear, dry running the code using pen and paper will surely help.\\n\\n(P.S - This program might seem lengthy, and although most of it stems from the \"adding zero\" process, I did not want to reduce the length and compromise readability.)\\n\\nHappy Coding..!!\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //Adding zeros to the start of the smaller list:\\n        ListNode *ptr1 = l1, *ptr2 = l2;\\n        while(ptr1 != NULL || ptr2 != NULL)\\n        {\\n            if(ptr1 == NULL)\\n            {\\n                ListNode *newNode = new ListNode(0);\\n                newNode->next = l1;\\n                l1 = newNode;\\n                \\n                ptr2 = ptr2->next;\\n            }\\n            else if(ptr2 == NULL)\\n            {\\n                ListNode *newNode = new ListNode(0);\\n                newNode->next = l2;\\n                l2 = newNode;\\n                \\n                ptr1 = ptr1->next;\\n            }\\n            else\\n            {\\n                ptr1 = ptr1->next;\\n                ptr2 = ptr2->next;\\n            }\\n        }\\n        \\n        //Main operation:\\n        int carry = 0;\\n        ListNode *dummy = new ListNode(-1);\\n        dummy->next = addTwoDigit(l1, l2, carry);\\n        if(carry != 0)\\n        {\\n            ListNode *newNode = new ListNode(carry);\\n            newNode->next = dummy->next;\\n            dummy->next = newNode;\\n        }\\n        \\n        return dummy->next;\\n    }\\n    \\n    ListNode* addTwoDigit(ListNode* l1, ListNode* l2, int &carry)\\n    {\\n        if(l1 == NULL && l2 == NULL)\\n            return NULL;\\n        \\n        ListNode *newNode = new ListNode(-1);\\n        newNode->next = addTwoDigit(l1->next, l2->next, carry);\\n        \\n        newNode->val = (l1->val + l2->val + carry) % 10;\\n        carry = (l1->val + l2->val + carry) / 10;\\n        \\n        return newNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nl1: 7->2->4->3\\nl2: 5->6->4\\n```\n```l2```\n```\\nl1: 7->2->4->3\\nl2: 0->5->6->4\\n```\n```l1```\n```l2```\n```carry```\n```carry```\n```carry```\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //Adding zeros to the start of the smaller list:\\n        ListNode *ptr1 = l1, *ptr2 = l2;\\n        while(ptr1 != NULL || ptr2 != NULL)\\n        {\\n            if(ptr1 == NULL)\\n            {\\n                ListNode *newNode = new ListNode(0);\\n                newNode->next = l1;\\n                l1 = newNode;\\n                \\n                ptr2 = ptr2->next;\\n            }\\n            else if(ptr2 == NULL)\\n            {\\n                ListNode *newNode = new ListNode(0);\\n                newNode->next = l2;\\n                l2 = newNode;\\n                \\n                ptr1 = ptr1->next;\\n            }\\n            else\\n            {\\n                ptr1 = ptr1->next;\\n                ptr2 = ptr2->next;\\n            }\\n        }\\n        \\n        //Main operation:\\n        int carry = 0;\\n        ListNode *dummy = new ListNode(-1);\\n        dummy->next = addTwoDigit(l1, l2, carry);\\n        if(carry != 0)\\n        {\\n            ListNode *newNode = new ListNode(carry);\\n            newNode->next = dummy->next;\\n            dummy->next = newNode;\\n        }\\n        \\n        return dummy->next;\\n    }\\n    \\n    ListNode* addTwoDigit(ListNode* l1, ListNode* l2, int &carry)\\n    {\\n        if(l1 == NULL && l2 == NULL)\\n            return NULL;\\n        \\n        ListNode *newNode = new ListNode(-1);\\n        newNode->next = addTwoDigit(l1->next, l2->next, carry);\\n        \\n        newNode->val = (l1->val + l2->val + carry) % 10;\\n        carry = (l1->val + l2->val + carry) / 10;\\n        \\n        return newNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92629,
                "title": "concise-c-solution-without-reverse",
                "content": "O(n) time, O(n) space\\nAnybody knows O(1) space solution without reverse?\\nclass Solution {\\npublic:\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        vector<int> nums1, nums2;\\n        while(l1) {\\n            nums1.push_back(l1->val);\\n            l1 = l1->next;\\n        }\\n        while(l2) {\\n            nums2.push_back(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        int m = nums1.size(), n = nums2.size();\\n        int sum = 0, carry = 0;\\n\\n        ListNode *head = nullptr, *p = nullptr;\\n\\n        for(int i = m - 1, j = n - 1; i >= 0 || j >= 0 || carry > 0; i--, j--) {\\n            sum = carry;\\n            if(i >= 0) \\n                sum += nums1[i];\\n\\n            if(j >= 0)\\n                sum += nums2[j];\\n\\n            carry = sum / 10;\\n\\n            p = new ListNode(sum%10);\\n            p->next = head;\\n            head = p;\\n        }\\n\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        vector<int> nums1, nums2;\\n        while(l1) {\\n            nums1.push_back(l1->val);\\n            l1 = l1->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 202769,
                "title": "fast-simple-python",
                "content": "If the numbers were in little-endian format, then we cound do something like a ripple adder directly. Since we can\\'t modify the inputs, the best thing to do is just find the numbers, add them, and create a new list from that number. I\\'ve avoided using strings because it seems like an unnecessary complexity or probably drag on speed to me.\\n\\n    class Solution(object):\\n        def addTwoNumbers(self, l1, l2):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type l1: ListNode\\n\\t\\t\\t:type l2: ListNode\\n\\t\\t\\t:rtype: ListNode\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t# turn the lists in to ints with simple loops. In case you didn\\'t know, you can put\\n\\t\\t\\t# multiple statements on the same line if you use semicolons in Python.\\n\\t\\t\\ts1 = 0\\n\\t\\t\\ts2 = 0\\n\\t\\t\\twhile l1: s1 *= 10; s1 += l1.val; l1 = l1.next\\n\\t\\t\\twhile l2: s2 *= 10; s2 += l2.val; l2 = l2.next\\n\\n\\t\\t\\t# take the sum and reconstruct the number from tail to head, because it\\'s easier\\n\\t\\t\\t# to isolate and chop off the little digits with modulus and division.\\n\\t\\t\\ts3 = s1 + s2\\n\\t\\t\\ttail = None\\n\\t\\t\\thead = None\\n\\t\\t\\twhile s3 > 0: head = ListNode(s3 % 10); head.next = tail; tail = head; s3 /= 10\\n\\t\\t\\treturn head if head else ListNode(0)",
                "solutionTags": [],
                "code": "If the numbers were in little-endian format, then we cound do something like a ripple adder directly. Since we can\\'t modify the inputs, the best thing to do is just find the numbers, add them, and create a new list from that number. I\\'ve avoided using strings because it seems like an unnecessary complexity or probably drag on speed to me.\\n\\n    class Solution(object):\\n        def addTwoNumbers(self, l1, l2):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type l1: ListNode\\n\\t\\t\\t:type l2: ListNode\\n\\t\\t\\t:rtype: ListNode\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t# turn the lists in to ints with simple loops. In case you didn\\'t know, you can put\\n\\t\\t\\t# multiple statements on the same line if you use semicolons in Python.\\n\\t\\t\\ts1 = 0\\n\\t\\t\\ts2 = 0\\n\\t\\t\\twhile l1: s1 *= 10; s1 += l1.val; l1 = l1.next\\n\\t\\t\\twhile l2: s2 *= 10; s2 += l2.val; l2 = l2.next\\n\\n\\t\\t\\t# take the sum and reconstruct the number from tail to head, because it\\'s easier\\n\\t\\t\\t# to isolate and chop off the little digits with modulus and division.\\n\\t\\t\\ts3 = s1 + s2\\n\\t\\t\\ttail = None\\n\\t\\t\\thead = None\\n\\t\\t\\twhile s3 > 0: head = ListNode(s3 % 10); head.next = tail; tail = head; s3 /= 10\\n\\t\\t\\treturn head if head else ListNode(0)",
                "codeTag": "Java"
            },
            {
                "id": 3776325,
                "title": "100-fast-very-easy-explanation-java-c-python",
                "content": "# Intuition\\n\\nReverse Both the list so both the last will come first and start adding untill both are not null and remainder is not 0.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/mrbIZ4vFAkA\\n or link in my profile.Here,you can find any solution in playlists monthwise from may 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The `rev` function is defined to reverse a linked list iteratively. It uses three pointers: `curr`, `prev`, and `nex`. It starts with `curr` pointing to the head of the list. It iteratively updates the `next` pointer of each node to point to the previous node. After updating the pointers, `prev` is updated to `curr`, `curr` is updated to `nex`, and `nex` is updated to `curr->next`. The function returns `prev`, which becomes the new head of the reversed list.\\n\\n2. The `rev2` function is defined to reverse a linked list recursively using the divide-and-conquer approach. It checks the base cases: if the `head` is `NULL`, it returns `NULL`, and if the `head->next` is `NULL`, it returns `head` itself. Otherwise, it recursively calls `rev2` on `head->next` to reverse the remaining sublist. After getting the reversed sublist, it updates the `next` pointer of the second node to point to the `head`, sets `head->next` to `NULL`, and returns the new head of the reversed list.\\n\\nYou can use any method recursive or inerative to reverse a List.\\n\\n3. The `solve` function performs the addition of two reversed linked lists. It initializes a carry variable as 0 and creates a dummy node `p` to store the result. It iterates over both linked lists simultaneously, adding the corresponding digits along with the carry. It calculates the sum, updates the carry, creates a new node with the value of the sum % 10, and appends it to the result linked list. The iteration continues until both input lists and the carry are exhausted.\\n\\n4. The `addTwoNumbers` function is the main entry point of the code. It first reverses the first input linked list using the `rev` function and reverses the second input linked list using the `rev2` function. Then, it calls the `solve` function with the reversed lists as arguments to perform the addition. The result is a reversed linked list, so it reverses the result again using the `rev` function before returning it.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  ListNode* rev(ListNode* head) {\\n          if(head==NULL)\\n            return NULL;\\n    ListNode*curr=head;\\n    ListNode*prev=NULL;\\n    ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode*rev2(ListNode*head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode*newhead=rev2(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return newhead;\\n    }\\n    ListNode* solve(ListNode* head1, ListNode* head2) {\\n          int car=0;\\n    ListNode*p=new ListNode(9);\\n        ListNode*ans=p;\\n    while(head1!=NULL||head2!=NULL||car>0){\\n        int sum=car;\\n        if(head1!=NULL){\\n            sum+=head1->val;\\n            head1=head1->next;\\n        }\\n        if(head2!=NULL){\\n            sum+=head2->val;\\n            head2=head2->next;\\n        }\\n        int v=sum%10;\\n        car=sum/10;\\n        ans->next=new ListNode(v);\\n        ans=ans->next;\\n    }\\n    return p->next;;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode*l1rev=rev(l1);\\n        ListNode*l2rev=rev2(l2);\\n        ListNode*res=solve(l1rev,l2rev);\\n        return rev(res);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode rev(ListNode head) {\\n        if (head == null)\\n            return null;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode nex = null;\\n        while (curr != null) {\\n            nex = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nex;\\n        }\\n        return prev;\\n    }\\n\\n    public ListNode rev2(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = rev2(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public ListNode solve(ListNode head1, ListNode head2) {\\n        int car = 0;\\n        ListNode p = new ListNode(9);\\n        ListNode ans = p;\\n        while (head1 != null || head2 != null || car > 0) {\\n            int sum = car;\\n            if (head1 != null) {\\n                sum += head1.val;\\n                head1 = head1.next;\\n            }\\n            if (head2 != null) {\\n                sum += head2.val;\\n                head2 = head2.next;\\n            }\\n            int v = sum % 10;\\n            car = sum / 10;\\n            ans.next = new ListNode(v);\\n            ans = ans.next;\\n        }\\n        return p.next;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode l1rev = rev(l1);\\n        ListNode l2rev = rev2(l2);\\n        ListNode res = solve(l1rev, l2rev);\\n        return rev(res);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def rev(self, head):\\n        if head is None:\\n            return None\\n        curr = head\\n        prev = None\\n        nex = None\\n        while curr is not None:\\n            nex = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nex\\n        return prev\\n\\n    def rev2(self, head):\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        new_head = self.rev2(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return new_head\\n\\n    def solve(self, head1, head2):\\n        car = 0\\n        p = ListNode(9)\\n        ans = p\\n        while head1 is not None or head2 is not None or car > 0:\\n            sum = car\\n            if head1 is not None:\\n                sum += head1.val\\n                head1 = head1.next\\n            if head2 is not None:\\n                sum += head2.val\\n                head2 = head2.next\\n            v = sum % 10\\n            car = sum // 10\\n            ans.next = ListNode(v)\\n            ans = ans.next\\n        return p.next\\n\\n    def addTwoNumbers(self, l1, l2):\\n        l1rev = self.rev(l1)\\n        l2rev = self.rev2(l2)\\n        res = self.solve(l1rev, l2rev)\\n        return self.rev(res)\\n\\n```\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/02e83be0-32f3-4736-b0dc-764b93af0eef_1689582958.3116593.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Math"
                ],
                "code": "```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  ListNode* rev(ListNode* head) {\\n          if(head==NULL)\\n            return NULL;\\n    ListNode*curr=head;\\n    ListNode*prev=NULL;\\n    ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode*rev2(ListNode*head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return head;\\n        }\\n        ListNode*newhead=rev2(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return newhead;\\n    }\\n    ListNode* solve(ListNode* head1, ListNode* head2) {\\n          int car=0;\\n    ListNode*p=new ListNode(9);\\n        ListNode*ans=p;\\n    while(head1!=NULL||head2!=NULL||car>0){\\n        int sum=car;\\n        if(head1!=NULL){\\n            sum+=head1->val;\\n            head1=head1->next;\\n        }\\n        if(head2!=NULL){\\n            sum+=head2->val;\\n            head2=head2->next;\\n        }\\n        int v=sum%10;\\n        car=sum/10;\\n        ans->next=new ListNode(v);\\n        ans=ans->next;\\n    }\\n    return p->next;;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode*l1rev=rev(l1);\\n        ListNode*l2rev=rev2(l2);\\n        ListNode*res=solve(l1rev,l2rev);\\n        return rev(res);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode rev(ListNode head) {\\n        if (head == null)\\n            return null;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode nex = null;\\n        while (curr != null) {\\n            nex = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nex;\\n        }\\n        return prev;\\n    }\\n\\n    public ListNode rev2(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return head;\\n        }\\n        ListNode newHead = rev2(head.next);\\n        head.next.next = head;\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public ListNode solve(ListNode head1, ListNode head2) {\\n        int car = 0;\\n        ListNode p = new ListNode(9);\\n        ListNode ans = p;\\n        while (head1 != null || head2 != null || car > 0) {\\n            int sum = car;\\n            if (head1 != null) {\\n                sum += head1.val;\\n                head1 = head1.next;\\n            }\\n            if (head2 != null) {\\n                sum += head2.val;\\n                head2 = head2.next;\\n            }\\n            int v = sum % 10;\\n            car = sum / 10;\\n            ans.next = new ListNode(v);\\n            ans = ans.next;\\n        }\\n        return p.next;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode l1rev = rev(l1);\\n        ListNode l2rev = rev2(l2);\\n        ListNode res = solve(l1rev, l2rev);\\n        return rev(res);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def rev(self, head):\\n        if head is None:\\n            return None\\n        curr = head\\n        prev = None\\n        nex = None\\n        while curr is not None:\\n            nex = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nex\\n        return prev\\n\\n    def rev2(self, head):\\n        if head is None:\\n            return None\\n        if head.next is None:\\n            return head\\n        new_head = self.rev2(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return new_head\\n\\n    def solve(self, head1, head2):\\n        car = 0\\n        p = ListNode(9)\\n        ans = p\\n        while head1 is not None or head2 is not None or car > 0:\\n            sum = car\\n            if head1 is not None:\\n                sum += head1.val\\n                head1 = head1.next\\n            if head2 is not None:\\n                sum += head2.val\\n                head2 = head2.next\\n            v = sum % 10\\n            car = sum // 10\\n            ans.next = ListNode(v)\\n            ans = ans.next\\n        return p.next\\n\\n    def addTwoNumbers(self, l1, l2):\\n        l1rev = self.rev(l1)\\n        l2rev = self.rev2(l2)\\n        res = self.solve(l1rev, l2rev)\\n        return self.rev(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927753,
                "title": "python-easy-to-understand-beats-99-with-o-1-space",
                "content": "please Upvote\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        \\n        \\n        s1,s2=0,0\\n        \\n        while l1!=None:\\n            s1=s1*10+l1.val\\n            l1=l1.next\\n        \\n        while l2!=None:\\n            s2=s2*10+l2.val\\n            l2=l2.next\\n        \\n        \\n        dummylist=dummy=ListNode(0)\\n        \\n        for i in str(s1+s2):\\n            dummy.next=ListNode(i)\\n            dummy=dummy.next\\n        \\n        return dummylist.next\\n        \\n            \\n```\\nplease Upvote",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        \\n        \\n        s1,s2=0,0\\n        \\n        while l1!=None:\\n            s1=s1*10+l1.val\\n            l1=l1.next\\n        \\n        while l2!=None:\\n            s2=s2*10+l2.val\\n            l2=l2.next\\n        \\n        \\n        dummylist=dummy=ListNode(0)\\n        \\n        for i in str(s1+s2):\\n            dummy.next=ListNode(i)\\n            dummy=dummy.next\\n        \\n        return dummylist.next\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 129192,
                "title": "clear-python-solution-using-stack",
                "content": "Since you can\\'t change the linked lists, then just have to walk them then push values to two stacks:\\n\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Use two stacks to store the number\\n        stack1 = []\\n        stack2 = []\\n        ptr = l1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n        ptr = l2\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n            \\n        carry = 0\\n        result = []\\n        head = ListNode(-1)\\n        while stack1 or stack2:\\n            if not stack1:\\n                val = stack2.pop()\\n            elif not stack2:\\n                val = stack1.pop()\\n            else:\\n                val = stack1.pop() + stack2.pop()    \\n            carry, val = divmod(carry + val, 10)\\n            head.val = val\\n            temp = head\\n            head = ListNode(-1)\\n            head.next = temp\\n        if carry: head.val = carry\\n        return head if head.val != -1 else head.next ",
                "solutionTags": [],
                "code": "Since you can\\'t change the linked lists, then just have to walk them then push values to two stacks:\\n\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Use two stacks to store the number\\n        stack1 = []\\n        stack2 = []\\n        ptr = l1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n        ptr = l2\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n            \\n        carry = 0\\n        result = []\\n        head = ListNode(-1)\\n        while stack1 or stack2:\\n            if not stack1:\\n                val = stack2.pop()\\n            elif not stack2:\\n                val = stack1.pop()\\n            else:\\n                val = stack1.pop() + stack2.pop()    \\n            carry, val = divmod(carry + val, 10)\\n            head.val = val\\n            temp = head\\n            head = ListNode(-1)\\n            head.next = temp\\n        if carry: head.val = carry\\n        return head if head.val != -1 else head.next ",
                "codeTag": "Java"
            },
            {
                "id": 926749,
                "title": "c-simple-string-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        string a, b;\\n        ListNode *result = nullptr;\\n        while(l1) { a.push_back(l1->val+\\'0\\'); l1 = l1->next;}\\n        while(l2) { b.push_back(l2->val+\\'0\\'); l2 = l2->next;}\\n        int l = a.size()-1, r = b.size()-1, carry = 0;\\n        while(l >= 0 || r >= 0 || carry == 1) {\\n            int c = (l >= 0 ? a[l--]-\\'0\\' : 0) + ( r >= 0 ? b[r--]-\\'0\\' : 0) + carry;\\n            ListNode *temp = new ListNode(c%10);\\n            temp->next = result;\\n            result = temp;\\n            carry = c/10;\\n        }        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        string a, b;\\n        ListNode *result = nullptr;\\n        while(l1) { a.push_back(l1->val+\\'0\\'); l1 = l1->next;}\\n        while(l2) { b.push_back(l2->val+\\'0\\'); l2 = l2->next;}\\n        int l = a.size()-1, r = b.size()-1, carry = 0;\\n        while(l >= 0 || r >= 0 || carry == 1) {\\n            int c = (l >= 0 ? a[l--]-\\'0\\' : 0) + ( r >= 0 ? b[r--]-\\'0\\' : 0) + carry;\\n            ListNode *temp = new ListNode(c%10);\\n            temp->next = result;\\n            result = temp;\\n            carry = c/10;\\n        }        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367026,
                "title": "javascript-o-n-solution-using-stack",
                "content": "```\\nvar addTwoNumbers = function(l1, l2) {\\n    let stack1 = [];\\n    let stack2 = [];\\n    while(l1) {\\n        stack1.push(l1.val);\\n        l1 = l1.next;\\n    }\\n    while(l2) {\\n        stack2.push(l2.val);\\n        l2 = l2.next;\\n    }\\n    let l3 = new ListNode(0);\\n    while(stack1.length || stack2.length) {\\n        let sum = 0;\\n        if(stack1.length) sum += stack1.pop();\\n        if(stack2.length) sum += stack2.pop();\\n        sum += l3.val;\\n        l3.val = sum%10;\\n        let head = new ListNode(Math.floor(sum/10));\\n        head.next = l3;\\n        l3 = head;\\n    }\\n    return (l3.val === 0) ? l3.next : l3;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoNumbers = function(l1, l2) {\\n    let stack1 = [];\\n    let stack2 = [];\\n    while(l1) {\\n        stack1.push(l1.val);\\n        l1 = l1.next;\\n    }\\n    while(l2) {\\n        stack2.push(l2.val);\\n        l2 = l2.next;\\n    }\\n    let l3 = new ListNode(0);\\n    while(stack1.length || stack2.length) {\\n        let sum = 0;\\n        if(stack1.length) sum += stack1.pop();\\n        if(stack2.length) sum += stack2.pop();\\n        sum += l3.val;\\n        l3.val = sum%10;\\n        let head = new ListNode(Math.floor(sum/10));\\n        head.next = l3;\\n        l3 = head;\\n    }\\n    return (l3.val === 0) ? l3.next : l3;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92788,
                "title": "java-iterative-o-1-space-lastnot9-solution-changed-from-plus-one-linked-list",
                "content": "This is similar to the problem Plus One Linked List.\\nLet's first look at the solution for Plus One Linked List. This solution is learnt from [this post](https://discuss.leetcode.com/topic/49556/iterative-two-pointers-with-dummy-node-java-o-n-time-o-1-space/2).\\n            \\n\\n    /*  Go to the last one, if == 9, then put 0 and remember a carry\\n     *  Remember the node before the last 9 in front of the end node. \\n     * ==> Remeber last node not 9!\\n     *  ** Corner case: head should also be modified and add a new node as a head.\\n     */\\n     public ListNode plusOne(ListNode head) {\\n         ListNode dummy = new ListNode(0); // start with 0. If need to update dummy, then check if dummy is modified to 1\\n         dummy.next = head;\\n         ListNode cur = dummy, lastnot9 = null;\\n         \\n         while(cur != null){\\n            if(cur.val != 9){\\n                lastnot9 = cur;\\n            }\\n            cur = cur.next;\\n         }\\n         \\n         lastnot9.val += 1;\\n         cur = lastnot9.next;\\n         while(cur != null){\\n            cur.val = 0;\\n            cur = cur.next;\\n         }\\n         if(dummy.val == 1) return dummy;\\n         return dummy.next;\\n    }\\n\\nThis is the lastNot9 solution for add two numbers II. Thanks to the swap trick provided by [this post](https://discuss.leetcode.com/topic/65298/java-o-n-scanning-twice-simple-with-comments).\\n\\n    /* Carry is at most 1. \\n     * If the current node is 9, even if there is a carry, the previous node may get affected.\\n     * If the current node is not 9, even if there is a carry after this, the previous node will not get affected.\\n     */\\n    \\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = getLength(l1), len2 = getLength(l2);\\n        if(len1 < len2){ // swap l1 and l2 to make sure l1 is the longer one\\n            ListNode tmp = l1; l1 = l2; l2 = tmp;\\n        }\\n        int diff = Math.abs(len1-len2);\\n        \\n        ListNode dummy = new ListNode(0);\\n        ListNode tail = dummy;\\n        ListNode lastnot9node = dummy;\\n        \\n        while(diff > 0){\\n            // create new node\\n            tail.next = new ListNode(l1.val);\\n\\n            // update lastnot9node\\n            if(l1.val != 9) lastnot9node = tail.next;\\n\\n            // update tails\\n            tail = tail.next;\\n            l1 = l1.next;\\n            diff--;\\n        }\\n\\n        while(l1 != null){\\n            int val = l1.val + l2.val;\\n            \\n            if(val >= 10){\\n                val -= 10;\\n                // update previous nodes\\n                lastnot9node.val++;\\n                lastnot9node = lastnot9node.next;\\n                while(lastnot9node != null){\\n                    lastnot9node.val = 0;\\n                    lastnot9node = lastnot9node.next;\\n                }\\n                lastnot9node = tail;\\n            }\\n            \\n            // create new node\\n            tail.next = new ListNode(val);\\n            \\n            // update lastnot9node\\n            if(val != 9) lastnot9node = tail.next;\\n            \\n            // update tails\\n            tail = tail.next;\\n            l1   = l1.next;\\n            l2   = l2.next;\\n        }\\n        \\n        if(dummy.val == 1) return dummy;\\n        return dummy.next;\\n    }\\n   \\n    private int getLength(ListNode node){\\n        int len = 0;\\n        while(node != null){\\n            len++;\\n            node = node.next;\\n        }\\n        return len;\\n    }",
                "solutionTags": [],
                "code": "This is similar to the problem Plus One Linked List.\\nLet's first look at the solution for Plus One Linked List. This solution is learnt from [this post](https://discuss.leetcode.com/topic/49556/iterative-two-pointers-with-dummy-node-java-o-n-time-o-1-space/2).\\n            \\n\\n    /*  Go to the last one, if == 9, then put 0 and remember a carry\\n     *  Remember the node before the last 9 in front of the end node. \\n     * ==> Remeber last node not 9!\\n     *  ** Corner case: head should also be modified and add a new node as a head.\\n     */\\n     public ListNode plusOne(ListNode head) {\\n         ListNode dummy = new ListNode(0); // start with 0. If need to update dummy, then check if dummy is modified to 1\\n         dummy.next = head;\\n         ListNode cur = dummy, lastnot9 = null;\\n         \\n         while(cur != null){\\n            if(cur.val != 9){\\n                lastnot9 = cur;\\n            }\\n            cur = cur.next;\\n         }\\n         \\n         lastnot9.val += 1;\\n         cur = lastnot9.next;\\n         while(cur != null){\\n            cur.val = 0;\\n            cur = cur.next;\\n         }\\n         if(dummy.val == 1) return dummy;\\n         return dummy.next;\\n    }\\n\\nThis is the lastNot9 solution for add two numbers II. Thanks to the swap trick provided by [this post](https://discuss.leetcode.com/topic/65298/java-o-n-scanning-twice-simple-with-comments).\\n\\n    /* Carry is at most 1. \\n     * If the current node is 9, even if there is a carry, the previous node may get affected.\\n     * If the current node is not 9, even if there is a carry after this, the previous node will not get affected.\\n     */\\n    \\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = getLength(l1), len2 = getLength(l2);\\n        if(len1 < len2){ // swap l1 and l2 to make sure l1 is the longer one\\n            ListNode tmp = l1; l1 = l2; l2 = tmp;\\n        }\\n        int diff = Math.abs(len1-len2);\\n        \\n        ListNode dummy = new ListNode(0);\\n        ListNode tail = dummy;\\n        ListNode lastnot9node = dummy;\\n        \\n        while(diff > 0){\\n            // create new node\\n            tail.next = new ListNode(l1.val);\\n\\n            // update lastnot9node\\n            if(l1.val != 9) lastnot9node = tail.next;\\n\\n            // update tails\\n            tail = tail.next;\\n            l1 = l1.next;\\n            diff--;\\n        }\\n\\n        while(l1 != null){\\n            int val = l1.val + l2.val;\\n            \\n            if(val >= 10){\\n                val -= 10;\\n                // update previous nodes\\n                lastnot9node.val++;\\n                lastnot9node = lastnot9node.next;\\n                while(lastnot9node != null){\\n                    lastnot9node.val = 0;\\n                    lastnot9node = lastnot9node.next;\\n                }\\n                lastnot9node = tail;\\n            }\\n            \\n            // create new node\\n            tail.next = new ListNode(val);\\n            \\n            // update lastnot9node\\n            if(val != 9) lastnot9node = tail.next;\\n            \\n            // update tails\\n            tail = tail.next;\\n            l1   = l1.next;\\n            l2   = l2.next;\\n        }\\n        \\n        if(dummy.val == 1) return dummy;\\n        return dummy.next;\\n    }\\n   \\n    private int getLength(ListNode node){\\n        int len = 0;\\n        while(node != null){\\n            len++;\\n            node = node.next;\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 927084,
                "title": "c-easy-simple-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        while (l1) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        \\n        int carry = 0, first, second;\\n        ListNode* head = NULL;\\n        while (!s1.empty() || !s2.empty() || carry) {\\n            if (!s1.empty()) {\\n                first = s1.top();\\n                s1.pop();\\n            }\\n            else\\n                first = 0;\\n            \\n            if (!s2.empty()) {\\n                second = s2.top();\\n                s2.pop();\\n            }\\n            else\\n                second = 0;\\n            \\n            int temp = first+second+carry;\\n            ListNode* node = new ListNode(temp%10);\\n            node->next = head;\\n            head = node;\\n            carry = temp/10;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        while (l1) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        \\n        int carry = 0, first, second;\\n        ListNode* head = NULL;\\n        while (!s1.empty() || !s2.empty() || carry) {\\n            if (!s1.empty()) {\\n                first = s1.top();\\n                s1.pop();\\n            }\\n            else\\n                first = 0;\\n            \\n            if (!s2.empty()) {\\n                second = s2.top();\\n                s2.pop();\\n            }\\n            else\\n                second = 0;\\n            \\n            int temp = first+second+carry;\\n            ListNode* node = new ListNode(temp%10);\\n            node->next = head;\\n            head = node;\\n            carry = temp/10;\\n            \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92767,
                "title": "c-solution-linear-time-and-o-1-space-except-answer-itself-32ms-non-recursive",
                "content": "Not sure if anyone got the same idea, but doesn't seem to appear in some top voted posts.\\n\\nThe \"frontier\" pointer stands for the nodes (possibly) impacted by carry and nearest to the list head. And \"head\" node is more like a helper node storing the carry propagated to the head.\\n\\n```\\n    int count(ListNode* n) {\\n        int ret =0 ;\\n        while(n) ++ret, n = n->next;\\n        return ret;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int c1 = count(l1), c2 = count(l2);\\n        if(c1 > c2) swap(c1,c2), swap(l1,l2);\\n        ListNode head(0);\\n        ListNode *n = &head, *frontier = &head;\\n        for(int i=0;i<c2-c1;++i, l2 = l2->next) {\\n            n = n->next = new ListNode(l2->val);\\n            if(n->val < 9) frontier = n;\\n        }\\n        for(;l1;l1 = l1->next, l2 = l2->next) {\\n            n = n->next = new ListNode(l1->val + l2->val);\\n            if(n->val < 9) frontier = n;\\n            else if(n->val > 9) {\\n                frontier->val +=1;\\n                frontier = frontier->next;\\n                while(frontier != n) {\\n                    frontier->val = 0;\\n                    frontier = frontier->next;\\n                }\\n                n->val -= 10;\\n            }\\n        }\\n        if(head.val) {\\n            ListNode* n2 = new ListNode(1);\\n            n2->next = head.next;\\n            n = n2;\\n        } else n = head.next;\\n        return n;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int count(ListNode* n) {\\n        int ret =0 ;\\n        while(n) ++ret, n = n->next;\\n        return ret;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int c1 = count(l1), c2 = count(l2);\\n        if(c1 > c2) swap(c1,c2), swap(l1,l2);\\n        ListNode head(0);\\n        ListNode *n = &head, *frontier = &head;\\n        for(int i=0;i<c2-c1;++i, l2 = l2->next) {\\n            n = n->next = new ListNode(l2->val);\\n            if(n->val < 9) frontier = n;\\n        }\\n        for(;l1;l1 = l1->next, l2 = l2->next) {\\n            n = n->next = new ListNode(l1->val + l2->val);\\n            if(n->val < 9) frontier = n;\\n            else if(n->val > 9) {\\n                frontier->val +=1;\\n                frontier = frontier->next;\\n                while(frontier != n) {\\n                    frontier->val = 0;\\n                    frontier = frontier->next;\\n                }\\n                n->val -= 10;\\n            }\\n        }\\n        if(head.val) {\\n            ListNode* n2 = new ListNode(1);\\n            n2->next = head.next;\\n            n = n2;\\n        } else n = head.next;\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92711,
                "title": "9-liner-c-o-n1-n2-solution-with-stacks-to-store-digits-no-list-modification",
                "content": "Algorithm:\\n1. Store the digits of the given two lists in separate stacks in reverse order.\\n2. Starting from top of stacks (least significant digits), calculate digit sum of each position and traverse through two stacks simultaneously.\\n```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2; // store digits in stack\\n        for (; l1; l1 = l1->next) s1.push(l1->val); \\n        for (; l2; l2 = l2->next) s2.push(l2->val);\\n        \\n        ListNode *res = new ListNode(0), *tmp = NULL;\\n        for (int sum = 0; !s1.empty()||!s2.empty(); tmp = new ListNode(sum/=10), tmp->next = res, res = tmp) {\\n            if (!s1.empty()) sum += s1.top(), s1.pop(); // get digit sum\\n            if (!s2.empty()) sum += s2.top(), s2.pop();\\n            res->val = sum%10;\\n        }\\n        return res->val? res : res->next;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2; // store digits in stack\\n        for (; l1; l1 = l1->next) s1.push(l1->val); \\n        for (; l2; l2 = l2->next) s2.push(l2->val);\\n        \\n        ListNode *res = new ListNode(0), *tmp = NULL;\\n        for (int sum = 0; !s1.empty()||!s2.empty(); tmp = new ListNode(sum/=10), tmp->next = res, res = tmp) {\\n            if (!s1.empty()) sum += s1.top(), s1.pop(); // get digit sum\\n            if (!s2.empty()) sum += s2.top(), s2.pop();\\n            res->val = sum%10;\\n        }\\n        return res->val? res : res->next;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486730,
                "title": "python-using-one-stack-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\t\\n        n1 = n2 = 0\\n        ptr1, ptr2 = l1, l2\\n        stack = []\\n        \\n        while ptr1: n1 += 1; ptr1 = ptr1.next\\n        while ptr2: n2 += 1; ptr2 = ptr2.next\\n        max_len = max(n1, n2)\\n        \\n        while max_len:\\n            a = b = 0\\n            if max_len <= n1: a = l1.val; l1 = l1.next\\n            if max_len <= n2: b = l2.val; l2 = l2.next\\n            stack.append(a + b)\\n            max_len -= 1\\n        \\n        sumval, head = 0, None\\n        while stack or sumval:\\n            if stack: sumval += stack.pop()\\n            node = ListNode(sumval % 10)\\n            node.next = head\\n            head = node\\n            sumval //= 10\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\t\\n        n1 = n2 = 0\\n        ptr1, ptr2 = l1, l2\\n        stack = []\\n        \\n        while ptr1: n1 += 1; ptr1 = ptr1.next\\n        while ptr2: n2 += 1; ptr2 = ptr2.next\\n        max_len = max(n1, n2)\\n        \\n        while max_len:\\n            a = b = 0\\n            if max_len <= n1: a = l1.val; l1 = l1.next\\n            if max_len <= n2: b = l2.val; l2 = l2.next\\n            stack.append(a + b)\\n            max_len -= 1\\n        \\n        sumval, head = 0, None\\n        while stack or sumval:\\n            if stack: sumval += stack.pop()\\n            node = ListNode(sumval % 10)\\n            node.next = head\\n            head = node\\n            sumval //= 10\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241079,
                "title": "fast-python3-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def addTwoNumbers(self, l1: \\'ListNode\\', l2: \\'ListNode\\') -> \\'ListNode\\':\\n        if not l1 and not l2:\\n            return None\\n\\n        l1_num = 0\\n        while l1:a\\n            l1_num = l1_num * 10 + l1.val\\n            l1 = l1.next\\n\\n        l2_num = 0\\n        while l2:\\n            l2_num = l2_num * 10 + l2.val\\n            l2 = l2.next\\n\\n        lsum = l1_num + l2_num\\n\\n        head = ListNode(None)\\n        cur = head\\n        for istr in str(lsum):\\n            cur.next = ListNode(int(istr))\\n            cur = cur.next\\n\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def addTwoNumbers(self, l1: \\'ListNode\\', l2: \\'ListNode\\') -> \\'ListNode\\':\\n        if not l1 and not l2:\\n            return None\\n\\n        l1_num = 0\\n        while l1:a\\n            l1_num = l1_num * 10 + l1.val\\n            l1 = l1.next\\n\\n        l2_num = 0\\n        while l2:\\n            l2_num = l2_num * 10 + l2.val\\n            l2 = l2.next\\n\\n        lsum = l1_num + l2_num\\n\\n        head = ListNode(None)\\n        cur = head\\n        for istr in str(lsum):\\n            cur.next = ListNode(int(istr))\\n            cur = cur.next\\n\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109424,
                "title": "java-simple-and-easy-to-understand-soln-time-o-n-space-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode curr1 = l1;\\n        ListNode curr2 = l2;\\n        \\n        // add in stack\\n        Stack<ListNode> stack1 = new Stack();\\n        Stack<ListNode> stack2 = new Stack();\\n        while(curr1 != null || curr2 != null){\\n            if(curr1 != null){\\n                stack1.push(curr1);\\n                curr1 = curr1.next;\\n            }\\n            \\n            if(curr2 != null){\\n                stack2.push(curr2);\\n                curr2 = curr2.next;\\n            }\\n        }\\n        \\n        return addTwoNumbers(stack1, stack2);\\n    }\\n    \\n    private ListNode  addTwoNumbers(Stack<ListNode> stack1, Stack<ListNode> stack2){\\n        ListNode dummyNode = new ListNode();\\n        ListNode head = dummyNode;\\n        \\n        int carry = 0;\\n        while(!stack1.empty() || !stack2.empty()){\\n            \\n            int sum = carry;\\n            \\n            if(!stack1.empty()){\\n                sum += stack1.pop().val;\\n            }\\n            \\n            if(!stack2.empty()){\\n                sum += stack2.pop().val;\\n            }\\n            \\n            \\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head.next;\\n            head.next = newNode;\\n            \\n            carry = sum / 10;\\n        }\\n        \\n        if(carry == 1){\\n            ListNode newNode = new ListNode(1);\\n            newNode.next = head.next;\\n            head.next = newNode;\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode curr1 = l1;\\n        ListNode curr2 = l2;\\n        \\n        // add in stack\\n        Stack<ListNode> stack1 = new Stack();\\n        Stack<ListNode> stack2 = new Stack();\\n        while(curr1 != null || curr2 != null){\\n            if(curr1 != null){\\n                stack1.push(curr1);\\n                curr1 = curr1.next;\\n            }\\n            \\n            if(curr2 != null){\\n                stack2.push(curr2);\\n                curr2 = curr2.next;\\n            }\\n        }\\n        \\n        return addTwoNumbers(stack1, stack2);\\n    }\\n    \\n    private ListNode  addTwoNumbers(Stack<ListNode> stack1, Stack<ListNode> stack2){\\n        ListNode dummyNode = new ListNode();\\n        ListNode head = dummyNode;\\n        \\n        int carry = 0;\\n        while(!stack1.empty() || !stack2.empty()){\\n            \\n            int sum = carry;\\n            \\n            if(!stack1.empty()){\\n                sum += stack1.pop().val;\\n            }\\n            \\n            if(!stack2.empty()){\\n                sum += stack2.pop().val;\\n            }\\n            \\n            \\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head.next;\\n            head.next = newNode;\\n            \\n            carry = sum / 10;\\n        }\\n        \\n        if(carry == 1){\\n            ListNode newNode = new ListNode(1);\\n            newNode.next = head.next;\\n            head.next = newNode;\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92644,
                "title": "straightforward-o-n-java-solution-without-modifying-input-lists",
                "content": "````\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        HashMap<Integer, Integer> hm1 = new HashMap<>(); //Store the 'index' and the value of List1\\n        HashMap<Integer, Integer> hm2 = new HashMap<>(); //Store the 'index' and the value of List2\\n        int i = 1, j = 1;\\n        \\n        while(l1 != null){\\n            hm1.put(i, l1.val);\\n            l1 = l1.next;\\n            i++;\\n        }\\n        while(l2 != null){\\n            hm2.put(j, l2.val);\\n            l2 = l2.next;\\n            j++;\\n        }\\n        \\n        int carry = 0;\\n        i--; j--;\\n        ListNode head = null;\\n        \\n      //Create new nodes to the front of a new LinkedList\\n        while(i > 0 || j > 0 || carry > 0){\\n\\n            int a = i > 0 ? hm1.get(i) : 0;\\n            int b = j > 0 ? hm2.get(j) : 0;\\n            int res = (a + b + carry) % 10;\\n            \\n            ListNode newNode = new ListNode(res);\\n            newNode.next = head;\\n            head = newNode;\\n            \\n            carry = (a + b + carry) / 10;\\n            i--; j--;\\n        }\\n        return head;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        HashMap<Integer, Integer> hm1 = new HashMap<>(); //Store the 'index' and the value of List1\\n        HashMap<Integer, Integer> hm2 = new HashMap<>(); //Store the 'index' and the value of List2\\n        int i = 1, j = 1;\\n        \\n        while(l1 != null){\\n            hm1.put(i, l1.val);\\n            l1 = l1.next;\\n            i++;\\n        }\\n        while(l2 != null){\\n            hm2.put(j, l2.val);\\n            l2 = l2.next;\\n            j++;\\n        }\\n        \\n        int carry = 0;\\n        i--; j--;\\n        ListNode head = null;\\n        \\n      //Create new nodes to the front of a new LinkedList\\n        while(i > 0 || j > 0 || carry > 0){\\n\\n            int a = i > 0 ? hm1.get(i) : 0;\\n            int b = j > 0 ? hm2.get(j) : 0;\\n            int res = (a + b + carry) % 10;\\n            \\n            ListNode newNode = new ListNode(res);\\n            newNode.next = head;\\n            head = newNode;\\n            \\n            carry = (a + b + carry) / 10;\\n            i--; j--;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720934,
                "title": "c-code-for-beginners-using-reverse",
                "content": "class Solution {\\npublic:\\n    \\n    ListNode* reversekro(ListNode *head){\\n        ListNode* curr = head,*prev = NULL,*next = NULL;\\n        while(curr){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n       if(!l1 and !l2)return NULL;\\n        if(!l1)return l2;\\n        if(!l2)return l1;\\n        l1 = reversekro(l1);\\n        l2 = reversekro(l2);\\n        ListNode* headd = new ListNode(0);\\n        ListNode* temp = headd;\\n        int carry =0;\\n        while(l1 or l2 or carry){\\n            int sum =0;\\n            if(l1){\\n                sum+=l1->val;\\n                l1 = l1->next;\\n            }\\n            if(l2){\\n                sum+=l2->val;\\n                l2 = l2->next;\\n            }\\n            sum+=carry;\\n            carry = sum/10;\\n            ListNode* newnode = new ListNode(sum%10);\\n            temp->next = newnode;\\n            temp = temp->next;\\n            \\n        }\\n        headd = reversekro(headd->next);\\n        return headd;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    ListNode* reversekro(ListNode *head){\\n        ListNode* curr = head,*prev = NULL,*next = NULL;\\n        while(curr){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 262479,
                "title": "c-100-in-speed-and-95-5-in-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int add(ListNode* one ,ListNode* two ,int sone,int stwo,ListNode* &t){\\n        if(sone==0&&stwo==0)\\n            return 0;    \\n        int carry;\\n        int t1=0,t2=0;\\n        if(sone>stwo)\\n        {\\n            carry=add(one->next,two,sone-1,stwo,t);\\n            t1=one->val;\\n        }else if(sone<stwo){\\n            carry=add(one,two->next,sone,stwo-1,t);\\n            t2=two->val;\\n        }else{\\n            carry=add(one->next,two->next,sone-1,stwo-1,t);\\n            t1=one->val;\\n            t2=two->val;\\n        }\\n        int data = t1+t2+carry;\\n        ListNode* nn = new ListNode(data%10);\\n        nn->next=t;\\n        t=nn;\\n        return data/10;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* one, ListNode* two) {\\n        ListNode* t= one;\\n        int sone=0;\\n        while(t!=NULL){\\n            sone++;\\n            t=t->next;\\n        }\\n        t=two;\\n        int stwo=0;\\n        while(t!=NULL){\\n            stwo++;\\n            t=t->next;\\n        }\\n        t=NULL;\\n        int carry = add(one,two,sone,stwo,t);\\n        if(carry){\\n            ListNode* nn = new ListNode(carry);\\n            nn->next=t;\\n            t=nn;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int add(ListNode* one ,ListNode* two ,int sone,int stwo,ListNode* &t){\\n        if(sone==0&&stwo==0)\\n            return 0;    \\n        int carry;\\n        int t1=0,t2=0;\\n        if(sone>stwo)\\n        {\\n            carry=add(one->next,two,sone-1,stwo,t);\\n            t1=one->val;\\n        }else if(sone<stwo){\\n            carry=add(one,two->next,sone,stwo-1,t);\\n            t2=two->val;\\n        }else{\\n            carry=add(one->next,two->next,sone-1,stwo-1,t);\\n            t1=one->val;\\n            t2=two->val;\\n        }\\n        int data = t1+t2+carry;\\n        ListNode* nn = new ListNode(data%10);\\n        nn->next=t;\\n        t=nn;\\n        return data/10;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* one, ListNode* two) {\\n        ListNode* t= one;\\n        int sone=0;\\n        while(t!=NULL){\\n            sone++;\\n            t=t->next;\\n        }\\n        t=two;\\n        int stwo=0;\\n        while(t!=NULL){\\n            stwo++;\\n            t=t->next;\\n        }\\n        t=NULL;\\n        int carry = add(one,two,sone,stwo,t);\\n        if(carry){\\n            ListNode* nn = new ListNode(carry);\\n            nn->next=t;\\n            t=nn;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531727,
                "title": "python3-using-2-stacks",
                "content": "```python3 []\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        st1, st2 = [], []\\n\\n        while l1:\\n            st1.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            st2.append(l2.val)\\n            l2 = l2.next\\n\\n        nextNode, remainder = None, 0\\n        while st1 or st2 or remainder:\\n            v1 = st1.pop() if st1 else 0\\n            v2 = st2.pop() if st2 else 0\\n            remainder, val = divmod(v1 + v2 + remainder, 10)\\n            node = ListNode(val, nextNode)\\n            nextNode = node\\n        \\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        st1, st2 = [], []\\n\\n        while l1:\\n            st1.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            st2.append(l2.val)\\n            l2 = l2.next\\n\\n        nextNode, remainder = None, 0\\n        while st1 or st2 or remainder:\\n            v1 = st1.pop() if st1 else 0\\n            v2 = st2.pop() if st2 else 0\\n            remainder, val = divmod(v1 + v2 + remainder, 10)\\n            node = ListNode(val, nextNode)\\n            nextNode = node\\n        \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803392,
                "title": "java-easy-solution-with-reverse-linked-list",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n        \\n        ListNode head = new ListNode(0);\\n        ListNode newNode=head;\\n        \\n        int carry=0;\\n        while(l1!=null || l2!=null || carry>0){\\n            int sum=0;\\n            if(l1!=null){\\n                sum+=l1.val;\\n                l1=l1.next;\\n            }\\n            if(l2!=null){\\n                sum+=l2.val;\\n                l2=l2.next;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ListNode node = new ListNode(sum%10);\\n            newNode.next=node;\\n            newNode=newNode.next;\\n        }\\n        return reverse(head.next);\\n    }\\n    private ListNode reverse(ListNode head){\\n        ListNode curr=head;\\n        ListNode prev=null;\\n        ListNode nex=null;\\n        \\n        while(curr!=null){\\n            nex=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n  } \\n};\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n        \\n        ListNode head = new ListNode(0);\\n        ListNode newNode=head;\\n        \\n        int carry=0;\\n        while(l1!=null || l2!=null || carry>0){\\n            int sum=0;\\n            if(l1!=null){\\n                sum+=l1.val;\\n                l1=l1.next;\\n            }\\n            if(l2!=null){\\n                sum+=l2.val;\\n                l2=l2.next;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            ListNode node = new ListNode(sum%10);\\n            newNode.next=node;\\n            newNode=newNode.next;\\n        }\\n        return reverse(head.next);\\n    }\\n    private ListNode reverse(ListNode head){\\n        ListNode curr=head;\\n        ListNode prev=null;\\n        ListNode nex=null;\\n        \\n        while(curr!=null){\\n            nex=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n  } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846777,
                "title": "python3-two-approaches",
                "content": "Approach 1 - collect numbers \\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\n        def fn(node): \\n            \"\"\"Return number represented by linked list.\"\"\"\\n            ans = 0\\n            while node:\\n                ans = 10*ans + node.val\\n                node = node.next\\n            return ans \\n        \\n        dummy = node = ListNode()\\n        for x in str(fn(l1) + fn(l2)): \\n            node.next = ListNode(int(x))\\n            node = node.next\\n        return dummy.next \\n```\\n\\nApproach 2 - reversed linked-lists (based on [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/discuss/456844/Python3-Compact-implementation-(96.75)).\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        \\n        def fn(node): \\n            \"\"\"Reverse a linked list.\"\"\"\\n            prev = None\\n            while node: prev, node.next, node = node, prev, node.next\\n            return prev \\n        \\n        l1, l2 = fn(l1), fn(l2) # reverse l1 & l2\\n        carry = 0\\n        dummy = node = ListNode()\\n        while carry or l1 or l2:\\n            if l1: \\n                carry += l1.val\\n                l1 = l1.next\\n            if l2: \\n                carry += l2.val\\n                l2 = l2.next\\n            carry, x = divmod(carry, 10)\\n            node.next = node = ListNode(x)\\n        return fn(dummy.next)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\n        def fn(node): \\n            \"\"\"Return number represented by linked list.\"\"\"\\n            ans = 0\\n            while node:\\n                ans = 10*ans + node.val\\n                node = node.next\\n            return ans \\n        \\n        dummy = node = ListNode()\\n        for x in str(fn(l1) + fn(l2)): \\n            node.next = ListNode(int(x))\\n            node = node.next\\n        return dummy.next \\n```\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        \\n        def fn(node): \\n            \"\"\"Reverse a linked list.\"\"\"\\n            prev = None\\n            while node: prev, node.next, node = node, prev, node.next\\n            return prev \\n        \\n        l1, l2 = fn(l1), fn(l2) # reverse l1 & l2\\n        carry = 0\\n        dummy = node = ListNode()\\n        while carry or l1 or l2:\\n            if l1: \\n                carry += l1.val\\n                l1 = l1.next\\n            if l2: \\n                carry += l2.val\\n                l2 = l2.next\\n            carry, x = divmod(carry, 10)\\n            node.next = node = ListNode(x)\\n        return fn(dummy.next)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92640,
                "title": "java-solution-by-reversing-linkedlist-beating-96",
                "content": "```\\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode n1 = reverse(l1);\\n        ListNode n2 = reverse(l2);\\n        int carry = 0;\\n        ListNode temp = n1;\\n        ListNode pre = n1;\\n        while(n1!= null || n2 != null || carry != 0){\\n            int v1 = n1 == null? 0: n1.val;\\n            int v2 = n2 == null? 0: n2.val;\\n            if(n1 == null){\\n                n1 = new ListNode((v1+v2+carry) % 10);\\n                pre.next = n1;\\n            }else{\\n                n1.val = (v1+v2+carry) % 10;\\n            }\\n            carry = (v1+v2+carry)/10;\\n            pre = n1;\\n            n1 = n1 == null? null : n1.next;\\n            n2 = n2 == null? null : n2.next;\\n        }\\n        return reverse(temp);\\n    }\\n    public ListNode reverse(ListNode head){\\n        ListNode newHead = null;\\n        while(head != null){\\n            ListNode next = head.next;\\n            head.next = newHead;\\n            newHead = head;\\n            head = next;\\n        }\\n        return newHead;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode n1 = reverse(l1);\\n        ListNode n2 = reverse(l2);\\n        int carry = 0;\\n        ListNode temp = n1;\\n        ListNode pre = n1;\\n        while(n1!= null || n2 != null || carry != 0){\\n            int v1 = n1 == null? 0: n1.val;\\n            int v2 = n2 == null? 0: n2.val;\\n            if(n1 == null){\\n                n1 = new ListNode((v1+v2+carry) % 10);\\n                pre.next = n1;\\n            }else{\\n                n1.val = (v1+v2+carry) % 10;\\n            }\\n            carry = (v1+v2+carry)/10;\\n            pre = n1;\\n            n1 = n1 == null? null : n1.next;\\n            n2 = n2 == null? null : n2.next;\\n        }\\n        return reverse(temp);\\n    }\\n    public ListNode reverse(ListNode head){\\n        ListNode newHead = null;\\n        while(head != null){\\n            ListNode next = head.next;\\n            head.next = newHead;\\n            newHead = head;\\n            head = next;\\n        }\\n        return newHead;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775750,
                "title": "c-2-method-s-recursion-beginner-s-friendly-faster-than-90-o-n-clean-and-concise",
                "content": "**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n# Method 1 : Using Recursion\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->Make the size of both the list equal by adding the 0\\'s at the end of the list which has less size than other\\n->Perform a recursive addition by passing list1,list2, and carry !\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n //addTwoNumbers\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *ptr1 = l1, *ptr2 = l2;\\n        while(ptr1 != NULL || ptr2 != NULL){\\n            if(ptr1 == NULL){\\n                ListNode *newNode = new ListNode(0);//Adding 0\\'s to end of the first list if its size is less than second list\\n                newNode->next = l1;\\n                l1 = newNode;\\n                \\n                ptr2 = ptr2->next;\\n            }\\n            else if(ptr2 == NULL){\\n                ListNode *newNode = new ListNode(0); //Adding 0\\'s to end of the second list if its size is less than first list\\n                newNode->next = l2;\\n                l2 = newNode;\\n                ptr1 = ptr1->next;\\n            }\\n            else{\\n                ptr1 = ptr1->next;\\n                ptr2 = ptr2->next;\\n            }\\n        }\\n        int carry = 0;\\n        ListNode *dummy = new ListNode(-1);\\n        dummy->next = addTwoDigit(l1, l2, carry);\\n        if(carry != 0){\\n            ListNode *newNode = new ListNode(carry);\\n            newNode->next = dummy->next;\\n            dummy->next = newNode;\\n        }\\n        return dummy->next;\\n    }\\n    ListNode* addTwoDigit(ListNode* l1, ListNode* l2, int &carry){ //recursion is used to perform addition \\n        if(l1 == NULL && l2 == NULL)  return NULL;\\n        ListNode *newNode = new ListNode(-1);\\n        newNode->next = addTwoDigit(l1->next, l2->next, carry);\\n        newNode->val = (l1->val + l2->val + carry) % 10;\\n        carry = (l1->val + l2->val + carry) / 10;\\n        return newNode;\\n    }\\n};\\n```\\n# Method 2: Beginner\\'s Friendly(Brute_Force)\\n\\n# Intuition\\n->Push the 2 list in two different string \\n->Perform a addition by adding that 2 strings !\\n->Reverse the answer string and form a new ListNode to store the\\nanswer\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    string add(string &x, string &y,string &ans) {\\n        int flag=0;\\n        int i;\\n        string str1=\"\";\\n        int j=0;\\n        while(x[j]==\\'0\\'){\\n            j++;\\n        }\\n        while(j<x.size()){\\n            str1+=x[j];\\n            j++;\\n        }\\n        string str2=\"\";\\n        j=0;\\n        while(y[j]==\\'0\\'){\\n            j++;\\n        }\\n        while(j<y.size()){\\n            str2+=y[j];\\n            j++;\\n        }\\n        i=str1.size()-1,j=str2.size()-1;\\n        if(str1.size()==0 and str2.size()==0){\\n            return \"0\";\\n        }\\n        while(i>=0 or j>=0){\\n            if(i>=0 and j>=0){\\n                int r=(str1[i]-\\'0\\')+(str2[j]-\\'0\\');\\n                r+=flag;\\n                flag=r/10;\\n                string res=to_string(r%10);\\n                ans+=res;\\n                i--;\\n                j--;\\n            }\\n            else if(j>=0){\\n                int r=(str2[j]-\\'0\\')+flag;\\n                flag=r/10;\\n                ans+=to_string(r%10);\\n                j--;\\n            }\\n            else if(i>=0){\\n                int r=(str1[i]-\\'0\\')+flag;\\n                flag=r/10;\\n                ans+=to_string(r%10);\\n                i--;\\n            }\\n        }\\n        if(flag>0){\\n            ans+=to_string(flag);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        string x=\"\",y=\"\",ans=\"\";\\n        while(l1!=NULL){\\n            x+=to_string(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2!=NULL){\\n            y+=to_string(l2->val);\\n            l2=l2->next;\\n        }\\n        add(x,y,ans);\\n        int i=0;\\n        ListNode *list=new ListNode();\\n        ListNode *anss=list;\\n        int cnt=0;\\n        while(i<ans.size()){\\n            int r=ans[i]-\\'0\\';\\n            ListNode *node=new ListNode(r);\\n            anss->next=node;\\n            anss=anss->next;\\n            i++;\\n            cnt++;\\n        }\\n        if(cnt==0){\\n            return list;\\n        }\\n        return list->next;\\n    }\\n};\\n```\\n\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n //addTwoNumbers\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *ptr1 = l1, *ptr2 = l2;\\n        while(ptr1 != NULL || ptr2 != NULL){\\n            if(ptr1 == NULL){\\n                ListNode *newNode = new ListNode(0);//Adding 0\\'s to end of the first list if its size is less than second list\\n                newNode->next = l1;\\n                l1 = newNode;\\n                \\n                ptr2 = ptr2->next;\\n            }\\n            else if(ptr2 == NULL){\\n                ListNode *newNode = new ListNode(0); //Adding 0\\'s to end of the second list if its size is less than first list\\n                newNode->next = l2;\\n                l2 = newNode;\\n                ptr1 = ptr1->next;\\n            }\\n            else{\\n                ptr1 = ptr1->next;\\n                ptr2 = ptr2->next;\\n            }\\n        }\\n        int carry = 0;\\n        ListNode *dummy = new ListNode(-1);\\n        dummy->next = addTwoDigit(l1, l2, carry);\\n        if(carry != 0){\\n            ListNode *newNode = new ListNode(carry);\\n            newNode->next = dummy->next;\\n            dummy->next = newNode;\\n        }\\n        return dummy->next;\\n    }\\n    ListNode* addTwoDigit(ListNode* l1, ListNode* l2, int &carry){ //recursion is used to perform addition \\n        if(l1 == NULL && l2 == NULL)  return NULL;\\n        ListNode *newNode = new ListNode(-1);\\n        newNode->next = addTwoDigit(l1->next, l2->next, carry);\\n        newNode->val = (l1->val + l2->val + carry) % 10;\\n        carry = (l1->val + l2->val + carry) / 10;\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string add(string &x, string &y,string &ans) {\\n        int flag=0;\\n        int i;\\n        string str1=\"\";\\n        int j=0;\\n        while(x[j]==\\'0\\'){\\n            j++;\\n        }\\n        while(j<x.size()){\\n            str1+=x[j];\\n            j++;\\n        }\\n        string str2=\"\";\\n        j=0;\\n        while(y[j]==\\'0\\'){\\n            j++;\\n        }\\n        while(j<y.size()){\\n            str2+=y[j];\\n            j++;\\n        }\\n        i=str1.size()-1,j=str2.size()-1;\\n        if(str1.size()==0 and str2.size()==0){\\n            return \"0\";\\n        }\\n        while(i>=0 or j>=0){\\n            if(i>=0 and j>=0){\\n                int r=(str1[i]-\\'0\\')+(str2[j]-\\'0\\');\\n                r+=flag;\\n                flag=r/10;\\n                string res=to_string(r%10);\\n                ans+=res;\\n                i--;\\n                j--;\\n            }\\n            else if(j>=0){\\n                int r=(str2[j]-\\'0\\')+flag;\\n                flag=r/10;\\n                ans+=to_string(r%10);\\n                j--;\\n            }\\n            else if(i>=0){\\n                int r=(str1[i]-\\'0\\')+flag;\\n                flag=r/10;\\n                ans+=to_string(r%10);\\n                i--;\\n            }\\n        }\\n        if(flag>0){\\n            ans+=to_string(flag);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        string x=\"\",y=\"\",ans=\"\";\\n        while(l1!=NULL){\\n            x+=to_string(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2!=NULL){\\n            y+=to_string(l2->val);\\n            l2=l2->next;\\n        }\\n        add(x,y,ans);\\n        int i=0;\\n        ListNode *list=new ListNode();\\n        ListNode *anss=list;\\n        int cnt=0;\\n        while(i<ans.size()){\\n            int r=ans[i]-\\'0\\';\\n            ListNode *node=new ListNode(r);\\n            anss->next=node;\\n            anss=anss->next;\\n            i++;\\n            cnt++;\\n        }\\n        if(cnt==0){\\n            return list;\\n        }\\n        return list->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195455,
                "title": "clean-javascript-3-solutions",
                "content": "```\\n/**\\n * 1. convert each LL into a number\\n * 2. add two numers\\n * 3. convert to LL\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(max(N, M))\\n * * Space: O(N + M)\\n */\\n// Runtime: 124 ms, faster than 96.31% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 44.4 MB, less than 65.73% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers1 = (l1, l2) => {\\n\\tlet n1 = \\'\\';\\n\\tlet n2 = \\'\\';\\n\\n\\twhile (l1 || l2) {\\n\\t\\tif (l1) {\\n\\t\\t\\tn1 += l1.val;\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t}\\n\\t\\tif (l2) {\\n\\t\\t\\tn2 += l2.val;\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t}\\n\\t}\\n\\n\\tn1 = BigInt(n1);\\n\\tn2 = BigInt(n2);\\n\\n\\tconst sum = (n1 + n2).toString();\\n\\tlet i = 0;\\n\\tlet sentinel = new ListNode(0);\\n\\tlet tail = sentinel;\\n\\n\\twhile (i < sum.length) {\\n\\t\\tconst node = new ListNode(parseInt(sum[i++]));\\n\\n\\t\\ttail.next = node;\\n\\t\\ttail = node;\\n\\t}\\n\\n\\treturn sentinel.next;\\n};\\n\\n/**\\n * 1. reverse LL\\n * 2. add numbers\\n * 3. build LL reversed\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(N + M)\\n * * Space: O(1)\\n */\\n// Runtime: 140 ms, faster than 50.54% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 43.8 MB, less than 97.18% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers2 = (l1, l2) => {\\n\\tconst reverse = head => {\\n\\t\\tlet prev = null; // new head\\n\\t\\tlet current = head;\\n\\n\\t\\twhile (current) {\\n\\t\\t\\tconst next = current.next;\\n\\n\\t\\t\\tcurrent.next = prev;\\n\\t\\t\\tprev = current;\\n\\t\\t\\tcurrent = next;\\n\\t\\t}\\n\\n\\t\\treturn prev;\\n\\t};\\n\\n\\tl1 = reverse(l1);\\n\\tl2 = reverse(l2);\\n\\n\\tlet LL = null;\\n\\tlet sum = 0;\\n\\n\\twhile (l1 || l2) {\\n\\t\\tif (l1) {\\n\\t\\t\\tsum += l1.val;\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t}\\n\\t\\tif (l2) {\\n\\t\\t\\tsum += l2.val;\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t}\\n\\n\\t\\tconst node = new ListNode(sum % 10, LL);\\n\\n\\t\\tLL = node;\\n\\t\\tsum = sum > 9 ? 1 : 0;\\n\\t}\\n\\n\\tif (sum) LL = new ListNode(1, LL);\\n\\n\\treturn LL;\\n};\\n\\n/**\\n * 1. get length of LL\\n * 2. add corresponding digits\\n * 3. build LL reversed\\n * 4. handle carray\\n * 5. reverse LL\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(N + M)\\n * * Space: O(1)\\n */\\n// Runtime: 140 ms, faster than 50.54% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 44.5 MB, less than 65.73% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers = (l1, l2) => {\\n\\tlet i = 0;\\n\\tlet j = 0;\\n\\tlet current1 = l1;\\n\\tlet current2 = l2;\\n\\n\\twhile (current1 || current2) {\\n\\t\\tif (current1) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcurrent1 = current1.next;\\n\\t\\t}\\n\\t\\tif (current2) {\\n\\t\\t\\tj++;\\n\\t\\t\\tcurrent2 = current2.next;\\n\\t\\t}\\n\\t}\\n\\n\\tlet LL = null;\\n\\n\\t// handle uneven number of digits\\n\\twhile (i !== j) {\\n\\t\\tif (i > j) {\\n\\t\\t\\tLL = new ListNode(l1.val, LL);\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t\\ti--;\\n\\t\\t} else {\\n\\t\\t\\tLL = new ListNode(l2.val, LL);\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\n\\t// sum and add rest of digits\\n\\twhile (i-- && j--) {\\n\\t\\tLL = new ListNode(l1.val + l2.val, LL);\\n\\n\\t\\tl1 = l1.next;\\n\\t\\tl2 = l2.next;\\n\\t}\\n\\n\\tlet current = LL;\\n\\tlet carry = 0;\\n\\n\\t// handle carry\\n\\twhile (current) {\\n\\t\\tif (carry) {\\n\\t\\t\\tcurrent.val += 1;\\n\\t\\t\\tcarry = 0;\\n\\t\\t}\\n\\t\\tif (current.val > 9) {\\n\\t\\t\\tcurrent.val = current.val % 10;\\n\\t\\t\\tcarry = 1;\\n\\t\\t}\\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n  let prev = null; // new head\\n  current = LL;\\n\\n  // handle reverse\\n  while (current) {\\n    const next = current.next\\n\\n    current.next = prev;\\n    prev = current;\\n    current = next;\\n  }\\n\\n  // handle adding one more digiti\\n  if (carry) prev = new ListNode(1, prev);\\n\\n  return prev;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * 1. convert each LL into a number\\n * 2. add two numers\\n * 3. convert to LL\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(max(N, M))\\n * * Space: O(N + M)\\n */\\n// Runtime: 124 ms, faster than 96.31% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 44.4 MB, less than 65.73% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers1 = (l1, l2) => {\\n\\tlet n1 = \\'\\';\\n\\tlet n2 = \\'\\';\\n\\n\\twhile (l1 || l2) {\\n\\t\\tif (l1) {\\n\\t\\t\\tn1 += l1.val;\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t}\\n\\t\\tif (l2) {\\n\\t\\t\\tn2 += l2.val;\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t}\\n\\t}\\n\\n\\tn1 = BigInt(n1);\\n\\tn2 = BigInt(n2);\\n\\n\\tconst sum = (n1 + n2).toString();\\n\\tlet i = 0;\\n\\tlet sentinel = new ListNode(0);\\n\\tlet tail = sentinel;\\n\\n\\twhile (i < sum.length) {\\n\\t\\tconst node = new ListNode(parseInt(sum[i++]));\\n\\n\\t\\ttail.next = node;\\n\\t\\ttail = node;\\n\\t}\\n\\n\\treturn sentinel.next;\\n};\\n\\n/**\\n * 1. reverse LL\\n * 2. add numbers\\n * 3. build LL reversed\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(N + M)\\n * * Space: O(1)\\n */\\n// Runtime: 140 ms, faster than 50.54% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 43.8 MB, less than 97.18% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers2 = (l1, l2) => {\\n\\tconst reverse = head => {\\n\\t\\tlet prev = null; // new head\\n\\t\\tlet current = head;\\n\\n\\t\\twhile (current) {\\n\\t\\t\\tconst next = current.next;\\n\\n\\t\\t\\tcurrent.next = prev;\\n\\t\\t\\tprev = current;\\n\\t\\t\\tcurrent = next;\\n\\t\\t}\\n\\n\\t\\treturn prev;\\n\\t};\\n\\n\\tl1 = reverse(l1);\\n\\tl2 = reverse(l2);\\n\\n\\tlet LL = null;\\n\\tlet sum = 0;\\n\\n\\twhile (l1 || l2) {\\n\\t\\tif (l1) {\\n\\t\\t\\tsum += l1.val;\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t}\\n\\t\\tif (l2) {\\n\\t\\t\\tsum += l2.val;\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t}\\n\\n\\t\\tconst node = new ListNode(sum % 10, LL);\\n\\n\\t\\tLL = node;\\n\\t\\tsum = sum > 9 ? 1 : 0;\\n\\t}\\n\\n\\tif (sum) LL = new ListNode(1, LL);\\n\\n\\treturn LL;\\n};\\n\\n/**\\n * 1. get length of LL\\n * 2. add corresponding digits\\n * 3. build LL reversed\\n * 4. handle carray\\n * 5. reverse LL\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @returns {ListNode}\\n * * Time: O(N + M)\\n * * Space: O(1)\\n */\\n// Runtime: 140 ms, faster than 50.54% of JavaScript online submissions for Add Two Numbers II.\\n// Memory Usage: 44.5 MB, less than 65.73% of JavaScript online submissions for Add Two Numbers II.\\nconst addTwoNumbers = (l1, l2) => {\\n\\tlet i = 0;\\n\\tlet j = 0;\\n\\tlet current1 = l1;\\n\\tlet current2 = l2;\\n\\n\\twhile (current1 || current2) {\\n\\t\\tif (current1) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcurrent1 = current1.next;\\n\\t\\t}\\n\\t\\tif (current2) {\\n\\t\\t\\tj++;\\n\\t\\t\\tcurrent2 = current2.next;\\n\\t\\t}\\n\\t}\\n\\n\\tlet LL = null;\\n\\n\\t// handle uneven number of digits\\n\\twhile (i !== j) {\\n\\t\\tif (i > j) {\\n\\t\\t\\tLL = new ListNode(l1.val, LL);\\n\\t\\t\\tl1 = l1.next;\\n\\t\\t\\ti--;\\n\\t\\t} else {\\n\\t\\t\\tLL = new ListNode(l2.val, LL);\\n\\t\\t\\tl2 = l2.next;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n\\n\\t// sum and add rest of digits\\n\\twhile (i-- && j--) {\\n\\t\\tLL = new ListNode(l1.val + l2.val, LL);\\n\\n\\t\\tl1 = l1.next;\\n\\t\\tl2 = l2.next;\\n\\t}\\n\\n\\tlet current = LL;\\n\\tlet carry = 0;\\n\\n\\t// handle carry\\n\\twhile (current) {\\n\\t\\tif (carry) {\\n\\t\\t\\tcurrent.val += 1;\\n\\t\\t\\tcarry = 0;\\n\\t\\t}\\n\\t\\tif (current.val > 9) {\\n\\t\\t\\tcurrent.val = current.val % 10;\\n\\t\\t\\tcarry = 1;\\n\\t\\t}\\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n  let prev = null; // new head\\n  current = LL;\\n\\n  // handle reverse\\n  while (current) {\\n    const next = current.next\\n\\n    current.next = prev;\\n    prev = current;\\n    current = next;\\n  }\\n\\n  // handle adding one more digiti\\n  if (carry) prev = new ListNode(1, prev);\\n\\n  return prev;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 926918,
                "title": "c-no-stack-plane-recursive-logic-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\t//both linkedlist of same size\\n    int addSameLength(ListNode* head1, ListNode *head2, ListNode* &head){\\n        if(head1==NULL && head2==NULL){\\n            return 0;\\n        }\\n        int sum=(head1->val+head2->val);\\n        sum+=addSameLength(head1->next,head2->next,head);\\n        ListNode *new_node= new ListNode(sum%10);\\n        new_node->next=head;\\n        head=new_node;\\n        return sum/10;\\n    }\\n\\t//Add carry to remaining linkedlist of extra length\\n    int addCarry(ListNode* head,int carry,ListNode* &new_head,int diff){\\n        if(head==NULL || diff==0){\\n            return carry;\\n        }\\n        carry=addCarry(head->next,carry,new_head,diff-1);\\n        int sum=head->val+carry;\\n        ListNode *new_node=new ListNode(sum%10);\\n        new_node->next=new_head;\\n        new_head=new_node;\\n        return sum/10;\\n    }\\n\\t//Calculates length of linkedlist\\n    int length(ListNode* head){\\n        int count=0;\\n        while(head){\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int len1=length(l1);\\n        int len2=length(l2);\\n        \\n\\t\\t//Always have l1 list as the longer.\\n        if(len2>len1){\\n            swap(l1,l2);\\n            swap(len1,len2);\\n        }\\n        ListNode *curr1=l1;\\n        int diff=len1-len2;\\n        for(int i=0;i<diff;i++){\\n            curr1=curr1->next;\\n        }\\n        ListNode *head=NULL;\\n        int carry=addSameLength(curr1,l2,head);\\n\\n        carry=addCarry(l1,carry,head,diff);\\n        if(carry){\\n            ListNode *new_node=new ListNode(1);\\n            new_node->next=head;\\n            head=new_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t//both linkedlist of same size\\n    int addSameLength(ListNode* head1, ListNode *head2, ListNode* &head){\\n        if(head1==NULL && head2==NULL){\\n            return 0;\\n        }\\n        int sum=(head1->val+head2->val);\\n        sum+=addSameLength(head1->next,head2->next,head);\\n        ListNode *new_node= new ListNode(sum%10);\\n        new_node->next=head;\\n        head=new_node;\\n        return sum/10;\\n    }\\n\\t//Add carry to remaining linkedlist of extra length\\n    int addCarry(ListNode* head,int carry,ListNode* &new_head,int diff){\\n        if(head==NULL || diff==0){\\n            return carry;\\n        }\\n        carry=addCarry(head->next,carry,new_head,diff-1);\\n        int sum=head->val+carry;\\n        ListNode *new_node=new ListNode(sum%10);\\n        new_node->next=new_head;\\n        new_head=new_node;\\n        return sum/10;\\n    }\\n\\t//Calculates length of linkedlist\\n    int length(ListNode* head){\\n        int count=0;\\n        while(head){\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int len1=length(l1);\\n        int len2=length(l2);\\n        \\n\\t\\t//Always have l1 list as the longer.\\n        if(len2>len1){\\n            swap(l1,l2);\\n            swap(len1,len2);\\n        }\\n        ListNode *curr1=l1;\\n        int diff=len1-len2;\\n        for(int i=0;i<diff;i++){\\n            curr1=curr1->next;\\n        }\\n        ListNode *head=NULL;\\n        int carry=addSameLength(curr1,l2,head);\\n\\n        carry=addCarry(l1,carry,head,diff);\\n        if(carry){\\n            ListNode *new_node=new ListNode(1);\\n            new_node->next=head;\\n            head=new_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525463,
                "title": "c-stack-without-modifying-the-original-list",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> num1;\\n        stack<int> num2;\\n        while(l1)\\n        {\\n            num1.push(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2)\\n        {\\n            num2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        ListNode* head=NULL;\\n        int carry=0;\\n        while(!num1.empty() && !num2.empty())\\n        {\\n            int sum=num1.top()+num2.top()+carry;\\n            num1.pop();\\n            num2.pop();\\n            carry=sum/10;\\n            if(head==NULL)\\n            {\\n                head=new ListNode(sum%10);\\n            }\\n            else\\n            {\\n                ListNode* temp=new ListNode(sum%10);\\n                temp->next=head;\\n                head=temp;\\n            }\\n        }\\n        while(!num1.empty())\\n        {\\n            int sum=num1.top()+carry;\\n            carry=sum/10;\\n            ListNode* temp=new ListNode(sum%10);\\n            num1.pop();\\n            temp->next=head;\\n            head=temp;\\n        }\\n        while(!num2.empty())\\n        {\\n            int sum=num2.top()+carry;\\n            carry=sum/10;\\n            ListNode* temp=new ListNode(sum%10);\\n            num2.pop();\\n            temp->next=head;\\n            head=temp;\\n        }\\n        if(carry)\\n        {\\n            ListNode* temp= new ListNode(carry);\\n            temp->next=head;\\n            head=temp;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> num1;\\n        stack<int> num2;\\n        while(l1)\\n        {\\n            num1.push(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2)\\n        {\\n            num2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        ListNode* head=NULL;\\n        int carry=0;\\n        while(!num1.empty() && !num2.empty())\\n        {\\n            int sum=num1.top()+num2.top()+carry;\\n            num1.pop();\\n            num2.pop();\\n            carry=sum/10;\\n            if(head==NULL)\\n            {\\n                head=new ListNode(sum%10);\\n            }\\n            else\\n            {\\n                ListNode* temp=new ListNode(sum%10);\\n                temp->next=head;\\n                head=temp;\\n            }\\n        }\\n        while(!num1.empty())\\n        {\\n            int sum=num1.top()+carry;\\n            carry=sum/10;\\n            ListNode* temp=new ListNode(sum%10);\\n            num1.pop();\\n            temp->next=head;\\n            head=temp;\\n        }\\n        while(!num2.empty())\\n        {\\n            int sum=num2.top()+carry;\\n            carry=sum/10;\\n            ListNode* temp=new ListNode(sum%10);\\n            num2.pop();\\n            temp->next=head;\\n            head=temp;\\n        }\\n        if(carry)\\n        {\\n            ListNode* temp= new ListNode(carry);\\n            temp->next=head;\\n            head=temp;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381068,
                "title": "java-solution-using-recursion-2ms-faster-than-99-8-no-stacks-no-list-reversals",
                "content": "\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        int len1 = findLength(l1);\\n        int len2 = findLength(l2);    \\n        \\n\\t\\t/*If the lists are not same size, padd the smaller one with zeros on the left.*/\\n        if(len1 < len2){\\n            l1 = paddWithZeros(l1, len2 - len1);\\n        } else if(len2 < len1){\\n            l2 = paddWithZeros(l2, len1 - len2);\\n        }\\n        /* will begin with 0 in the list. Treat this 0 as you carry */\\n        ListNode result = new ListNode(0);\\n        \\n        result = addTwoNumbersUtil(l1, l2, result);   \\n        \\n\\t\\t/*if the carry is 0 for the first digits in the lists, result.val will be zero. So omit that 0 node*/\\n        if(result.val == 0){\\n            return result.next;\\n        }        \\n        \\n        return result;\\n        \\n        \\n    }\\n    \\n\\t/* Creates a Sub Sum node and Carry node on the last recursive call. Result always points to the carry node. On the way down the call stack, it modifies the carry node with the current sub sum value*/\\n    public ListNode addTwoNumbersUtil(ListNode l1, ListNode l2, ListNode result){\\n        \\n        if(l1 == null && l2 == null){\\n            return result;\\n            \\n        } else {\\n            result = addTwoNumbersUtil(l1.next, l2.next, result);\\n\\t\\t\\t\\n            int sum = l1.val + l2.val + result.val;           \\n            int carry = sum/10;\\n            sum = sum%10;\\n            result.val = sum;\\n            ListNode carryNode = new ListNode(carry);\\n            carryNode.next = result;            \\n            result = carryNode;           \\n            \\n            return result;\\n            \\n        }\\n        \\n       \\n    }\\n    \\n    public int findLength(ListNode node){\\n        \\n        int len = 0;\\n        while(node != null){\\n            len++;\\n            node = node.next;\\n        }\\n        \\n        return len;\\n    }\\n    \\n    \\n    public ListNode paddWithZeros(ListNode node, int lenDiff){\\n        \\n        while(lenDiff > 0){\\n            \\n            ListNode newNode = new ListNode(0);\\n            newNode.next = node;\\n            node = newNode;\\n            \\n            lenDiff --;\\n        }\\n        return node;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        int len1 = findLength(l1);\\n        int len2 = findLength(l2);    \\n        \\n\\t\\t/*If the lists are not same size, padd the smaller one with zeros on the left.*/\\n        if(len1 < len2){\\n            l1 = paddWithZeros(l1, len2 - len1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 250352,
                "title": "python-stack-recursion",
                "content": "A typical add two number question solution is to add two number\\'s digits from right to left. We add one carry unit to the next digit if the current sum is larger than 10 and set **sum mod 10** as new digit value. We also need to handle the situation when two number have different length.\\nFor two numbers with the form of single linked list, the key challenge is that we have to read number from left to right. Thus, we can either store digit val to a stack or solve it in recursive way.\\n\\nStack\\nWe store linked list\\'s val to a stack and then pop a digit out (LIFO) for each addition so that we add digits from right to left. We also create a new linked list **ans** to store our addition result. We keep add new added digit (saved in **head**) to its front. \\nIf one stack is empty, we add nothing from it. If both stacks are empty, we finish our addition. And last addition\\'s carry is saved in **sum_val** and carried to the next addition.\\n```\\ndef addTwoNumbers(l1, l2):\\n\\ts1, s2 = read(l1), read(l2)\\n\\tsum_val, ans = 0, ListNode(0)\\n\\twhile s1 or s2:\\n\\t\\tif s1: sum_val += s1.pop()\\n\\t\\tif s2: sum_val += s2.pop()\\n\\t\\tsum_val, ans.val = divmod(sum_val, 10)\\n\\t\\thead = ListNode(sum_val)\\n\\t\\thead.next, ans = ans, head\\n\\treturn ans if ans.val else ans.next\\n\\t\\ndef read(node):\\n\\ts = []\\n\\twhile node:\\n\\t\\ts.append(node.val)\\n\\t\\tnode = node.next\\n\\treturn s\\n```\\nThe time complexity is O(n) and space complexity is O(n) since we create two stacks and one linked list.\\n\\nRecursion\\nTo solve it in a more \\'linked list\\' way, we can do it via recursion. We get right digits addition result from recursion and carry out current digit addition. Then store the recursion result to current node\\'s next pointer. We do it by passing l1.next and l2.next to our recursive function.\\nWe need to handle length difference issue. So we make sure l1\\'s length is no smaller than l2\\'s length by variable switch trick. And we add l2\\'s node.val and move to l2.next only when l1\\'s length equals to l2\\'s length. Since l1 is longer, we save our addition result in l1\\'s node to save some space. If the final carry is larger than 0, we add one new node at the head.\\n```\\ndef addTwoNumbers(l1, l2):\\n\\tlen1, len2, carry = getLen(l1), getLen(l2), 0\\n\\tif len1 < len2: l1, len1, l2, len2 = l2, len2, l1, len1\\n\\tcarry = recur(l1, len1, l2, len2)\\n\\tif carry: \\n\\t\\thead, head.next = ListNode(carry), l1\\n\\t\\treturn head\\n\\treturn l1\\n\\ndef recur(l1, len1, l2, len2):\\n\\tif not (l1 or l2): return 0\\n\\t(len1, l2v, l2n) = (len1-1, 0, l2) if len1 > len2 else (len1, l2.val, l2.next)\\n\\tcarry, l1v = recur(l1.next, len1, l2n, len2), l1.val\\n\\tl1.val = (l1v + l2v + carry) % 10\\n\\treturn (l1v + l2v + carry) // 10\\n\\ndef getLen(node):\\n\\tl = 0\\n\\twhile node: \\n\\t\\tnode, l = node.next, l+1\\n\\treturn l\\n```\\nThe time complexity is O(n) and space complexity is O(1) since we carry out our addition by updating l1\\'s value",
                "solutionTags": [],
                "code": "```\\ndef addTwoNumbers(l1, l2):\\n\\ts1, s2 = read(l1), read(l2)\\n\\tsum_val, ans = 0, ListNode(0)\\n\\twhile s1 or s2:\\n\\t\\tif s1: sum_val += s1.pop()\\n\\t\\tif s2: sum_val += s2.pop()\\n\\t\\tsum_val, ans.val = divmod(sum_val, 10)\\n\\t\\thead = ListNode(sum_val)\\n\\t\\thead.next, ans = ans, head\\n\\treturn ans if ans.val else ans.next\\n\\t\\ndef read(node):\\n\\ts = []\\n\\twhile node:\\n\\t\\ts.append(node.val)\\n\\t\\tnode = node.next\\n\\treturn s\\n```\n```\\ndef addTwoNumbers(l1, l2):\\n\\tlen1, len2, carry = getLen(l1), getLen(l2), 0\\n\\tif len1 < len2: l1, len1, l2, len2 = l2, len2, l1, len1\\n\\tcarry = recur(l1, len1, l2, len2)\\n\\tif carry: \\n\\t\\thead, head.next = ListNode(carry), l1\\n\\t\\treturn head\\n\\treturn l1\\n\\ndef recur(l1, len1, l2, len2):\\n\\tif not (l1 or l2): return 0\\n\\t(len1, l2v, l2n) = (len1-1, 0, l2) if len1 > len2 else (len1, l2.val, l2.next)\\n\\tcarry, l1v = recur(l1.next, len1, l2n, len2), l1.val\\n\\tl1.val = (l1v + l2v + carry) % 10\\n\\treturn (l1v + l2v + carry) // 10\\n\\ndef getLen(node):\\n\\tl = 0\\n\\twhile node: \\n\\t\\tnode, l = node.next, l+1\\n\\treturn l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3776670,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing two stacks to make calculation easy.\\n\\n# Solution Video\\n\\nhttps://youtu.be/DP1oVjE5t6o\\n\\n# *** Please Upvote and subscribe to my channel from here. I have 224 LeetCode videos as of July 17th, 2023. ***\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other language might be different a bit.\\n\\n1. Create two empty stacks, `stack1` and `stack2`, to store the digits of the linked lists `l1` and `l2`, respectively.\\n\\n2. Push the digits of `l1` to `stack1` using a while loop:\\n   - Traverse the linked list `l1` while it is not empty.\\n   - For each node in `l1`, push its value (digit) onto `stack1`.\\n   - Move to the next node in `l1` until the end of the linked list is reached.\\n\\n3. Push the digits of `l2` to `stack2` using a similar while loop as in step 2.\\n\\n4. Initialize a variable `carry` to store the carry from the previous addition. Set `dummy_head` to `None`, which will be the head of the result linked list.\\n\\n5. Perform the addition:\\n   - Use a while loop to continue adding digits until both `stack1` and `stack2` are empty, and there is no carry left.\\n   - Inside the loop:\\n     - Pop the top element from `stack1` if it is not empty; otherwise, set `val1` to 0.\\n     - Pop the top element from `stack2` if it is not empty; otherwise, set `val2` to 0.\\n     - Add `val1`, `val2`, and the current `carry`, and store the sum in `total`.\\n     - Update `carry` to store the carry for the next iteration (carry will be either 0 or 1).\\n     - Create a new node with the value `(total % 10)` and set its `next` pointer to `dummy_head`.\\n     - Update `dummy_head` to point to the new node, effectively reversing the order of the nodes in the result linked list.\\n\\n6. After the loop, the addition is complete, and the result is stored in the linked list starting from `dummy_head`. Return `dummy_head`, which is the head of the result linked list.\\n\\nThe algorithm uses the property of a stack to reverse the order of digits in the linked lists `l1` and `l2` so that the addition can be performed from the least significant digit to the most significant digit. This approach avoids the need to reverse the linked lists before performing the addition.\\n\\n# Complexity\\nThis is based on Python code. Other language might be different a bit.\\n\\n- Time complexity: O(m + n)\\n \\'m\\' and \\'n\\' are the lengths of the two linked lists, l1 and l2\\n\\n- Space complexity: O(m + n)\\n \\'m\\' and \\'n\\' are the lengths of the two linked lists, l1 and l2\\n\\n\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack1, stack2 = [], []\\n\\n        # push digits of l1 to stack1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        # push digits of l2 to stack1\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n        \\n        carry = 0\\n        dummy_head = None\\n\\n        # Pop digits from both stacks and add them\\n        while stack1 or stack2 or carry:\\n            val1 = stack1.pop() if stack1 else 0\\n            val2 = stack2.pop() if stack2 else 0\\n\\n            total = val1 + val2 + carry\\n            carry = total // 10\\n\\n            new_node = ListNode(total % 10)\\n            new_node.next = dummy_head\\n            dummy_head = new_node\\n\\n        return dummy_head            \\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    let stack1 = [];\\n    let stack2 = [];\\n\\n    // Push digits of l1 to stack1\\n    while (l1) {\\n        stack1.push(l1.val);\\n        l1 = l1.next;\\n    }\\n\\n    // Push digits of l2 to stack2\\n    while (l2) {\\n        stack2.push(l2.val);\\n        l2 = l2.next;\\n    }\\n\\n    let carry = 0;\\n    let dummyHead = null;\\n\\n    // Pop digits from both stacks and add them\\n    while (stack1.length || stack2.length || carry) {\\n        let val1 = stack1.pop() || 0;\\n        let val2 = stack2.pop() || 0;\\n\\n        let total = val1 + val2 + carry;\\n        carry = Math.floor(total / 10);\\n\\n        let new_node = new ListNode(total % 10);\\n        new_node.next = dummyHead;\\n        dummyHead = new_node;\\n    }\\n\\n    return dummyHead;    \\n};\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> stack1 = new Stack<>();\\n        Stack<Integer> stack2 = new Stack<>();\\n\\n        // Push digits of l1 to stack1\\n        while (l1 != null) {\\n            stack1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n\\n        // Push digits of l2 to stack2\\n        while (l2 != null) {\\n            stack2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n\\n        int carry = 0;\\n        ListNode dummyHead = null;\\n\\n        // Pop digits from both stacks and add them\\n        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {\\n            int val1 = stack1.isEmpty() ? 0 : stack1.pop();\\n            int val2 = stack2.isEmpty() ? 0 : stack2.pop();\\n\\n            int total = val1 + val2 + carry;\\n            carry = total / 10;\\n\\n            ListNode new_node = new ListNode(total % 10);\\n            new_node.next = dummyHead;\\n            dummyHead = new_node;\\n        }\\n\\n        return dummyHead;        \\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        std::stack<int> stack1, stack2;\\n\\n        // Push digits of l1 to stack1\\n        while (l1) {\\n            stack1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        // Push digits of l2 to stack2\\n        while (l2) {\\n            stack2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        int carry = 0, val1, val2;\\n        ListNode* dummyHead = NULL;\\n\\n        // Pop digits from both stacks and add them\\n        while (!stack1.empty() || !stack2.empty() || carry) {\\n            if (!stack1.empty()) {\\n                val1 = stack1.top();\\n                stack1.pop();\\n            }\\n            else\\n                val1 = 0;\\n            \\n            if (!stack2.empty()) {\\n                val2 = stack2.top();\\n                stack2.pop();\\n            }\\n            else\\n                val2 = 0;\\n            \\n            int total = val1 + val2 + carry;\\n            carry = total / 10;\\n\\n            ListNode* new_node = new ListNode(total % 10);\\n            new_node->next = dummyHead;\\n            dummyHead = new_node;\\n        }\\n\\n        return dummyHead;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack1, stack2 = [], []\\n\\n        # push digits of l1 to stack1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        # push digits of l2 to stack1\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n        \\n        carry = 0\\n        dummy_head = None\\n\\n        # Pop digits from both stacks and add them\\n        while stack1 or stack2 or carry:\\n            val1 = stack1.pop() if stack1 else 0\\n            val2 = stack2.pop() if stack2 else 0\\n\\n            total = val1 + val2 + carry\\n            carry = total // 10\\n\\n            new_node = ListNode(total % 10)\\n            new_node.next = dummy_head\\n            dummy_head = new_node\\n\\n        return dummy_head            \\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    let stack1 = [];\\n    let stack2 = [];\\n\\n    // Push digits of l1 to stack1\\n    while (l1) {\\n        stack1.push(l1.val);\\n        l1 = l1.next;\\n    }\\n\\n    // Push digits of l2 to stack2\\n    while (l2) {\\n        stack2.push(l2.val);\\n        l2 = l2.next;\\n    }\\n\\n    let carry = 0;\\n    let dummyHead = null;\\n\\n    // Pop digits from both stacks and add them\\n    while (stack1.length || stack2.length || carry) {\\n        let val1 = stack1.pop() || 0;\\n        let val2 = stack2.pop() || 0;\\n\\n        let total = val1 + val2 + carry;\\n        carry = Math.floor(total / 10);\\n\\n        let new_node = new ListNode(total % 10);\\n        new_node.next = dummyHead;\\n        dummyHead = new_node;\\n    }\\n\\n    return dummyHead;    \\n};\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> stack1 = new Stack<>();\\n        Stack<Integer> stack2 = new Stack<>();\\n\\n        // Push digits of l1 to stack1\\n        while (l1 != null) {\\n            stack1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n\\n        // Push digits of l2 to stack2\\n        while (l2 != null) {\\n            stack2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n\\n        int carry = 0;\\n        ListNode dummyHead = null;\\n\\n        // Pop digits from both stacks and add them\\n        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {\\n            int val1 = stack1.isEmpty() ? 0 : stack1.pop();\\n            int val2 = stack2.isEmpty() ? 0 : stack2.pop();\\n\\n            int total = val1 + val2 + carry;\\n            carry = total / 10;\\n\\n            ListNode new_node = new ListNode(total % 10);\\n            new_node.next = dummyHead;\\n            dummyHead = new_node;\\n        }\\n\\n        return dummyHead;        \\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        std::stack<int> stack1, stack2;\\n\\n        // Push digits of l1 to stack1\\n        while (l1) {\\n            stack1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        // Push digits of l2 to stack2\\n        while (l2) {\\n            stack2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        int carry = 0, val1, val2;\\n        ListNode* dummyHead = NULL;\\n\\n        // Pop digits from both stacks and add them\\n        while (!stack1.empty() || !stack2.empty() || carry) {\\n            if (!stack1.empty()) {\\n                val1 = stack1.top();\\n                stack1.pop();\\n            }\\n            else\\n                val1 = 0;\\n            \\n            if (!stack2.empty()) {\\n                val2 = stack2.top();\\n                stack2.pop();\\n            }\\n            else\\n                val2 = 0;\\n            \\n            int total = val1 + val2 + carry;\\n            carry = total / 10;\\n\\n            ListNode* new_node = new ListNode(total % 10);\\n            new_node->next = dummyHead;\\n            dummyHead = new_node;\\n        }\\n\\n        return dummyHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776401,
                "title": "without-reversing-lists-using-stacks-easy-solution-clean-code",
                "content": "**PLEASE UPVOTE :)**\\n# Intuition\\nWe need to reverse the lists to add, so Stack can be used.\\n\\n# Approach\\nWe\\'ll push both the lists into 2 separate stacks and will perform addition operation till the stack isn\\'t empty.\\nThen create a final answer list from the answer stack created.\\n\\n# Complexity\\n- Time complexity:\\nTC : O(n1 + n2)\\n\\n- Space complexity:\\nSC : O(n1 + n2)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic: \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1, s2, ans;\\n        while(l1){\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while(l2){\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int carry = 0;\\n        while(s1.size() || s2.size()){\\n            int temp = 0;\\n            if(s1.size()){\\n                temp += s1.top();\\n                s1.pop();\\n            }\\n            if(s2.size()){\\n                temp += s2.top();\\n                s2.pop();\\n            }\\n            temp += carry;\\n            carry = temp/10;\\n            temp = temp%10;\\n\\n            ans.push(temp);\\n        }\\n\\n        if(carry){\\n            ans.push(carry);\\n        }\\n        ListNode* head = new ListNode();\\n        ListNode* prev = head;\\n        while(ans.size()){\\n            ListNode* curr = new ListNode(ans.top());\\n            prev->next = curr;\\n            prev = prev->next;\\n            ans.pop(); \\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic: \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1, s2, ans;\\n        while(l1){\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while(l2){\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int carry = 0;\\n        while(s1.size() || s2.size()){\\n            int temp = 0;\\n            if(s1.size()){\\n                temp += s1.top();\\n                s1.pop();\\n            }\\n            if(s2.size()){\\n                temp += s2.top();\\n                s2.pop();\\n            }\\n            temp += carry;\\n            carry = temp/10;\\n            temp = temp%10;\\n\\n            ans.push(temp);\\n        }\\n\\n        if(carry){\\n            ans.push(carry);\\n        }\\n        ListNode* head = new ListNode();\\n        ListNode* prev = head;\\n        while(ans.size()){\\n            ListNode* curr = new ListNode(ans.top());\\n            prev->next = curr;\\n            prev = prev->next;\\n            ans.pop(); \\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776018,
                "title": "stack-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/bcqCFKSME7w\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n          Stack<Integer> s1 = new Stack<>();\\n          Stack<Integer> s2 = new Stack<>();\\n          while (l1!=null){\\n             s1.add(l1.val);\\n             l1=l1.next;\\n          }\\n          while (l2!=null){\\n            s2.add(l2.val);\\n            l2=l2.next;\\n          }\\n          int sum = 0; int carry = 0; ListNode ans = null;\\n          ListNode newNode;\\n          while (!s1.isEmpty() || !s2.isEmpty()){\\n              if(!s1.isEmpty()) sum+=s1.pop();\\n              if(!s2.isEmpty()) sum+=s2.pop();\\n              sum+=carry;\\n              carry = sum/10;\\n              newNode = new ListNode(sum%10);\\n              newNode.next = ans;\\n              ans = newNode;\\n              sum = 0;\\n          }\\n          if (carry!=0) {\\n              newNode = new ListNode(carry);\\n              newNode.next = ans;\\n              ans = newNode;\\n          }\\n          return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n        while (l1 != nullptr) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2 != nullptr) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int sum = 0;\\n        int carry = 0;\\n        ListNode* ans = nullptr;\\n        ListNode* newNode;\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n            sum += carry;\\n            carry = sum / 10;\\n            newNode = new ListNode(sum % 10);\\n            newNode->next = ans;\\n            ans = newNode;\\n            sum = 0;\\n        }\\n        if (carry != 0) {\\n            newNode = new ListNode(carry);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        s1 = []\\n        s2 = []\\n        \\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        \\n        sum = 0\\n        carry = 0\\n        ans = None\\n        \\n        while s1 or s2:\\n            if s1:\\n                sum += s1.pop()\\n            \\n            if s2:\\n                sum += s2.pop()\\n            \\n            sum += carry\\n            carry = sum // 10\\n            newNode = ListNode(sum % 10)\\n            newNode.next = ans\\n            ans = newNode\\n            sum = 0\\n        \\n        if carry != 0:\\n            newNode = ListNode(carry)\\n            newNode.next = ans\\n            ans = newNode\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n          Stack<Integer> s1 = new Stack<>();\\n          Stack<Integer> s2 = new Stack<>();\\n          while (l1!=null){\\n             s1.add(l1.val);\\n             l1=l1.next;\\n          }\\n          while (l2!=null){\\n            s2.add(l2.val);\\n            l2=l2.next;\\n          }\\n          int sum = 0; int carry = 0; ListNode ans = null;\\n          ListNode newNode;\\n          while (!s1.isEmpty() || !s2.isEmpty()){\\n              if(!s1.isEmpty()) sum+=s1.pop();\\n              if(!s2.isEmpty()) sum+=s2.pop();\\n              sum+=carry;\\n              carry = sum/10;\\n              newNode = new ListNode(sum%10);\\n              newNode.next = ans;\\n              ans = newNode;\\n              sum = 0;\\n          }\\n          if (carry!=0) {\\n              newNode = new ListNode(carry);\\n              newNode.next = ans;\\n              ans = newNode;\\n          }\\n          return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n        while (l1 != nullptr) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2 != nullptr) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int sum = 0;\\n        int carry = 0;\\n        ListNode* ans = nullptr;\\n        ListNode* newNode;\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n            sum += carry;\\n            carry = sum / 10;\\n            newNode = new ListNode(sum % 10);\\n            newNode->next = ans;\\n            ans = newNode;\\n            sum = 0;\\n        }\\n        if (carry != 0) {\\n            newNode = new ListNode(carry);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        s1 = []\\n        s2 = []\\n        \\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        \\n        sum = 0\\n        carry = 0\\n        ans = None\\n        \\n        while s1 or s2:\\n            if s1:\\n                sum += s1.pop()\\n            \\n            if s2:\\n                sum += s2.pop()\\n            \\n            sum += carry\\n            carry = sum // 10\\n            newNode = ListNode(sum % 10)\\n            newNode.next = ans\\n            ans = newNode\\n            sum = 0\\n        \\n        if carry != 0:\\n            newNode = ListNode(carry)\\n            newNode.next = ans\\n            ans = newNode\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775997,
                "title": "easy-java-solution-beats-100-linked-list",
                "content": "# Intuition\\nThis solution aims to add two numbers represented as linked lists in reverse order. \\n# Approach\\nTo achieve above intuition , the code first reverses both input lists using the rev method, which reverses a linked list by rearranging the pointers.\\n\\nAfter the reversal, the code iterates through both lists simultaneously while keeping track of a carry value. It calculates the sum of the corresponding nodes from both lists and the carry value. If there are still elements in either list or there is a carry value, the loop continues.\\n\\nInside the loop, it creates a new node for the result and updates the carry value accordingly. The new node is then linked to the previous node using the temp variable. Finally, the code returns the reversed result by calling the rev method again on the final result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(max(N, M)), where N and M are the lengths of the input linked lists l1 and l2, respectively.\\n\\nThe code iterates through both lists simultaneously in the while loop, which takes O(max(N, M)) iterations since it continues until both lists are fully traversed. Inside the loop, the code performs constant-time operations such as addition, modulo, and node creation, which do not contribute significantly to the overall time complexity.\\n\\n- Space complexity:\\nThe space complexity of this code is also O(max(N, M)), where N and M are the lengths of the input linked lists l1 and l2, respectively.\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode rev(ListNode head){\\n        if(head==null || head.next==null)\\n            return head;\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        ListNode temp = curr.next;\\n        while(temp!=null){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n            temp = temp.next;\\n        }\\n        head.next = null;\\n        curr.next = prev;\\n        return curr;\\n    }\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode head1 = rev(l1);\\n        ListNode head2 = rev(l2);\\n        int carry = 0;\\n        ListNode head = null;\\n        ListNode temp = null;\\n        while (head1 != null || head2 != null || carry != 0) {\\n            int sum = carry;\\n            if (head1 != null) {\\n                sum += head1.val;\\n                head1 = head1.next;\\n            }\\n            if (head2 != null) {\\n                sum += head2.val;\\n                head2 = head2.next;\\n            }\\n            carry = sum / 10;\\n            sum = sum % 10;\\n            ListNode newNode = new ListNode(sum);\\n            if (head == null) {\\n                head = newNode;\\n                temp = head;\\n            }\\n            else {\\n                temp.next = newNode;\\n                temp = temp.next;\\n            }\\n        }\\n        return rev(head); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode rev(ListNode head){\\n        if(head==null || head.next==null)\\n            return head;\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        ListNode temp = curr.next;\\n        while(temp!=null){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n            temp = temp.next;\\n        }\\n        head.next = null;\\n        curr.next = prev;\\n        return curr;\\n    }\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode head1 = rev(l1);\\n        ListNode head2 = rev(l2);\\n        int carry = 0;\\n        ListNode head = null;\\n        ListNode temp = null;\\n        while (head1 != null || head2 != null || carry != 0) {\\n            int sum = carry;\\n            if (head1 != null) {\\n                sum += head1.val;\\n                head1 = head1.next;\\n            }\\n            if (head2 != null) {\\n                sum += head2.val;\\n                head2 = head2.next;\\n            }\\n            carry = sum / 10;\\n            sum = sum % 10;\\n            ListNode newNode = new ListNode(sum);\\n            if (head == null) {\\n                head = newNode;\\n                temp = head;\\n            }\\n            else {\\n                temp.next = newNode;\\n                temp = temp.next;\\n            }\\n        }\\n        return rev(head); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075130,
                "title": "easy-concise-java-o-n-beats-100-best-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve in simple linear approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReverse both the linkedlist and add them in new Linkedlist. \\nFinally, reverse the ans list and return\\n\\nPlease Upvote if you liked it!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\n        ListNode temp = new ListNode(0), head = temp;\\n        int carry = 0;\\n        \\n        while(l1 != null || l2 != null || carry != 0){\\n            int sum = 0;\\n            sum+= (l1 != null) ? l1.val : 0;\\n            sum+= (l2 != null) ? l2.val : 0;\\n            l1 = (l1 != null) ? l1.next : null;\\n            l2 = (l2 != null) ? l2.next : null;\\n\\n            sum+=carry;\\n            carry = sum/10;\\n            ListNode n = new ListNode(sum%10);\\n            temp.next = n;\\n            temp = temp.next;\\n        }\\n\\n        ListNode ans = reverse(head.next);\\n        return ans;\\n    }\\n    \\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null, curr=head;\\n        while(curr != null){\\n            ListNode n = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = n;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\n        ListNode temp = new ListNode(0), head = temp;\\n        int carry = 0;\\n        \\n        while(l1 != null || l2 != null || carry != 0){\\n            int sum = 0;\\n            sum+= (l1 != null) ? l1.val : 0;\\n            sum+= (l2 != null) ? l2.val : 0;\\n            l1 = (l1 != null) ? l1.next : null;\\n            l2 = (l2 != null) ? l2.next : null;\\n\\n            sum+=carry;\\n            carry = sum/10;\\n            ListNode n = new ListNode(sum%10);\\n            temp.next = n;\\n            temp = temp.next;\\n        }\\n\\n        ListNode ans = reverse(head.next);\\n        return ans;\\n    }\\n    \\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null, curr=head;\\n        while(curr != null){\\n            ListNode n = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = n;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712252,
                "title": "easy-c-solution-using-reverse",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n         ListNode* res = NULL;\\n        ListNode* temp = NULL;\\n        ListNode* prev = NULL;\\n        int carry = 0,sum;\\n        while(l1||l2){\\n            sum = carry + (l1?l1->val:0)+(l2?l2->val:0);\\n            carry= (sum>=10)?1:0;\\n            sum=sum%10;\\n            temp = new ListNode(sum);\\n            if(res==NULL)\\n                res=temp;\\n            else\\n                prev->next=temp;\\n            prev=temp;\\n            if(l1)l1=l1->next;\\n            if(l2)l2=l2->next;\\n        }\\n        if(carry>0) temp->next = new ListNode(carry);\\n        return reverse(res);\\n    }\\n    ListNode* reverse(ListNode* head){\\n        ListNode* current = head;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        while(current!=NULL){\\n            next=current->next;\\n            current->next=prev;\\n            prev=current;\\n            current=next;\\n        }\\n        head=prev;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n         ListNode* res = NULL;\\n        ListNode* temp = NULL;\\n        ListNode* prev = NULL;\\n        int carry = 0,sum;\\n        while(l1||l2){\\n            sum = carry + (l1?l1->val:0)+(l2?l2->val:0);\\n            carry= (sum>=10)?1:0;\\n            sum=sum%10;\\n            temp = new ListNode(sum);\\n            if(res==NULL)\\n                res=temp;\\n            else\\n                prev->next=temp;\\n            prev=temp;\\n            if(l1)l1=l1->next;\\n            if(l2)l2=l2->next;\\n        }\\n        if(carry>0) temp->next = new ListNode(carry);\\n        return reverse(res);\\n    }\\n    ListNode* reverse(ListNode* head){\\n        ListNode* current = head;\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        while(current!=NULL){\\n            next=current->next;\\n            current->next=prev;\\n            prev=current;\\n            current=next;\\n        }\\n        head=prev;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767797,
                "title": "python-recursive-o-n-solution-without-convert-to-int-and-without-stack",
                "content": "```\\nclass Solution:\\n    \\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        len1 = self._getLength(l1)\\n        len2 = self._getLength(l2)\\n        \\n        head, carry = self._addRecursively(l1, len1, l2, len2)\\n        \\n        if carry:\\n            head = ListNode(carry, head)\\n            \\n        return head\\n    \\n    def _addRecursively(self, l1: ListNode, len1: int, l2: ListNode, len2: int) -> ListNode:\\n        if not l1 and not l2:\\n            return (None, 0)\\n        \\n        current_sum = 0\\n        carry = 0\\n        \\n        if len1 > len2:\\n            head, carry = self._addRecursively(l1.next, len1 - 1, l2, len2)\\n            current_sum = l1.val + carry\\n        elif len1 < len2:\\n            head, carry = self._addRecursively(l1, len1, l2.next, len2 - 1)\\n            current_sum = l2.val + carry\\n        else:\\n            head, carry = self._addRecursively(l1.next, len1 - 1, l2.next, len2 - 1)\\n            current_sum = l1.val + l2.val + carry\\n            \\n        carry = current_sum // 10\\n        current_sum %= 10\\n        \\n        return (ListNode(current_sum, head), carry)\\n\\n    def _getLength(self, l: ListNode) -> int:\\n        result = 0\\n        curr = l\\n        \\n        while curr:\\n            curr = curr.next\\n            result += 1\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        len1 = self._getLength(l1)\\n        len2 = self._getLength(l2)\\n        \\n        head, carry = self._addRecursively(l1, len1, l2, len2)\\n        \\n        if carry:\\n            head = ListNode(carry, head)\\n            \\n        return head\\n    \\n    def _addRecursively(self, l1: ListNode, len1: int, l2: ListNode, len2: int) -> ListNode:\\n        if not l1 and not l2:\\n            return (None, 0)\\n        \\n        current_sum = 0\\n        carry = 0\\n        \\n        if len1 > len2:\\n            head, carry = self._addRecursively(l1.next, len1 - 1, l2, len2)\\n            current_sum = l1.val + carry\\n        elif len1 < len2:\\n            head, carry = self._addRecursively(l1, len1, l2.next, len2 - 1)\\n            current_sum = l2.val + carry\\n        else:\\n            head, carry = self._addRecursively(l1.next, len1 - 1, l2.next, len2 - 1)\\n            current_sum = l1.val + l2.val + carry\\n            \\n        carry = current_sum // 10\\n        current_sum %= 10\\n        \\n        return (ListNode(current_sum, head), carry)\\n\\n    def _getLength(self, l: ListNode) -> int:\\n        result = 0\\n        curr = l\\n        \\n        while curr:\\n            curr = curr.next\\n            result += 1\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757260,
                "title": "java-solution-3ms-fast-2stacks-detailed-explanation",
                "content": "If you found the solution helpful, kindly like or upvote. :)\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n            \\tStack<Integer> stack1= new Stack<Integer>();\\n    \\tStack<Integer> stack2= new Stack<Integer>();\\n    \\t//Add the values of the nodes in the stack\\n    \\twhile(l1 != null)\\n    \\t{\\n    \\t\\tstack1.push(l1.val);\\n    \\t\\tl1= l1.next;\\n    \\t}\\n    \\twhile(l2 != null)\\n    \\t{\\n    \\t\\tstack2.push(l2.val);\\n    \\t\\tl2= l2.next;\\n    \\t}\\n    \\t\\n    \\tint sum=0;\\n    \\t\\n    \\tListNode res= new ListNode(0);\\n    \\twhile(!stack1.isEmpty() || !stack2.isEmpty())\\n    \\t{\\n    \\t\\tif(!stack1.isEmpty())\\n    \\t\\t\\tsum += stack1.pop();\\n    \\t\\tif(!stack2.isEmpty())\\n    \\t\\t\\tsum += stack2.pop();\\n    \\t\\tres.val= sum%10;\\n    \\t\\t//We make a new node which will store the carry of the sum\\n    \\t\\tListNode before= new ListNode(sum/10);\\n    \\t\\tbefore.next= res;\\n    \\t\\t//Updating the pointer for next iteration\\n    \\t\\tres=before;\\n    \\t\\tsum /= 10;\\t//sum=1 if carry is there, 0 if not there\\n    \\t}\\n    \\treturn res.val==0 ? res.next:res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n            \\tStack<Integer> stack1= new Stack<Integer>();\\n    \\tStack<Integer> stack2= new Stack<Integer>();\\n    \\t//Add the values of the nodes in the stack\\n    \\twhile(l1 != null)\\n    \\t{\\n    \\t\\tstack1.push(l1.val);\\n    \\t\\tl1= l1.next;\\n    \\t}\\n    \\twhile(l2 != null)\\n    \\t{\\n    \\t\\tstack2.push(l2.val);\\n    \\t\\tl2= l2.next;\\n    \\t}\\n    \\t\\n    \\tint sum=0;\\n    \\t\\n    \\tListNode res= new ListNode(0);\\n    \\twhile(!stack1.isEmpty() || !stack2.isEmpty())\\n    \\t{\\n    \\t\\tif(!stack1.isEmpty())\\n    \\t\\t\\tsum += stack1.pop();\\n    \\t\\tif(!stack2.isEmpty())\\n    \\t\\t\\tsum += stack2.pop();\\n    \\t\\tres.val= sum%10;\\n    \\t\\t//We make a new node which will store the carry of the sum\\n    \\t\\tListNode before= new ListNode(sum/10);\\n    \\t\\tbefore.next= res;\\n    \\t\\t//Updating the pointer for next iteration\\n    \\t\\tres=before;\\n    \\t\\tsum /= 10;\\t//sum=1 if carry is there, 0 if not there\\n    \\t}\\n    \\treturn res.val==0 ? res.next:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395500,
                "title": "simple-java-recursion-beats-99-8",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int c = 0;\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) \\n    {\\n        if(l1 == null && l2 == null)\\n            return null;\\n        if(l1 == null)\\n            return l2;\\n        if(l2 == null)\\n            return l1;\\n        int len1 = 0;\\n        ListNode curr = l1;\\n        while(curr != null)\\n        {\\n            curr = curr.next;\\n            len1++;\\n        }\\n        int len2 = 0;\\n        curr = l2;\\n        while(curr != null)\\n        {\\n            curr = curr.next;\\n            len2++;\\n        }\\n        ListNode next = helper(len1, len2, l1, l2);\\n        if(c == 0)\\n            return next;\\n        else\\n        {\\n            ListNode start = new ListNode(c);\\n            start.next = next;\\n            return start;\\n        }\\n    }\\n    private ListNode helper(int remain1, int remain2, ListNode l1, ListNode l2)\\n    {\\n        if(l1 == null && l2 == null)\\n            return null;\\n        if(remain1 > remain2)\\n        {\\n            ListNode next = helper(remain1-1, remain2, l1.next, l2);\\n            int sum = l1.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n        else if(remain1 < remain2)\\n        {\\n            ListNode next = helper(remain1, remain2-1, l1, l2.next);\\n            int sum = l2.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n        else\\n        {\\n            ListNode next = helper(remain1-1, remain2-1, l1.next, l2.next);\\n            int sum = l1.val + l2.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int c = 0;\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) \\n    {\\n        if(l1 == null && l2 == null)\\n            return null;\\n        if(l1 == null)\\n            return l2;\\n        if(l2 == null)\\n            return l1;\\n        int len1 = 0;\\n        ListNode curr = l1;\\n        while(curr != null)\\n        {\\n            curr = curr.next;\\n            len1++;\\n        }\\n        int len2 = 0;\\n        curr = l2;\\n        while(curr != null)\\n        {\\n            curr = curr.next;\\n            len2++;\\n        }\\n        ListNode next = helper(len1, len2, l1, l2);\\n        if(c == 0)\\n            return next;\\n        else\\n        {\\n            ListNode start = new ListNode(c);\\n            start.next = next;\\n            return start;\\n        }\\n    }\\n    private ListNode helper(int remain1, int remain2, ListNode l1, ListNode l2)\\n    {\\n        if(l1 == null && l2 == null)\\n            return null;\\n        if(remain1 > remain2)\\n        {\\n            ListNode next = helper(remain1-1, remain2, l1.next, l2);\\n            int sum = l1.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n        else if(remain1 < remain2)\\n        {\\n            ListNode next = helper(remain1, remain2-1, l1, l2.next);\\n            int sum = l2.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n        else\\n        {\\n            ListNode next = helper(remain1-1, remain2-1, l1.next, l2.next);\\n            int sum = l1.val + l2.val + c;\\n            ListNode node = new ListNode(sum % 10);\\n            c = sum / 10;\\n            node.next = next;\\n            return node;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378243,
                "title": "java-stacks-follow-up-question-explained",
                "content": "I solved the follow-up question. First we need to start from lower digit, so for that list need to be reversed. We use stack for this (separate for each list). \\nThen we start pushing element from both stacks at the same time, add them and form the current node of the resulting list. Two catches here: \\n1. we need to return the list in reversed order, similar to the input list. For that we add every \"current\" node as next to the list we already have. This way to form the result from tail. \\n2. We need to take care of carry over in case sum of digits is greater than 9. For that we keep the carry on on each step, add it to the sum and calculate new one. After both numbers are exaughsted we need to check if carry on is > 0 and add one more node for it if needed.\\n\\nO(max(len(l1), len(l2))) for time and space- ruled by max number of digits in list, we need to make this much iterations and allocate this much space in stack.\\n\\n```\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if (l1 == null && l2 == null)\\n                return null;\\n        //push numbers to stack so we can start from the lower digit\\n        Stack<ListNode> s1 = new Stack();\\n        while(l1 != null) {\\n            s1.push(l1);\\n            l1 = l1.next;\\n        }\\n        Stack<ListNode> s2 = new Stack();\\n        while(l2 != null) {\\n            s2.push(l2);\\n            l2 = l2.next;\\n        }\\n        int carry = 0;\\n        ListNode resNode = null;\\n        //start iterating on stacks until both are empty, keep the carry on part\\n        while (!s1.isEmpty() || !s2.isEmpty()) {\\n            int n1 = s1.isEmpty() ? 0 : s1.pop().val;\\n            int n2 = s2.isEmpty() ? 0 : s2.pop().val;\\n            int sum = n1 + n2 + carry;\\n            //create current sum digit, add previous node as next \\n            ListNode n = new ListNode(sum % 10);\\n            n.next = resNode;\\n            //make current node our result\\n            resNode = n;\\n            carry = sum / 10;\\n        }\\n        //take care of remainder\\n        if (carry > 0) {\\n            ListNode n = new ListNode(carry);\\n            n.next = resNode;\\n            resNode = n;\\n        }\\n        return resNode;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if (l1 == null && l2 == null)\\n                return null;\\n        //push numbers to stack so we can start from the lower digit\\n        Stack<ListNode> s1 = new Stack();\\n        while(l1 != null) {\\n            s1.push(l1);\\n            l1 = l1.next;\\n        }\\n        Stack<ListNode> s2 = new Stack();\\n        while(l2 != null) {\\n            s2.push(l2);\\n            l2 = l2.next;\\n        }\\n        int carry = 0;\\n        ListNode resNode = null;\\n        //start iterating on stacks until both are empty, keep the carry on part\\n        while (!s1.isEmpty() || !s2.isEmpty()) {\\n            int n1 = s1.isEmpty() ? 0 : s1.pop().val;\\n            int n2 = s2.isEmpty() ? 0 : s2.pop().val;\\n            int sum = n1 + n2 + carry;\\n            //create current sum digit, add previous node as next \\n            ListNode n = new ListNode(sum % 10);\\n            n.next = resNode;\\n            //make current node our result\\n            resNode = n;\\n            carry = sum / 10;\\n        }\\n        //take care of remainder\\n        if (carry > 0) {\\n            ListNode n = new ListNode(carry);\\n            n.next = resNode;\\n            resNode = n;\\n        }\\n        return resNode;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189893,
                "title": "javascript-explained-o-1-space-no-stack-no-reverse",
                "content": "IMO having a stack is defeating the purpose of having the numbers as a linked list (you would have a dequeue instead). Reversing any of the input lists or output is forbidden by the statement.\\n\\nMy strategy here is to **add numbers up** with their corresponding position:\\n\\n`7 -> 2 -> 4 -> 3 ` + `5 -> 6 -> 4` = `7 -> 7 -> 10 -> 7`\\n\\nThen **iterate through the list over and over until the numbers are <= 9**, just keeping the previous node in memory (`O(1)` space). Time wise this is at most `O(max(N + M))`\\n\\n`7 -> 7 -> 10 -> 7` = `7 -> (7 + 1) -> (10 % 10) -> 7`\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} number1\\n * @param {ListNode} number2\\n * @return {ListNode}\\n */\\nfunction addTwoNumbers(number1, number2) {\\n    const number3 = new ListNode();\\n    const length1 = listLength(number1);\\n    const length2 = listLength(number2);\\n    const maxLength = Math.max(length1, length2);\\n    \\n    let headNumber1 = number1;\\n    let headNumber2 = number2;\\n    let headNumber3 = number3;\\n    for (let i = 0; i < maxLength; i += 1) {\\n        const takeNumber1 = i >= maxLength - length1;\\n        const takeNumber2 = i >= maxLength - length2;\\n        const value1 = takeNumber1 ? headNumber1.val : 0;\\n        const value2 = takeNumber2 ? headNumber2.val : 0;\\n        const node = new ListNode(value1 + value2);\\n        headNumber3.next = node;\\n        if (takeNumber1) {\\n            headNumber1 = headNumber1.next;\\n        }\\n        if (takeNumber2) {\\n            headNumber2 = headNumber2.next;\\n        }\\n        headNumber3 = headNumber3.next;\\n    }\\n    \\n    let dummyNode = false;\\n    let numberOver10 = true;\\n    while (numberOver10) {\\n        numberOver10 = false;\\n        let previousNode = null;\\n        let node = number3.next;\\n        while (node) {\\n            if (node.val > 9) {\\n                numberOver10 = true;\\n                if (!previousNode) {\\n                    dummyNode = true;\\n                    previousNode = number3;\\n                    number3.val = 0;\\n                }\\n                previousNode.val += 1;\\n                node.val %= 10;\\n            }\\n            previousNode = node;\\n            node = node.next;\\n        }\\n    }\\n    return dummyNode ? number3 : number3.next;\\n};\\n\\nfunction listLength(list) {\\n    let length = 0;\\n    while (list) {\\n        length += 1;\\n        list = list.next;\\n    }\\n    return length;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} number1\\n * @param {ListNode} number2\\n * @return {ListNode}\\n */\\nfunction addTwoNumbers(number1, number2) {\\n    const number3 = new ListNode();\\n    const length1 = listLength(number1);\\n    const length2 = listLength(number2);\\n    const maxLength = Math.max(length1, length2);\\n    \\n    let headNumber1 = number1;\\n    let headNumber2 = number2;\\n    let headNumber3 = number3;\\n    for (let i = 0; i < maxLength; i += 1) {\\n        const takeNumber1 = i >= maxLength - length1;\\n        const takeNumber2 = i >= maxLength - length2;\\n        const value1 = takeNumber1 ? headNumber1.val : 0;\\n        const value2 = takeNumber2 ? headNumber2.val : 0;\\n        const node = new ListNode(value1 + value2);\\n        headNumber3.next = node;\\n        if (takeNumber1) {\\n            headNumber1 = headNumber1.next;\\n        }\\n        if (takeNumber2) {\\n            headNumber2 = headNumber2.next;\\n        }\\n        headNumber3 = headNumber3.next;\\n    }\\n    \\n    let dummyNode = false;\\n    let numberOver10 = true;\\n    while (numberOver10) {\\n        numberOver10 = false;\\n        let previousNode = null;\\n        let node = number3.next;\\n        while (node) {\\n            if (node.val > 9) {\\n                numberOver10 = true;\\n                if (!previousNode) {\\n                    dummyNode = true;\\n                    previousNode = number3;\\n                    number3.val = 0;\\n                }\\n                previousNode.val += 1;\\n                node.val %= 10;\\n            }\\n            previousNode = node;\\n            node = node.next;\\n        }\\n    }\\n    return dummyNode ? number3 : number3.next;\\n};\\n\\nfunction listLength(list) {\\n    let length = 0;\\n    while (list) {\\n        length += 1;\\n        list = list.next;\\n    }\\n    return length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112021,
                "title": "python-ac-138-ms-reverse-ll",
                "content": "```\\nclass Solution(object):\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        l1 = self.reverseLL(l1)\\n        l2 = self.reverseLL(l2)\\n        car = 0\\n        sen = ListNode(0)\\n        cur = sen\\n        while l1 or l2 or car:\\n            if l1 and l2:\\n                tot = l1.val + l2.val + car\\n                l1, l2 = l1.next, l2.next\\n            elif l1:\\n                tot = l1.val + car\\n                l1 = l1.next\\n            elif l2:\\n                tot = l2.val + car\\n                l2 = l2.next\\n            else:\\n                tot = car\\n            cur.next, car = ListNode(tot%10), tot//10\\n            cur = cur.next\\n            \\n        return self.reverseLL(sen.next)\\n            \\n        \\n    def reverseLL(self, head):\\n        prev, cur = None, head\\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        return prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        l1 = self.reverseLL(l1)\\n        l2 = self.reverseLL(l2)\\n        car = 0\\n        sen = ListNode(0)\\n        cur = sen\\n        while l1 or l2 or car:\\n            if l1 and l2:\\n                tot = l1.val + l2.val + car\\n                l1, l2 = l1.next, l2.next\\n            elif l1:\\n                tot = l1.val + car\\n                l1 = l1.next\\n            elif l2:\\n                tot = l2.val + car\\n                l2 = l2.next\\n            else:\\n                tot = car\\n            cur.next, car = ListNode(tot%10), tot//10\\n            cur = cur.next\\n            \\n        return self.reverseLL(sen.next)\\n            \\n        \\n    def reverseLL(self, head):\\n        prev, cur = None, head\\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776855,
                "title": "add-two-numbers-in-linked-list-recursion-java",
                "content": "Hi,\\n\\nI came up with a recursive logic to find the solution.\\n\\n**Intution:** Considering that the last digit must be added first to determine the carry (whether it\\'s 0 or 1) and the linked list is in reverse order, it\\'s advisable to calculate the length of both linked lists and ensure that the first one is larger. This approach will make it easier to follow the remaining logic.\\n\\n**Logic:** Having determined the lengths of both nodes and ensured that the first node is larger than the second, we can focus solely on the carry while adding the elements. Create a method to return the carry resulting from the addition of the two elements. Once the sizes are equal, sum the values of the first node, second node, and the carry.\\n\\nPlease do upvote if you find it helpful. Happy learning! Let\\'s look into the code.\\n\\n```\\n   public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getSize(l1);\\n        int size2 = getSize(l2);\\n        if(size2>size1){\\n            ListNode tmp = l1;\\n            l1 = l2;\\n            l2 = tmp;\\n\\n            int t = size1;\\n            size1 = size2;\\n            size2 = t;\\n        }\\n        int carry = logic(l1, l2, size1, size2, 0);\\n        if(carry!=0)\\n            return new ListNode(carry, l1);\\n        return l1;\\n    }\\n\\n    private int logic(ListNode l1, ListNode l2, int size1, int size2, int idx1) {\\n        if(l1==null || l2==null)\\n            return 0;\\n        if(size1-idx1>size2){\\n            int carry = logic(l1.next, l2, size1, size2, idx1+1);\\n            int sum = l1.val+carry;\\n            l1.val = sum%10;\\n            return sum/10;\\n        } else{\\n            int carry = logic(l1.next, l2.next, size1, size2, idx1+1);\\n            int sum = l1.val+l2.val+carry;\\n            l1.val = sum%10;\\n            return sum/10;\\n        }\\n    }\\n\\n    private int getSize(ListNode l1) {\\n        int len=0;\\n        while(l1.next!=null){\\n            len++;\\n            l1=l1.next;\\n        }\\n        return len;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Hi,\\n\\nI came up with a recursive logic to find the solution.\\n\\n**Intution:** Considering that the last digit must be added first to determine the carry (whether it\\'s 0 or 1) and the linked list is in reverse order, it\\'s advisable to calculate the length of both linked lists and ensure that the first one is larger. This approach will make it easier to follow the remaining logic.\\n\\n**Logic:** Having determined the lengths of both nodes and ensured that the first node is larger than the second, we can focus solely on the carry while adding the elements. Create a method to return the carry resulting from the addition of the two elements. Once the sizes are equal, sum the values of the first node, second node, and the carry.\\n\\nPlease do upvote if you find it helpful. Happy learning! Let\\'s look into the code.\\n\\n```\\n   public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getSize(l1);\\n        int size2 = getSize(l2);\\n        if(size2>size1){\\n            ListNode tmp = l1;\\n            l1 = l2;\\n            l2 = tmp;\\n\\n            int t = size1;\\n            size1 = size2;\\n            size2 = t;\\n        }\\n        int carry = logic(l1, l2, size1, size2, 0);\\n        if(carry!=0)\\n            return new ListNode(carry, l1);\\n        return l1;\\n    }\\n\\n    private int logic(ListNode l1, ListNode l2, int size1, int size2, int idx1) {\\n        if(l1==null || l2==null)\\n            return 0;\\n        if(size1-idx1>size2){\\n            int carry = logic(l1.next, l2, size1, size2, idx1+1);\\n            int sum = l1.val+carry;\\n            l1.val = sum%10;\\n            return sum/10;\\n        } else{\\n            int carry = logic(l1.next, l2.next, size1, size2, idx1+1);\\n            int sum = l1.val+l2.val+carry;\\n            l1.val = sum%10;\\n            return sum/10;\\n        }\\n    }\\n\\n    private int getSize(ListNode l1) {\\n        int len=0;\\n        while(l1.next!=null){\\n            len++;\\n            l1=l1.next;\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3776124,
                "title": "easy-to-understand-c-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- It is similar to Add Numbers I but here we have reverse the linked lists and do Add Numbers I.\\n- In the end we return it after reversing.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Reverse both input linked lists.\\n- Iterate through the reversed lists, adding corresponding digits while tracking carry values.\\n- Handle any remaining digits and the final carry separately.\\n- Reverse the resulting linked list to restore the correct order of digits.\\n- Return the reversed linked list as the sum.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n# Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n     ListNode* reverse(ListNode* head){\\n        ListNode* prev = nullptr;\\n        while(head){\\n            ListNode* next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\n        int c = 0;\\n        ListNode* ans = new ListNode(), *tail = ans;\\n\\n        while(l1 || l2 || c){\\n            int sum = c;\\n            if(l1) sum += l1->val, l1 = l1->next;\\n            if(l2) sum += l2->val, l2 = l2->next;\\n            c = sum / 10;\\n            tail->next = new ListNode(sum%10);\\n            tail = tail->next; \\n        }\\n        ans = reverse(ans->next);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n     ListNode* reverse(ListNode* head){\\n        ListNode* prev = nullptr;\\n        while(head){\\n            ListNode* next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\n        int c = 0;\\n        ListNode* ans = new ListNode(), *tail = ans;\\n\\n        while(l1 || l2 || c){\\n            int sum = c;\\n            if(l1) sum += l1->val, l1 = l1->next;\\n            if(l2) sum += l2->val, l2 = l2->next;\\n            c = sum / 10;\\n            tail->next = new ListNode(sum%10);\\n            tail = tail->next; \\n        }\\n        ans = reverse(ans->next);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126335,
                "title": "c-81-faster-memory-uses-is-less-than-96-simple-without-any-extra-list",
                "content": "```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1=reverse(l1);\\n        int n2= reverse(l2);\\n        ListNode* temp1=l1;\\n        ListNode* temp2=l2;\\n        int q=0;\\n        if(n1>n2){\\n             while(temp2){\\n                 int k= (temp1->val+temp2->val+q);\\n                  temp1->val = (k)%10;\\n                 q= (k)/10;\\n                 temp1=temp1->next;\\n                 temp2=temp2->next;\\n             }\\n            while(temp1 && q!=0){\\n                int k=temp1->val+q;\\n                temp1->val=(k)%10;\\n                q=(k)/10;\\n                temp1=temp1->next;\\n            }\\n            // int reverse(l1)\\n           \\n            int k =reverse(l1);\\n            if(q!=0){\\n                ListNode *ptr= new ListNode(1);\\n                ptr->next = l1;\\n                l1=ptr;;\\n            }\\n            return l1;\\n        }\\n        else{\\n            while(temp1){\\n                 int k= (temp1->val+temp2->val+q);\\n                  temp2->val = (k)%10;\\n                 q= (k)/10;\\n                 temp1=temp1->next;\\n                 temp2=temp2->next;\\n             }\\n            while(temp2 && q!=0){\\n                int k=temp2->val+q;\\n                temp2->val=(k)%10;\\n                q=k/10;\\n                \\n               temp2=temp2->next;\\n                \\n            }\\n            // int reverse(l1)\\n            \\n            int k =reverse(l2);\\n            if(q!=0){\\n                ListNode *ptr= new ListNode(1);\\n                ptr->next = l2;\\n                l2=ptr;;\\n            }\\n            return l2;\\n        }\\n       \\n    }\\n    int reverse(ListNode *&head)\\n    {\\n        int count=0;\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != NULL) {\\n            count++;\\n            next = current->next;\\n            \\n            current->next = prev;\\n            \\n            prev = current;\\n            current = next;\\n        }\\n        head = prev;\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1=reverse(l1);\\n        int n2= reverse(l2);\\n        ListNode* temp1=l1;\\n        ListNode* temp2=l2;\\n        int q=0;\\n        if(n1>n2){\\n             while(temp2){\\n                 int k= (temp1->val+temp2->val+q);\\n                  temp1->val = (k)%10;\\n                 q= (k)/10;\\n                 temp1=temp1->next;\\n                 temp2=temp2->next;\\n             }\\n            while(temp1 && q!=0){\\n                int k=temp1->val+q;\\n                temp1->val=(k)%10;\\n                q=(k)/10;\\n                temp1=temp1->next;\\n            }\\n            // int reverse(l1)\\n           \\n            int k =reverse(l1);\\n            if(q!=0){\\n                ListNode *ptr= new ListNode(1);\\n                ptr->next = l1;\\n                l1=ptr;;\\n            }\\n            return l1;\\n        }\\n        else{\\n            while(temp1){\\n                 int k= (temp1->val+temp2->val+q);\\n                  temp2->val = (k)%10;\\n                 q= (k)/10;\\n                 temp1=temp1->next;\\n                 temp2=temp2->next;\\n             }\\n            while(temp2 && q!=0){\\n                int k=temp2->val+q;\\n                temp2->val=(k)%10;\\n                q=k/10;\\n                \\n               temp2=temp2->next;\\n                \\n            }\\n            // int reverse(l1)\\n            \\n            int k =reverse(l2);\\n            if(q!=0){\\n                ListNode *ptr= new ListNode(1);\\n                ptr->next = l2;\\n                l2=ptr;;\\n            }\\n            return l2;\\n        }\\n       \\n    }\\n    int reverse(ListNode *&head)\\n    {\\n        int count=0;\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != NULL) {\\n            count++;\\n            next = current->next;\\n            \\n            current->next = prev;\\n            \\n            prev = current;\\n            current = next;\\n        }\\n        head = prev;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1013830,
                "title": "c-efficient-o-1-extra-space-o-n-time-complexity",
                "content": "The idea is the following:\\n1. Create the reversed output list by taking the sum of the respective digits of the `l1`, `l2`.\\n2. Reverse the output and update the stored pair sums to be digits.\\n\\n1) Firstly, we find the greater in length list, store the length difference in `diff`.\\nThis means we have diff digits in list `l1` without respective digits in `l2`, which need to be treated separately.\\n2) After that, we construct the reversed list of the sum of two, meaning the least significant digit is at the beginning.\\nIf `diff` is zero, we add `l1->val + l2->val` to the Node - otherwise, we store `l1->val` only and update the `diff`.\\n3) Finally, we reverse the output list and calculate the remainder of the fly.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int diff = 0;\\n        //find longer between two lists\\n        for (ListNode* cur = l1; cur; ++diff, cur = cur->next);\\n        for (ListNode* cur = l2; cur; --diff, cur = cur->next);\\n        \\n        //l1 must be longer - if not, swap\\n        if (diff < 0) {\\n            swap(l1, l2);\\n            diff = -diff;\\n        }\\n        \\n        //create output list with reversed digits, store full sum first\\n        //this means digits can be [0-18]\\n        ListNode *res = nullptr;\\n        while(l1) {\\n            int val = l1->val;\\n            if (!diff)\\n                val += l2->val, l2 = l2->next;\\n            else\\n                --diff;\\n            res = new ListNode(val, res);\\n            l1 = l1->next;\\n        }\\n        \\n        //reverse the output with taking remainder into account\\n        //after this digits are [0-9]\\n        int ost = 0;\\n        ListNode *reversed = nullptr;\\n        while (res) {\\n            ListNode *next = res->next;\\n            res->val += ost;\\n            res->next = reversed;\\n        \\n            if (res->val > 9)\\n                res->val -= 10, ost = 1;\\n            else\\n                ost = 0;\\n            reversed = res, res = next;\\n        }\\n        \\n        if (ost) reversed = new ListNode(ost, reversed);\\n        return reversed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int diff = 0;\\n        //find longer between two lists\\n        for (ListNode* cur = l1; cur; ++diff, cur = cur->next);\\n        for (ListNode* cur = l2; cur; --diff, cur = cur->next);\\n        \\n        //l1 must be longer - if not, swap\\n        if (diff < 0) {\\n            swap(l1, l2);\\n            diff = -diff;\\n        }\\n        \\n        //create output list with reversed digits, store full sum first\\n        //this means digits can be [0-18]\\n        ListNode *res = nullptr;\\n        while(l1) {\\n            int val = l1->val;\\n            if (!diff)\\n                val += l2->val, l2 = l2->next;\\n            else\\n                --diff;\\n            res = new ListNode(val, res);\\n            l1 = l1->next;\\n        }\\n        \\n        //reverse the output with taking remainder into account\\n        //after this digits are [0-9]\\n        int ost = 0;\\n        ListNode *reversed = nullptr;\\n        while (res) {\\n            ListNode *next = res->next;\\n            res->val += ost;\\n            res->next = reversed;\\n        \\n            if (res->val > 9)\\n                res->val -= 10, ost = 1;\\n            else\\n                ost = 0;\\n            reversed = res, res = next;\\n        }\\n        \\n        if (ost) reversed = new ListNode(ost, reversed);\\n        return reversed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299779,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack(), s2 = new Stack();\\n        \\n        while (l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n        \\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int sum = 0;\\n        ListNode head = new ListNode(0);\\n        while (!s1.isEmpty() || !s2.isEmpty() || sum != 0) {\\n            if (!s1.isEmpty()) sum += s1.pop();\\n            if (!s2.isEmpty()) sum += s2.pop();\\n            \\n            ListNode node = new ListNode(sum % 10);\\n            node.next = head.next;\\n            head.next = node;\\n            sum /= 10;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack(), s2 = new Stack();\\n        \\n        while (l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        }\\n        \\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int sum = 0;\\n        ListNode head = new ListNode(0);\\n        while (!s1.isEmpty() || !s2.isEmpty() || sum != 0) {\\n            if (!s1.isEmpty()) sum += s1.pop();\\n            if (!s2.isEmpty()) sum += s2.pop();\\n            \\n            ListNode node = new ListNode(sum % 10);\\n            node.next = head.next;\\n            head.next = node;\\n            sum /= 10;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275729,
                "title": "o-n-java-solution-beats-100-submissions-recursive-solution",
                "content": "We can get rid of maintaining the offset just by padding the shorter list with zeros. Now both the lists are same length.\\nl1 = 7 -> 5- >4 ->3 ->1\\nl2 = 0-> 0-> 6 -> 7 -> 2\\nThen you can do recursive call to manage the sum and carry.\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if(l1 == null && l2 ==null) \\n            return null;\\n        \\n        int length1 = getLength(l1);\\n        int length2 = getLength(l2);\\n        \\n         if(length1 > length2) {\\n             l2= addZeros(l2,length1-length2);\\n         }else{\\n             l1 = addZeros(l1,length2-length1);\\n         }\\n        \\n        ListNode res = helper(l1,l2);\\n        if(res.val >9){\\n            ListNode node = new ListNode(1);\\n            res.val = res.val % 10;\\n            node.next = res;\\n            res = node;\\n        }\\n        return res;\\n    }\\n    \\n    public ListNode helper(ListNode l1, ListNode l2){\\n        if(l1 == null && l2 == null) return null;\\n        ListNode result = new ListNode(0);\\n        \\n        result.val = l1.val + l2.val;\\n        ListNode post = helper(l1.next,l2.next);\\n        \\n        if(post!= null && post.val > 9){\\n            result.val = result.val + 1;\\n            post.val = post.val % 10;\\n        }\\n        \\n        result.next = post;\\n        return result;\\n        \\n    }\\n    \\n    public int getLength(ListNode node){\\n        int count = 0;\\n        while(node != null){\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }\\n    \\n    public ListNode addZeros(ListNode node, int n){\\n        while(n>0){\\n            ListNode head = new ListNode(0);\\n            head.next = node;\\n            node = head;\\n            n--;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if(l1 == null && l2 ==null) \\n            return null;\\n        \\n        int length1 = getLength(l1);\\n        int length2 = getLength(l2);\\n        \\n         if(length1 > length2) {\\n             l2= addZeros(l2,length1-length2);\\n         }else{\\n             l1 = addZeros(l1,length2-length1);\\n         }\\n        \\n        ListNode res = helper(l1,l2);\\n        if(res.val >9){\\n            ListNode node = new ListNode(1);\\n            res.val = res.val % 10;\\n            node.next = res;\\n            res = node;\\n        }\\n        return res;\\n    }\\n    \\n    public ListNode helper(ListNode l1, ListNode l2){\\n        if(l1 == null && l2 == null) return null;\\n        ListNode result = new ListNode(0);\\n        \\n        result.val = l1.val + l2.val;\\n        ListNode post = helper(l1.next,l2.next);\\n        \\n        if(post!= null && post.val > 9){\\n            result.val = result.val + 1;\\n            post.val = post.val % 10;\\n        }\\n        \\n        result.next = post;\\n        return result;\\n        \\n    }\\n    \\n    public int getLength(ListNode node){\\n        int count = 0;\\n        while(node != null){\\n            count++;\\n            node = node.next;\\n        }\\n        return count;\\n    }\\n    \\n    public ListNode addZeros(ListNode node, int n){\\n        while(n>0){\\n            ListNode head = new ListNode(0);\\n            head.next = node;\\n            node = head;\\n            n--;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778001,
                "title": "simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  public:\\n    ListNode* rev(ListNode* h) {\\n        ListNode* cur = h;\\n        ListNode* prev = NULL;\\n        while(cur) {\\n            ListNode* n = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = n;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* rev_list1 = rev(l1);\\n        ListNode* rev_list2 = rev(l2);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* tmp = dummy;\\n        int sum=0, rem=0;\\n\\n        while(true) {\\n            sum = 0;\\n            sum += rem;\\n            if (rev_list1) {\\n              sum += rev_list1->val; \\n              rev_list1 = rev_list1->next;\\n            }\\n            if (rev_list2) {\\n              sum += rev_list2->val; \\n              rev_list2 = rev_list2->next;\\n            }\\n            rem = sum/10;\\n            sum = sum%10;\\n            tmp->next = new ListNode(sum);\\n            tmp = tmp->next;\\n            \\n            if(!rev_list1 && !rev_list2 && (rem == 0)) break;\\n        }\\n        return rev(dummy->next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    ListNode* rev(ListNode* h) {\\n        ListNode* cur = h;\\n        ListNode* prev = NULL;\\n        while(cur) {\\n            ListNode* n = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = n;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* rev_list1 = rev(l1);\\n        ListNode* rev_list2 = rev(l2);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* tmp = dummy;\\n        int sum=0, rem=0;\\n\\n        while(true) {\\n            sum = 0;\\n            sum += rem;\\n            if (rev_list1) {\\n              sum += rev_list1->val; \\n              rev_list1 = rev_list1->next;\\n            }\\n            if (rev_list2) {\\n              sum += rev_list2->val; \\n              rev_list2 = rev_list2->next;\\n            }\\n            rem = sum/10;\\n            sum = sum%10;\\n            tmp->next = new ListNode(sum);\\n            tmp = tmp->next;\\n            \\n            if(!rev_list1 && !rev_list2 && (rem == 0)) break;\\n        }\\n        return rev(dummy->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777689,
                "title": "easy-python-and-java-solution-with-explanation-beats-99",
                "content": "# Approach 1 => Using Stack\\n- Create 2 stacks `s1` and `s2` for both the numbers and append the numbers in the respective stacks.\\n- After that create a variable named `carry` which will take care of our carry values and one more variable as `root` which will be assigned to none so that we can return head of the list at the end.\\n- Now use while loop and add values from both the stacks along with carry and append the `value` as a new node in our `ans` linked list.\\n- At the end return `root`.\\n\\n#  Approach 1 Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        s1, s2 =[], []\\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        root = None\\n        carry = 0\\n        while s1 or s2 or carry:\\n            v1,v2 = 0,0\\n            if s1:\\n                v1 = s1.pop()\\n            if s2:\\n                v2 = s2.pop()\\n            carry, value = divmod(v1+v2+carry, 10)\\n            ans = ListNode(value)\\n            ans.next = root\\n            root = ans\\n        return root\\n        \\n```\\n```java []\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack<Integer>();\\n        Stack<Integer> s2 = new Stack<Integer>();\\n        \\n        while(l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        };\\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int totalSum = 0, carry = 0;\\n        ListNode ans = new ListNode();\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) totalSum += s1.pop();\\n            if (!s2.empty()) totalSum += s2.pop();\\n            \\n            ans.val = totalSum % 10;\\n            carry = totalSum / 10;\\n            ListNode head = new ListNode(carry);\\n            head.next = ans;\\n            ans = head;\\n            totalSum = carry;\\n        }\\n\\n        return carry == 0 ? ans.next: ans;\\n    }\\n}\\n```\\n# Approach 2 => Reverse given linked list\\n- Reverse both the linked list\\n- After that create a variable named `carry` which will take care of our carry values and one more variable as `root` which will be assigned to none so that we can return head of the list at the end.\\n- Now use while loop and add values from both the linked list along with carry and append the `value` as a new node in our `ans` linked list.\\n- At the end return `root`.\\n\\n# Approach 2 Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverse(self, head: Optional[ListNode]) -> Optional[ListNode] :\\n            prev = None\\n            temp = None\\n            while head:\\n                temp = head.next\\n                head.next = prev\\n                prev = head\\n                head = temp\\n            return prev\\n\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        rl1 = self.reverse(l1)\\n        rl2 = self.reverse(l2)\\n        root = None\\n        carry = 0\\n        while rl1 or rl2 or carry:\\n            v1,v2 = 0,0\\n            if rl1:\\n                v1 = rl1.val\\n                rl1 = rl1.next\\n            if rl2:\\n                v2 = rl2.val\\n                rl2 = rl2.next\\n            carry, value = divmod(v1+v2+carry, 10)\\n            ans = ListNode(value)\\n            ans.next = root\\n            root = ans\\n        return root\\n        \\n\\n```\\n```java []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        temp = None\\n        while head:\\n            # Keep the next node\\n            temp = head.next\\n            # Reverse the link\\n            head.next = prev\\n            # Update the previous node and the current node.\\n            prev = head\\n            head = temp\\n        return prev\\n\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        r1 = self.reverseList(l1)\\n        r2 = self.reverseList(l2)\\n\\n        total_sum = 0\\n        carry = 0\\n        ans = ListNode()\\n        while r1 or r2:\\n            if r1:\\n                total_sum += r1.val\\n                r1 = r1.next\\n            if r2:\\n                total_sum += r2.val\\n                r2 = r2.next\\n\\n            ans.val = total_sum % 10\\n            carry = total_sum // 10\\n            head = ListNode(carry)\\n            head.next = ans\\n            ans = head\\n            total_sum = carry\\n\\n        return ans.next if carry == 0 else ans\\n```\\n# Video Explanation\\nhttps://youtu.be/JX6NNkaUfQM\\n\\n# Complexity (For both approaches)\\nwhere `m` is length of `l1` and `n` is length of `l2`\\n- Time complexity:\\nO(m+n)\\n\\n- Space complexity:\\nO(m+n)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        s1, s2 =[], []\\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        root = None\\n        carry = 0\\n        while s1 or s2 or carry:\\n            v1,v2 = 0,0\\n            if s1:\\n                v1 = s1.pop()\\n            if s2:\\n                v2 = s2.pop()\\n            carry, value = divmod(v1+v2+carry, 10)\\n            ans = ListNode(value)\\n            ans.next = root\\n            root = ans\\n        return root\\n        \\n```\n```java []\\npublic class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> s1 = new Stack<Integer>();\\n        Stack<Integer> s2 = new Stack<Integer>();\\n        \\n        while(l1 != null) {\\n            s1.push(l1.val);\\n            l1 = l1.next;\\n        };\\n        while(l2 != null) {\\n            s2.push(l2.val);\\n            l2 = l2.next;\\n        }\\n        \\n        int totalSum = 0, carry = 0;\\n        ListNode ans = new ListNode();\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) totalSum += s1.pop();\\n            if (!s2.empty()) totalSum += s2.pop();\\n            \\n            ans.val = totalSum % 10;\\n            carry = totalSum / 10;\\n            ListNode head = new ListNode(carry);\\n            head.next = ans;\\n            ans = head;\\n            totalSum = carry;\\n        }\\n\\n        return carry == 0 ? ans.next: ans;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverse(self, head: Optional[ListNode]) -> Optional[ListNode] :\\n            prev = None\\n            temp = None\\n            while head:\\n                temp = head.next\\n                head.next = prev\\n                prev = head\\n                head = temp\\n            return prev\\n\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        rl1 = self.reverse(l1)\\n        rl2 = self.reverse(l2)\\n        root = None\\n        carry = 0\\n        while rl1 or rl2 or carry:\\n            v1,v2 = 0,0\\n            if rl1:\\n                v1 = rl1.val\\n                rl1 = rl1.next\\n            if rl2:\\n                v2 = rl2.val\\n                rl2 = rl2.next\\n            carry, value = divmod(v1+v2+carry, 10)\\n            ans = ListNode(value)\\n            ans.next = root\\n            root = ans\\n        return root\\n        \\n\\n```\n```java []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev = None\\n        temp = None\\n        while head:\\n            # Keep the next node\\n            temp = head.next\\n            # Reverse the link\\n            head.next = prev\\n            # Update the previous node and the current node.\\n            prev = head\\n            head = temp\\n        return prev\\n\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        r1 = self.reverseList(l1)\\n        r2 = self.reverseList(l2)\\n\\n        total_sum = 0\\n        carry = 0\\n        ans = ListNode()\\n        while r1 or r2:\\n            if r1:\\n                total_sum += r1.val\\n                r1 = r1.next\\n            if r2:\\n                total_sum += r2.val\\n                r2 = r2.next\\n\\n            ans.val = total_sum % 10\\n            carry = total_sum // 10\\n            head = ListNode(carry)\\n            head.next = ans\\n            ans = head\\n            total_sum = carry\\n\\n        return ans.next if carry == 0 else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776631,
                "title": "java-simple-2-approaches-fast-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 1 -> Reversing the Linked Lists\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n        ListNode node = new ListNode();\\n        int sum=0;\\n        int carry = 0;\\n        while(l1!=null || l2!=null){\\n            if(l1!=null) sum+=l1.val;\\n            if(l2!=null) sum+=l2.val;\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            l1 = l1!=null? l1.next : null;\\n            l2 = l2!=null? l2.next : null;\\n        }\\n        return carry==0? node.next:node;\\n    }\\n    private ListNode reverse(ListNode head){\\n        if(head==null || head.next==null) return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode next = null;\\n        while(cur!=null){\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n}\\n```\\n\\n# Using WrapperClass for Void Function\\n\\nIt is not possible to reverse a linked list in place using a void function in Java because Java passes arguments by value, not by reference. This means that when you pass the head of the linked list to the reverse method, a copy of the reference to the head node is created and passed to the method. Any changes made to this reference within the method will not be reflected outside of the method.\\n\\nOne way to work around this limitation is to use a wrapper class that holds a reference to the head of the linked list. You can pass an instance of this wrapper class to the reverse method and update the reference to the head node within the method.\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNodeWrapper w1 = new ListNodeWrapper(l1);\\n        ListNodeWrapper w2 = new ListNodeWrapper(l2);\\n        reverse(w1);\\n        reverse(w2);\\n        l1 = w1.head;\\n        l2 = w2.head;\\n        ListNode node = new ListNode();\\n        int sum=0;\\n        int carry = 0;\\n        while(l1!=null || l2!=null){\\n            if(l1!=null) sum+=l1.val;\\n            if(l2!=null) sum+=l2.val;\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            l1 = l1!=null? l1.next : null;\\n            l2 = l2!=null? l2.next : null;\\n        }\\n        return carry==0? node.next:node;\\n    }\\n\\n    private void reverse(ListNodeWrapper wrapper){\\n        if(wrapper.head==null || wrapper.head.next==null) return;\\n        ListNode prev = null;\\n        ListNode cur = wrapper.head;\\n        ListNode next = null;\\n        while(cur!=null){\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        wrapper.head = prev;\\n    }\\n}\\n\\nclass ListNodeWrapper {\\n    ListNode head;\\n\\n    public ListNodeWrapper(ListNode head) {\\n        this.head = head;\\n    }\\n}\\n\\n```\\n\\n# Approch 2 -> Using Stacks\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> st1 = new Stack<>();\\n        Stack<Integer> st2 = new Stack<>();\\n        ListNode node = new ListNode();\\n        int sum = 0;\\n        int carry = 0;\\n        while(l1!=null){\\n            st1.push(l1.val);\\n            l1=l1.next;\\n        }\\n        while(l2!=null){\\n            st2.push(l2.val);\\n            l2=l2.next;\\n        }\\n        while(!st1.empty() || !st2.empty()){\\n            if(!st1.empty()) sum+=st1.pop();\\n            if(!st2.empty()) sum+=st2.pop();\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            \\n        }\\n        return carry==0? node.next:node;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/2fe91f99-1d3b-47be-ba81-241e64c732fc_1675058149.943284.png)",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n        ListNode node = new ListNode();\\n        int sum=0;\\n        int carry = 0;\\n        while(l1!=null || l2!=null){\\n            if(l1!=null) sum+=l1.val;\\n            if(l2!=null) sum+=l2.val;\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            l1 = l1!=null? l1.next : null;\\n            l2 = l2!=null? l2.next : null;\\n        }\\n        return carry==0? node.next:node;\\n    }\\n    private ListNode reverse(ListNode head){\\n        if(head==null || head.next==null) return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        ListNode next = null;\\n        while(cur!=null){\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNodeWrapper w1 = new ListNodeWrapper(l1);\\n        ListNodeWrapper w2 = new ListNodeWrapper(l2);\\n        reverse(w1);\\n        reverse(w2);\\n        l1 = w1.head;\\n        l2 = w2.head;\\n        ListNode node = new ListNode();\\n        int sum=0;\\n        int carry = 0;\\n        while(l1!=null || l2!=null){\\n            if(l1!=null) sum+=l1.val;\\n            if(l2!=null) sum+=l2.val;\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            l1 = l1!=null? l1.next : null;\\n            l2 = l2!=null? l2.next : null;\\n        }\\n        return carry==0? node.next:node;\\n    }\\n\\n    private void reverse(ListNodeWrapper wrapper){\\n        if(wrapper.head==null || wrapper.head.next==null) return;\\n        ListNode prev = null;\\n        ListNode cur = wrapper.head;\\n        ListNode next = null;\\n        while(cur!=null){\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        wrapper.head = prev;\\n    }\\n}\\n\\nclass ListNodeWrapper {\\n    ListNode head;\\n\\n    public ListNodeWrapper(ListNode head) {\\n        this.head = head;\\n    }\\n}\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Stack<Integer> st1 = new Stack<>();\\n        Stack<Integer> st2 = new Stack<>();\\n        ListNode node = new ListNode();\\n        int sum = 0;\\n        int carry = 0;\\n        while(l1!=null){\\n            st1.push(l1.val);\\n            l1=l1.next;\\n        }\\n        while(l2!=null){\\n            st2.push(l2.val);\\n            l2=l2.next;\\n        }\\n        while(!st1.empty() || !st2.empty()){\\n            if(!st1.empty()) sum+=st1.pop();\\n            if(!st2.empty()) sum+=st2.pop();\\n            node.val = sum%10;\\n            carry = sum/10;\\n            ListNode temp = new ListNode(carry);\\n            sum = carry;\\n            temp.next = node;\\n            node = temp;\\n            \\n        }\\n        return carry==0? node.next:node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776444,
                "title": "stack-based-approach-3-stacks",
                "content": "# Intuition\\n1st way is that we can reverse both the linkedlist and then perform simple addition, and maintain a carry and then add at the end.\\n\\nBut the question mention, that we cannot reverse the linked list, so here we\\'ll be using a stack based approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSo we take 3 stacks, 1st contains all the elements of the L1 list and the 2nd stack contains all the elements of the L2 list.\\n\\nNow until any of the stack goes empty, we keeping taking out element and then perform simple addition.\\nAlso, we need to keep a track of the carry generated, so I\\'ve used a carry variable to store the carry.\\n\\nAll the sum generated should be inserted inside the ans stack.\\nonce both stack1 and stack2 goes empty, we have our summation ready in the ans stack.\\n\\nNow, we pop all the elements from the ans stack and create a new linkedlist.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1,s2, ans;\\n\\n        ListNode* head1 = l1;\\n        ListNode* head2 = l2;\\n\\n        while(head1){\\n            s1.push(head1 -> val);\\n            head1 = head1 -> next;\\n        }\\n\\n        while(head2){\\n            s2.push(head2 -> val);\\n            head2 = head2 -> next;\\n        }\\n        \\n        int carry = 0;\\n\\n        while(s1.size() || s2.size()){\\n            int ele1 = 0, ele2= 0;\\n\\n            // warning , we need to check if the stack is empty or not\\n\\n            if(!s1.empty())\\n                ele1 = s1.top(), s1.pop();\\n            if(!s2.empty())\\n                ele2 = s2.top(), s2.pop();\\n\\n            int sum = ele1 + ele2 + carry;\\n            carry = sum/10;\\n            int data = sum%10;\\n            ans.push(data);\\n        }\\n\\n// even after the stack goes empty, we need to check for any leftover carry.\\n        if(carry) ans.push(carry);\\n        ListNode* dummy = new ListNode(0), *nh = dummy;\\n\\n        while(ans.size()) {\\n            dummy -> next = new ListNode(ans.top());\\n            ans.pop();\\n            dummy = dummy -> next;\\n        }\\n\\n        return nh -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1,s2, ans;\\n\\n        ListNode* head1 = l1;\\n        ListNode* head2 = l2;\\n\\n        while(head1){\\n            s1.push(head1 -> val);\\n            head1 = head1 -> next;\\n        }\\n\\n        while(head2){\\n            s2.push(head2 -> val);\\n            head2 = head2 -> next;\\n        }\\n        \\n        int carry = 0;\\n\\n        while(s1.size() || s2.size()){\\n            int ele1 = 0, ele2= 0;\\n\\n            // warning , we need to check if the stack is empty or not\\n\\n            if(!s1.empty())\\n                ele1 = s1.top(), s1.pop();\\n            if(!s2.empty())\\n                ele2 = s2.top(), s2.pop();\\n\\n            int sum = ele1 + ele2 + carry;\\n            carry = sum/10;\\n            int data = sum%10;\\n            ans.push(data);\\n        }\\n\\n// even after the stack goes empty, we need to check for any leftover carry.\\n        if(carry) ans.push(carry);\\n        ListNode* dummy = new ListNode(0), *nh = dummy;\\n\\n        while(ans.size()) {\\n            dummy -> next = new ListNode(ans.top());\\n            ans.pop();\\n            dummy = dummy -> next;\\n        }\\n\\n        return nh -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775793,
                "title": "3-stacks-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2, s3;\\n        while(l1) {\\n            s1.push(l1 -> val);\\n            l1 = l1 -> next;\\n        }\\n        while(l2) {\\n            s2.push(l2 -> val);\\n            l2 = l2 -> next;\\n        }\\n\\n        int carry = 0;\\n        while(s1.size() || s2.size()){\\n            int a = 0, b = 0;\\n            if(s1.size()) {\\n                a = s1.top();\\n                s1.pop();\\n            }\\n            if(s2.size()) {\\n                b = s2.top();\\n                s2.pop();\\n            }\\n\\n            s3.push((a + b + carry) % 10);\\n            carry = (a + b + carry) / 10;\\n        }\\n        if(carry) s3.push(carry);\\n\\n        ListNode* dummy = new ListNode(0), *nh = dummy;\\n        while(s3.size()) {\\n            dummy -> next = new ListNode(s3.top());\\n            s3.pop();\\n            dummy = dummy -> next;\\n        }\\n        return nh -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2, s3;\\n        while(l1) {\\n            s1.push(l1 -> val);\\n            l1 = l1 -> next;\\n        }\\n        while(l2) {\\n            s2.push(l2 -> val);\\n            l2 = l2 -> next;\\n        }\\n\\n        int carry = 0;\\n        while(s1.size() || s2.size()){\\n            int a = 0, b = 0;\\n            if(s1.size()) {\\n                a = s1.top();\\n                s1.pop();\\n            }\\n            if(s2.size()) {\\n                b = s2.top();\\n                s2.pop();\\n            }\\n\\n            s3.push((a + b + carry) % 10);\\n            carry = (a + b + carry) / 10;\\n        }\\n        if(carry) s3.push(carry);\\n\\n        ListNode* dummy = new ListNode(0), *nh = dummy;\\n        while(s3.size()) {\\n            dummy -> next = new ListNode(s3.top());\\n            s3.pop();\\n            dummy = dummy -> next;\\n        }\\n        return nh -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666457,
                "title": "c-solution-using-reversing-the-linked-lists",
                "content": "# Intuition\\nWe need to find the sum from the end of the linked list to the start and return the answer in same fashion.\\n\\n# Approach\\nAs soon as we see that we need to operate on the linked list in a reverse fashion, we can be sure that we can reverse the linked lists to solve the problem. So do it. The template to reverse the linkedlist is in the function reverseln. \\nNow initialise carry to 0 and go node by node in every list, if both the lists have some value at that position then add that with carry. Remember to recompute the new carry. Now this a bit tricky part as we want to return the LinkedNode in the same fashion, i.e. highest significant digit. So we will update this new linked list in reverse order. Notice that from curr->next = head  and head = curr line. As head is now the latest added node. Hop on to the next nodes in both the lists if they exist.\\nAt last, if there is still a carry remanining then make the head this new node. Atlast return the node.\\n\\n# Complexity\\n- Time complexity:\\nO(N+M) where N and M are the length of the linked lists \\n\\n- Space complexity:\\nO(max(N, M))\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseListNode(ListNode* head)\\n    {\\n        ListNode* last = NULL;\\n        while(head)\\n        {\\n            ListNode* tmp = head->next;\\n            head->next = last;\\n            last = head;\\n            head = tmp;\\n        }\\n        return last;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseListNode(l1);\\n        l2 = reverseListNode(l2);\\n        ListNode* head = NULL;\\n        int carry = 0;\\n        while(l1||l2)\\n        {\\n            int x1 = l1?l1->val:0;\\n            int x2 = l2?l2->val:0;\\n            int sum = (x1+x2+carry)%10;\\n            carry = (x1+x2+carry)/10;\\n            ListNode* curr = new ListNode(sum);\\n            curr->next = head;\\n            head = curr;\\n            l1 = l1?l1->next:NULL;\\n            l2 = l2?l2->next:NULL;\\n        }\\n        if(carry)\\n        {\\n            ListNode* curr = new ListNode(carry);\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseListNode(ListNode* head)\\n    {\\n        ListNode* last = NULL;\\n        while(head)\\n        {\\n            ListNode* tmp = head->next;\\n            head->next = last;\\n            last = head;\\n            head = tmp;\\n        }\\n        return last;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseListNode(l1);\\n        l2 = reverseListNode(l2);\\n        ListNode* head = NULL;\\n        int carry = 0;\\n        while(l1||l2)\\n        {\\n            int x1 = l1?l1->val:0;\\n            int x2 = l2?l2->val:0;\\n            int sum = (x1+x2+carry)%10;\\n            carry = (x1+x2+carry)/10;\\n            ListNode* curr = new ListNode(sum);\\n            curr->next = head;\\n            head = curr;\\n            l1 = l1?l1->next:NULL;\\n            l2 = l2?l2->next:NULL;\\n        }\\n        if(carry)\\n        {\\n            ListNode* curr = new ListNode(carry);\\n            curr->next = head;\\n            head = curr;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764987,
                "title": "simple-o-n-solution-using-unordered-map-without-reversing-any-link-list",
                "content": "# The idea is to map the next node to its parent node so that we can move back using map and move forward by next method.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(!l1)\\n            return l2;\\n        if(!l2)\\n            return l1;\\n        \\n        unordered_map<ListNode*,ListNode*> mp1,mp2;\\n        \\n        ListNode *list1=l1,*list2=l2;\\n        \\n        while(list1) // mapping next node to its parent node\\n        {\\n            mp1[list1->next]=list1;\\n            list1=list1->next;\\n        }\\n        \\n        while(list2)\\n        {\\n            mp2[list2->next]=list2;\\n            list2=list2->next;\\n        }\\n        \\n        ListNode *prev=nullptr,*curr=nullptr;  //to desig our desired output link list\\n        int carry=0;\\n        \\n        while(list1!=l1 && list2!=l2) //now current both list1 and list2 is null. If any will hit the head of any\\n        {                                          //given input list we will stop\\n            list1=mp1[list1];\\n            list2=mp2[list2];\\n            \\n            int sum=list1->val+list2->val+carry;\\n            carry=sum/10;\\n            curr=new ListNode(sum%10,prev);\\n            prev=curr;\\n        }\\n        \\n        if(list1==l1)\\n        {\\n            while(list2!=l2) //when l1 length is greater than l2 length\\n            {\\n                list2=mp2[list2];\\n                \\n                int sum=list2->val+carry;\\n                carry=sum/10;\\n                curr=new ListNode(sum%10,prev);\\n                prev=curr;\\n            }\\n        }\\n        else\\n        {\\n            while(list1!=l1) //when l2 length is greater than l1 length\\n            {\\n                list1=mp1[list1];\\n                \\n                int sum=list1->val+carry;\\n                carry=sum/10;\\n                curr=new ListNode(sum%10,prev);\\n                prev=curr; \\n            }\\n        }\\n        \\n        if(carry>0) //if some value is left in a carry\\n        {\\n            curr=new ListNode(carry,prev);\\n            prev=curr;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(!l1)\\n            return l2;\\n        if(!l2)\\n            return l1;\\n        \\n        unordered_map<ListNode*,ListNode*> mp1,mp2;\\n        \\n        ListNode *list1=l1,*list2=l2;\\n        \\n        while(list1) // mapping next node to its parent node\\n        {\\n            mp1[list1->next]=list1;\\n            list1=list1->next;\\n        }\\n        \\n        while(list2)\\n        {\\n            mp2[list2->next]=list2;\\n            list2=list2->next;\\n        }\\n        \\n        ListNode *prev=nullptr,*curr=nullptr;  //to desig our desired output link list\\n        int carry=0;\\n        \\n        while(list1!=l1 && list2!=l2) //now current both list1 and list2 is null. If any will hit the head of any\\n        {                                          //given input list we will stop\\n            list1=mp1[list1];\\n            list2=mp2[list2];\\n            \\n            int sum=list1->val+list2->val+carry;\\n            carry=sum/10;\\n            curr=new ListNode(sum%10,prev);\\n            prev=curr;\\n        }\\n        \\n        if(list1==l1)\\n        {\\n            while(list2!=l2) //when l1 length is greater than l2 length\\n            {\\n                list2=mp2[list2];\\n                \\n                int sum=list2->val+carry;\\n                carry=sum/10;\\n                curr=new ListNode(sum%10,prev);\\n                prev=curr;\\n            }\\n        }\\n        else\\n        {\\n            while(list1!=l1) //when l2 length is greater than l1 length\\n            {\\n                list1=mp1[list1];\\n                \\n                int sum=list1->val+carry;\\n                carry=sum/10;\\n                curr=new ListNode(sum%10,prev);\\n                prev=curr; \\n            }\\n        }\\n        \\n        if(carry>0) //if some value is left in a carry\\n        {\\n            curr=new ListNode(carry,prev);\\n            prev=curr;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267079,
                "title": "easy-explained-o-n-solution",
                "content": "// Firstly reverse both the lists then keep the track of carry and value of node to be added \\n// at every step create a node with given value and the created list to its next and update head \\n\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n\\n\\t\\t\\t\\t\\t l1 = reverseList(l1);\\n\\t\\t\\t\\t\\t l2 = reverseList(l2);\\n\\t\\t\\t\\t\\tint data =0;\\n\\t\\t\\t\\t\\tint carry =0;\\n\\t\\t\\t\\t\\tListNode head = null; \\n\\t\\t\\t\\t\\twhile(l1 != null && l2 != null){\\n\\t\\t\\t\\t\\t\\tdata = carry + l1.val + l2.val;\\n\\t\\t\\t\\t\\t\\tint value = data % 10;\\n\\t\\t\\t\\t\\t\\tcarry = data/10;\\n\\t\\t\\t\\t\\t\\tListNode temp = new ListNode(value);\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t\\tl1 = l1.next;\\n\\t\\t\\t\\t\\t\\tl2 = l2.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t//  if both the lists have different size then we have to iterate that list seperately .......which has greater size\\t\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\twhile(l1 != null){\\n\\t\\t\\t\\t\\t\\tdata = l1.val +carry;\\n\\t\\t\\t\\t\\t\\tint value = data % 10;\\n\\t\\t\\t\\t\\t\\tcarry = data /10;\\n\\t\\t\\t\\t\\t\\t ListNode temp = new ListNode(value);\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t\\tl1 = l1.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(l2 != null){\\n\\t\\t\\t\\t\\t\\t data = l2.val +carry;\\n\\t\\t\\t\\t\\t\\tint value = data % 10;\\n\\t\\t\\t\\t\\t\\tcarry = data /10;\\n\\t\\t\\t\\t\\t\\t ListNode temp = new ListNode(value);\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t\\tl2 = l2.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t// If both the lists are completly iterated and carry contains non zero value then we have to create a new node for this carry too\\n\\t\\t\\t\\n\\t\\t\\t\\t\\tif(carry != 0){\\n\\t\\t\\t\\t\\t\\t ListNode temp = new ListNode(carry);\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn head;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n    //  Function to reverse Linked list with given head\\n\\t\\n\\t\\t\\t\\t private ListNode reverseList(ListNode head) {\\n\\t\\t\\t\\t\\tif(head == null || head.next == null){\\n\\t\\t\\t\\t\\t\\treturn head;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t  ListNode temp = head.next;\\n\\t\\t\\t\\t  ListNode prev = head;\\n\\t\\t\\t\\t\\twhile(temp!= null){\\n\\t\\t\\t\\t\\t  prev.next = temp.next;\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t\\ttemp = prev.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn head;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t//all the suggestions that can help me to update my code are welcome\\n\\t//for any query do let me know in the comment section\\n\\t//if  the solution was helpful please up vote",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n\\n\\t\\t\\t\\t\\t l1 = reverseList(l1);\\n\\t\\t\\t\\t\\t l2 = reverseList(l2);\\n\\t\\t\\t\\t\\tint data =0;\\n\\t\\t\\t\\t\\tint carry =0;\\n\\t\\t\\t\\t\\tListNode head = null; \\n\\t\\t\\t\\t\\twhile(l1 != null && l2 != null){\\n\\t\\t\\t\\t\\t\\tdata = carry + l1.val + l2.val;\\n\\t\\t\\t\\t\\t\\tint value = data % 10;\\n\\t\\t\\t\\t\\t\\tcarry = data/10;\\n\\t\\t\\t\\t\\t\\tListNode temp = new ListNode(value);\\n\\t\\t\\t\\t\\t\\ttemp.next = head;\\n\\t\\t\\t\\t\\t\\thead = temp;\\n\\t\\t\\t\\t\\t\\tl1 = l1.next;\\n\\t\\t\\t\\t\\t\\tl2 = l2.next;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1243186,
                "title": "c-easy-solution-using-stacks-clean-code",
                "content": "***\\u2714C++ Implementation :***\\n\\n```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        ListNode* head = NULL;  // new head of result LL\\n        int carry = 0;\\n        \\n\\t\\t// insert elements of both linked lists into stacks\\n        ListNode* h1 = l1;\\n        while(h1) {\\n            s1.push(h1->val);\\n            h1 = h1->next;\\n        }\\n        \\n        ListNode* h2 = l2;\\n        while(h2) {\\n            s2.push(h2->val);\\n            h2 = h2->next;\\n        }\\n        \\n        while(!s1.empty() || !s2.empty()){\\n            int sum = (s1.empty() ? 0 : s1.top()) + (s2.empty() ? 0 : s2.top()) + carry;\\n            carry = sum>=10 ? 1 : 0;\\n            ListNode * temp = new ListNode(sum%10);\\n            \\n            if(head==NULL)\\n                head = temp;\\n            else{\\n                temp->next = head;\\n                head = temp;\\n            }\\n            \\n            if(!s1.empty()) s1.pop();\\n            if(!s2.empty()) s2.pop();\\n            \\n        }\\n        // 9->9 + 9->9 = 1->9->8 type of case\\n        if(carry == 1){\\n            ListNode * temp = new ListNode(1);\\n            temp->next = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHope you guys liked it , kindly upvote :)\\n\\n## Happy Coding Fellas \\uD83E\\uDD17\\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        ListNode* head = NULL;  // new head of result LL\\n        int carry = 0;\\n        \\n\\t\\t// insert elements of both linked lists into stacks\\n        ListNode* h1 = l1;\\n        while(h1) {\\n            s1.push(h1->val);\\n            h1 = h1->next;\\n        }\\n        \\n        ListNode* h2 = l2;\\n        while(h2) {\\n            s2.push(h2->val);\\n            h2 = h2->next;\\n        }\\n        \\n        while(!s1.empty() || !s2.empty()){\\n            int sum = (s1.empty() ? 0 : s1.top()) + (s2.empty() ? 0 : s2.top()) + carry;\\n            carry = sum>=10 ? 1 : 0;\\n            ListNode * temp = new ListNode(sum%10);\\n            \\n            if(head==NULL)\\n                head = temp;\\n            else{\\n                temp->next = head;\\n                head = temp;\\n            }\\n            \\n            if(!s1.empty()) s1.pop();\\n            if(!s2.empty()) s2.pop();\\n            \\n        }\\n        // 9->9 + 9->9 = 1->9->8 type of case\\n        if(carry == 1){\\n            ListNode * temp = new ListNode(1);\\n            temp->next = head;\\n            head = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 926775,
                "title": "add-two-numbers-ii-c-two-stacks-o-m-n",
                "content": "A simple solution is to push each list-number to a stack such that the least significant digit of each number is on top of the stack, then build the list from the back/least significant digit forward. Just make sure to keep track of the carry digit.\\n```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n\\tstack<int> s1, s2;\\n\\t// push l1 to stack\\n\\twhile(l1) {\\n\\t\\ts1.push(l1->val);\\n\\t\\tl1 = l1->next;\\n\\t}\\n\\t// push l2 to stack\\n\\twhile(l2) {\\n\\t\\ts2.push(l2->val);\\n\\t\\tl2 = l2->next;\\n\\t}\\n\\t// build sum list\\n\\tListNode* l3 = nullptr;\\n\\tint carry = 0;\\n\\twhile(!s1.empty() || !s2.empty() || carry) {\\n\\t\\tint n1 = 0, n2 = 0;\\n\\t\\tif(!s1.empty()) {\\n\\t\\t\\tn1 = s1.top();\\n\\t\\t\\ts1.pop();\\n\\t\\t}\\n\\t\\tif(!s2.empty()) {\\n\\t\\t\\tn2 = s2.top();\\n\\t\\t\\ts2.pop();\\n\\t\\t}\\n\\t\\tListNode* t = new ListNode((n1 + n2 + carry) % 10, l3);\\n\\t\\tl3 = t;\\n\\t\\tcarry = (n1 + n2 + carry) / 10;\\n\\t}\\n\\treturn l3;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n\\tstack<int> s1, s2;\\n\\t// push l1 to stack\\n\\twhile(l1) {\\n\\t\\ts1.push(l1->val);\\n\\t\\tl1 = l1->next;\\n\\t}\\n\\t// push l2 to stack\\n\\twhile(l2) {\\n\\t\\ts2.push(l2->val);\\n\\t\\tl2 = l2->next;\\n\\t}\\n\\t// build sum list\\n\\tListNode* l3 = nullptr;\\n\\tint carry = 0;\\n\\twhile(!s1.empty() || !s2.empty() || carry) {\\n\\t\\tint n1 = 0, n2 = 0;\\n\\t\\tif(!s1.empty()) {\\n\\t\\t\\tn1 = s1.top();\\n\\t\\t\\ts1.pop();\\n\\t\\t}\\n\\t\\tif(!s2.empty()) {\\n\\t\\t\\tn2 = s2.top();\\n\\t\\t\\ts2.pop();\\n\\t\\t}\\n\\t\\tListNode* t = new ListNode((n1 + n2 + carry) % 10, l3);\\n\\t\\tl3 = t;\\n\\t\\tcarry = (n1 + n2 + carry) / 10;\\n\\t}\\n\\treturn l3;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869697,
                "title": "javascript-using-stack",
                "content": "Using stack for Javascript solution\\n\\n- Time complexity: `O(l1+l2)`\\n- Space complexity: `O(max(l1,l2))`\\n\\n``` javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    // make 2 stack\\n    let s1 = []\\n    let s2 = []\\n    while (l1){\\n        s1.push(l1.val)\\n        l1 = l1.next\\n    }\\n    while (l2){\\n        s2.push(l2.val)\\n        l2 = l2.next\\n    }\\n    \\n\\t// similiar to 2. Add Two Numbers\\n    let list = new ListNode(0)\\n    let sum = 0;\\n    \\n    while (s1.length !== 0 || s2.length !== 0 || sum > 0){\\n        sum = sum + (s1.length === 0? 0: s1.pop())\\n        sum = sum + (s2.length === 0? 0: s2.pop())\\n        // start to deal with linked list\\n\\t\\t// update current node value\\n        list.val = sum % 10\\n\\t\\t// add new head node with carry, head.val could be 1 or 0\\n\\t\\tsum = Math.floor(sum/10);\\n        let head = new ListNode(sum)\\n\\t\\t// connect\\n        head.next = list\\n\\t\\t// update the head\\n        list = head\\n    }\\n    if (list.val === 0){\\n        return list.next\\n    } else {\\n        return list\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    // make 2 stack\\n    let s1 = []\\n    let s2 = []\\n    while (l1){\\n        s1.push(l1.val)\\n        l1 = l1.next\\n    }\\n    while (l2){\\n        s2.push(l2.val)\\n        l2 = l2.next\\n    }\\n    \\n\\t// similiar to 2. Add Two Numbers\\n    let list = new ListNode(0)\\n    let sum = 0;\\n    \\n    while (s1.length !== 0 || s2.length !== 0 || sum > 0){\\n        sum = sum + (s1.length === 0? 0: s1.pop())\\n        sum = sum + (s2.length === 0? 0: s2.pop())\\n        // start to deal with linked list\\n\\t\\t// update current node value\\n        list.val = sum % 10\\n\\t\\t// add new head node with carry, head.val could be 1 or 0\\n\\t\\tsum = Math.floor(sum/10);\\n        let head = new ListNode(sum)\\n\\t\\t// connect\\n        head.next = list\\n\\t\\t// update the head\\n        list = head\\n    }\\n    if (list.val === 0){\\n        return list.next\\n    } else {\\n        return list\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560667,
                "title": "python-pythonic-way-using-generator-and-zip",
                "content": "Use a post-order iterator and zip two iterators on `l1` and `l2` at the same time, the corresponding digits will be paired.\\n\\n```python\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\t\\t# post-order generator\\n        def it(node):\\n            if node:\\n                yield from it(node.next)\\n                yield node.val\\n        \\n        ans = ListNode(None)\\n        carry = 0\\n        for v1, v2 in itertools.zip_longest(it(l1), it(l2), fillvalue=0):\\n            v = v1 + v2 + carry\\n            digit, carry = ListNode(v % 10), v // 10\\n            digit.next, ans.next = ans.next, digit\\n        \\n        if carry > 0:\\n            digit = ListNode(carry)\\n            digit.next, ans.next = ans.next, digit\\n        \\n        return ans.next\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n\\t\\t# post-order generator\\n        def it(node):\\n            if node:\\n                yield from it(node.next)\\n                yield node.val\\n        \\n        ans = ListNode(None)\\n        carry = 0\\n        for v1, v2 in itertools.zip_longest(it(l1), it(l2), fillvalue=0):\\n            v = v1 + v2 + carry\\n            digit, carry = ListNode(v % 10), v // 10\\n            digit.next, ans.next = ans.next, digit\\n        \\n        if carry > 0:\\n            digit = ListNode(carry)\\n            digit.next, ans.next = ans.next, digit\\n        \\n        return ans.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480177,
                "title": "java-easy-to-read-solution-o-n-using-two-stacks",
                "content": "```java\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Deque<Integer> stack1 = toDeque(l1);\\n        Deque<Integer> stack2 = toDeque(l2);\\n        \\n        int carry = 0;\\n        ListNode result = null;\\n        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {\\n            int sum = carry;\\n            if (!stack1.isEmpty()) sum += stack1.pop();\\n            if (!stack2.isEmpty()) sum += stack2.pop();\\n            carry = sum / 10;\\n            ListNode temp = new ListNode(sum % 10);\\n            temp.next = result;\\n            result = temp;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Deque<Integer> toDeque(ListNode l1) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (ListNode cur = l1; cur != null; cur = cur.next) {\\n            stack.push(cur.val);\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        Deque<Integer> stack1 = toDeque(l1);\\n        Deque<Integer> stack2 = toDeque(l2);\\n        \\n        int carry = 0;\\n        ListNode result = null;\\n        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) {\\n            int sum = carry;\\n            if (!stack1.isEmpty()) sum += stack1.pop();\\n            if (!stack2.isEmpty()) sum += stack2.pop();\\n            carry = sum / 10;\\n            ListNode temp = new ListNode(sum % 10);\\n            temp.next = result;\\n            result = temp;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Deque<Integer> toDeque(ListNode l1) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for (ListNode cur = l1; cur != null; cur = cur.next) {\\n            stack.push(cur.val);\\n        }\\n        return stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472195,
                "title": "javascript-recursion-backtracking-solution-no-stack-simple",
                "content": "### The idea\\n1. There are two ways of passing variables. To pass down, we use parameters. To pass up/back, we use return values. And this problem is the perfect example of the later where we need to pass the carry number up/back. \\n2. Define a recursion function `getCarry` which recursively sets the local sum and returns the carry during backtracking stage.\\n3. Beware of numbers of different length, we can incorporate an `offset` to solve the problem.\\n``` javascript\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    let l1Len = getLen(l1);\\n    let l2Len = getLen(l2);\\n    let offset = Math.abs(l1Len - l2Len);\\n    if (l2Len > l1Len) [l1, l2] = [l2, l1]; // l1 will always be the longer one\\n    let dummyHead = new ListNode(0);\\n    dummyHead.val = getCarry(l1, l2, dummyHead, offset);\\n\\n    return dummyHead.val==1?dummyHead:dummyHead.next;\\n};\\n\\n/**\\n * @param {ListNode} l1 \\n * @param {ListNode} l2 \\n * @param {ListNode} node \\n * @param {Number} offset \\n */\\nfunction getCarry(l1, l2, node, offset) {\\n    if (l1==null || l2==null) return 0;\\n    node.next = new ListNode(0);\\n    let sum = 0;\\n    if (offset > 0) sum = l1.val + getCarry(l1.next, l2, node.next, offset-1);\\n    else sum = l1.val + l2.val + getCarry(l1.next, l2.next, node.next, offset-1);\\n\\n    node.next.val = sum % 10;\\n    return parseInt(sum / 10); // return the carry\\n}\\n\\n/**\\n * @param {ListNode} root \\n */\\nfunction getLen(root) {\\n    let len = 0;\\n    while(root) {\\n        len++;\\n        root = root.next;\\n    }\\n    return len;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function(l1, l2) {\\n    let l1Len = getLen(l1);\\n    let l2Len = getLen(l2);\\n    let offset = Math.abs(l1Len - l2Len);\\n    if (l2Len > l1Len) [l1, l2] = [l2, l1]; // l1 will always be the longer one\\n    let dummyHead = new ListNode(0);\\n    dummyHead.val = getCarry(l1, l2, dummyHead, offset);\\n\\n    return dummyHead.val==1?dummyHead:dummyHead.next;\\n};\\n\\n/**\\n * @param {ListNode} l1 \\n * @param {ListNode} l2 \\n * @param {ListNode} node \\n * @param {Number} offset \\n */\\nfunction getCarry(l1, l2, node, offset) {\\n    if (l1==null || l2==null) return 0;\\n    node.next = new ListNode(0);\\n    let sum = 0;\\n    if (offset > 0) sum = l1.val + getCarry(l1.next, l2, node.next, offset-1);\\n    else sum = l1.val + l2.val + getCarry(l1.next, l2.next, node.next, offset-1);\\n\\n    node.next.val = sum % 10;\\n    return parseInt(sum / 10); // return the carry\\n}\\n\\n/**\\n * @param {ListNode} root \\n */\\nfunction getLen(root) {\\n    let len = 0;\\n    while(root) {\\n        len++;\\n        root = root.next;\\n    }\\n    return len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410293,
                "title": "c-beats-80-in-runtime-simple-solution-with-explanation",
                "content": "```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n      \\tstack<int> stackA;\\n        stack<int> stackB;\\n        \\n\\t\\twhile (l1) {\\n\\t\\t\\tstackA.push(l1->val);\\n\\t\\t\\tl1 = l1->next;\\n\\t\\t}\\n        \\n\\t\\twhile (l2) {\\n\\t\\t\\tstackB.push(l2->val);\\n\\t\\t\\tl2 = l2->next;\\n\\t\\t}\\n\\n\\t\\tListNode* Temp = new ListNode(0); // Create anchor node. The list will be built attached to this node.\\n\\t\\tTemp->next = nullptr;\\n\\t\\tint carry{}, num1{} ,num2{};\\n\\n\\t\\twhile (!stackA.empty() || !stackB.empty() || carry) { // The trick is that carry is needed in the while look.\\n\\t\\t// As long as you have a remainder, you need a node to hold that remainder. This is what frustrated me\\n\\t\\t// for quite some time...\\n\\t\\t\\t\\n            if (!stackA.empty()) {\\n\\t\\t\\t\\tnum1 = stackA.top();\\n\\t\\t\\t\\tstackA.pop();\\n\\t\\t\\t}\\n            \\n\\n\\t\\t\\tif (!stackB.empty()) {\\n\\t\\t\\t\\tnum2 = stackB.top();\\n\\t\\t\\t\\tstackB.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sum = num1 + num2 + carry;\\n\\t\\t\\tint value = sum % 10;\\n\\t\\t\\tcarry = sum / 10; // e.g. 11 / 10 is 1\\n            \\n            num1 = 0; // Reset num1 and num2\\n            num2 = 0;\\n            \\n\\t\\t\\tListNode* newNode = new ListNode(value);\\n\\t\\t\\tnewNode->next = Temp->next; // Building on the original temp anchor\\n\\t\\t\\tTemp->next = newNode;\\n        }\\n        return Temp->next; // The attached list starts after the anchor node.\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n      \\tstack<int> stackA;\\n        stack<int> stackB;\\n        \\n\\t\\twhile (l1) {\\n\\t\\t\\tstackA.push(l1->val);\\n\\t\\t\\tl1 = l1->next;\\n\\t\\t}\\n        \\n\\t\\twhile (l2) {\\n\\t\\t\\tstackB.push(l2->val);\\n\\t\\t\\tl2 = l2->next;\\n\\t\\t}\\n\\n\\t\\tListNode* Temp = new ListNode(0); // Create anchor node. The list will be built attached to this node.\\n\\t\\tTemp->next = nullptr;\\n\\t\\tint carry{}, num1{} ,num2{};\\n\\n\\t\\twhile (!stackA.empty() || !stackB.empty() || carry) { // The trick is that carry is needed in the while look.\\n\\t\\t// As long as you have a remainder, you need a node to hold that remainder. This is what frustrated me\\n\\t\\t// for quite some time...\\n\\t\\t\\t\\n            if (!stackA.empty()) {\\n\\t\\t\\t\\tnum1 = stackA.top();\\n\\t\\t\\t\\tstackA.pop();\\n\\t\\t\\t}\\n            \\n\\n\\t\\t\\tif (!stackB.empty()) {\\n\\t\\t\\t\\tnum2 = stackB.top();\\n\\t\\t\\t\\tstackB.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sum = num1 + num2 + carry;\\n\\t\\t\\tint value = sum % 10;\\n\\t\\t\\tcarry = sum / 10; // e.g. 11 / 10 is 1\\n            \\n            num1 = 0; // Reset num1 and num2\\n            num2 = 0;\\n            \\n\\t\\t\\tListNode* newNode = new ListNode(value);\\n\\t\\t\\tnewNode->next = Temp->next; // Building on the original temp anchor\\n\\t\\t\\tTemp->next = newNode;\\n        }\\n        return Temp->next; // The attached list starts after the anchor node.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 362282,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def addTwoNumbers(self, l1, l2):\\n        n1 = n2 = \\'\\'\\n        \\n        while l1 != None:\\n            n1 += str(l1.val)\\n            l1 = l1.next\\n        \\n        while l2 != None:\\n            n2 += str(l2.val)\\n            l2 = l2.next\\n            \\n        n3 = str(int(n1) + int(n2))\\n        \\n        head = ListNode(int(n3[0]))\\n        res = head\\n        for i in range(1,len(n3)):\\n            head.next = ListNode( int( n3[i] ) )\\n            head = head.next\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def addTwoNumbers(self, l1, l2):\\n        n1 = n2 = \\'\\'\\n        \\n        while l1 != None:\\n            n1 += str(l1.val)\\n            l1 = l1.next\\n        \\n        while l2 != None:\\n            n2 += str(l2.val)\\n            l2 = l2.next\\n            \\n        n3 = str(int(n1) + int(n2))\\n        \\n        head = ListNode(int(n3[0]))\\n        res = head\\n        for i in range(1,len(n3)):\\n            head.next = ListNode( int( n3[i] ) )\\n            head = head.next\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209873,
                "title": "javascript-o-max-n-m-time-o-max-n-m-space-using-stack",
                "content": "```javascript\\n/**\\n * Time: O(max(n, m))\\n * Space: O(max(n, m))\\n * n - # of nodes in l1\\n * m - # of nodes in l2\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nfunction addTwoNumbers(l1, l2) {\\n  const digits1 = [];\\n  const digits2 = [];\\n\\n  // Fill in digits from each list\\n  for (let n = l1; n !== null; n = n.next) {\\n    digits1.push(n.val);\\n  }\\n  for (let n = l2; n !== null; n = n.next) {\\n    digits2.push(n.val);\\n  }\\n\\n  // Sum the digits in reverse order (least significant first)\\n  let prev = null;\\n  let carry = 0;\\n  while (digits1.length || digits2.length || carry) {\\n    const val1 = digits1.pop() || 0;\\n    const val2 = digits2.pop() || 0;\\n    const sum = val1 + val2 + carry;\\n    carry = sum > 9 ? 1 : 0;\\n\\n    // Build the list backwards so digits are in forward order\\n    const newNode = new ListNode(sum % 10);\\n    newNode.next = prev;\\n    prev = newNode;\\n  }\\n\\n  return prev;\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(max(n, m))\\n * Space: O(max(n, m))\\n * n - # of nodes in l1\\n * m - # of nodes in l2\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nfunction addTwoNumbers(l1, l2) {\\n  const digits1 = [];\\n  const digits2 = [];\\n\\n  // Fill in digits from each list\\n  for (let n = l1; n !== null; n = n.next) {\\n    digits1.push(n.val);\\n  }\\n  for (let n = l2; n !== null; n = n.next) {\\n    digits2.push(n.val);\\n  }\\n\\n  // Sum the digits in reverse order (least significant first)\\n  let prev = null;\\n  let carry = 0;\\n  while (digits1.length || digits2.length || carry) {\\n    const val1 = digits1.pop() || 0;\\n    const val2 = digits2.pop() || 0;\\n    const sum = val1 + val2 + carry;\\n    carry = sum > 9 ? 1 : 0;\\n\\n    // Build the list backwards so digits are in forward order\\n    const newNode = new ListNode(sum % 10);\\n    newNode.next = prev;\\n    prev = newNode;\\n  }\\n\\n  return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92747,
                "title": "python-solution",
                "content": "```\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1:ListNode\\n        :type l2:ListNode\\n        :rtype:ListNode\\n        :param l1:\\n        :param l2:\\n        :return:\\n        \"\"\"\\n        s1 = []\\n        s2 = []\\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        tmp = ListNode(0)\\n        s = 0\\n        while s1 or s2:\\n            if s1:\\n                s += s1.pop()\\n            if s2:\\n                s += s2.pop()\\n            tmp.val = s % 10\\n            head = ListNode(s / 10)\\n            head.next = tmp\\n            tmp = head\\n            s /= 10\\n        return tmp if tmp.val else tmp.next\\n```",
                "solutionTags": [],
                "code": "```\\n    def addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1:ListNode\\n        :type l2:ListNode\\n        :rtype:ListNode\\n        :param l1:\\n        :param l2:\\n        :return:\\n        \"\"\"\\n        s1 = []\\n        s2 = []\\n        while l1:\\n            s1.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            s2.append(l2.val)\\n            l2 = l2.next\\n        tmp = ListNode(0)\\n        s = 0\\n        while s1 or s2:\\n            if s1:\\n                s += s1.pop()\\n            if s2:\\n                s += s2.pop()\\n            tmp.val = s % 10\\n            head = ListNode(s / 10)\\n            head.next = tmp\\n            tmp = head\\n            s /= 10\\n        return tmp if tmp.val else tmp.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 92761,
                "title": "c-recursive-32ms",
                "content": "first find which linked list is longer\\nthen find the start node to add both lists, we only add numbers and do not care about carry over\\nthen recursively fix the carry over\\n\\n```\\nclass Solution {\\npublic:\\n    int check( ListNode * node)\\n    {\\n        int carry = 0;\\n        if(node -> next) carry += check(node -> next);\\n        int val = carry + node -> val;;\\n        carry = val / 10;\\n        node -> val = val % 10;\\n        return carry;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        auto node = l1;\\n        int len1 = 1, len2 = 1;\\n        while(node -> next)\\n        {\\n            node = node -> next;\\n            len1++;\\n        }\\n        node = l2;\\n        while(node -> next)\\n        {\\n            node = node -> next;\\n            len2++;\\n        }\\n        \\n        auto n1 = len1 > len2 ? l1 : l2;\\n        auto n2 = len1 > len2 ? l2 : l1;\\n        \\n        node = n1;\\n        for(int i = 0; i < abs(len1-len2); i++) node = node -> next;\\n        while(node)\\n        {\\n            node -> val += n2 -> val;\\n            n2 = n2 -> next;\\n            node = node -> next;\\n        }\\n        \\n        if(check(n1) == 0) return n1;\\n        node = new ListNode(1);\\n        node -> next = n1;\\n        return node;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int check( ListNode * node)\\n    {\\n        int carry = 0;\\n        if(node -> next) carry += check(node -> next);\\n        int val = carry + node -> val;;\\n        carry = val / 10;\\n        node -> val = val % 10;\\n        return carry;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 92794,
                "title": "java-54ms-space-o-1-solution-without-stack",
                "content": "```\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = 0, len2 = 0;\\n        if(l1 == null) return l2;\\n        if(l2 == null) return l1;\\n        ListNode cur1 = l1, cur2 = l2;\\n        while(cur1 != null){\\n            len1++;\\n            cur1 = cur1.next;\\n        }\\n        while(cur2 != null){\\n            len2++;\\n            cur2 = cur2.next;\\n        }\\n        if(len1 < len2){\\n            ListNode tmp = l1;\\n            l1 = l2;\\n            l2 = tmp;\\n        }\\n        cur1 = l1;\\n        cur2 = l2;\\n        int offset = Math.abs(len1 - len2);\\n        while(offset > 0){\\n            offset--;\\n            cur1 = cur1.next;\\n        }\\n        while(cur1 != null){\\n            cur1.val += cur2.val;\\n            cur1 = cur1.next;\\n            cur2 = cur2.next;\\n        }\\n        cur1 = l1; cur2 = l1.next;\\n        while(cur2 != null){\\n            while(cur2 != null && cur2.val < 9){\\n                cur1 = cur1.next;\\n                cur2 = cur2.next;\\n            }\\n            if(cur2 == null) break;\\n            while(cur2 != null && cur2.val == 9){\\n                cur2 = cur2.next;\\n            }\\n            if(cur2 == null) break;\\n            if(cur2.val > 9){\\n                cur1.val++;\\n                cur1 = cur1.next;\\n                while(cur1 != cur2){\\n                    cur1.val = 0;\\n                    cur1 = cur1.next;\\n                }\\n                cur1.val %= 10;\\n            }\\n            cur1 = cur2;\\n            cur2 = cur1.next;\\n        }\\n        if(l1.val > 9){\\n            ListNode newNode = new ListNode(1);\\n            newNode.next = l1;\\n            l1.val %= 10;\\n            l1 = newNode;\\n        }\\n        return l1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = 0, len2 = 0;\\n        if(l1 == null) return l2;\\n        if(l2 == null) return l1;\\n        ListNode cur1 = l1, cur2 = l2;\\n        while(cur1 != null){\\n            len1++;\\n            cur1 = cur1.next;\\n        }\\n        while(cur2 != null){\\n            len2++;\\n            cur2 = cur2.next;\\n        }\\n        if(len1 < len2){\\n            ListNode tmp = l1;\\n            l1 = l2;\\n            l2 = tmp;\\n        }\\n        cur1 = l1;\\n        cur2 = l2;\\n        int offset = Math.abs(len1 - len2);\\n        while(offset > 0){\\n            offset--;\\n            cur1 = cur1.next;\\n        }\\n        while(cur1 != null){\\n            cur1.val += cur2.val;\\n            cur1 = cur1.next;\\n            cur2 = cur2.next;\\n        }\\n        cur1 = l1; cur2 = l1.next;\\n        while(cur2 != null){\\n            while(cur2 != null && cur2.val < 9){\\n                cur1 = cur1.next;\\n                cur2 = cur2.next;\\n            }\\n            if(cur2 == null) break;\\n            while(cur2 != null && cur2.val == 9){\\n                cur2 = cur2.next;\\n            }\\n            if(cur2 == null) break;\\n            if(cur2.val > 9){\\n                cur1.val++;\\n                cur1 = cur1.next;\\n                while(cur1 != cur2){\\n                    cur1.val = 0;\\n                    cur1 = cur1.next;\\n                }\\n                cur1.val %= 10;\\n            }\\n            cur1 = cur2;\\n            cur2 = cur1.next;\\n        }\\n        if(l1.val > 9){\\n            ListNode newNode = new ListNode(1);\\n            newNode.next = l1;\\n            l1.val %= 10;\\n            l1 = newNode;\\n        }\\n        return l1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3779737,
                "title": "important-clean-well-explained-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Need to reverse the linkedlist to add them\\n- As well as have to maintal a carray variable\\n- And store these values accordingly in new linkedlist\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- A reverse function to reverse the linked list (basic)\\n- Then a function which stores values of the summation in linked list.\\n- Maintain a carry as well\\n- Now, only the sum%10 will be added in one node\\n- The way we use to create digits from a string: done the same.\\n\\n# Complexity\\n- Time complexity: O(l1_length + l2_length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(l1_length , l2_length()))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseLinkedList(ListNode* head){\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n\\n\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        // reverse the both ll and add\\n        // maintain a carry and sum variable\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* tail = dummy;\\n        int carry = 0;\\n\\n        while(l1 || l2 || carry!=0){\\n            int num1 = (l1!=NULL) ? l1->val : 0;\\n            int num2 = (l2!=NULL) ? l2->val : 0;\\n\\n            int sum = num1 + num2 + carry;\\n            int digit = sum % 10;\\n            carry = sum/10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            tail->next = newNode;\\n            tail = tail->next;\\n\\n            l1 = (l1!=NULL) ? l1->next : NULL;\\n            l2 = (l2!=NULL) ? l2->next : NULL;\\n        }\\n\\n        ListNode* result = dummy->next;\\n        delete dummy;\\n        return result;\\n    }\\n\\n     ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseLinkedList(l1);\\n        l2 = reverseLinkedList(l2);\\n        ListNode* ans = Helper(l1, l2);\\n        return reverseLinkedList(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseLinkedList(ListNode* head){\\n        ListNode* prev = NULL;\\n\\n        while(head) {\\n            ListNode* nxt = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = nxt;\\n        }\\n        return prev;\\n    }\\n\\n\\n    ListNode* Helper(ListNode* l1, ListNode* l2) {\\n        // reverse the both ll and add\\n        // maintain a carry and sum variable\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* tail = dummy;\\n        int carry = 0;\\n\\n        while(l1 || l2 || carry!=0){\\n            int num1 = (l1!=NULL) ? l1->val : 0;\\n            int num2 = (l2!=NULL) ? l2->val : 0;\\n\\n            int sum = num1 + num2 + carry;\\n            int digit = sum % 10;\\n            carry = sum/10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            tail->next = newNode;\\n            tail = tail->next;\\n\\n            l1 = (l1!=NULL) ? l1->next : NULL;\\n            l2 = (l2!=NULL) ? l2->next : NULL;\\n        }\\n\\n        ListNode* result = dummy->next;\\n        delete dummy;\\n        return result;\\n    }\\n\\n     ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseLinkedList(l1);\\n        l2 = reverseLinkedList(l2);\\n        ListNode* ans = Helper(l1, l2);\\n        return reverseLinkedList(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778211,
                "title": "using-reverse-of-lists",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public ListNode reverseList(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = null;\\n        while(curr!=null)\\n        {\\n            temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if(l1 == null)  return l2;\\n        if(l2 == null)  return l1;\\n        int sum = 0;\\n        int carry = 0;\\n        ListNode t1 = reverseList(l1);\\n        ListNode t2 = reverseList(l2);\\n        ListNode result = new ListNode(-1);\\n        ListNode curr = result;\\n        while(t1!=null || t2!=null)\\n        {\\n            sum = ((t1 == null)?0:t1.val)+((t2 == null)?0:t2.val)+carry;\\n            carry = sum/10;\\n            curr.next = new ListNode(sum%10);\\n            curr = curr.next;\\n            if(t1!=null)\\n                t1 = t1.next;\\n            if(t2!=null)\\n                t2 = t2.next;\\n        }\\n        if(carry!=0)\\n            curr.next = new ListNode(carry);\\n        return reverseList(result.next);\\n    }\\n}\\n```\\n>## *Please don\\'t forget to upvote if you\\'ve liked my solution.*",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseList(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode temp = null;\\n        while(curr!=null)\\n        {\\n            temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        if(l1 == null)  return l2;\\n        if(l2 == null)  return l1;\\n        int sum = 0;\\n        int carry = 0;\\n        ListNode t1 = reverseList(l1);\\n        ListNode t2 = reverseList(l2);\\n        ListNode result = new ListNode(-1);\\n        ListNode curr = result;\\n        while(t1!=null || t2!=null)\\n        {\\n            sum = ((t1 == null)?0:t1.val)+((t2 == null)?0:t2.val)+carry;\\n            carry = sum/10;\\n            curr.next = new ListNode(sum%10);\\n            curr = curr.next;\\n            if(t1!=null)\\n                t1 = t1.next;\\n            if(t2!=null)\\n                t2 = t2.next;\\n        }\\n        if(carry!=0)\\n            curr.next = new ListNode(carry);\\n        return reverseList(result.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777707,
                "title": "easy-c-solution-using-stack-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to add two numbers represented as linked lists. We can approach this problem by simulating the addition process digit by digit, starting from the least significant digit and moving towards the most significant digit. To do this, we can use stacks to store the digits of both numbers in reverse order. We can then pop digits from the stacks, add them along with the carry, and create a new linked list with the resulting sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a helper function, helper, that takes a linked list as input and returns a stack containing the digits of the linked list in reverse order.\\n2. In the addTwoNumbers function, create two stacks `s1` and `s2` using the helper function on l1 and l2, respectively. These stacks will contain the digits of both linked lists in reverse order.\\n3. Initialize a `carry` variable to 0 and create a new head pointer for the resulting linked list, initially set to `NULL`.\\n4. While `s1` or `s2` is not empty or there is a carry:\\n    - Pop the top digits from `s1` and `s2`. If either stack is empty, consider the popped digit as 0\\n    - Add the popped digits along with the carry.\\n    - Create a new node with the value as the `sum % 10` (***to get the digit***) and set its next pointer to the current head of the resulting linked list.\\n    - Update the `head` of the resulting linked list to the new node.\\n    - Update the carry as `sum / 10` (***to get the carry for the next iteration***).\\n# Complexity\\n- Time complexity: $$O(max(N1, N2))$$\\n    -  where N1 and N2 are the lengths of the input linked lists l1 and l2, respectively. We iterate through both linked lists once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(N1, N2))$$\\n    - as we use stacks to store the digits of the linked lists. The space required is proportional to the length of the longer linked list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    // Helper function to convert linked list to stack of digits in reverse order\\n    stack<int> helper(ListNode* head) {\\n        stack<int> st;\\n        while (head) {\\n            st.push(head->val);\\n            head = head->next;\\n        }\\n        return st;\\n    }\\n\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        s1 = helper(l1); // Convert l1 to stack\\n        s2 = helper(l2); // Convert l2 to stack\\n\\n        int carry = 0;\\n        ListNode* head = nullptr;\\n\\n        while (!s1.empty() || !s2.empty() || carry != 0) {\\n            int sum = carry;\\n\\n            // Pop digits from stack s1 if not empty\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n\\n            // Pop digits from stack s2 if not empty\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n\\n            // Create a new node with the digit as sum % 10\\n            ListNode* temp = new ListNode(sum % 10);\\n\\n            // Update the next pointer of the new node to the current head\\n            temp->next = head;\\n\\n            // Update the head to the new node\\n            head = temp;\\n\\n            // Update the carry for the next iteration\\n            carry = sum / 10;\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    // Helper function to convert linked list to stack of digits in reverse order\\n    stack<int> helper(ListNode* head) {\\n        stack<int> st;\\n        while (head) {\\n            st.push(head->val);\\n            head = head->next;\\n        }\\n        return st;\\n    }\\n\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        s1 = helper(l1); // Convert l1 to stack\\n        s2 = helper(l2); // Convert l2 to stack\\n\\n        int carry = 0;\\n        ListNode* head = nullptr;\\n\\n        while (!s1.empty() || !s2.empty() || carry != 0) {\\n            int sum = carry;\\n\\n            // Pop digits from stack s1 if not empty\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n\\n            // Pop digits from stack s2 if not empty\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n\\n            // Create a new node with the digit as sum % 10\\n            ListNode* temp = new ListNode(sum % 10);\\n\\n            // Update the next pointer of the new node to the current head\\n            temp->next = head;\\n\\n            // Update the head to the new node\\n            head = temp;\\n\\n            // Update the carry for the next iteration\\n            carry = sum / 10;\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777404,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the least significant node (right side)  from both list and add them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince it is linked list so can\\'t access all elements directly from right side. so we will reverse both list. Now, we keep accessing element from left side in both list and add them with previous carry and store them and then store the carry separate.. do it untill the end of list. At the end, if there is carry then add it to answer list . \\n\\n# Complexity\\n# - ***Time complexity:   O( 2     *    (    |l1|   +    |l2|   )     )***\\n\\n- Space complexity: O(1) .. if we ignore the final output list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n    ListNode* Node=head;\\n    ListNode* rev=NULL;\\n    \\n        \\n    if(head==NULL){\\n        return head;\\n    }    \\n    while(head!=NULL){\\n        Node=head->next;\\n        head->next=rev;\\n        rev=head;\\n        head=Node;\\n    }    \\n        \\n        return rev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        \\n        int carry = 0;\\n        ListNode* ans =  new ListNode();\\n        ListNode* temp = ans;\\n        while(l1 && l2){\\n            int sum = l1->val + l2->val+carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l1=l1->next;\\n            l2=l2->next;\\n        }\\n        while(l1){\\n            int sum = l1->val + carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l1=l1->next;\\n        }\\n        while(l2){\\n            int sum = l2->val + carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l2=l2->next;\\n        }\\n        if(carry){\\n            ListNode* curr = new ListNode(carry);\\n            temp->next = curr;\\n        }\\n        ListNode* res= ans->next;\\n        \\n        res = reverseList(res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        \\n    ListNode* Node=head;\\n    ListNode* rev=NULL;\\n    \\n        \\n    if(head==NULL){\\n        return head;\\n    }    \\n    while(head!=NULL){\\n        Node=head->next;\\n        head->next=rev;\\n        rev=head;\\n        head=Node;\\n    }    \\n        \\n        return rev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        \\n        int carry = 0;\\n        ListNode* ans =  new ListNode();\\n        ListNode* temp = ans;\\n        while(l1 && l2){\\n            int sum = l1->val + l2->val+carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l1=l1->next;\\n            l2=l2->next;\\n        }\\n        while(l1){\\n            int sum = l1->val + carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l1=l1->next;\\n        }\\n        while(l2){\\n            int sum = l2->val + carry;\\n            ListNode* curr = new ListNode(sum%10);\\n            temp->next = curr;\\n            temp = temp->next;\\n            carry = sum / 10;\\n            l2=l2->next;\\n        }\\n        if(carry){\\n            ListNode* curr = new ListNode(carry);\\n            temp->next = curr;\\n        }\\n        ListNode* res= ans->next;\\n        \\n        res = reverseList(res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776815,
                "title": "c-solution-brute-force-optimized-approach",
                "content": "\\n# Complexity\\n- Time complexity:  length of l1=m, length of l2=n;\\n- For Reversing: O(m) +  O(n)  +  O(max(m,n)) + O(n+m)\\n\\n\\n# Space complexity:\\n- O(max(m,n))\\n\\n# Code1 ( Addition Function has 4 loop )\\n```\\n\\n    ListNode* ReverseLL(ListNode* &head){\\n        if(head==NULL  ||  head->next==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n\\n        while(curr != NULL){\\n            ListNode* next= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n\\n    void InsertAtTail(ListNode*&head, ListNode*&tail, int val){\\n        ListNode* temp=new ListNode(val);\\n        if(head==NULL){\\n            head= temp;\\n            tail=head;\\n            return;\\n        }\\n        else{\\n            tail->next=temp;\\n            tail=tail->next;\\n        }\\n    }\\n\\n    ListNode* Addition(ListNode*first, ListNode*second){\\n        int carry=0;\\n        ListNode*head=NULL;\\n        ListNode*tail=NULL;\\n\\n        while(first != NULL   &&   second != NULL){\\n            int sum= first->val + second->val + carry;\\n            carry= sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            first=first->next; \\n            second=second->next;\\n        }\\n\\n        while(first!=NULL){\\n            int sum= carry+ first->val;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            first=first->next; \\n        }\\n        while(second!=NULL){\\n            int sum= carry+ second->val;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            second=second->next;\\n        }\\n        while(carry != 0){\\n            int sum= carry;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n        }\\n        return head;\\n    }\\n\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=ReverseLL(l1);\\n        l2=ReverseLL(l2);\\n\\n        ListNode* ansLL= Addition(l1,l2);\\n\\n        ansLL= ReverseLL(ansLL);\\n        return ansLL;\\n    }\\n};\\n```\\n# Code2 (Addition Function Short Approach in one Loop)\\n```\\n    ListNode* Addition(ListNode*first, ListNode*second){\\n        int carry=0;\\n        ListNode*head=NULL;\\n        ListNode*tail=NULL;\\n\\n        while(first != NULL   ||   second != NULL   ||   carry != 0){\\n            int val1=0;\\n            if(first!=NULL) val1=first->val;\\n\\n            int val2=0;\\n            if(second!=NULL) val2=second->val;\\n\\n            int sum= val1 + val2 + carry;\\n\\n            carry= sum/10;\\n            int digit= sum%10;\\n\\n            InsertAtTail(head,tail,digit);\\n\\n            if(first!=NULL) first=first->next; \\n            if(second!=NULL) second=second->next;\\n        }\\n\\n        return head;\\n    }\\n    \\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    ListNode* ReverseLL(ListNode* &head){\\n        if(head==NULL  ||  head->next==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n\\n        while(curr != NULL){\\n            ListNode* next= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n\\n    void InsertAtTail(ListNode*&head, ListNode*&tail, int val){\\n        ListNode* temp=new ListNode(val);\\n        if(head==NULL){\\n            head= temp;\\n            tail=head;\\n            return;\\n        }\\n        else{\\n            tail->next=temp;\\n            tail=tail->next;\\n        }\\n    }\\n\\n    ListNode* Addition(ListNode*first, ListNode*second){\\n        int carry=0;\\n        ListNode*head=NULL;\\n        ListNode*tail=NULL;\\n\\n        while(first != NULL   &&   second != NULL){\\n            int sum= first->val + second->val + carry;\\n            carry= sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            first=first->next; \\n            second=second->next;\\n        }\\n\\n        while(first!=NULL){\\n            int sum= carry+ first->val;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            first=first->next; \\n        }\\n        while(second!=NULL){\\n            int sum= carry+ second->val;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n            second=second->next;\\n        }\\n        while(carry != 0){\\n            int sum= carry;\\n            carry=sum/10;\\n            int digit= sum%10;\\n            InsertAtTail(head,tail,digit);\\n        }\\n        return head;\\n    }\\n\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=ReverseLL(l1);\\n        l2=ReverseLL(l2);\\n\\n        ListNode* ansLL= Addition(l1,l2);\\n\\n        ansLL= ReverseLL(ansLL);\\n        return ansLL;\\n    }\\n};\\n```\n```\\n    ListNode* Addition(ListNode*first, ListNode*second){\\n        int carry=0;\\n        ListNode*head=NULL;\\n        ListNode*tail=NULL;\\n\\n        while(first != NULL   ||   second != NULL   ||   carry != 0){\\n            int val1=0;\\n            if(first!=NULL) val1=first->val;\\n\\n            int val2=0;\\n            if(second!=NULL) val2=second->val;\\n\\n            int sum= val1 + val2 + carry;\\n\\n            carry= sum/10;\\n            int digit= sum%10;\\n\\n            InsertAtTail(head,tail,digit);\\n\\n            if(first!=NULL) first=first->next; \\n            if(second!=NULL) second=second->next;\\n        }\\n\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776587,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n     {\\n     stack<int> s1,s2;\\n\\t\\t\\t\\t\\twhile(l1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.push(l1->val);\\n\\t\\t\\t\\t\\t\\tl1=l1->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(l2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.push(l2->val);\\n\\t\\t\\t\\t\\t\\tl2=l2->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tListNode* dummy=new ListNode(0);\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\twhile(!s1.empty() || !s2.empty())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!s1.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s1.top();\\n\\t\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!s2.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s2.top();;\\n\\t\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdummy->val=sum%10;\\n\\t\\t\\t\\t\\t\\tListNode* head=new ListNode(sum/10);\\n\\t\\t\\t\\t\\t\\thead->next=dummy;\\n\\t\\t\\t\\t\\t\\tdummy=head;\\n\\t\\t\\t\\t\\t\\tsum/=10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dummy->val==0? dummy->next:dummy;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n     {\\n     stack<int> s1,s2;\\n\\t\\t\\t\\t\\twhile(l1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.push(l1->val);\\n\\t\\t\\t\\t\\t\\tl1=l1->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(l2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.push(l2->val);\\n\\t\\t\\t\\t\\t\\tl2=l2->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tListNode* dummy=new ListNode(0);\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\twhile(!s1.empty() || !s2.empty())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!s1.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s1.top();\\n\\t\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!s2.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s2.top();;\\n\\t\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdummy->val=sum%10;\\n\\t\\t\\t\\t\\t\\tListNode* head=new ListNode(sum/10);\\n\\t\\t\\t\\t\\t\\thead->next=dummy;\\n\\t\\t\\t\\t\\t\\tdummy=head;\\n\\t\\t\\t\\t\\t\\tsum/=10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dummy->val==0? dummy->next:dummy;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776112,
                "title": "c-reverses-linked-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n The code effectively adds two numbers represented as linked lists and returns the result as a new linked list. The reverse function is used to simplify the addition process by reversing the linked lists before performing the addition of digits.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n+m)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int reverse(ListNode* head, ListNode*& prev) {\\n        ListNode* ptr = head;\\n        ListNode* next = NULL;\\n        int len = 0;\\n        while (ptr) {\\n            next = ptr->next;\\n            ptr->next = prev;\\n            prev = ptr;\\n            ptr = next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = nullptr;\\n        ListNode* r2 = nullptr;\\n\\n        int len1 = reverse(l1, r1);\\n        int len2 = reverse(l2, r2);\\n\\n        if (len1 < len2) {\\n            swap(len1, len2);\\n            swap(r1, r2);\\n        }\\n\\n        int carry = 0;\\n        ListNode* ptr1 = r1;\\n        ListNode* ptr2 = r2;\\n        ListNode* ans = NULL;\\n        ListNode* next = NULL;\\n\\n        while (ptr1) {\\n            if (ptr2) {\\n                ptr1->val += ptr2->val + carry;\\n                ptr2 = ptr2->next;\\n            } \\n            else {\\n                ptr1->val += carry;\\n            }\\n\\n            carry = ptr1->val / 10;\\n            ptr1->val %= 10;\\n\\n            next = ptr1->next;\\n            ptr1->next = ans;\\n            ans = ptr1;\\n            ptr1 = next;\\n        }\\n\\n        if (carry == 1) {\\n            ListNode* newNode = new ListNode(1);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Reverse the linked list pointed by \\'head\\', update \\'prev\\' to point to the new head.\\n    // Returns the length of the reversed list.\\n    int reverse(ListNode* head, ListNode*& prev) {\\n        ListNode* ptr = head;\\n        ListNode* next = NULL;\\n        int len = 0;\\n        while (ptr) {\\n            next = ptr->next;\\n            ptr->next = prev;\\n            prev = ptr;\\n            ptr = next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    // Main function to add two numbers represented as linked lists.\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = nullptr;\\n        ListNode* r2 = nullptr;\\n\\n        // Reverse both linked lists to simplify addition.\\n        int len1 = reverse(l1, r1);\\n        int len2 = reverse(l2, r2);\\n\\n        // Ensure \\'r1\\' represents the longer number and \\'r2\\' represents the shorter number.\\n        if (len1 < len2) {\\n            swap(len1, len2);\\n            swap(r1, r2);\\n        }\\n\\n        int carry = 0;\\n        ListNode* ptr1 = r1;\\n        ListNode* ptr2 = r2;\\n        ListNode* ans = NULL;\\n        ListNode* next = NULL;\\n\\n        // Iterate through the longer list and add corresponding digits from the shorter list.\\n        while (ptr1) {\\n            if (ptr2) {\\n                ptr1->val += ptr2->val + carry;\\n                ptr2 = ptr2->next;\\n            } \\n            else {\\n                ptr1->val += carry;\\n            }\\n\\n            // Update carry and calculate new value for the current digit.\\n            carry = ptr1->val / 10;\\n            ptr1->val %= 10;\\n\\n            // Reverse the processed node and move to the next node.\\n            next = ptr1->next;\\n            ptr1->next = ans;\\n            ans = ptr1;\\n            ptr1 = next;\\n        }\\n\\n        // If there is any carry left after processing all digits, add it as a new node.\\n        if (carry == 1) {\\n            ListNode* newNode = new ListNode(1);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int reverse(ListNode* head, ListNode*& prev) {\\n        ListNode* ptr = head;\\n        ListNode* next = NULL;\\n        int len = 0;\\n        while (ptr) {\\n            next = ptr->next;\\n            ptr->next = prev;\\n            prev = ptr;\\n            ptr = next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = nullptr;\\n        ListNode* r2 = nullptr;\\n\\n        int len1 = reverse(l1, r1);\\n        int len2 = reverse(l2, r2);\\n\\n        if (len1 < len2) {\\n            swap(len1, len2);\\n            swap(r1, r2);\\n        }\\n\\n        int carry = 0;\\n        ListNode* ptr1 = r1;\\n        ListNode* ptr2 = r2;\\n        ListNode* ans = NULL;\\n        ListNode* next = NULL;\\n\\n        while (ptr1) {\\n            if (ptr2) {\\n                ptr1->val += ptr2->val + carry;\\n                ptr2 = ptr2->next;\\n            } \\n            else {\\n                ptr1->val += carry;\\n            }\\n\\n            carry = ptr1->val / 10;\\n            ptr1->val %= 10;\\n\\n            next = ptr1->next;\\n            ptr1->next = ans;\\n            ans = ptr1;\\n            ptr1 = next;\\n        }\\n\\n        if (carry == 1) {\\n            ListNode* newNode = new ListNode(1);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Reverse the linked list pointed by \\'head\\', update \\'prev\\' to point to the new head.\\n    // Returns the length of the reversed list.\\n    int reverse(ListNode* head, ListNode*& prev) {\\n        ListNode* ptr = head;\\n        ListNode* next = NULL;\\n        int len = 0;\\n        while (ptr) {\\n            next = ptr->next;\\n            ptr->next = prev;\\n            prev = ptr;\\n            ptr = next;\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    // Main function to add two numbers represented as linked lists.\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = nullptr;\\n        ListNode* r2 = nullptr;\\n\\n        // Reverse both linked lists to simplify addition.\\n        int len1 = reverse(l1, r1);\\n        int len2 = reverse(l2, r2);\\n\\n        // Ensure \\'r1\\' represents the longer number and \\'r2\\' represents the shorter number.\\n        if (len1 < len2) {\\n            swap(len1, len2);\\n            swap(r1, r2);\\n        }\\n\\n        int carry = 0;\\n        ListNode* ptr1 = r1;\\n        ListNode* ptr2 = r2;\\n        ListNode* ans = NULL;\\n        ListNode* next = NULL;\\n\\n        // Iterate through the longer list and add corresponding digits from the shorter list.\\n        while (ptr1) {\\n            if (ptr2) {\\n                ptr1->val += ptr2->val + carry;\\n                ptr2 = ptr2->next;\\n            } \\n            else {\\n                ptr1->val += carry;\\n            }\\n\\n            // Update carry and calculate new value for the current digit.\\n            carry = ptr1->val / 10;\\n            ptr1->val %= 10;\\n\\n            // Reverse the processed node and move to the next node.\\n            next = ptr1->next;\\n            ptr1->next = ans;\\n            ans = ptr1;\\n            ptr1 = next;\\n        }\\n\\n        // If there is any carry left after processing all digits, add it as a new node.\\n        if (carry == 1) {\\n            ListNode* newNode = new ListNode(1);\\n            newNode->next = ans;\\n            ans = newNode;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775861,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        num1,num2=0,0\\n        while l1!=None:\\n            num1=num1*10+l1.val\\n            l1=l1.next\\n\\n        while l2!=None:\\n            num2=num2*10+l2.val\\n            l2=l2.next\\n\\n        dummylist=dummy=ListNode(0)\\n\\n        ans=str(num1+num2)\\n        for i in ans:\\n            dummy.next=ListNode(i)\\n            dummy=dummy.next\\n\\n        return dummylist.next                     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        num1,num2=0,0\\n        while l1!=None:\\n            num1=num1*10+l1.val\\n            l1=l1.next\\n\\n        while l2!=None:\\n            num2=num2*10+l2.val\\n            l2=l2.next\\n\\n        dummylist=dummy=ListNode(0)\\n\\n        ans=str(num1+num2)\\n        for i in ans:\\n            dummy.next=ListNode(i)\\n            dummy=dummy.next\\n\\n        return dummylist.next                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775839,
                "title": "python-left-pad-then-recursion",
                "content": "# Intuition\\nIf we made sure the lists were the same length, it would simplify the problem. We can do that with a way to measure length and then left pad 0 values for the difference\\n\\n# Approach\\n1. Determine the lengths of both linked lists\\n2. prepend pad 0 value nodes on the smaller list to get lists of equal length\\n3. Make recursive calls to add values, then post call process each node\\'s value along with the results of the previous call.\\n4. Make sure to account for the final possible carry digit before returning answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\ndef add(l1: Optional[ListNode], l2: Optional[ListNode]) -> tuple[int, Union[None, ListNode]]:\\n    if not l1 or not l2:\\n        #print(f\"reached the end\")\\n        return (0, None)\\n    addend_carry, result = add(l1.next, l2.next)\\n    sum_carry, val = divmod(l1.val + l2.val + addend_carry, 10)\\n    #print(f\"{l1.val} + {l2.val} + {addend_carry} = {val} carry {sum_carry}\")\\n\\n    result = ListNode(val, result)\\n    return (sum_carry, result)\\n\\ndef length(ln: Optional[ListNode]) -> int:\\n    if not ln:\\n        return 0\\n    return length(ln.next) + 1\\n\\ndef left_pad(padding: int, ln: ListNode) -> ListNode:\\n    if padding <= 0:\\n        return ln\\n    return left_pad(padding - 1, ListNode(0, ln))\\n\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        l1_size = length(l1)\\n        l2_size = length(l2)\\n\\n        padded_l1 = left_pad(max(0, l2_size - l1_size), l1)\\n        padded_l2 = left_pad(max(0, l1_size - l2_size), l2)\\n\\n        carry, result = add(padded_l1, padded_l2)\\n        if carry:\\n            result = ListNode(carry, result)\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\ndef add(l1: Optional[ListNode], l2: Optional[ListNode]) -> tuple[int, Union[None, ListNode]]:\\n    if not l1 or not l2:\\n        #print(f\"reached the end\")\\n        return (0, None)\\n    addend_carry, result = add(l1.next, l2.next)\\n    sum_carry, val = divmod(l1.val + l2.val + addend_carry, 10)\\n    #print(f\"{l1.val} + {l2.val} + {addend_carry} = {val} carry {sum_carry}\")\\n\\n    result = ListNode(val, result)\\n    return (sum_carry, result)\\n\\ndef length(ln: Optional[ListNode]) -> int:\\n    if not ln:\\n        return 0\\n    return length(ln.next) + 1\\n\\ndef left_pad(padding: int, ln: ListNode) -> ListNode:\\n    if padding <= 0:\\n        return ln\\n    return left_pad(padding - 1, ListNode(0, ln))\\n\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        l1_size = length(l1)\\n        l2_size = length(l2)\\n\\n        padded_l1 = left_pad(max(0, l2_size - l1_size), l1)\\n        padded_l2 = left_pad(max(0, l1_size - l2_size), l2)\\n\\n        carry, result = add(padded_l1, padded_l2)\\n        if carry:\\n            result = ListNode(carry, result)\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775741,
                "title": "c-o-n-reverse-list",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head){\\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        \\n        while(p!=NULL){\\n            ListNode* on=p->next; // keep track of original next node\\n            p->next=q; // reversing links\\n            q=p;\\n            p=on;\\n        }\\n        return q;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* head1, ListNode* head2) {\\n        ListNode* p=reverse(head1);\\n        ListNode* q=reverse(head2);\\n        \\n        ListNode *head, *last;\\n        head=last=new ListNode(-1); // pointers to new list\\n        \\n        int carry=0;\\n        while(p!=NULL || q!=NULL){\\n            int d=(p!=NULL ? p->val:0) + (q!=NULL ? q->val:0) + carry;\\n            \\n            ListNode *temp=new ListNode(d%10);\\n            last->next=temp;\\n            last=temp;\\n            \\n            carry=d/10;\\n            \\n            if(p) p=p->next;\\n            if(q) q=q->next;\\n        }\\n        \\n        if(carry!=0){\\n            ListNode *temp=new ListNode(carry);\\n            last->next=temp;\\n            last=temp;\\n        }\\n        \\n        head=head->next; // since head was pointing to dummy node\\n        head=reverse(head);\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head){\\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        \\n        while(p!=NULL){\\n            ListNode* on=p->next; // keep track of original next node\\n            p->next=q; // reversing links\\n            q=p;\\n            p=on;\\n        }\\n        return q;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* head1, ListNode* head2) {\\n        ListNode* p=reverse(head1);\\n        ListNode* q=reverse(head2);\\n        \\n        ListNode *head, *last;\\n        head=last=new ListNode(-1); // pointers to new list\\n        \\n        int carry=0;\\n        while(p!=NULL || q!=NULL){\\n            int d=(p!=NULL ? p->val:0) + (q!=NULL ? q->val:0) + carry;\\n            \\n            ListNode *temp=new ListNode(d%10);\\n            last->next=temp;\\n            last=temp;\\n            \\n            carry=d/10;\\n            \\n            if(p) p=p->next;\\n            if(q) q=q->next;\\n        }\\n        \\n        if(carry!=0){\\n            ListNode *temp=new ListNode(carry);\\n            last->next=temp;\\n            last=temp;\\n        }\\n        \\n        head=head->next; // since head was pointing to dummy node\\n        head=reverse(head);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775703,
                "title": "simplest-code-beginner-friendly-code-and-intuition-c-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head;\\n        while (curr){\\n            ListNode* forward= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr= forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2){\\n        ListNode* head= new ListNode(-1);\\n        ListNode* curr= head;\\n        int carry=0;\\n        while (l1!=NULL || l2!=NULL || carry>0){\\n            int v1=0, v2=0;\\n            if (l1)v1= l1->val;\\n            if (l2)v2= l2->val;\\n            int sum= v1+v2+carry;\\n            carry= sum/10;\\n            sum= sum%10;\\n            curr->next= new ListNode(sum);\\n            curr= curr->next;\\n            if (l1)l1= l1->next;\\n            if (l2)l2= l2->next;\\n        }\\n        head= head->next;\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1= reverse(l1);\\n        l2= reverse(l2);\\n        ListNode* ans= add(l1,l2);\\n        ans= reverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head;\\n        while (curr){\\n            ListNode* forward= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr= forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2){\\n        ListNode* head= new ListNode(-1);\\n        ListNode* curr= head;\\n        int carry=0;\\n        while (l1!=NULL || l2!=NULL || carry>0){\\n            int v1=0, v2=0;\\n            if (l1)v1= l1->val;\\n            if (l2)v2= l2->val;\\n            int sum= v1+v2+carry;\\n            carry= sum/10;\\n            sum= sum%10;\\n            curr->next= new ListNode(sum);\\n            curr= curr->next;\\n            if (l1)l1= l1->next;\\n            if (l2)l2= l2->next;\\n        }\\n        head= head->next;\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1= reverse(l1);\\n        l2= reverse(l2);\\n        ListNode* ans= add(l1,l2);\\n        ans= reverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699655,
                "title": "simple-c-solution-using-stack",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        while (l1) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int carry = 0;\\n        ListNode* dummy = new ListNode(0);\\n        while (!s1.empty() || !s2.empty() || carry) {\\n            int sum = carry;\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n            carry = sum / 10;\\n            ListNode* node = new ListNode(sum % 10);\\n            node->next = dummy->next;\\n            dummy->next = node;\\n        }\\n        return dummy->next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n        while (l1) {\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n        while (l2) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n        int carry = 0;\\n        ListNode* dummy = new ListNode(0);\\n        while (!s1.empty() || !s2.empty() || carry) {\\n            int sum = carry;\\n            if (!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n            carry = sum / 10;\\n            ListNode* node = new ListNode(sum % 10);\\n            node->next = dummy->next;\\n            dummy->next = node;\\n        }\\n        return dummy->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564872,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n     {\\n     stack<int> s1,s2;\\n\\t\\t\\t\\t\\twhile(l1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.push(l1->val);\\n\\t\\t\\t\\t\\t\\tl1=l1->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(l2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.push(l2->val);\\n\\t\\t\\t\\t\\t\\tl2=l2->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tListNode* dummy=new ListNode(0);\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\twhile(!s1.empty() || !s2.empty())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!s1.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s1.top();\\n\\t\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!s2.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s2.top();;\\n\\t\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdummy->val=sum%10;\\n\\t\\t\\t\\t\\t\\tListNode* head=new ListNode(sum/10);\\n\\t\\t\\t\\t\\t\\thead->next=dummy;\\n\\t\\t\\t\\t\\t\\tdummy=head;\\n\\t\\t\\t\\t\\t\\tsum/=10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dummy->val==0? dummy->next:dummy;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n     {\\n     stack<int> s1,s2;\\n\\t\\t\\t\\t\\twhile(l1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts1.push(l1->val);\\n\\t\\t\\t\\t\\t\\tl1=l1->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(l2)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts2.push(l2->val);\\n\\t\\t\\t\\t\\t\\tl2=l2->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tListNode* dummy=new ListNode(0);\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\twhile(!s1.empty() || !s2.empty())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(!s1.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s1.top();\\n\\t\\t\\t\\t\\t\\t\\ts1.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!s2.empty())\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tsum+=s2.top();;\\n\\t\\t\\t\\t\\t\\t\\ts2.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tdummy->val=sum%10;\\n\\t\\t\\t\\t\\t\\tListNode* head=new ListNode(sum/10);\\n\\t\\t\\t\\t\\t\\thead->next=dummy;\\n\\t\\t\\t\\t\\t\\tdummy=head;\\n\\t\\t\\t\\t\\t\\tsum/=10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dummy->val==0? dummy->next:dummy;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275240,
                "title": "easy-python3-solution-no-recursion-no-reverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First convert the linkedlist 1 as an integer number.\\n2. Again convert the linkedlist 2 as another integer number like step 1.\\n3. Add both integer number and convert it as a string value.\\n```\\nSUM = str(int(val1) + int(val2))\\n```\\n4. Create a new linklist from the added string value.\\n```\\nhead = ListNode()\\ncurr = head\\nfor i in range(len(SUM)):\\n    curr.next = ListNode(SUM[i])\\n    curr = curr.next\\nreturn head.next\\n```\\n\\nHappy Leetcoding.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        val1 = \\'\\'\\n        itr = l1\\n        while itr:\\n            val1 += str(itr.val)\\n            itr = itr.next\\n        val2 = \\'\\'\\n        itr = l2\\n        while itr:\\n            val2 += str(itr.val)\\n            itr = itr.next\\n        SUM = str(int(val1) + int(val2))\\n\\n        head = ListNode()\\n        curr = head\\n        for i in range(len(SUM)):\\n            curr.next = ListNode(SUM[i])\\n            curr = curr.next\\n        return head.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nSUM = str(int(val1) + int(val2))\\n```\n```\\nhead = ListNode()\\ncurr = head\\nfor i in range(len(SUM)):\\n    curr.next = ListNode(SUM[i])\\n    curr = curr.next\\nreturn head.next\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        val1 = \\'\\'\\n        itr = l1\\n        while itr:\\n            val1 += str(itr.val)\\n            itr = itr.next\\n        val2 = \\'\\'\\n        itr = l2\\n        while itr:\\n            val2 += str(itr.val)\\n            itr = itr.next\\n        SUM = str(int(val1) + int(val2))\\n\\n        head = ListNode()\\n        curr = head\\n        for i in range(len(SUM)):\\n            curr.next = ListNode(SUM[i])\\n            curr = curr.next\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274631,
                "title": "445-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two stacks stack1 and stack2 to store the values of each linked list.\\n2. Traverse the first linked list l1 and push its values onto stack1.\\n3. Traverse the second linked list l2 and push its values onto stack2.\\n4. Initialize variables for sum and carry. Set result to None.\\n5. Pop values from the stacks and add them together until both stacks are empty:\\na. If stack1 is not empty, pop its top value as val1. Otherwise, set val1 to 0.\\nb. If stack2 is not empty, pop its top value as val2. Otherwise, set val2 to 0.\\nc. Calculate the sum of val1, val2, and carry and get the quotient and remainder using divmod(). Set carry to the quotient and val to the remainder.\\nd. Create a new node to store the sum as new_node with value val and set its next to result.\\ne. Update result to new_node.\\n6. Return result or ListNode(0) if result is None.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        # Create two stacks to store the values of each linked list\\n        stack1, stack2 = [], []\\n\\n        # Traverse the first linked list and push its values onto stack1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        # Traverse the second linked list and push its values onto stack2\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n\\n        # Initialize variables for sum and carry\\n        carry = 0\\n        result = None\\n\\n        # Pop values from the stacks and add them together until both stacks are empty\\n        while stack1 or stack2 or carry:\\n            val1 = stack1.pop() if stack1 else 0\\n            val2 = stack2.pop() if stack2 else 0\\n            carry, val = divmod(val1 + val2 + carry, 10)\\n\\n            # Create a new node to store the sum and add it to the front of the result linked list\\n            new_node = ListNode(val)\\n            new_node.next = result\\n            result = new_node\\n\\n        return result or ListNode(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        # Create two stacks to store the values of each linked list\\n        stack1, stack2 = [], []\\n\\n        # Traverse the first linked list and push its values onto stack1\\n        while l1:\\n            stack1.append(l1.val)\\n            l1 = l1.next\\n\\n        # Traverse the second linked list and push its values onto stack2\\n        while l2:\\n            stack2.append(l2.val)\\n            l2 = l2.next\\n\\n        # Initialize variables for sum and carry\\n        carry = 0\\n        result = None\\n\\n        # Pop values from the stacks and add them together until both stacks are empty\\n        while stack1 or stack2 or carry:\\n            val1 = stack1.pop() if stack1 else 0\\n            val2 = stack2.pop() if stack2 else 0\\n            carry, val = divmod(val1 + val2 + carry, 10)\\n\\n            # Create a new node to store the sum and add it to the front of the result linked list\\n            new_node = ListNode(val)\\n            new_node.next = result\\n            result = new_node\\n\\n        return result or ListNode(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614311,
                "title": "c-easy-to-understand-use-reverse-beginner-level",
                "content": "```\\n// this problem is similar to Add two Numbers the main diffence here in this problem is we have to revese the the given two ListNode  and then pass it to addTwoNumbers(first part) . \\n//we have to revese the returned ListNode from addTwoNumbers(first part) and that will be our ans.\\n\\nclass Solution {\\npublic:\\n    \\n   ListNode* reverseList(ListNode* head) {\\n        if(head==0||head->next==0)return head;\\n        ListNode*p=0;\\n        ListNode*c=head;\\n        ListNode*n=head->next;\\n        while(c!=0&&n!=0){\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            n=n->next;\\n            \\n        }\\n        c->next=p;\\n        return c;\\n   }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(l1==0)return l2;\\n        if(l2==0)return l1;\\n        ListNode*h1=reverseList(l1);\\n         ListNode*h2=reverseList(l2);\\n         \\n        ListNode*dummy=new ListNode(0);\\n        ListNode*temp1=dummy;\\n        int carry=0;\\n        while(h1||h2||carry){\\n            int sum=0;\\n            if(h1!=0){\\n             sum+=h1->val;\\n            h1=h1->next;}\\n            if(h2!=0){\\n            sum+=h2->val;\\n            h2=h2->next;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ListNode* temp=new ListNode(sum);\\n            temp1->next=temp;\\n            temp1=temp1->next;\\n        }\\n       ListNode*ans=reverseList(dummy->next);\\n           return ans;\\n    }\\n};\\n\\n\\n\\n// please upvote if you find it helpful\\n```",
                "solutionTags": [],
                "code": "```\\n// this problem is similar to Add two Numbers the main diffence here in this problem is we have to revese the the given two ListNode  and then pass it to addTwoNumbers(first part) . \\n//we have to revese the returned ListNode from addTwoNumbers(first part) and that will be our ans.\\n\\nclass Solution {\\npublic:\\n    \\n   ListNode* reverseList(ListNode* head) {\\n        if(head==0||head->next==0)return head;\\n        ListNode*p=0;\\n        ListNode*c=head;\\n        ListNode*n=head->next;\\n        while(c!=0&&n!=0){\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            n=n->next;\\n            \\n        }\\n        c->next=p;\\n        return c;\\n   }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(l1==0)return l2;\\n        if(l2==0)return l1;\\n        ListNode*h1=reverseList(l1);\\n         ListNode*h2=reverseList(l2);\\n         \\n        ListNode*dummy=new ListNode(0);\\n        ListNode*temp1=dummy;\\n        int carry=0;\\n        while(h1||h2||carry){\\n            int sum=0;\\n            if(h1!=0){\\n             sum+=h1->val;\\n            h1=h1->next;}\\n            if(h2!=0){\\n            sum+=h2->val;\\n            h2=h2->next;\\n            }\\n            sum+=carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ListNode* temp=new ListNode(sum);\\n            temp1->next=temp;\\n            temp1=temp1->next;\\n        }\\n       ListNode*ans=reverseList(dummy->next);\\n           return ans;\\n    }\\n};\\n\\n\\n\\n// please upvote if you find it helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494357,
                "title": "c-o-n-recursion-w-o-reversing-explaination-easy",
                "content": "**Idea**\\nFirst forget everything and assume both list have equal lengths. Then below are the steps\\n**steps** \\n\\n* `add(l1, l2)`\\n1. perform addition at next level \\n`ListNode* nxt = add(l1 -> next, l2 -> next)`\\n2. pick-out carry from resulting node it returned \\n`int carry = (nxt -> val) / 10`\\n   `nxt -> val %= 10`\\n3. add values at current level \\n`int sum = l1 -> val + l2 -> val + carry`\\n`ListNode *curr = new ListNode(sum)`\\n4. join current node with next level and return it\\n`curr -> next = nxt`\\n`return curr`\\n\\nNow when `l1` length greater than `l2` length, just make sure that you don\\'t go to next level of `l2` until both list have reached next level i.e only move `l1` till then.\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    \\n    // get length of list\\n    int get_len(ListNode* l)\\n    {\\n        int len = 0;\\n        while(l)\\n            l = l -> next, len++;\\n        return len;\\n    }\\n    \\n    ListNode* add(ListNode *l1, ListNode *l2, int diff)\\n    {\\n        if(!l1 || !l2)  return nullptr;\\n        \\n        ListNode *nxt;\\n        \\n        // with un-equal lengths only move to next node of big length list\\n        if(diff)    nxt = add(l1 -> next, l2, diff - 1);\\n        else    nxt = add(l1 -> next, l2 -> next, diff);\\n        \\n        int carry = 0;\\n        if(nxt)             \\n        {\\n            carry = (nxt -> val) / 10;\\n            nxt -> val %= 10;    \\n        }\\n        \\n        ListNode *curr = new ListNode(0);\\n        if(diff)    curr -> val = carry + l1 -> val;\\n        else    curr -> val = carry + l1 -> val + l2 -> val;\\n        \\n        curr -> next = nxt;\\n        return curr;\\n    }\\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        int len1 = get_len(l1), len2 = get_len(l2);\\n        \\n        ListNode *res;\\n        \\n        // first argument -> list with greater length\\n        // third argument -> current difference in lengths b/w lists\\n        if(len1 >= len2)\\n            res = add(l1, l2, len1 - len2);\\n        else \\n            res = add(l2, l1, len2 - len1);\\n        \\n        // pick out carry and generate new node in front\\n        if(res -> val > 9)\\n        {\\n            ListNode *temp = res;\\n            res = new ListNode((temp -> val) / 10);\\n            temp -> val %= 10;\\n            res -> next = temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote if it was of any help** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // get length of list\\n    int get_len(ListNode* l)\\n    {\\n        int len = 0;\\n        while(l)\\n            l = l -> next, len++;\\n        return len;\\n    }\\n    \\n    ListNode* add(ListNode *l1, ListNode *l2, int diff)\\n    {\\n        if(!l1 || !l2)  return nullptr;\\n        \\n        ListNode *nxt;\\n        \\n        // with un-equal lengths only move to next node of big length list\\n        if(diff)    nxt = add(l1 -> next, l2, diff - 1);\\n        else    nxt = add(l1 -> next, l2 -> next, diff);\\n        \\n        int carry = 0;\\n        if(nxt)             \\n        {\\n            carry = (nxt -> val) / 10;\\n            nxt -> val %= 10;    \\n        }\\n        \\n        ListNode *curr = new ListNode(0);\\n        if(diff)    curr -> val = carry + l1 -> val;\\n        else    curr -> val = carry + l1 -> val + l2 -> val;\\n        \\n        curr -> next = nxt;\\n        return curr;\\n    }\\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        int len1 = get_len(l1), len2 = get_len(l2);\\n        \\n        ListNode *res;\\n        \\n        // first argument -> list with greater length\\n        // third argument -> current difference in lengths b/w lists\\n        if(len1 >= len2)\\n            res = add(l1, l2, len1 - len2);\\n        else \\n            res = add(l2, l1, len2 - len1);\\n        \\n        // pick out carry and generate new node in front\\n        if(res -> val > 9)\\n        {\\n            ListNode *temp = res;\\n            res = new ListNode((temp -> val) / 10);\\n            temp -> val %= 10;\\n            res -> next = temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351877,
                "title": "cpp-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n        ListNode * temp = l1;\\n        \\n        while(temp){\\n            s1.push(temp->val);\\n            temp = temp -> next;\\n        }\\n        temp = l2;\\n        while(temp){\\n            s2.push(temp->val);\\n            temp = temp -> next;\\n        }\\n        \\n        int carry = 0;\\n        ListNode * res= NULL;\\n        \\n        while(!s1.empty() || !s2.empty() || carry == 1){\\n            int ans = (s1.empty() ? 0 : s1.top()) + (s2.empty() ? 0 : s2.top()) + carry;\\n            if(!s1.empty()) s1.pop();\\n            if(!s2.empty()) s2.pop();\\n            ListNode * temp = new ListNode(ans % 10);\\n            temp -> next = res;\\n            res = temp;\\n            carry = ans / 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n        ListNode * temp = l1;\\n        \\n        while(temp){\\n            s1.push(temp->val);\\n            temp = temp -> next;\\n        }\\n        temp = l2;\\n        while(temp){\\n            s2.push(temp->val);\\n            temp = temp -> next;\\n        }\\n        \\n        int carry = 0;\\n        ListNode * res= NULL;\\n        \\n        while(!s1.empty() || !s2.empty() || carry == 1){\\n            int ans = (s1.empty() ? 0 : s1.top()) + (s2.empty() ? 0 : s2.top()) + carry;\\n            if(!s1.empty()) s1.pop();\\n            if(!s2.empty()) s2.pop();\\n            ListNode * temp = new ListNode(ans % 10);\\n            temp -> next = res;\\n            res = temp;\\n            carry = ans / 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939999,
                "title": "java-o-n-easy",
                "content": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=rev(l1);\\n        l2=rev(l2);\\n        ListNode result=addTwoNum(l1,l2);\\n        return rev(result);\\n    }\\n    public ListNode rev(ListNode node){\\n        ListNode prev = null;\\n        ListNode current = node;\\n        ListNode next = null;\\n        while (current != null) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        node = prev;\\n        return node;\\n    }\\n    public ListNode addTwoNum(ListNode l1, ListNode l2) {\\n        ListNode result=new ListNode(0);\\n        ListNode temp=result;\\n        int bit=0;\\n        while(l1!=null && l2!=null){\\n            int sum=l1.val+l2.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l1=l1.next;\\n            l2=l2.next;\\n        }\\n        while(l1!=null){\\n            int sum=l1.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l1=l1.next;\\n        }\\n        while(l2!=null){\\n            int sum=l2.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l2=l2.next;\\n        }\\n        if(bit > 0){\\n            temp.next=new ListNode(1);\\n        }\\n        result=result.next;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1=rev(l1);\\n        l2=rev(l2);\\n        ListNode result=addTwoNum(l1,l2);\\n        return rev(result);\\n    }\\n    public ListNode rev(ListNode node){\\n        ListNode prev = null;\\n        ListNode current = node;\\n        ListNode next = null;\\n        while (current != null) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        node = prev;\\n        return node;\\n    }\\n    public ListNode addTwoNum(ListNode l1, ListNode l2) {\\n        ListNode result=new ListNode(0);\\n        ListNode temp=result;\\n        int bit=0;\\n        while(l1!=null && l2!=null){\\n            int sum=l1.val+l2.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l1=l1.next;\\n            l2=l2.next;\\n        }\\n        while(l1!=null){\\n            int sum=l1.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l1=l1.next;\\n        }\\n        while(l2!=null){\\n            int sum=l2.val;\\n            if(bit > 0){\\n                sum=sum+bit;\\n                bit=0;\\n            }\\n            if(sum > 9){\\n                sum=sum%10;\\n                bit++;\\n            }\\n            temp.next=new ListNode(sum);\\n            temp=temp.next;\\n            l2=l2.next;\\n        }\\n        if(bit > 0){\\n            temp.next=new ListNode(1);\\n        }\\n        result=result.next;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861130,
                "title": "c-easy-to-understand-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1,s2;\\n        while(l1!=NULL){\\n            s1.push(l1->val);\\n            l1=l1->next;\\n        }\\n         while(l2!=NULL){\\n            s2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        ListNode* dummy=new ListNode(0);\\n        \\n       \\n        int carry=0;\\n        while(!s1.empty() || !s2.empty() || carry){\\n           int first=0,second=0;\\n            if(!s1.empty()){\\n               first= s1.top();\\n                s1.pop();\\n            }\\n           if(!s2.empty()){\\n               second= s2.top();\\n                s2.pop();\\n            }\\n            int sum=carry+first+second;\\n            carry=sum/10;\\n            ListNode* attach=new ListNode(sum%10); //bcz we can only attach <10 so thats why modulo of 10\\n            attach->next=dummy->next;\\n            dummy->next=attach;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1,s2;\\n        while(l1!=NULL){\\n            s1.push(l1->val);\\n            l1=l1->next;\\n        }\\n         while(l2!=NULL){\\n            s2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        ListNode* dummy=new ListNode(0);\\n        \\n       \\n        int carry=0;\\n        while(!s1.empty() || !s2.empty() || carry){\\n           int first=0,second=0;\\n            if(!s1.empty()){\\n               first= s1.top();\\n                s1.pop();\\n            }\\n           if(!s2.empty()){\\n               second= s2.top();\\n                s2.pop();\\n            }\\n            int sum=carry+first+second;\\n            carry=sum/10;\\n            ListNode* attach=new ListNode(sum%10); //bcz we can only attach <10 so thats why modulo of 10\\n            attach->next=dummy->next;\\n            dummy->next=attach;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845463,
                "title": "c-solution-using-stack-without-reversing-input-list",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n      ListNode *reverse(ListNode * head)\\n     {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != NULL) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n          head = prev;\\n          return prev;\\n    }\\n \\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode *h1=l1,*h2=l2,*tmp;\\n        int n1=0,n2=0;\\n        stack<int>s1,s2;\\n        vector<int>v;\\n        while(h1)\\n        {\\n            n1++;\\n            s1.push(h1->val);\\n            h1=h1->next;\\n        }\\n        while(h2)\\n        {\\n            n2++;\\n            s2.push(h2->val);\\n            h2=h2->next;\\n        }\\n        int x=0,y=0,sum=0,carry=0;\\n        \\n        \\n        ListNode *start,*l3;\\n        \\n        l3=new ListNode();\\n        start=l3;\\n        while(!s1.empty() || !s2.empty() || carry!=0 )\\n        {\\n            if(s1.empty())\\n                x=0;\\n            else{\\n                x=s1.top();\\n                s1.pop();\\n            }\\n            \\n             if(s2.empty())\\n                y=0;\\n            else{\\n                y=s2.top();\\n                s2.pop();\\n            }\\n            sum=x+y+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            tmp=new ListNode();\\n            tmp->val=sum;\\n            l3->next=tmp;\\n            l3=l3->next;\\n        }\\n        \\n        start = reverse(start->next);\\n        return start;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n      ListNode *reverse(ListNode * head)\\n     {\\n        ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n \\n        while (current != NULL) {\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n          head = prev;\\n          return prev;\\n    }\\n \\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode *h1=l1,*h2=l2,*tmp;\\n        int n1=0,n2=0;\\n        stack<int>s1,s2;\\n        vector<int>v;\\n        while(h1)\\n        {\\n            n1++;\\n            s1.push(h1->val);\\n            h1=h1->next;\\n        }\\n        while(h2)\\n        {\\n            n2++;\\n            s2.push(h2->val);\\n            h2=h2->next;\\n        }\\n        int x=0,y=0,sum=0,carry=0;\\n        \\n        \\n        ListNode *start,*l3;\\n        \\n        l3=new ListNode();\\n        start=l3;\\n        while(!s1.empty() || !s2.empty() || carry!=0 )\\n        {\\n            if(s1.empty())\\n                x=0;\\n            else{\\n                x=s1.top();\\n                s1.pop();\\n            }\\n            \\n             if(s2.empty())\\n                y=0;\\n            else{\\n                y=s2.top();\\n                s2.pop();\\n            }\\n            sum=x+y+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            tmp=new ListNode();\\n            tmp->val=sum;\\n            l3->next=tmp;\\n            l3=l3->next;\\n        }\\n        \\n        start = reverse(start->next);\\n        return start;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815651,
                "title": "c-easy-to-understand-basic-maths-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode *reverse(ListNode *head){\\n\\t\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\tListNode *curr=head,*prev=nullptr,*next;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tnext=curr->next;\\n\\t\\t\\t\\tcurr->next=prev;\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t\\tcurr=next;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev;\\n\\t\\t}\\n\\t\\tListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n\\t\\t\\t ListNode *p1=reverse(l1);\\n\\t\\t\\t ListNode *p2=reverse(l2);\\n\\t\\t\\t ListNode *temp=new ListNode(0);\\n\\t\\t\\t ListNode *t=temp;\\n\\t\\t\\t int carry=0;\\n\\t\\t\\t while(p1 && p2){\\n\\t\\t\\t\\t carry+=p1->val;\\n\\t\\t\\t\\t carry+=p2->val;\\n\\t\\t\\t\\t ListNode *var=new ListNode(carry%10);\\n\\t\\t\\t\\t t->next=var;\\n\\t\\t\\t\\t t=t->next;\\n\\t\\t\\t\\t carry/=10;\\n\\t\\t\\t\\t p1=p1->next;\\n\\t\\t\\t\\t p2=p2->next;\\n\\t\\t\\t }\\n\\t\\t\\twhile(p1){\\n\\t\\t\\t\\tcarry+=p1->val;\\n\\t\\t\\t\\t ListNode *var=new ListNode(carry%10);\\n\\t\\t\\t\\t t->next=var;\\n\\t\\t\\t\\t t=t->next;\\n\\t\\t\\t\\t  carry/=10;\\n\\t\\t\\t\\t p1=p1->next;   \\n\\t\\t\\t}\\n\\t\\t\\twhile(p2){\\n\\t\\t\\t\\tcarry+=p2->val;\\n\\t\\t\\t\\t ListNode *var=new ListNode(carry%10);\\n\\t\\t\\t\\t t->next=var;\\n\\t\\t\\t\\t t=t->next;\\n\\t\\t\\t\\t  carry/=10;\\n\\t\\t\\t\\t p2=p2->next;   \\n\\t\\t\\t}\\n\\t\\t\\t//if you still have carry>0 add it to your linked list\\n\\t\\t\\tif(carry>0){\\n\\t\\t\\t\\tListNode *var=new ListNode(carry%10);\\n\\t\\t\\t\\t t->next=var;\\n\\t\\t\\t\\t t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn reverse(temp->next);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode *reverse(ListNode *head){\\n\\t\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\tListNode *curr=head,*prev=nullptr,*next;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tnext=curr->next;\\n\\t\\t\\t\\tcurr->next=prev;\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t\\tcurr=next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1707722,
                "title": "python-simple-stack-solution-85-runtime",
                "content": "This could also be done using recursion however recursion will be similar(or a bit slower) as resursion also uses stack internally.\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        stack1, stack2, curr1, curr2, head, carry = [], [], l1, l2, ListNode(), 0\\n        while curr1 is not None:\\n            stack1.append(curr1.val)\\n            curr1 = curr1.next\\n        while curr2 is not None:\\n            stack2.append(curr2.val)\\n            curr2 = curr2.next\\n        l1, l2 = len(stack1), len(stack2)\\n        for _ in range(max(l1, l2)):\\n            a = 0 if l1 <= 0 else stack1.pop()\\n            b = 0 if l2 <= 0 else stack2.pop()\\n            l1 -= 1\\n            l2 -= 1\\n            sum = a+b+carry\\n            carry = sum//10\\n            temp = ListNode(sum%10, head.next)\\n            head.next = temp\\n        if carry != 0:\\n            temp = ListNode(carry, head.next)\\n            head.next = temp\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        stack1, stack2, curr1, curr2, head, carry = [], [], l1, l2, ListNode(), 0\\n        while curr1 is not None:\\n            stack1.append(curr1.val)\\n            curr1 = curr1.next\\n        while curr2 is not None:\\n            stack2.append(curr2.val)\\n            curr2 = curr2.next\\n        l1, l2 = len(stack1), len(stack2)\\n        for _ in range(max(l1, l2)):\\n            a = 0 if l1 <= 0 else stack1.pop()\\n            b = 0 if l2 <= 0 else stack2.pop()\\n            l1 -= 1\\n            l2 -= 1\\n            sum = a+b+carry\\n            carry = sum//10\\n            temp = ListNode(sum%10, head.next)\\n            head.next = temp\\n        if carry != 0:\\n            temp = ListNode(carry, head.next)\\n            head.next = temp\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642641,
                "title": "c-solution-easy-to-understand-without-reversing-linkedlist",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1;\\n        stack<int>s2;\\n        stack<int>s;\\n        \\n        while(l1){\\n            s1.push(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2){\\n            s2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        int carry=0;\\n        while( !s1.empty() || !s2.empty() || carry!=0){\\n            int s1val=!s1.empty() ?s1.top(): 0;\\n            int s2val=!s2.empty() ?s2.top(): 0;\\n            \\n            int current_sum=s1val+s2val+ carry;\\n            \\n            int finaldigit=current_sum%10;\\n            carry= current_sum/10;\\n            \\n            s.push(finaldigit);\\n            if(!s1.empty()){\\n                s1.pop();\\n            }\\n            if(!s2.empty()){\\n                s2.pop();\\n            }\\n        }\\n        \\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* l3=dummy;\\n        while(!s.empty()){\\n            ListNode* new_node=new ListNode(s.top());\\n            l3->next=new_node;\\n            l3=l3->next;\\n            \\n            s.pop();\\n        }\\n        return dummy->next;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int>s1;\\n        stack<int>s2;\\n        stack<int>s;\\n        \\n        while(l1){\\n            s1.push(l1->val);\\n            l1=l1->next;\\n        }\\n        while(l2){\\n            s2.push(l2->val);\\n            l2=l2->next;\\n        }\\n        int carry=0;\\n        while( !s1.empty() || !s2.empty() || carry!=0){\\n            int s1val=!s1.empty() ?s1.top(): 0;\\n            int s2val=!s2.empty() ?s2.top(): 0;\\n            \\n            int current_sum=s1val+s2val+ carry;\\n            \\n            int finaldigit=current_sum%10;\\n            carry= current_sum/10;\\n            \\n            s.push(finaldigit);\\n            if(!s1.empty()){\\n                s1.pop();\\n            }\\n            if(!s2.empty()){\\n                s2.pop();\\n            }\\n        }\\n        \\n        ListNode* dummy=new ListNode(-1);\\n        ListNode* l3=dummy;\\n        while(!s.empty()){\\n            ListNode* new_node=new ListNode(s.top());\\n            l3->next=new_node;\\n            l3=l3->next;\\n            \\n            s.pop();\\n        }\\n        return dummy->next;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479784,
                "title": "java-implementation-with-followup-without-reversing-input-list",
                "content": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode curr1 = l1;\\n        ListNode curr2 = l2;\\n        \\n        int size1 = getSize(curr1);\\n        int size2 = getSize(curr2);\\n        \\n          curr1 = l1;\\n          curr2 = l2;\\n          ListNode head = null;\\n        \\n        while(size1 > 0 && size2 > 0) {\\n            int sumVal = 0;\\n            if(size1 >= size2) {\\n                sumVal += curr1.val;\\n                curr1 = curr1.next;\\n                size1--;\\n            }\\n            \\n            if(size2 > size1) {\\n                sumVal += curr2.val;\\n                curr2 = curr2.next;\\n                size2--;\\n            }\\n            \\n            //Magic happens here pay attention\\n            //Make sum node and always append on head\\n            //For example \\n            //                 newNode1 <- null\\n            // nextNewNode2 <- newNode1 <- null\\n            ListNode newNode = new ListNode(sumVal);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        \\n        //curr ans     = 7 -> 10 -> 7 -> 7\\n        //Expected ans = 7 <- 8 <- 0 <- 7\\n        //reuse same node to traverse again\\n        curr1 = head;\\n        head = null;\\n        int carry = 0;\\n        \\n        //trim value which are greater than 9 and add carry to next node\\n        while(curr1 != null) {\\n            int val = (curr1.val + carry) % 10;\\n            carry = (curr1.val + carry) / 10;\\n            \\n            //Do same thing we did above.\\n            //Create new node and add to the head;\\n            ListNode newNode = new ListNode(val);\\n            newNode.next = head;\\n            head = newNode;\\n            \\n            //move ahead\\n            curr1 = curr1.next;\\n        }\\n        \\n        \\n        //if Carry is not zero append one extra to head\\n        if(carry != 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n    \\n    private int getSize(ListNode head) {\\n        int size = 0;\\n        while(head != null) {\\n            size++;\\n            head = head.next;\\n        }\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode curr1 = l1;\\n        ListNode curr2 = l2;\\n        \\n        int size1 = getSize(curr1);\\n        int size2 = getSize(curr2);\\n        \\n          curr1 = l1;\\n          curr2 = l2;\\n          ListNode head = null;\\n        \\n        while(size1 > 0 && size2 > 0) {\\n            int sumVal = 0;\\n            if(size1 >= size2) {\\n                sumVal += curr1.val;\\n                curr1 = curr1.next;\\n                size1--;\\n            }\\n            \\n            if(size2 > size1) {\\n                sumVal += curr2.val;\\n                curr2 = curr2.next;\\n                size2--;\\n            }\\n            \\n            //Magic happens here pay attention\\n            //Make sum node and always append on head\\n            //For example \\n            //                 newNode1 <- null\\n            // nextNewNode2 <- newNode1 <- null\\n            ListNode newNode = new ListNode(sumVal);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        \\n        //curr ans     = 7 -> 10 -> 7 -> 7\\n        //Expected ans = 7 <- 8 <- 0 <- 7\\n        //reuse same node to traverse again\\n        curr1 = head;\\n        head = null;\\n        int carry = 0;\\n        \\n        //trim value which are greater than 9 and add carry to next node\\n        while(curr1 != null) {\\n            int val = (curr1.val + carry) % 10;\\n            carry = (curr1.val + carry) / 10;\\n            \\n            //Do same thing we did above.\\n            //Create new node and add to the head;\\n            ListNode newNode = new ListNode(val);\\n            newNode.next = head;\\n            head = newNode;\\n            \\n            //move ahead\\n            curr1 = curr1.next;\\n        }\\n        \\n        \\n        //if Carry is not zero append one extra to head\\n        if(carry != 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n    \\n    private int getSize(ListNode head) {\\n        int size = 0;\\n        while(head != null) {\\n            size++;\\n            head = head.next;\\n        }\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407757,
                "title": "c-self-explanatory-with-comments",
                "content": "```\\n/**\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//Recursive utility function to reverse linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head==NULL || head->next==NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* rest = reverse(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return rest;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n\\t  // if any 1 list is empty, return the other\\n        if(l1==NULL) return l2;\\n        if(l2==NULL) return l1;\\n\\t\\t\\n\\t\\t//reverse both the lists to start addition from units digit (rightmost digit)\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\t\\t\\n\\t\\t//Initialize a new list with a sentinel node (-1)\\n        ListNode* newlist=  new ListNode(-1);\\n        ListNode* temp = newlist;\\n        int sum=0;\\n        int carry=0;\\n\\t\\t\\n\\t\\t// Loop until both the lists are not empty\\n        while(l1!=NULL || l2!=NULL)\\n        {\\n\\t\\t\\t// if lists are not null, add the digits to sum variable and add previous carry\\n            sum = carry;\\n            if(l1!=NULL)\\n            {\\n                sum+=l1->val;\\n                l1=l1->next;\\n            }\\n            if(l2!=NULL)\\n            {\\n                sum+=l2->val;\\n                l2=l2->next;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// find carry for next iteration and insert new node with current digit as value\\n            carry = sum/10;\\n            temp->next = new ListNode(sum%10);\\n            temp=temp->next;\\n        }\\n\\t\\t\\n\\t\\t// if carry is not 0, add a new node with the value of carry\\n        if(carry!=0)\\n        {\\n            temp->next = new ListNode(carry);\\n            temp = temp->next;\\n        }\\n\\t\\t\\n\\t\\t// return the reverse of the new list\\n        return reverse(newlist->next);\\n    }\\n};\\n```\\n\\nRuntime: 16 ms, faster than 98.35% \\nMemory Usage: 71.3 MB, less than 49.51% \\n\\nIterative reversal might increase the Runtime speed and reduce Space consumed.\\nFeel free to ask doubts or teach me a better approach! \\u270C",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//Recursive utility function to reverse linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head==NULL || head->next==NULL)\\n        {\\n            return head;\\n        }\\n        ListNode* rest = reverse(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return rest;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n\\t  // if any 1 list is empty, return the other\\n        if(l1==NULL) return l2;\\n        if(l2==NULL) return l1;\\n\\t\\t\\n\\t\\t//reverse both the lists to start addition from units digit (rightmost digit)\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n\\t\\t\\n\\t\\t//Initialize a new list with a sentinel node (-1)\\n        ListNode* newlist=  new ListNode(-1);\\n        ListNode* temp = newlist;\\n        int sum=0;\\n        int carry=0;\\n\\t\\t\\n\\t\\t// Loop until both the lists are not empty\\n        while(l1!=NULL || l2!=NULL)\\n        {\\n\\t\\t\\t// if lists are not null, add the digits to sum variable and add previous carry\\n            sum = carry;\\n            if(l1!=NULL)\\n            {\\n                sum+=l1->val;\\n                l1=l1->next;\\n            }\\n            if(l2!=NULL)\\n            {\\n                sum+=l2->val;\\n                l2=l2->next;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// find carry for next iteration and insert new node with current digit as value\\n            carry = sum/10;\\n            temp->next = new ListNode(sum%10);\\n            temp=temp->next;\\n        }\\n\\t\\t\\n\\t\\t// if carry is not 0, add a new node with the value of carry\\n        if(carry!=0)\\n        {\\n            temp->next = new ListNode(carry);\\n            temp = temp->next;\\n        }\\n\\t\\t\\n\\t\\t// return the reverse of the new list\\n        return reverse(newlist->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401921,
                "title": "without-using-stack-and-without-reversing-c",
                "content": "A bit lengthy but a different, simple and efficient approach.\\n**Intuition:-**\\n1) Count total no. of nodes in both linked lists.\\n2) If the length is same we simply call helper function that adds up the values of nodes and make l1->val = l1->val + l2->val, we are adding the nodes when we backtrack the lists and maintain a carry(incase sum of nodes >= 10) as well.\\n3) Then if n1 != n2 we are moving in else condition. Here if the length of 2nd linked list is greater then we swap the linked lists as we are considering 1st linked list to be greater always.\\n4) And then the main part, we simply make a linked list of nodes having values 0 equal to the difference of length of both linked list and concatenate this list to the 2nd (i.e shorter) list and call the helper function to add both lists.\\n5) Then if the carry is left we simply make a node of that value (carry) and concatenate that to l1 and return that node, else if carry = 0 we simply return l1 (as l1 contains the summation of both lists refer point no.2).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int carry = 0;\\n    void helper(ListNode *l1, ListNode *l2){\\n        if(!l1 && !l2) return;\\n        helper(l1->next,l2->next);\\n        int value = l1->val + l2->val + carry;\\n        carry = value/10;\\n        value %= 10;\\n        l1->val = value;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1 = 0;\\n        int n2 = 0;\\n\\t\\t\\n        ListNode* curr = l1;\\n        while(curr){\\n            n1++;\\n            curr=curr->next;\\n        }\\n\\t\\t\\n        curr = l2;\\n        while(curr){\\n            n2++;\\n            curr=curr->next;\\n        }\\n\\t\\t\\n        if(n1 == n2) helper(l1,l2);\\n\\t\\t\\n        else{\\n            if(n2 > n1){\\n                swap(l1,l2);\\n                swap(n1,n2);\\n            }\\n            ListNode *curr2 = new ListNode(0);\\n            ListNode *tempHead = curr2;\\n            while(n1 > n2+1){\\n                ListNode *temp = new ListNode(0);\\n                curr2->next = temp;\\n                curr2 = temp;\\n                n1--;\\n            }\\n            curr2->next = l2;\\n            helper(l1,tempHead);\\n        } \\n        \\n        if(carry){\\n                ListNode *a = new ListNode(carry);\\n                a->next =l1;\\n                return a;\\n            }\\n        return l1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int carry = 0;\\n    void helper(ListNode *l1, ListNode *l2){\\n        if(!l1 && !l2) return;\\n        helper(l1->next,l2->next);\\n        int value = l1->val + l2->val + carry;\\n        carry = value/10;\\n        value %= 10;\\n        l1->val = value;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int n1 = 0;\\n        int n2 = 0;\\n\\t\\t\\n        ListNode* curr = l1;\\n        while(curr){\\n            n1++;\\n            curr=curr->next;\\n        }\\n\\t\\t\\n        curr = l2;\\n        while(curr){\\n            n2++;\\n            curr=curr->next;\\n        }\\n\\t\\t\\n        if(n1 == n2) helper(l1,l2);\\n\\t\\t\\n        else{\\n            if(n2 > n1){\\n                swap(l1,l2);\\n                swap(n1,n2);\\n            }\\n            ListNode *curr2 = new ListNode(0);\\n            ListNode *tempHead = curr2;\\n            while(n1 > n2+1){\\n                ListNode *temp = new ListNode(0);\\n                curr2->next = temp;\\n                curr2 = temp;\\n                n1--;\\n            }\\n            curr2->next = l2;\\n            helper(l1,tempHead);\\n        } \\n        \\n        if(carry){\\n                ListNode *a = new ListNode(carry);\\n                a->next =l1;\\n                return a;\\n            }\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317925,
                "title": "python-95-runtime-99-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        one =\\'\\'\\n        two=\\'\\'\\n        \\n        while l1:\\n            one+=str(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            two+=str(l2.val)\\n            l2 = l2.next\\n        \\n        u= int(one)+int(two)\\n        s = ListNode(0)\\n        \\n        hea = s\\n        \\n        for i in str(u):\\n            s.next = ListNode(val =int(i))\\n            s = s.next\\n        return hea.next\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        one =\\'\\'\\n        two=\\'\\'\\n        \\n        while l1:\\n            one+=str(l1.val)\\n            l1 = l1.next\\n        \\n        while l2:\\n            two+=str(l2.val)\\n            l2 = l2.next\\n        \\n        u= int(one)+int(two)\\n        s = ListNode(0)\\n        \\n        hea = s\\n        \\n        for i in str(u):\\n            s.next = ListNode(val =int(i))\\n            s = s.next\\n        return hea.next\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267250,
                "title": "simplest-c-solution-o-n1-n2-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverselist(ListNode *l){\\n        ListNode* prev = NULL;\\n        ListNode* next;\\n        ListNode* curr = l;\\n        while(curr!=NULL){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n        \\n    }\\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverselist(l1);\\n        l2 = reverselist(l2);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        int sum, carry = 0;\\n        while (l1 != NULL || l2 != NULL) {\\n            int a = l1!=NULL? l1->val:0;\\n            int b = l2!=NULL? l2->val:0;\\n            sum = a+b+carry;\\n            carry = sum/10;\\n            curr->next = new ListNode(sum%10);\\n            curr = curr->next;\\n            if(l1!=NULL)l1 = l1->next;\\n            if(l2!=NULL)l2 = l2->next;\\n        }\\n        if(carry>0){\\n            curr->next = new ListNode(carry);\\n        }\\n        dummy->next = reverselist(dummy->next);\\n        return dummy->next;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverselist(ListNode *l){\\n        ListNode* prev = NULL;\\n        ListNode* next;\\n        ListNode* curr = l;\\n        while(curr!=NULL){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n        \\n    }\\n    \\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverselist(l1);\\n        l2 = reverselist(l2);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        int sum, carry = 0;\\n        while (l1 != NULL || l2 != NULL) {\\n            int a = l1!=NULL? l1->val:0;\\n            int b = l2!=NULL? l2->val:0;\\n            sum = a+b+carry;\\n            carry = sum/10;\\n            curr->next = new ListNode(sum%10);\\n            curr = curr->next;\\n            if(l1!=NULL)l1 = l1->next;\\n            if(l2!=NULL)l2 = l2->next;\\n        }\\n        if(carry>0){\\n            curr->next = new ListNode(carry);\\n        }\\n        dummy->next = reverselist(dummy->next);\\n        return dummy->next;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028018,
                "title": "c-recursive-iterative",
                "content": "# recursive (faster & less memory)\\n```\\nclass Solution {\\npublic:\\n    int carry(ListNode* l1, ListNode* l2, int size1, int size2){\\n        if(!size1)\\n            return 0;\\n        int val = l1->val;\\n        if(size1 > size2)\\n            val += carry(l1->next, l2, size1 - 1, size2);\\n        else\\n            val += l2->val + carry(l1->next, l2->next, size1 - 1, size2 - 1);   \\n        l1->val = val % 10;\\n        return val / 10;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int size1 = 0, size2 = 0;\\n        for(ListNode *tmp = l1; tmp; tmp = tmp->next, size1++);\\n        for(ListNode *tmp = l2; tmp; tmp = tmp->next, size2++);\\n        if(size2 > size1)\\n            return addTwoNumbers(l2, l1);\\n        int c = carry(l1, l2, size1, size2);\\n        if(c){\\n            ListNode* tmp = new ListNode;\\n            tmp->val = c;\\n            tmp->next = l1;\\n            l1 = tmp;\\n        }\\n            \\n        return l1;\\n    }\\n};\\n```\\n# iterative\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        vector<ListNode **> indirect1, indirect2;\\n        for(ListNode **indirect = &l1; *indirect; indirect = &(*indirect)->next)\\n            indirect1.emplace_back(indirect);\\n        for(ListNode **indirect = &l2; *indirect; indirect = &(*indirect)->next)\\n            indirect2.emplace_back(indirect);\\n        int idx1 = indirect1.size() - 1, idx2 = indirect2.size() - 1;\\n        if(idx2 > idx1)\\n            return addTwoNumbers(l2, l1);\\n        int carry = 0;\\n\\n        for(; idx2 >= 0 || carry; idx1--, idx2--){\\n            cout << idx2 << \\'\\\\n\\';\\n            int val = carry; \\n            val += idx1 >= 0 ? (*indirect1[idx1])->val : 0; \\n            val += idx2 >= 0 ? (*indirect2[idx2])->val : 0;\\n            carry = val / 10;\\n            val %= 10;\\n            if(idx1 < 0){\\n                auto tmp = new ListNode;\\n                tmp->next = l1;\\n                l1 = tmp;\\n                idx1 = 0;\\n            }\\n            (*indirect1[idx1])->val = val;\\n        }\\n        \\n        return l1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int carry(ListNode* l1, ListNode* l2, int size1, int size2){\\n        if(!size1)\\n            return 0;\\n        int val = l1->val;\\n        if(size1 > size2)\\n            val += carry(l1->next, l2, size1 - 1, size2);\\n        else\\n            val += l2->val + carry(l1->next, l2->next, size1 - 1, size2 - 1);   \\n        l1->val = val % 10;\\n        return val / 10;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int size1 = 0, size2 = 0;\\n        for(ListNode *tmp = l1; tmp; tmp = tmp->next, size1++);\\n        for(ListNode *tmp = l2; tmp; tmp = tmp->next, size2++);\\n        if(size2 > size1)\\n            return addTwoNumbers(l2, l1);\\n        int c = carry(l1, l2, size1, size2);\\n        if(c){\\n            ListNode* tmp = new ListNode;\\n            tmp->val = c;\\n            tmp->next = l1;\\n            l1 = tmp;\\n        }\\n            \\n        return l1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        vector<ListNode **> indirect1, indirect2;\\n        for(ListNode **indirect = &l1; *indirect; indirect = &(*indirect)->next)\\n            indirect1.emplace_back(indirect);\\n        for(ListNode **indirect = &l2; *indirect; indirect = &(*indirect)->next)\\n            indirect2.emplace_back(indirect);\\n        int idx1 = indirect1.size() - 1, idx2 = indirect2.size() - 1;\\n        if(idx2 > idx1)\\n            return addTwoNumbers(l2, l1);\\n        int carry = 0;\\n\\n        for(; idx2 >= 0 || carry; idx1--, idx2--){\\n            cout << idx2 << \\'\\\\n\\';\\n            int val = carry; \\n            val += idx1 >= 0 ? (*indirect1[idx1])->val : 0; \\n            val += idx2 >= 0 ? (*indirect2[idx2])->val : 0;\\n            carry = val / 10;\\n            val %= 10;\\n            if(idx1 < 0){\\n                auto tmp = new ListNode;\\n                tmp->next = l1;\\n                l1 = tmp;\\n                idx1 = 0;\\n            }\\n            (*indirect1[idx1])->val = val;\\n        }\\n        \\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 926695,
                "title": "c-add-two-numbers-ii-using-stack-o-max-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *tmp1 = l1, *tmp2 = l2;\\n\\n        if( !tmp1 && !tmp2 ) return NULL;\\n\\n        stack<int> st1, st2;\\n\\t\\t// Push val into two stack\\n        while( tmp1 && tmp2 ){\\n            st1.push(tmp1->val);\\n            st2.push(tmp2->val);\\n            tmp1 = tmp1->next;\\n            tmp2 = tmp2->next;\\n        }\\n        while( tmp1 ){\\n            st1.push(tmp1->val);\\n            tmp1 = tmp1->next;\\n        } \\n        while( tmp2 ){\\n            st2.push(tmp2->val);\\n            tmp2 = tmp2->next; \\n        }\\n        \\n        ListNode* res = NULL;\\n        int mem = 0; // memo = 0 or memo = 1\\n        \\n        while( !st1.empty() || !st2.empty() ){\\n            int a = st1.empty() ? 0 : st1.top();\\n            int b = st2.empty() ? 0 : st2.top();\\n            res = new ListNode((a + b + mem) % 10, res);// Insert to head of list\\n            mem = a + b + mem >= 10 ? 1 : 0;// Update memo\\n            if( !st1.empty() ) st1.pop();\\n            if( !st2.empty() ) st2.pop();\\n        }\\n        if( mem ) res = new ListNode(1, res);// Case memo = 1\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *tmp1 = l1, *tmp2 = l2;\\n\\n        if( !tmp1 && !tmp2 ) return NULL;\\n\\n        stack<int> st1, st2;\\n\\t\\t// Push val into two stack\\n        while( tmp1 && tmp2 ){\\n            st1.push(tmp1->val);\\n            st2.push(tmp2->val);\\n            tmp1 = tmp1->next;\\n            tmp2 = tmp2->next;\\n        }\\n        while( tmp1 ){\\n            st1.push(tmp1->val);\\n            tmp1 = tmp1->next;\\n        } \\n        while( tmp2 ){\\n            st2.push(tmp2->val);\\n            tmp2 = tmp2->next; \\n        }\\n        \\n        ListNode* res = NULL;\\n        int mem = 0; // memo = 0 or memo = 1\\n        \\n        while( !st1.empty() || !st2.empty() ){\\n            int a = st1.empty() ? 0 : st1.top();\\n            int b = st2.empty() ? 0 : st2.top();\\n            res = new ListNode((a + b + mem) % 10, res);// Insert to head of list\\n            mem = a + b + mem >= 10 ? 1 : 0;// Update memo\\n            if( !st1.empty() ) st1.pop();\\n            if( !st2.empty() ) st2.pop();\\n        }\\n        if( mem ) res = new ListNode(1, res);// Case memo = 1\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926677,
                "title": "cpp-easy-to-understand-using-recursion-without-reverse-explained-step-by-step-solution",
                "content": "* Find the size of both lists and find difference in size\\n* Make both the list equal size by adding 0 in starting of smaller list.\\n* Use a recursive function to add both the lists along with carry.\\n\\nBelow is the simple implementation of above approch:\\n\\n```\\nclass Solution {\\npublic:\\n    //Carry\\n    int c=0;\\n    \\n    //Find sum of two equal size linkedlist\\n    void findsum(ListNode* l1, ListNode* l2)\\n    {\\n        //we reached at end of list, return \\n        if(l1==NULL&&l2==NULL)  return;\\n        \\n        findsum(l1->next,l2->next);\\n        \\n        //add valued with carry\\n        int s=l1->val+l2->val+c;\\n        c=s/10; s%=10;\\n        \\n        //Allocate to any list(not require both)\\n        l1->val=s,l2->val=s;\\n            \\n    }\\n    \\n    \\n    //Make list equal\\n    ListNode* mkequal(ListNode* l,int dif)\\n    {\\n        while(dif--)\\n        {\\n            ListNode* nw=new ListNode(0);\\n            nw->next=l;\\n            l=nw;\\n        }\\n        return l;\\n    }\\n    \\n    //Driver function\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode* m1=l1,*m2=l2;\\n        int sz1=0,sz2=0;\\n        \\n        //finding length of both lists\\n        while(m1!=NULL) {sz1++;m1=m1->next;}\\n        while(m2!=NULL) {sz2++;m2=m2->next;}\\n        \\n        int dif=abs(sz1-sz2);\\n        \\n        //make both of equal size\\n        if(sz1<sz2) l1=mkequal(l1,dif); \\n        if(sz2<sz1) l2=mkequal(l2,dif); \\n          \\n        //find sum of both list\\n        findsum(l1,l2);\\n        \\n        //if any extra carry, generated in MSB\\n        //Add a node in front of final result with value c\\n        if(c)\\n        {\\n           ListNode* nw=new ListNode(c);\\n           nw->next=l1;\\n           l1=nw; \\n        }\\n        \\n        //return updated list\\n        return l1;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(N), N-> length of longest list\\nSpace Complexity: O(N), in worst case if one string in NULL**\\n\\n***If any improvement needed feel free to comment*** **:)**\\n***If it was helpful, please***  **\\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Carry\\n    int c=0;\\n    \\n    //Find sum of two equal size linkedlist\\n    void findsum(ListNode* l1, ListNode* l2)\\n    {\\n        //we reached at end of list, return \\n        if(l1==NULL&&l2==NULL)  return;\\n        \\n        findsum(l1->next,l2->next);\\n        \\n        //add valued with carry\\n        int s=l1->val+l2->val+c;\\n        c=s/10; s%=10;\\n        \\n        //Allocate to any list(not require both)\\n        l1->val=s,l2->val=s;\\n            \\n    }\\n    \\n    \\n    //Make list equal\\n    ListNode* mkequal(ListNode* l,int dif)\\n    {\\n        while(dif--)\\n        {\\n            ListNode* nw=new ListNode(0);\\n            nw->next=l;\\n            l=nw;\\n        }\\n        return l;\\n    }\\n    \\n    //Driver function\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode* m1=l1,*m2=l2;\\n        int sz1=0,sz2=0;\\n        \\n        //finding length of both lists\\n        while(m1!=NULL) {sz1++;m1=m1->next;}\\n        while(m2!=NULL) {sz2++;m2=m2->next;}\\n        \\n        int dif=abs(sz1-sz2);\\n        \\n        //make both of equal size\\n        if(sz1<sz2) l1=mkequal(l1,dif); \\n        if(sz2<sz1) l2=mkequal(l2,dif); \\n          \\n        //find sum of both list\\n        findsum(l1,l2);\\n        \\n        //if any extra carry, generated in MSB\\n        //Add a node in front of final result with value c\\n        if(c)\\n        {\\n           ListNode* nw=new ListNode(c);\\n           nw->next=l1;\\n           l1=nw; \\n        }\\n        \\n        //return updated list\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926674,
                "title": "c-10-lines-simple-recursive-no-reverse-operation-or-extra-stack",
                "content": "Add from tail. if the sum > 9 return a new node(1, l1), otherwise return null. Repeat the process.\\n\\n```\\npublic class Solution {\\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = GetLength(l1);\\n        int len2 = GetLength(l2);\\n        if(len1 < len2) return AddTwoNumbers(l2, l1);\\n        return Add(l1, l2, len1 - len2) ?? l1;\\n    }\\n    \\n    public int GetLength(ListNode node)\\n    {\\n        return node == null ? 0 : GetLength(node.next) + 1;\\n    }\\n    \\n    public ListNode Add(ListNode l1, ListNode l2, int offset)\\n    {\\n        if (l2 == null) return null;\\n        ListNode next = offset > 0 ? Add(l1.next, l2, offset - 1) : Add(l1.next, l2.next, 0);\\n        int val = l1.val + (offset > 0 ? 0 : l2.val) + (next == null ? 0 : 1);\\n        l1.val = val % 10;\\n        return val > 9 ? new ListNode(1, l1) : null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1 = GetLength(l1);\\n        int len2 = GetLength(l2);\\n        if(len1 < len2) return AddTwoNumbers(l2, l1);\\n        return Add(l1, l2, len1 - len2) ?? l1;\\n    }\\n    \\n    public int GetLength(ListNode node)\\n    {\\n        return node == null ? 0 : GetLength(node.next) + 1;\\n    }\\n    \\n    public ListNode Add(ListNode l1, ListNode l2, int offset)\\n    {\\n        if (l2 == null) return null;\\n        ListNode next = offset > 0 ? Add(l1.next, l2, offset - 1) : Add(l1.next, l2.next, 0);\\n        int val = l1.val + (offset > 0 ? 0 : l2.val) + (next == null ? 0 : 1);\\n        l1.val = val % 10;\\n        return val > 9 ? new ListNode(1, l1) : null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925373,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nSolution\\n\\n1. Reverse both lists\\n2. Add numbers and arrange pointers properly to obtain a new list of sum\\n3. Reverse the new list\\n*/\\nvar addTwoNumbers = function(l1, l2) {\\n    let head = new ListNode();\\n    let cur = head;\\n    l1 = reverseList(l1);\\n    l2 = reverseList(l2);\\n    let carry = 0, sum = 0;\\n    while (l1 || l2) {\\n        let l1Val = l1 ? l1.val : 0;\\n        let l2Val = l2 ? l2.val : 0;\\n        sum = l1Val + l2Val + carry;\\n        carry = sum > 9 ? 1 : 0;\\n        if (l1) {\\n            l1.val = sum % 10;\\n            cur.next = l1;\\n        } else {\\n            l2.val = sum % 10;\\n            cur.next = l2;\\n        }\\n        if (l1) l1 = l1.next;\\n        if (l2) l2 = l2.next;\\n        cur = cur.next;\\n    }\\n    if (carry > 0) {\\n        cur.next = new ListNode(1);\\n    }\\n    let res = reverseList(head.next);\\n    return res;\\n    // T.C: O(M + N)\\n    // S.C: O(1)\\n};\\n\\nconst reverseList = (head) => {\\n    let prev = null, cur = head;\\n    while (cur !== null) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution\\n\\n1. Reverse both lists\\n2. Add numbers and arrange pointers properly to obtain a new list of sum\\n3. Reverse the new list\\n*/\\nvar addTwoNumbers = function(l1, l2) {\\n    let head = new ListNode();\\n    let cur = head;\\n    l1 = reverseList(l1);\\n    l2 = reverseList(l2);\\n    let carry = 0, sum = 0;\\n    while (l1 || l2) {\\n        let l1Val = l1 ? l1.val : 0;\\n        let l2Val = l2 ? l2.val : 0;\\n        sum = l1Val + l2Val + carry;\\n        carry = sum > 9 ? 1 : 0;\\n        if (l1) {\\n            l1.val = sum % 10;\\n            cur.next = l1;\\n        } else {\\n            l2.val = sum % 10;\\n            cur.next = l2;\\n        }\\n        if (l1) l1 = l1.next;\\n        if (l2) l2 = l2.next;\\n        cur = cur.next;\\n    }\\n    if (carry > 0) {\\n        cur.next = new ListNode(1);\\n    }\\n    let res = reverseList(head.next);\\n    return res;\\n    // T.C: O(M + N)\\n    // S.C: O(1)\\n};\\n\\nconst reverseList = (head) => {\\n    let prev = null, cur = head;\\n    while (cur !== null) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880961,
                "title": "c-no-reverse-solution-explained-100-time-80-space",
                "content": "That is a fun one and I wanted to take the extra challenge of NOT reversing the lists (and reversing the result later), both as an extra challenge and as a way to save needless computational effort.\\n\\nTo do that I decided to take a stack-like approach, just using an array instead of an actual stack - again, just for the love of performance.\\n\\nTo do so I created a good amount of support variables:\\n* `hasRem`, a boolean to keep track if our addition has a remainder or not, initially set to `false`;\\n* `len1` and `len2`, which, to nobody\\'s surprise, will store the length of `l1` and `l2`, respectively, thanks to the helper function `findLength` (which seems rather trivial and I would not explain further, but feel free to ask, in case);\\n* `pos`, the pointer to which cell of our \"stack\" we should use next\\n* `store`, an array of pairs of `ListNode` pointers - our own cheaper \"stack\", as mentioned.\\n\\nIn order to simplify the logic a bit, we assume that `l2` is never going to be longer than `l1`; if so, we just swap them and their respective lengths.\\n\\nWe then go for a first loop to read both of them and store their content in `store`, with the extra logic needed NOT to increase the position of `l2` and not to add its nodes to `store` until `len2 <= len1`, with `len1` decreasing at each iteration by `1`.\\n\\nSo, if for example we consider the `l1 = {7, 6, 3, 2, 1, 0, 9}` and `l2 = {3, 0, 6, 6}`, our `store` will contain in its first 7 cells: \\n\\n```cpp\\n{7, NULL}, {6, NULL}, {3, NULL}, {2, 3}, {1, 0}, {0, 6}, {9, 6}\\n```\\n\\nTime for a second loop, this time until `pos` is positive: we will take each item from the top of the \"stack\" as `l1` and `l2` respectively and update `l1->val` with `hasRem + (l2 ? l2->val : 0)`, so our previous example will lead to having `l1` now like this:\\n\\n```cpp\\n7->6->3->5->1->7->5\\n```\\n\\nFinally, in case the last operation was to leave us with `hasRem == true`, we need to do an extra step to create an extra node and put it on top of the list with value of `1`; even better if we could just recycle the last valid node pointed by `l2`, to save even a bit more memory, but that would require extra logic with hardly any gain, so I decided not to go there.\\n\\nFinally, we can return `l1` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(ListNode *root) {\\n        int res = 0;\\n        while (root) {\\n            res++;\\n            root = root->next;\\n        }\\n        return res;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // support variables\\n        bool hasRem = false;\\n        int len1 = findLength(l1), len2 = findLength(l2), pos = 0;\\n        pair<ListNode*, ListNode*> store[100];\\n        // making sure l1 is not smaller\\n        if (len1 < len2) {\\n            swap(l1, l2);\\n            swap(len1, len2);\\n        }\\n        // main loop to read\\n        while (len1--) {\\n            // storing the explored value, having l2 advance only when len2 >= len1\\n            store[pos++] = {l1, len2 <= len1 ? NULL : l2};\\n            l1 = l1->next;\\n            l2 = len2 <= len1 ? l2 : l2->next;\\n        }\\n        // main loop to write\\n        while (pos--) {\\n            l1 = store[pos].first;\\n            l2 = store[pos].second;\\n            l1->val += hasRem + (l2 ? l2->val : 0);\\n            hasRem = l1->val > 9;\\n            l1->val %= 10;\\n        }\\n        // last touch: we need to add a node on top if we still had a remainder\\n        if (hasRem) {\\n            l2->val = 1;\\n            l2->next = l1;\\n            l1 = l2;\\n        }\\n        return l1;\\n    }\\n};\\n```\\n\\nAlternative take with 2 separate arrays used as stacks, no need to pre-check the linked lists before; same memory usage and slightly faster execution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // support variables\\n        bool asRem = false;\\n        int pos1 = 0, pos2 = 0;\\n        ListNode *store1[100], *store2[100];\\n        // main loop to read\\n        while (l1 || l2) {\\n            // storing the explored values\\n            if (l1) {\\n                store1[pos1++] = l1;\\n                l1 = l1->next;\\n            }\\n            if (l2) {\\n                store2[pos2++] = l2;\\n                l2 = l2->next;\\n            }\\n        }\\n        // making sure l1 is not smaller\\n        if (pos1 < pos2) {\\n            swap(store1, store2);\\n            swap(pos1, pos2);\\n        }\\n        // main loop to write\\n        while (pos1--) {\\n            l1 = store1[pos1];\\n            l2 = pos2 > 0 ? store2[--pos2] : NULL;\\n            l1->val += asRem + (l2 ? l2->val : 0);\\n            asRem = l1->val > 9;\\n            l1->val %= 10;\\n        }\\n        // last touch: we need to add a node on top if we still had a remainder\\n        if (asRem) {\\n            l2 = new ListNode(1);\\n            l2->next = l1;\\n            l1 = l2;\\n        }\\n        return l1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```cpp\\n{7, NULL}, {6, NULL}, {3, NULL}, {2, 3}, {1, 0}, {0, 6}, {9, 6}\\n```\n```cpp\\n7->6->3->5->1->7->5\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findLength(ListNode *root) {\\n        int res = 0;\\n        while (root) {\\n            res++;\\n            root = root->next;\\n        }\\n        return res;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // support variables\\n        bool hasRem = false;\\n        int len1 = findLength(l1), len2 = findLength(l2), pos = 0;\\n        pair<ListNode*, ListNode*> store[100];\\n        // making sure l1 is not smaller\\n        if (len1 < len2) {\\n            swap(l1, l2);\\n            swap(len1, len2);\\n        }\\n        // main loop to read\\n        while (len1--) {\\n            // storing the explored value, having l2 advance only when len2 >= len1\\n            store[pos++] = {l1, len2 <= len1 ? NULL : l2};\\n            l1 = l1->next;\\n            l2 = len2 <= len1 ? l2 : l2->next;\\n        }\\n        // main loop to write\\n        while (pos--) {\\n            l1 = store[pos].first;\\n            l2 = store[pos].second;\\n            l1->val += hasRem + (l2 ? l2->val : 0);\\n            hasRem = l1->val > 9;\\n            l1->val %= 10;\\n        }\\n        // last touch: we need to add a node on top if we still had a remainder\\n        if (hasRem) {\\n            l2->val = 1;\\n            l2->next = l1;\\n            l1 = l2;\\n        }\\n        return l1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // support variables\\n        bool asRem = false;\\n        int pos1 = 0, pos2 = 0;\\n        ListNode *store1[100], *store2[100];\\n        // main loop to read\\n        while (l1 || l2) {\\n            // storing the explored values\\n            if (l1) {\\n                store1[pos1++] = l1;\\n                l1 = l1->next;\\n            }\\n            if (l2) {\\n                store2[pos2++] = l2;\\n                l2 = l2->next;\\n            }\\n        }\\n        // making sure l1 is not smaller\\n        if (pos1 < pos2) {\\n            swap(store1, store2);\\n            swap(pos1, pos2);\\n        }\\n        // main loop to write\\n        while (pos1--) {\\n            l1 = store1[pos1];\\n            l2 = pos2 > 0 ? store2[--pos2] : NULL;\\n            l1->val += asRem + (l2 ? l2->val : 0);\\n            asRem = l1->val > 9;\\n            l1->val %= 10;\\n        }\\n        // last touch: we need to add a node on top if we still had a remainder\\n        if (asRem) {\\n            l2 = new ListNode(1);\\n            l2->next = l1;\\n            l1 = l2;\\n        }\\n        return l1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743105,
                "title": "python-2-ways-w-explanation",
                "content": "**IDEA 1**: Obtain the numbers from the linked lists, add them and then using this result, generate a linked list again. \\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        if not l1 and not l2:\\n            return None\\n        if not l1 and l2: return l2\\n        if not l2 and l1: return l1\\n\\n        result_l1, result_l2 = 0, 0\\n        while l1 or l2:\\n            if l1:\\n                result_l1 = result_l1*10 + l1.val\\n                l1 = l1.next\\n            if l2:\\n                result_l2 = result_l2 * 10 + l2.val\\n                l2 = l2.next\\n\\n        result = result_l1 + result_l2\\n\\n        dummy_head = ListNode(-math.inf)\\n        curr_node = dummy_head\\n        for char in str(result):\\n            curr_node.next = ListNode(int(char))\\n            curr_node = curr_node.next\\n\\n        return dummy_head.next\\n```\\n\\n------------------------------------------------------------------------------------------------------\\n\\n**IDEA** **2**: Since the MSB is present at the start of the Linked List and LSB at the end, we can reverse the linked lists to allow traversing the linked list and simultaneously creating the result linked list. \\nAfter reversing the linked list, the problem is essentially the same as LC [#2. Add Two Numbers ](https://leetcode.com/problems/add-two-numbers/)\\n\\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n       l1, l2 = self.reverse_ll(l1), self.reverse_ll(l2)\\n        head = curr = ListNode(0)\\n        carry = 0\\n        while l1 or l2 or carry:\\n            val1, val2 = 0, 0\\n            if l1:\\n                val1 = l1.val\\n                l1 = l1.next\\n            if l2:\\n                val2 = l2.val\\n                l2 = l2.next\\n            carry, val = divmod(val1 + val2 + carry, 10)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n        return self.reverse_ll(head.next)\\n    \\n    def reverse_ll(self, head):\\n        curr, prev = head, None\\n        while curr:\\n            curr.next, prev, curr = prev, curr, curr.next\\n        return prev\\n          \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        if not l1 and not l2:\\n            return None\\n        if not l1 and l2: return l2\\n        if not l2 and l1: return l1\\n\\n        result_l1, result_l2 = 0, 0\\n        while l1 or l2:\\n            if l1:\\n                result_l1 = result_l1*10 + l1.val\\n                l1 = l1.next\\n            if l2:\\n                result_l2 = result_l2 * 10 + l2.val\\n                l2 = l2.next\\n\\n        result = result_l1 + result_l2\\n\\n        dummy_head = ListNode(-math.inf)\\n        curr_node = dummy_head\\n        for char in str(result):\\n            curr_node.next = ListNode(int(char))\\n            curr_node = curr_node.next\\n\\n        return dummy_head.next\\n```\n```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n       l1, l2 = self.reverse_ll(l1), self.reverse_ll(l2)\\n        head = curr = ListNode(0)\\n        carry = 0\\n        while l1 or l2 or carry:\\n            val1, val2 = 0, 0\\n            if l1:\\n                val1 = l1.val\\n                l1 = l1.next\\n            if l2:\\n                val2 = l2.val\\n                l2 = l2.next\\n            carry, val = divmod(val1 + val2 + carry, 10)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n        return self.reverse_ll(head.next)\\n    \\n    def reverse_ll(self, head):\\n        curr, prev = head, None\\n        while curr:\\n            curr.next, prev, curr = prev, curr, curr.next\\n        return prev\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 742579,
                "title": "python-faster-than-91",
                "content": "```\\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        r1 = self.reverse_list(l1)\\n        r2 = self.reverse_list(l2)\\n        r = ListNode(\\'dummy\\')\\n        \\n        c1, c2, rc, carry = r1, r2, r, 0\\n        \\n        while c1 and c2:\\n            res = c1.val + c2.val + carry\\n            rc.next, carry = ListNode(res % 10), res // 10\\n            \\n            c1, c2, rc = c1.next, c2.next, rc.next\\n            \\n        if c1:\\n            rc, carry = self.exhaust_list(c1, rc, carry)\\n        \\n        if c2:\\n            rc, carry = self.exhaust_list(c2, rc, carry)\\n        \\n        if carry:\\n            rc.next = ListNode(carry)\\n            \\n        return self.reverse_list(r.next)\\n        \\n    \\n    def reverse_list(self, l):\\n        p, c = None, l\\n        while c:\\n            c.next, p, c = p, c, c.next\\n        \\n        return p\\n    \\n    def exhaust_list(self, l, rc, carry):\\n        while l:\\n            res = l.val + carry\\n            rc.next = ListNode(res % 10)\\n            carry = res // 10\\n            \\n            l, rc = l.next, rc.next\\n        \\n        return rc, carry\\n```",
                "solutionTags": [],
                "code": "```\\ndef addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        r1 = self.reverse_list(l1)\\n        r2 = self.reverse_list(l2)\\n        r = ListNode(\\'dummy\\')\\n        \\n        c1, c2, rc, carry = r1, r2, r, 0\\n        \\n        while c1 and c2:\\n            res = c1.val + c2.val + carry\\n            rc.next, carry = ListNode(res % 10), res // 10\\n            \\n            c1, c2, rc = c1.next, c2.next, rc.next\\n            \\n        if c1:\\n            rc, carry = self.exhaust_list(c1, rc, carry)\\n        \\n        if c2:\\n            rc, carry = self.exhaust_list(c2, rc, carry)\\n        \\n        if carry:\\n            rc.next = ListNode(carry)\\n            \\n        return self.reverse_list(r.next)\\n        \\n    \\n    def reverse_list(self, l):\\n        p, c = None, l\\n        while c:\\n            c.next, p, c = p, c, c.next\\n        \\n        return p\\n    \\n    def exhaust_list(self, l, rc, carry):\\n        while l:\\n            res = l.val + carry\\n            rc.next = ListNode(res % 10)\\n            carry = res // 10\\n            \\n            l, rc = l.next, rc.next\\n        \\n        return rc, carry\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 673175,
                "title": "using-stacks-approach",
                "content": "[ The code can further be simplied by breaking it into smaller reusable functions ] \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        int carry = 0;\\n        if (l1 == null && l2 == null) {\\n            return null;\\n        }\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        // l1 && l2 then\\n        Stack<ListNode> s1 = new Stack<>();\\n        Stack<ListNode> s2 = new Stack<>();\\n        while(l1 != null) {\\n            s1.push(l1);\\n            l1 = l1.next;\\n        }\\n        while(l2 != null) {\\n            s2.push(l2);\\n            l2 = l2.next;\\n        }\\n        ListNode result = null;\\n        while(!s1.isEmpty() || !s2.isEmpty()) {\\n          \\n            int s1Val = (!s1.isEmpty()) ? s1.pop().val: 0;\\n            int s2Val =(!s2.isEmpty()) ? s2.pop().val : 0;\\n            int sum = s1Val + s2Val + carry;\\n            if (sum > 9) {\\n                carry = sum / 10;\\n                sum = sum % 10;\\n                \\n            } else {\\n                carry = 0;\\n            }\\n            ListNode curr = new ListNode(sum);\\n            if (result == null) {\\n                // head\\n                result = curr;\\n            } else {\\n                curr.next = result;\\n                result = curr;\\n            }\\n            \\n            \\n        }\\n        if (carry != 0) {\\n              ListNode curr = new ListNode(carry);\\n            if (result == null) {\\n                // head\\n                result = curr;\\n            } else {\\n                curr.next = result;\\n                result = curr;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        \\n        int carry = 0;\\n        if (l1 == null && l2 == null) {\\n            return null;\\n        }\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        // l1 && l2 then\\n        Stack<ListNode> s1 = new Stack<>();\\n        Stack<ListNode> s2 = new Stack<>();\\n        while(l1 != null) {\\n            s1.push(l1);\\n            l1 = l1.next;\\n        }\\n        while(l2 != null) {\\n            s2.push(l2);\\n            l2 = l2.next;\\n        }\\n        ListNode result = null;\\n        while(!s1.isEmpty() || !s2.isEmpty()) {\\n          \\n            int s1Val = (!s1.isEmpty()) ? s1.pop().val: 0;\\n            int s2Val =(!s2.isEmpty()) ? s2.pop().val : 0;\\n            int sum = s1Val + s2Val + carry;\\n            if (sum > 9) {\\n                carry = sum / 10;\\n                sum = sum % 10;\\n                \\n            } else {\\n                carry = 0;\\n            }\\n            ListNode curr = new ListNode(sum);\\n            if (result == null) {\\n                // head\\n                result = curr;\\n            } else {\\n                curr.next = result;\\n                result = curr;\\n            }\\n            \\n            \\n        }\\n        if (carry != 0) {\\n              ListNode curr = new ListNode(carry);\\n            if (result == null) {\\n                // head\\n                result = curr;\\n            } else {\\n                curr.next = result;\\n                result = curr;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641486,
                "title": "add-two-numbers-ii",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        //Maintain 3 stacks \\n        Stack<ListNode> a = new Stack<>();\\n        Stack<ListNode> b = new Stack<>();\\n        Stack<ListNode> c = new Stack<>();\\n        int carry=0;\\n        ListNode res = null,prev=null;\\n        \\n        //Populate stack a:\\n        while(l1!=null){\\n            a.push(l1);\\n            l1=l1.next;\\n        }\\n        \\n        //Populate stack b:\\n        while(l2!=null){\\n            b.push(l2);\\n            l2=l2.next;\\n        }\\n        \\n        //populate stack c:\\n        while((!a.isEmpty()) || (!b.isEmpty())){\\n            \\n            int sum = (a.isEmpty()?0:a.pop().val)+(b.isEmpty()?0:b.pop().val)+carry;\\n            carry=sum/10;\\n            if(sum>9)\\n                sum%=10;\\n            ListNode node = new ListNode(sum);\\n            c.push(node);\\n        }\\n        \\n        //Add a node if carry present\\n        if(carry>0){\\n            ListNode node = new ListNode(carry);\\n            c.push(node);\\n        }\\n        \\n        //Generate List\\n        while(!c.empty()){\\n            ListNode node = c.pop();\\n            if(res==null){\\n                res=node;\\n                prev=res;\\n            }else{\\n                prev.next=node;\\n                prev=node;\\n            }\\n        }\\n\\n        //Terminate list\\n        prev.next=null;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        //Maintain 3 stacks \\n        Stack<ListNode> a = new Stack<>();\\n        Stack<ListNode> b = new Stack<>();\\n        Stack<ListNode> c = new Stack<>();\\n        int carry=0;\\n        ListNode res = null,prev=null;\\n        \\n        //Populate stack a:\\n        while(l1!=null){\\n            a.push(l1);\\n            l1=l1.next;\\n        }\\n        \\n        //Populate stack b:\\n        while(l2!=null){\\n            b.push(l2);\\n            l2=l2.next;\\n        }\\n        \\n        //populate stack c:\\n        while((!a.isEmpty()) || (!b.isEmpty())){\\n            \\n            int sum = (a.isEmpty()?0:a.pop().val)+(b.isEmpty()?0:b.pop().val)+carry;\\n            carry=sum/10;\\n            if(sum>9)\\n                sum%=10;\\n            ListNode node = new ListNode(sum);\\n            c.push(node);\\n        }\\n        \\n        //Add a node if carry present\\n        if(carry>0){\\n            ListNode node = new ListNode(carry);\\n            c.push(node);\\n        }\\n        \\n        //Generate List\\n        while(!c.empty()){\\n            ListNode node = c.pop();\\n            if(res==null){\\n                res=node;\\n                prev=res;\\n            }else{\\n                prev.next=node;\\n                prev=node;\\n            }\\n        }\\n\\n        //Terminate list\\n        prev.next=null;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548366,
                "title": "ez-python",
                "content": "```\\ndef addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        def toInt(node):\\n            res = 0\\n            while node:\\n                res = res*10 + node.val\\n                node = node.next\\n            return res\\n        def toList(n):\\n            res = start = ListNode(None)\\n            for num in n:\\n                start.next = start = ListNode(int(num))\\n            return res.next\\n                \\n        return toList(str(toInt(l1) + toInt(l2)))\\n```",
                "solutionTags": [],
                "code": "```\\ndef addTwoNumbers(self, l1, l2):\\n        \"\"\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        def toInt(node):\\n            res = 0\\n            while node:\\n                res = res*10 + node.val\\n                node = node.next\\n            return res\\n        def toList(n):\\n            res = start = ListNode(None)\\n            for num in n:\\n                start.next = start = ListNode(int(num))\\n            return res.next\\n                \\n        return toList(str(toInt(l1) + toInt(l2)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528574,
                "title": "java-o-n-recursive-with-no-reverse-beat-99",
                "content": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode longlist = l1;\\n        ListNode shortlist = l2;\\n        int size1 = 0, size2 = 0;\\n        ListNode cur = l1;\\n        \\n        // get length of l1 and l2\\n        while (cur != null) {\\n            cur = cur.next;\\n            size1++;\\n        }\\n        cur = l2;\\n        while (cur != null) {\\n            cur = cur.next;\\n            size2++;\\n        }\\n        \\n        // make sure long list is longer than short list\\n        if (size1 < size2){\\n            longlist = l2;\\n            shortlist = l1;\\n        }\\n        int dif = Math.abs(size1 - size2); // length difference between l1 and l2\\n        \\n        // if first bit get bigger than 9 \\n        if (rec(longlist, shortlist, dif) > 0) {\\n            ListNode n = new ListNode(1);\\n            n.next = longlist;\\n            return n;\\n        }\\n        return longlist;\\n    }\\n    public int rec(ListNode longlist, ListNode shortlist, int dif) {\\n        if (longlist == null) return 0;\\n        int sum, c = 0;\\n        if (dif > 0) {\\n            c = rec(longlist.next, shortlist, dif - 1);\\n            sum = c + longlist.val;\\n            \\n        } else {\\n            c = rec(longlist.next, shortlist.next, dif - 1);\\n            sum = c + longlist.val + shortlist.val;\\n        }\\n        \\n        // change number in long node\\n        longlist.val = sum %10;\\n        \\n        //return add number in previous node\\n        return sum/10;  \\n    }   \\n}\\n```\\n\\nSpace: O(1)\\nTime: O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode longlist = l1;\\n        ListNode shortlist = l2;\\n        int size1 = 0, size2 = 0;\\n        ListNode cur = l1;\\n        \\n        // get length of l1 and l2\\n        while (cur != null) {\\n            cur = cur.next;\\n            size1++;\\n        }\\n        cur = l2;\\n        while (cur != null) {\\n            cur = cur.next;\\n            size2++;\\n        }\\n        \\n        // make sure long list is longer than short list\\n        if (size1 < size2){\\n            longlist = l2;\\n            shortlist = l1;\\n        }\\n        int dif = Math.abs(size1 - size2); // length difference between l1 and l2\\n        \\n        // if first bit get bigger than 9 \\n        if (rec(longlist, shortlist, dif) > 0) {\\n            ListNode n = new ListNode(1);\\n            n.next = longlist;\\n            return n;\\n        }\\n        return longlist;\\n    }\\n    public int rec(ListNode longlist, ListNode shortlist, int dif) {\\n        if (longlist == null) return 0;\\n        int sum, c = 0;\\n        if (dif > 0) {\\n            c = rec(longlist.next, shortlist, dif - 1);\\n            sum = c + longlist.val;\\n            \\n        } else {\\n            c = rec(longlist.next, shortlist.next, dif - 1);\\n            sum = c + longlist.val + shortlist.val;\\n        }\\n        \\n        // change number in long node\\n        longlist.val = sum %10;\\n        \\n        //return add number in previous node\\n        return sum/10;  \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333986,
                "title": "python-faster-than-99-88-64ms",
                "content": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        num1 = \"\"\\n        num2 = \"\"\\n\\t\\t# loop through the first linked list, storing the values in the num1 variable\\n        while l1 is not None:\\n            num1 += str(l1.val)\\n            l1 = l1.next\\n\\t\\t# follows same process as above\\n        while l2 is not None:\\n            num2 += str(l2.val)\\n            l2 = l2.next\\n\\t\\t# calculate the sum of the values that we just obtained and store it as a string\\n        summation = str(int(num1) + int(num2))\\n\\t\\t# make the head of the node the first number in the summation string\\n        head = ListNode(summation[0])\\n\\t\\t# create a new reference to the head so we can manipulate the linked list but not lose the original reference to the head\\n        temp = head\\n\\t\\t# loop through the remaining numbers in the summation string, each time creating a new node\\n        for val in summation[1:]:\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\t\\t# return the original reference to the head\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        num1 = \"\"\\n        num2 = \"\"\\n\\t\\t# loop through the first linked list, storing the values in the num1 variable\\n        while l1 is not None:\\n            num1 += str(l1.val)\\n            l1 = l1.next\\n\\t\\t# follows same process as above\\n        while l2 is not None:\\n            num2 += str(l2.val)\\n            l2 = l2.next\\n\\t\\t# calculate the sum of the values that we just obtained and store it as a string\\n        summation = str(int(num1) + int(num2))\\n\\t\\t# make the head of the node the first number in the summation string\\n        head = ListNode(summation[0])\\n\\t\\t# create a new reference to the head so we can manipulate the linked list but not lose the original reference to the head\\n        temp = head\\n\\t\\t# loop through the remaining numbers in the summation string, each time creating a new node\\n        for val in summation[1:]:\\n            temp.next = ListNode(val)\\n            temp = temp.next\\n\\t\\t# return the original reference to the head\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213025,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Using Two Stacks**\\n\\n**Time Complexity:** `O(N + M)`, Time it takes to traverse both lists, where `N` and `M` are the lengths of the two input lists.\\n**Space Complexity:** `O(N + M)` - space required for two stacks is `(N + M)` and space required for output list is `(Max(N, M))`\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode L1, ListNode L2) {\\n        Deque<Integer> stack1 = new ArrayDeque<>();\\n        Deque<Integer> stack2 = new ArrayDeque<>();\\n        ListNode head = null;\\n        int carry = 0;\\n\\n        for (ListNode current = L1; current != null; current = current.next) {\\n            stack1.push(current.val);\\n        }\\n        for (ListNode current = L2; current != null; current = current.next) {\\n            stack2.push(current.val);\\n        }\\n\\n        while (!stack1.isEmpty() || !stack2.isEmpty()) {\\n            int x = stack1.isEmpty() ? 0 : stack1.pop();\\n            int y = stack2.isEmpty() ? 0 : stack2.pop();\\n            int sum = x + y + carry;\\n            carry = sum / 10;\\n\\n            // Insert Node at front of the result List\\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        // When carry still has a value after both Lists are processed\\n        if (carry > 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**Solution 2: Reverse Input List + Construct Output List by Adding to Front**\\n\\n**Algorithm:**\\n1. Implement `reverseList()` method.\\n1. Reverse both input lists: `L1 = reverseList(L1), L2 = reverseList(L2)`.\\n1. Initialize the result List: `head = null`.\\n1. Initialize the carry: `carry = 0`.\\n1. Loop through lists `L1` and `L2` until you reach both ends:\\n\\t- Set `x = L1.val` if `L1` is not finished yet, and `x = 0` otherwise.\\n\\t- Set `y = L2.val` if `L2` is not finished yet, and `y = 0` otherwise.\\n\\t- Compute the SUM as: `sum = x1 + x2 + carry`, and the current CARRY as: `carry = sum / 10`.\\n\\t- Update the result by adding the least-significat-digit of SUM (`sum % 10`) to the front of result List.\\n\\t- Move to the next elements in the lists.\\n1. If the `carry` is still not equal to zero, append it to front of the result List.\\n1. Return the result List: return `head`.\\n\\n**Time complexity:** `O(N + M)`, where `N + M` is a number of elements in both lists.\\n**Space complexity:** `O(1)` space complexity without taking the output list into account, and `O(Max(N, M))` to store the output list.\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode L1, ListNode L2) {\\n        // Reverse Both Lists: O(N + M)\\n        L1 = reverseList(L1);\\n        L2 = reverseList(L2);\\n\\n        ListNode head = null;\\n        int carry = 0;\\n\\n        // O(Max(N + M))\\n        while (L1 != null || L2 != null) {\\n            // Get the current values\\n            int x1 = L1 != null ? L1.val : 0;\\n            int x2 = L2 != null ? L2.val : 0;\\n\\n            // Current sum and carry\\n            int sum = x1 + x2 + carry;\\n            carry = sum / 10;\\n\\n            // Update the result: Add newNode to the front of output List\\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head;\\n            head = newNode;\\n\\n            // Move to the next elements in the Lists\\n            if (L1 != null) {\\n                L1 = L1.next;\\n            }\\n            if (L2 != null) {\\n                L2 = L2.next;\\n            }\\n        }\\n        // When carry still has a value after both Lists are processed\\n        if (carry > 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode current = head;\\n\\n        while (current != null) {\\n            ListNode nextNode = current.next;   // Store the next Node\\n            current.next = prev;                // Reverse the link\\n            prev = current;                     // Update the prev node and the current node\\n            current = nextNode;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode L1, ListNode L2) {\\n        Deque<Integer> stack1 = new ArrayDeque<>();\\n        Deque<Integer> stack2 = new ArrayDeque<>();\\n        ListNode head = null;\\n        int carry = 0;\\n\\n        for (ListNode current = L1; current != null; current = current.next) {\\n            stack1.push(current.val);\\n        }\\n        for (ListNode current = L2; current != null; current = current.next) {\\n            stack2.push(current.val);\\n        }\\n\\n        while (!stack1.isEmpty() || !stack2.isEmpty()) {\\n            int x = stack1.isEmpty() ? 0 : stack1.pop();\\n            int y = stack2.isEmpty() ? 0 : stack2.pop();\\n            int sum = x + y + carry;\\n            carry = sum / 10;\\n\\n            // Insert Node at front of the result List\\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        // When carry still has a value after both Lists are processed\\n        if (carry > 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode L1, ListNode L2) {\\n        // Reverse Both Lists: O(N + M)\\n        L1 = reverseList(L1);\\n        L2 = reverseList(L2);\\n\\n        ListNode head = null;\\n        int carry = 0;\\n\\n        // O(Max(N + M))\\n        while (L1 != null || L2 != null) {\\n            // Get the current values\\n            int x1 = L1 != null ? L1.val : 0;\\n            int x2 = L2 != null ? L2.val : 0;\\n\\n            // Current sum and carry\\n            int sum = x1 + x2 + carry;\\n            carry = sum / 10;\\n\\n            // Update the result: Add newNode to the front of output List\\n            ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = head;\\n            head = newNode;\\n\\n            // Move to the next elements in the Lists\\n            if (L1 != null) {\\n                L1 = L1.next;\\n            }\\n            if (L2 != null) {\\n                L2 = L2.next;\\n            }\\n        }\\n        // When carry still has a value after both Lists are processed\\n        if (carry > 0) {\\n            ListNode newNode = new ListNode(carry);\\n            newNode.next = head;\\n            head = newNode;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode current = head;\\n\\n        while (current != null) {\\n            ListNode nextNode = current.next;   // Store the next Node\\n            current.next = prev;                // Reverse the link\\n            prev = current;                     // Update the prev node and the current node\\n            current = nextNode;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92645,
                "title": "my-favorite-java-recursive-solution-a-clean-and-fancy-way",
                "content": "1. put the longer list in front.\\n\\n2. Take one or two nodes out of lists and make the rest of them a subproblem. The recursive function will generate the sum of current nodes and update its parent node as the carry.\\n\\n\\n```\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getLength(l1);\\n        int size2 = getLength(l2);\\n        ListNode head = new ListNode(0);\\n        // Make sure l1.length >= l2.length\\n        head.next = size1 < size2 ? helper(l2, l1, head, size2 - size1) : helper(l1, l2, head, size1 - size2);\\n        \\n        return head.val == 1 ? head : head.next;\\n    }\\n    \\n    public int getLength(ListNode l) {\\n        int count = 0;\\n        while (l != null) {\\n            l = l.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private ListNode helper(ListNode l1, ListNode l2, ListNode head, int offset) {\\n        if (l1 == null) return null;\\n        \\n        ListNode cur = new ListNode (0);\\n        int sum = 0;\\n        if (offset > 0) {\\n            cur.next = helper(l1.next, l2, cur, offset - 1);\\n            sum = cur.val + l1.val;\\n        } else {\\n            cur.next = helper(l1.next, l2.next, cur, offset);\\n            sum = cur.val + l1.val + l2.val;\\n        }\\n        \\n        cur.val = sum % 10;\\n        head.val = sum / 10;\\n        \\n        return cur;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int size1 = getLength(l1);\\n        int size2 = getLength(l2);\\n        ListNode head = new ListNode(0);\\n        // Make sure l1.length >= l2.length\\n        head.next = size1 < size2 ? helper(l2, l1, head, size2 - size1) : helper(l1, l2, head, size1 - size2);\\n        \\n        return head.val == 1 ? head : head.next;\\n    }\\n    \\n    public int getLength(ListNode l) {\\n        int count = 0;\\n        while (l != null) {\\n            l = l.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private ListNode helper(ListNode l1, ListNode l2, ListNode head, int offset) {\\n        if (l1 == null) return null;\\n        \\n        ListNode cur = new ListNode (0);\\n        int sum = 0;\\n        if (offset > 0) {\\n            cur.next = helper(l1.next, l2, cur, offset - 1);\\n            sum = cur.val + l1.val;\\n        } else {\\n            cur.next = helper(l1.next, l2.next, cur, offset);\\n            sum = cur.val + l1.val + l2.val;\\n        }\\n        \\n        cur.val = sum % 10;\\n        head.val = sum / 10;\\n        \\n        return cur;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92682,
                "title": "naive-python-solution",
                "content": "    class Solution(object):\\n        def addTwoNumbers(self, l1, l2):\\n            c1, c2 = '', ''\\n            while l1:\\n                c1 += str(l1.val)\\n                l1 = l1.next\\n            while l2:\\n                c2 += str(l2.val)\\n                l2 = l2.next\\n            num = str(int(c1) + int(c2))\\n            dummy = ListNode(0)\\n            c = dummy\\n            for i in range(len(num)):\\n                c.next = ListNode(num[i])\\n                c = c.next\\n            return dummy.next",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def addTwoNumbers(self, l1, l2):\\n            c1, c2 = '', ''\\n            while l1:\\n                c1 += str(l1.val)\\n                l1 = l1.next\\n            while l2:\\n                c2 += str(l2.val)\\n                l2 = l2.next\\n            num = str(int(c1) + int(c2))\\n            dummy = ListNode(0)\\n            c = dummy\\n            for i in range(len(num)):\\n                c.next = ListNode(num[i])\\n                c = c.next\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 92814,
                "title": "easy-o-n-recursion-solution-c",
                "content": "Recursion solution without data structure.\\nEasy to understand.\\n```\\nclass Solution {\\npublic:\\n    int addhelper(ListNode *l1, ListNode* l2, ListNode* result, int &len1, int &len2){\\n        if(!l1 || !l2) return 0;\\n        if(len1 == len2){\\n            if(l1->next)\\n                result->next = new ListNode(0);\\n            int sum = l1->val + l2->val + addhelper(l1->next, l2->next, result->next, --len1, --len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }else if(len1 > len2){\\n            if(l1->next)\\n                result->next = new ListNode(0);\\n            int sum = l1->val + addhelper(l1->next, l2, result->next, --len1, len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }else{\\n            if(l2->next)\\n                result->next = new ListNode(0);\\n            int sum = l2->val + addhelper(l1, l2->next, result->next, len1, --len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        int len1 = 0, len2 = 0;\\n        ListNode * head1 = l1, *head2 = l2;\\n        while(l1){\\n            l1 = l1->next;\\n            ++ len1;\\n        }\\n        while(l2){\\n            l2 = l2->next;\\n            ++ len2;\\n        }\\n        ListNode *result = new ListNode(0);\\n        int carry = 0;\\n        ListNode * tmp = result;\\n        carry = addhelper(head1, head2, tmp, len1, len2);\\n        if(carry){\\n            ListNode * result_f = new ListNode(carry);\\n            result_f->next = result;\\n            return result_f;\\n        }else\\n            return result;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int addhelper(ListNode *l1, ListNode* l2, ListNode* result, int &len1, int &len2){\\n        if(!l1 || !l2) return 0;\\n        if(len1 == len2){\\n            if(l1->next)\\n                result->next = new ListNode(0);\\n            int sum = l1->val + l2->val + addhelper(l1->next, l2->next, result->next, --len1, --len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }else if(len1 > len2){\\n            if(l1->next)\\n                result->next = new ListNode(0);\\n            int sum = l1->val + addhelper(l1->next, l2, result->next, --len1, len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }else{\\n            if(l2->next)\\n                result->next = new ListNode(0);\\n            int sum = l2->val + addhelper(l1, l2->next, result->next, len1, --len2);\\n            result->val = sum % 10;\\n            return sum / 10;\\n        }\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        int len1 = 0, len2 = 0;\\n        ListNode * head1 = l1, *head2 = l2;\\n        while(l1){\\n            l1 = l1->next;\\n            ++ len1;\\n        }\\n        while(l2){\\n            l2 = l2->next;\\n            ++ len2;\\n        }\\n        ListNode *result = new ListNode(0);\\n        int carry = 0;\\n        ListNode * tmp = result;\\n        carry = addhelper(head1, head2, tmp, len1, len2);\\n        if(carry){\\n            ListNode * result_f = new ListNode(carry);\\n            result_f->next = result;\\n            return result_f;\\n        }else\\n            return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022729,
                "title": "too-easy-solution-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* cur) {\\n        ListNode* prev = NULL;\\n        ListNode* fast = cur->next;\\n        while(cur) {\\n            // in the first loop current node point NULL and after first loop it points previous node\\'s memory which is prev node\\n            cur->next = prev;\\n            // after this prev has to keep being previous node\\n            prev = cur;\\n            // meanwhile current point its next pointer which is fast\\n            cur = fast;\\n            // fast keeps pointing the next pointer of current if it is available\\n            if(fast) fast = fast->next;\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = reverseList(l1);\\n        ListNode* r2 = reverseList(l2);\\n        l1 = r1;\\n        l2 = r2;\\n        // sum will be sum of 2 node values and rem stores the value of tenths place integer \\n        int sum=0, rem=0;\\n        ListNode* res = new ListNode();\\n        \\n        while(l1 || l2) {\\n            if(l1) {\\n                sum += l1->val; \\n                l1 = l1->next;\\n            }\\n            if(l2) {\\n                sum += l2->val; \\n                l2 = l2->next;\\n            }\\n            res->val = sum%10;\\n            rem = sum/10;\\n            ListNode* temp = new ListNode(rem);\\n            temp->next = res;\\n            res = temp;\\n            sum = rem;\\n        }\\n        // if rem is 0 them it should not be returned\\n        return rem == 0 ? res->next : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* cur) {\\n        ListNode* prev = NULL;\\n        ListNode* fast = cur->next;\\n        while(cur) {\\n            // in the first loop current node point NULL and after first loop it points previous node\\'s memory which is prev node\\n            cur->next = prev;\\n            // after this prev has to keep being previous node\\n            prev = cur;\\n            // meanwhile current point its next pointer which is fast\\n            cur = fast;\\n            // fast keeps pointing the next pointer of current if it is available\\n            if(fast) fast = fast->next;\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* r1 = reverseList(l1);\\n        ListNode* r2 = reverseList(l2);\\n        l1 = r1;\\n        l2 = r2;\\n        // sum will be sum of 2 node values and rem stores the value of tenths place integer \\n        int sum=0, rem=0;\\n        ListNode* res = new ListNode();\\n        \\n        while(l1 || l2) {\\n            if(l1) {\\n                sum += l1->val; \\n                l1 = l1->next;\\n            }\\n            if(l2) {\\n                sum += l2->val; \\n                l2 = l2->next;\\n            }\\n            res->val = sum%10;\\n            rem = sum/10;\\n            ListNode* temp = new ListNode(rem);\\n            temp->next = res;\\n            res = temp;\\n            sum = rem;\\n        }\\n        // if rem is 0 them it should not be returned\\n        return rem == 0 ? res->next : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986788,
                "title": "java-brute-force-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode rev1 = reverse(l1);\\n        ListNode rev2 = reverse(l2);\\n        List<Integer> al = new ArrayList();\\n        int sum = 0;\\n        int rem = 0;\\n        while(rev1 != null && rev2 != null) {\\n            sum = rem + rev1.val + rev2.val;\\n            if(sum >= 10) {\\n                al.add(sum % 10);\\n                rem = sum / 10;\\n            } else {\\n                al.add(sum);\\n                rem = 0;\\n            }\\n            rev1 = rev1.next;\\n            rev2 = rev2.next;\\n        }\\n        while(rev1 != null) {\\n            if(rem != 0) {\\n                sum = rem + rev1.val;\\n                if(sum >= 10) {\\n                    al.add(sum % 10);\\n                    rem = sum / 10;\\n                } else {\\n                    al.add(sum);\\n                    rem = 0;\\n                }\\n            } else {\\n                al.add(rev1.val);\\n            }\\n            rev1 = rev1.next;\\n        }\\n        while(rev2 != null) {\\n            if(rem != 0) {\\n                sum = rem + rev2.val;\\n                if(sum >= 10) {\\n                    al.add(sum % 10);\\n                    rem = sum / 10;\\n                } else {\\n                    al.add(sum);\\n                    rem = 0;\\n                }\\n            } else {\\n                al.add(rev2.val);\\n            }\\n            rev2 = rev2.next;\\n        }\\n        if(rem != 0) {\\n            al.add(rem);\\n        }\\n        ListNode res = new ListNode();\\n        ListNode r = res;\\n        for(int i = al.size()-1; i >= 0; i--) {\\n            r.next = new ListNode(al.get(i));\\n            r = r.next;\\n        }\\n        return res.next;\\n    }\\n\\n    ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode rev1 = reverse(l1);\\n        ListNode rev2 = reverse(l2);\\n        List<Integer> al = new ArrayList();\\n        int sum = 0;\\n        int rem = 0;\\n        while(rev1 != null && rev2 != null) {\\n            sum = rem + rev1.val + rev2.val;\\n            if(sum >= 10) {\\n                al.add(sum % 10);\\n                rem = sum / 10;\\n            } else {\\n                al.add(sum);\\n                rem = 0;\\n            }\\n            rev1 = rev1.next;\\n            rev2 = rev2.next;\\n        }\\n        while(rev1 != null) {\\n            if(rem != 0) {\\n                sum = rem + rev1.val;\\n                if(sum >= 10) {\\n                    al.add(sum % 10);\\n                    rem = sum / 10;\\n                } else {\\n                    al.add(sum);\\n                    rem = 0;\\n                }\\n            } else {\\n                al.add(rev1.val);\\n            }\\n            rev1 = rev1.next;\\n        }\\n        while(rev2 != null) {\\n            if(rem != 0) {\\n                sum = rem + rev2.val;\\n                if(sum >= 10) {\\n                    al.add(sum % 10);\\n                    rem = sum / 10;\\n                } else {\\n                    al.add(sum);\\n                    rem = 0;\\n                }\\n            } else {\\n                al.add(rev2.val);\\n            }\\n            rev2 = rev2.next;\\n        }\\n        if(rem != 0) {\\n            al.add(rem);\\n        }\\n        ListNode res = new ListNode();\\n        ListNode r = res;\\n        for(int i = al.size()-1; i >= 0; i--) {\\n            r.next = new ListNode(al.get(i));\\n            r = r.next;\\n        }\\n        return res.next;\\n    }\\n\\n    ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923082,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* rev(ListNode* node)\\n    {\\n        ListNode* prev=nullptr,*cur=node;\\n        while(cur!=nullptr)\\n        {\\n            ListNode* nxt=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        if(l1==nullptr) return l2;\\n        if(l2==nullptr) return l1;\\n\\n        ListNode* h1=rev(l1);\\n        ListNode* h2=rev(l2);\\n\\n        ListNode* ans = new ListNode();\\n\\n\\n        int carry=0;\\n        while(h1!=nullptr || h2!=nullptr)\\n        {\\n            int fno=carry;\\n            \\n            if(h1 && h2)\\n            { \\n                fno=(fno+h1->val+h2->val)%10;\\n                carry=(carry+h1->val+h2->val)/10;\\n                h1=h1->next;\\n                h2=h2->next;\\n            }\\n            else if(h1)\\n            {\\n                fno=(fno+h1->val)%10;\\n                carry=(carry+h1->val)/10;\\n                h1=h1->next;\\n            }else{\\n                fno=(fno+h2->val)%10;\\n                carry=(carry+h2->val)/10;\\n                h2=h2->next;\\n            }\\n            ans->val=fno;\\n            ListNode * temp=new ListNode(carry);\\n            temp->next=ans;\\n            ans=temp;\\n        }\\n        return carry==0?ans->next:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* rev(ListNode* node)\\n    {\\n        ListNode* prev=nullptr,*cur=node;\\n        while(cur!=nullptr)\\n        {\\n            ListNode* nxt=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        if(l1==nullptr) return l2;\\n        if(l2==nullptr) return l1;\\n\\n        ListNode* h1=rev(l1);\\n        ListNode* h2=rev(l2);\\n\\n        ListNode* ans = new ListNode();\\n\\n\\n        int carry=0;\\n        while(h1!=nullptr || h2!=nullptr)\\n        {\\n            int fno=carry;\\n            \\n            if(h1 && h2)\\n            { \\n                fno=(fno+h1->val+h2->val)%10;\\n                carry=(carry+h1->val+h2->val)/10;\\n                h1=h1->next;\\n                h2=h2->next;\\n            }\\n            else if(h1)\\n            {\\n                fno=(fno+h1->val)%10;\\n                carry=(carry+h1->val)/10;\\n                h1=h1->next;\\n            }else{\\n                fno=(fno+h2->val)%10;\\n                carry=(carry+h2->val)/10;\\n                h2=h2->next;\\n            }\\n            ans->val=fno;\\n            ListNode * temp=new ListNode(carry);\\n            temp->next=ans;\\n            ans=temp;\\n        }\\n        return carry==0?ans->next:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872245,
                "title": "100-beats-c-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->STEP 1 : CREATE A NEW NODE TO STORE THE SUM OF ELEMENTS.\\nSTEP 2 : REVERSE TH GIVEN LINKED LISTS L1 AND L2 USING REVERSE FUNCTION.\\nSTEP 3 : CREATE A FUNCTION TO ADD THE DATA INSIDE THE LISTS WITH CARRY.\\nSTEP 4 : CREATE A FUNCTION TO INSERT THE VALUE OF SUM OF ELEMENTS L1 AND L2 + CARRY.\\nSTEP 5 : REVERSE THE ANSWER AND RETUEN IT.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->~O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->~O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    void insertAtTail(ListNode* &head , ListNode* &tail , int data){\\n        ListNode* temp = new ListNode(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return;\\n        }\\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n    }\\n    ListNode* add(ListNode* first, ListNode* second){\\n        int carry = 0;\\n        ListNode* anshead = NULL;\\n        ListNode* anstail = NULL;\\n\\n        while(first != NULL || second != NULL || carry != 0)\\n        {\\n            int a = 0;\\n            if(first != NULL){\\n                a = first->val;\\n            }\\n            int b = 0;\\n            if(second != NULL){\\n                b = second->val;\\n            }\\n            \\n            int sum = carry + a + b;\\n            int digit = sum%10;\\n            \\n            //insertion  \\n            insertAtTail(anshead , anstail , digit);\\n            carry = sum/10;\\n\\n            if(first != NULL){\\n                first = first->next;\\n            }\\n            if(second != NULL){\\n                second = second->next;\\n            }\\n        }\\n        return anshead;\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n        ListNode* ans = add(l1,l2);\\n        return reverse(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    void insertAtTail(ListNode* &head , ListNode* &tail , int data){\\n        ListNode* temp = new ListNode(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return;\\n        }\\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n    }\\n    ListNode* add(ListNode* first, ListNode* second){\\n        int carry = 0;\\n        ListNode* anshead = NULL;\\n        ListNode* anstail = NULL;\\n\\n        while(first != NULL || second != NULL || carry != 0)\\n        {\\n            int a = 0;\\n            if(first != NULL){\\n                a = first->val;\\n            }\\n            int b = 0;\\n            if(second != NULL){\\n                b = second->val;\\n            }\\n            \\n            int sum = carry + a + b;\\n            int digit = sum%10;\\n            \\n            //insertion  \\n            insertAtTail(anshead , anstail , digit);\\n            carry = sum/10;\\n\\n            if(first != NULL){\\n                first = first->next;\\n            }\\n            if(second != NULL){\\n                second = second->next;\\n            }\\n        }\\n        return anshead;\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n        ListNode* ans = add(l1,l2);\\n        return reverse(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780335,
                "title": "c-easy-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // Reverse the input linked lists\\n        ListNode* reversedL1 = reverseLinkedList(l1);\\n        ListNode* reversedL2 = reverseLinkedList(l2);\\n\\n        ListNode* result = nullptr;\\n        ListNode* current = nullptr;\\n        int carry = 0;\\n\\n        while (reversedL1 || reversedL2 || carry) {\\n            int sum = carry;\\n            if (reversedL1) {\\n                sum += reversedL1->val;\\n                reversedL1 = reversedL1->next;\\n            }\\n            if (reversedL2) {\\n                sum += reversedL2->val;\\n                reversedL2 = reversedL2->next;\\n            }\\n\\n            carry = sum / 10;\\n            int digit = sum % 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            if (result == nullptr) {\\n                result = newNode;\\n                current = newNode;\\n            } else {\\n                current->next = newNode;\\n                current = current->next;\\n            }\\n        }\\n\\n        // Reverse the result linked list\\n        result = reverseLinkedList(result);\\n\\n        return result;\\n    }\\n\\nprivate:\\n    ListNode* reverseLinkedList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* current = head;\\n        while (current) {\\n            ListNode* nextNode = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = nextNode;\\n        }\\n        return prev;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // Reverse the input linked lists\\n        ListNode* reversedL1 = reverseLinkedList(l1);\\n        ListNode* reversedL2 = reverseLinkedList(l2);\\n\\n        ListNode* result = nullptr;\\n        ListNode* current = nullptr;\\n        int carry = 0;\\n\\n        while (reversedL1 || reversedL2 || carry) {\\n            int sum = carry;\\n            if (reversedL1) {\\n                sum += reversedL1->val;\\n                reversedL1 = reversedL1->next;\\n            }\\n            if (reversedL2) {\\n                sum += reversedL2->val;\\n                reversedL2 = reversedL2->next;\\n            }\\n\\n            carry = sum / 10;\\n            int digit = sum % 10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            if (result == nullptr) {\\n                result = newNode;\\n                current = newNode;\\n            } else {\\n                current->next = newNode;\\n                current = current->next;\\n            }\\n        }\\n\\n        // Reverse the result linked list\\n        result = reverseLinkedList(result);\\n\\n        return result;\\n    }\\n\\nprivate:\\n    ListNode* reverseLinkedList(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* current = head;\\n        while (current) {\\n            ListNode* nextNode = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = nextNode;\\n        }\\n        return prev;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779144,
                "title": "beats-100-java-solution-best-solution-ever-just-reverse-concept",
                "content": "\\r\\n\\r\\n# Approach\\r\\nThe Concept is:-\\r\\nIn part1 of this similar question, we had directly added\\xA0the\\xA02\\xA0lists.\\r\\n\\r\\nwhile in part 2, first reverse the two input lists ,add them and then\\xA0reverse\\xA0the\\xA0ans.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(n)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nIf you like the solution please upvote.\\r\\n\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * Definition for singly-linked list.\\r\\n * public class ListNode {\\r\\n *     int val;\\r\\n *     ListNode next;\\r\\n *     ListNode() {}\\r\\n *     ListNode(int val) { this.val = val; }\\r\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\r\\n * }\\r\\n */\\r\\nclass Solution {\\r\\n     public static ListNode reverse(ListNode head) {\\r\\n        ListNode current = head;\\r\\n        ListNode previous = null;\\r\\n        while (current != null) {\\r\\n            ListNode next = current.next;\\r\\n            current.next = previous;\\r\\n            previous = current;\\r\\n            current = next;\\r\\n        }\\r\\n        return previous;\\r\\n    }\\r\\n    \\r\\n    public ListNode addTwoNumbers(ListNode list1, ListNode list2) {\\r\\n        ListNode l1=reverse(list1);\\r\\n        ListNode l2=reverse(list2);\\r\\n        \\r\\n        ListNode dummy = new ListNode();\\r\\n       ListNode temp=dummy;\\r\\n       int carry=0;\\r\\n        \\r\\n       while(l1!=null || l2!=null || carry==1)\\r\\n       {\\r\\n           int sum=0;\\r\\n           if(l1!=null)\\r\\n           {\\r\\n               sum+=l1.val;\\r\\n               l1=l1.next;\\r\\n           }\\r\\n           if(l2!=null)\\r\\n           {\\r\\n               sum+=l2.val;\\r\\n               l2=l2.next;\\r\\n           }\\r\\n           sum+=carry;\\r\\n           carry=sum/10;\\r\\n           ListNode node = new ListNode(sum%10);\\r\\n           temp.next=node;\\r\\n           temp=temp.next;\\r\\n\\r\\n       }\\r\\n        ListNode temp2=reverse(dummy.next);\\r\\n       return temp2; \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\n/**\\r\\n * Definition for singly-linked list.\\r\\n * public class ListNode {\\r\\n *     int val;\\r\\n *     ListNode next;\\r\\n *     ListNode() {}\\r\\n *     ListNode(int val) { this.val = val; }\\r\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\r\\n * }\\r\\n */\\r\\nclass Solution {\\r\\n     public static ListNode reverse(ListNode head) {\\r\\n        ListNode current = head;\\r\\n        ListNode previous = null;\\r\\n        while (current != null) {\\r\\n            ListNode next = current.next;\\r\\n            current.next = previous;\\r\\n            previous = current;\\r\\n            current = next;\\r\\n        }\\r\\n        return previous;\\r\\n    }\\r\\n    \\r\\n    public ListNode addTwoNumbers(ListNode list1, ListNode list2) {\\r\\n        ListNode l1=reverse(list1);\\r\\n        ListNode l2=reverse(list2);\\r\\n        \\r\\n        ListNode dummy = new ListNode();\\r\\n       ListNode temp=dummy;\\r\\n       int carry=0;\\r\\n        \\r\\n       while(l1!=null || l2!=null || carry==1)\\r\\n       {\\r\\n           int sum=0;\\r\\n           if(l1!=null)\\r\\n           {\\r\\n               sum+=l1.val;\\r\\n               l1=l1.next;\\r\\n           }\\r\\n           if(l2!=null)\\r\\n           {\\r\\n               sum+=l2.val;\\r\\n               l2=l2.next;\\r\\n           }\\r\\n           sum+=carry;\\r\\n           carry=sum/10;\\r\\n           ListNode node = new ListNode(sum%10);\\r\\n           temp.next=node;\\r\\n           temp=temp.next;\\r\\n\\r\\n       }\\r\\n        ListNode temp2=reverse(dummy.next);\\r\\n       return temp2; \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778640,
                "title": "parent-mapping-without-reversing-linked-list-o-n",
                "content": "# Intuition\\nSame as https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/ \\nwhere we create parent graph and do bfs, here we are using\\nsame parent to traverse from tail to head.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a map which contains node and its prev node, put all node pairing into map do same thing as we did in: https://leetcode.com/problems/add-two-numbers/submissions/996669246/\\n\\njust be careful while creating new LL, we need to create the LL in reverse direction and at the end return tail.\\n\\n# Complexity\\n- Time complexity: O(n)  where n is max len of l1 and l2.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)     used for parent mapping for each node + new LL.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        unordered_map<ListNode*,ListNode*> mp;\\n        ListNode* templ1 = l1;\\n        ListNode* templ2 = l2;\\n\\n        while(templ1 && templ1->next){\\n            mp[templ1->next] = templ1;\\n            templ1=templ1->next;\\n        } \\n        while(templ2 && templ2->next){\\n            mp[templ2->next] = templ2;\\n            templ2=templ2->next;\\n        } \\n\\n        l1=templ1,l2=templ2;\\n         ListNode* tail = NULL;\\n        ListNode * prev = NULL;\\n        int carry=0,newVal;\\n        while(l1 && l2){\\n            newVal = l1->val + l2->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n          \\n                tail = newNode;\\n            if(prev)\\n                newNode->next = prev;\\n            prev = newNode;\\n            l1 = mp[l1];\\n            l2 = mp[l2];\\n        }\\n         while(l1)\\n         {\\n             newVal = l1->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n       \\n                tail = newNode;\\n            if(prev)\\n                           newNode->next = prev;\\n            prev = newNode;\\n            l1 = mp[l1];\\n         }\\n          while(l2)\\n         {\\n             newVal = l2->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n                tail = newNode;\\n            if(prev)\\n                    newNode->next = prev;\\n            prev = newNode;\\n            l2 =  mp[l2];\\n         }\\n        if(carry==1)\\n            {\\n                ListNode *newNode = new ListNode(1);\\n                newNode->next = prev;\\n                 tail = newNode;\\n            }\\n\\n        return tail;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        unordered_map<ListNode*,ListNode*> mp;\\n        ListNode* templ1 = l1;\\n        ListNode* templ2 = l2;\\n\\n        while(templ1 && templ1->next){\\n            mp[templ1->next] = templ1;\\n            templ1=templ1->next;\\n        } \\n        while(templ2 && templ2->next){\\n            mp[templ2->next] = templ2;\\n            templ2=templ2->next;\\n        } \\n\\n        l1=templ1,l2=templ2;\\n         ListNode* tail = NULL;\\n        ListNode * prev = NULL;\\n        int carry=0,newVal;\\n        while(l1 && l2){\\n            newVal = l1->val + l2->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n          \\n                tail = newNode;\\n            if(prev)\\n                newNode->next = prev;\\n            prev = newNode;\\n            l1 = mp[l1];\\n            l2 = mp[l2];\\n        }\\n         while(l1)\\n         {\\n             newVal = l1->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n       \\n                tail = newNode;\\n            if(prev)\\n                           newNode->next = prev;\\n            prev = newNode;\\n            l1 = mp[l1];\\n         }\\n          while(l2)\\n         {\\n             newVal = l2->val + carry;\\n            if(newVal >9)\\n                carry=1;\\n            else\\n                carry=0; \\n            ListNode *newNode = new ListNode(newVal % 10);\\n                tail = newNode;\\n            if(prev)\\n                    newNode->next = prev;\\n            prev = newNode;\\n            l2 =  mp[l2];\\n         }\\n        if(carry==1)\\n            {\\n                ListNode *newNode = new ListNode(1);\\n                newNode->next = prev;\\n                 tail = newNode;\\n            }\\n\\n        return tail;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778609,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(max(n1, n2))$$\\n\\n- Space complexity: $$O(n1 + n2)$$\\n\\nwhere,\\n`n1 is length of l1`,\\n`n2 is length of l2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        def to_int(ll: ListNode) -> int:\\n            n = 0\\n            while ll: n = n * 10 + ll.val; ll = ll.next\\n            return n\\n        \\n        def to_LL(n: int) -> ListNode:\\n            ll = None\\n            while n: n, val = divmod(n, 10); ll = ListNode(val, ll)\\n            return ll or ListNode()\\n        \\n        return to_LL(to_int(l1) + to_int(l2))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Math",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        def to_int(ll: ListNode) -> int:\\n            n = 0\\n            while ll: n = n * 10 + ll.val; ll = ll.next\\n            return n\\n        \\n        def to_LL(n: int) -> ListNode:\\n            ll = None\\n            while n: n, val = divmod(n, 10); ll = ListNode(val, ll)\\n            return ll or ListNode()\\n        \\n        return to_LL(to_int(l1) + to_int(l2))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776688,
                "title": "c-easiest-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode* reverse(ListNode* head){\\n       ListNode* curr=head;\\n       ListNode* prev=NULL;\\n       ListNode* nextptr;\\n\\n       while(curr!=NULL){\\n             nextptr=curr->next;\\n             curr->next=prev;\\n\\n             prev=curr;\\n             curr=nextptr;\\n       }\\n\\n       return prev;\\n   }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n\\n        ListNode* ans= new ListNode(-1);\\n        ListNode* res=ans;\\n        int sum=0,carry=0;\\n        while(l1 || l2 || carry){\\n            sum=0;\\n            if(l1){\\n                sum+=l1->val;\\n                l1=l1->next;\\n            }\\n            if(l2){\\n                sum+=l2->val;\\n                l2=l2->next;\\n            }\\n\\n            sum+=carry;\\n            int digit=sum%10;\\n\\n            ListNode* temp=new ListNode(digit);\\n            ans->next=temp;\\n            ans=ans->next;\\n            carry=sum/10;\\n\\n        }\\n         ans=reverse(res->next);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   ListNode* reverse(ListNode* head){\\n       ListNode* curr=head;\\n       ListNode* prev=NULL;\\n       ListNode* nextptr;\\n\\n       while(curr!=NULL){\\n             nextptr=curr->next;\\n             curr->next=prev;\\n\\n             prev=curr;\\n             curr=nextptr;\\n       }\\n\\n       return prev;\\n   }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverse(l1);\\n        l2=reverse(l2);\\n\\n        ListNode* ans= new ListNode(-1);\\n        ListNode* res=ans;\\n        int sum=0,carry=0;\\n        while(l1 || l2 || carry){\\n            sum=0;\\n            if(l1){\\n                sum+=l1->val;\\n                l1=l1->next;\\n            }\\n            if(l2){\\n                sum+=l2->val;\\n                l2=l2->next;\\n            }\\n\\n            sum+=carry;\\n            int digit=sum%10;\\n\\n            ListNode* temp=new ListNode(digit);\\n            ans->next=temp;\\n            ans=ans->next;\\n            carry=sum/10;\\n\\n        }\\n         ans=reverse(res->next);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776513,
                "title": "easy-c-2-methods",
                "content": "# Approach\\nApproach 1: Reverse both the lists, add them, then reverse the answer.\\nApproach 2: Use stacks to store values, which is very similar to reversing a list.\\n\\n# Approach 1: Reverse Lists\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL) return head;\\n        ListNode* newHead = NULL;\\n        while(head != NULL){\\n            ListNode* next = head->next;\\n            head->next = newHead;\\n            newHead = head;\\n            head = next;\\n        } \\n\\n        return newHead;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2) {\\n        auto dummyHead = new ListNode(0); \\n        auto curr = dummyHead;\\n        int carry = 0;\\n\\n        while(l1 != NULL || l2 != NULL || carry > 0){\\n            int sum = carry;\\n\\n            if(l1 != NULL){\\n                sum += l1->val;\\n                l1 = l1->next;\\n            }\\n\\n            if(l2 != NULL){\\n                sum += l2->val;\\n                l2 = l2->next;\\n            }\\n\\n            int digit = sum%10;\\n            carry = sum/10;\\n\\n            curr->next = new ListNode(digit);\\n            curr = curr->next;\\n        }\\n\\n        return dummyHead->next;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* nl1 = reverseList(l1);\\n        ListNode* nl2 = reverseList(l2);\\n        return (reverseList(add(nl1, nl2)));\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Use Stacks\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n\\n        while(l1){\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        while(l2){\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n\\n        ListNode* dummy = NULL;\\n        int carry = 0;\\n        while(!s1.empty() || !s2.empty() || carry != 0) {\\n            int sum = carry;\\n            if(!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if(!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n\\n            int digit = sum%10;\\n            carry = sum/10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            newNode->next = dummy;\\n            dummy = newNode;\\n        }\\n\\n        return dummy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == NULL) return head;\\n        ListNode* newHead = NULL;\\n        while(head != NULL){\\n            ListNode* next = head->next;\\n            head->next = newHead;\\n            newHead = head;\\n            head = next;\\n        } \\n\\n        return newHead;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2) {\\n        auto dummyHead = new ListNode(0); \\n        auto curr = dummyHead;\\n        int carry = 0;\\n\\n        while(l1 != NULL || l2 != NULL || carry > 0){\\n            int sum = carry;\\n\\n            if(l1 != NULL){\\n                sum += l1->val;\\n                l1 = l1->next;\\n            }\\n\\n            if(l2 != NULL){\\n                sum += l2->val;\\n                l2 = l2->next;\\n            }\\n\\n            int digit = sum%10;\\n            carry = sum/10;\\n\\n            curr->next = new ListNode(digit);\\n            curr = curr->next;\\n        }\\n\\n        return dummyHead->next;\\n    }\\n\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* nl1 = reverseList(l1);\\n        ListNode* nl2 = reverseList(l2);\\n        return (reverseList(add(nl1, nl2)));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1;\\n        stack<int> s2;\\n\\n        while(l1){\\n            s1.push(l1->val);\\n            l1 = l1->next;\\n        }\\n\\n        while(l2){\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n\\n        ListNode* dummy = NULL;\\n        int carry = 0;\\n        while(!s1.empty() || !s2.empty() || carry != 0) {\\n            int sum = carry;\\n            if(!s1.empty()) {\\n                sum += s1.top();\\n                s1.pop();\\n            }\\n            if(!s2.empty()) {\\n                sum += s2.top();\\n                s2.pop();\\n            }\\n\\n            int digit = sum%10;\\n            carry = sum/10;\\n\\n            ListNode* newNode = new ListNode(digit);\\n            newNode->next = dummy;\\n            dummy = newNode;\\n        }\\n\\n        return dummy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776328,
                "title": "c-solution-using-stack-easy-fast",
                "content": "# Intuition\\nTo solve this problem, we can utilize stacks to store the digits of the two linked lists in reverse order. We\\'ll then perform the addition digit by digit while keeping track of the carry. Finally, we\\'ll create a new linked list from the resulting digits.\\n\\n# Approach\\n1. Initialize two pointers `node1` and `node2` to the heads of `l1` and `l2` respectively.\\n2. Create two stacks `st1` and `st2` to store the digits of `l1` and `l2` in reverse order.\\n3. Iterate through `l1` and push each digit onto `st1`. Move `node1` to the next node until `node1` becomes null.\\n4. Similarly, iterate through `l2` and push each digit onto `st2`. Move `node2` to the next node until `node2` becomes null.\\n5. Create an empty vector `ans` to store the digits of the resulting sum.\\n6. Initialize a carry variable to 0.\\n7. While both `st1` and `st2` are not empty:\\n   - Pop the top digits from `st1` and `st2`.\\n   - Add the popped digits and the carry together. Store the sum in a variable `sum`.\\n   - Update the carry by dividing `sum` by 10.\\n   - Push the remainder of `sum` (i.e., `sum % 10`) into `ans`.\\n8. After the above loop, at least one of `st1` and `st2` will be empty.\\n9. While `st1` is not empty:\\n   - Pop the top digit from `st1`.\\n   - Add the popped digit and the carry together. Store the sum in `sum`.\\n   - Update the carry by dividing `sum` by 10.\\n   - Push the remainder of `sum` into `ans`.\\n10. While `st2` is not empty:\\n    - Pop the top digit from `st2`.\\n    - Add the popped digit and the carry together. Store the sum in `sum`.\\n    - Update the carry by dividing `sum` by 10.\\n    - Push the remainder of `sum` into `ans`.\\n11. If there is a remaining carry greater than 0, push it into `ans`.\\n12. Create a dummy node and a temporary pointer `temp` pointing to the dummy node.\\n13. Iterate through the `ans` vector in reverse order:\\n   - Create a new node with the current digit.\\n   - Set `temp->next` to the new node.\\n   - Move `temp` to the next node.\\n14. Return the next pointer of the dummy node, which will be the head of the resulting linked list.\\n\\n# Complexity\\n- Time complexity: O(n + m), where n and m are the lengths of `l1` and `l2` respectively. We iterate through both linked lists once to convert them into stacks.\\n- Space complexity: O(n + m), the space required to store the two stacks and the resulting digits vector.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode* node1 = l1;\\n        ListNode* node2= l2;\\n\\n        stack<int>st1, st2;\\n        while(node1) {\\n            st1.push(node1->val);\\n            node1=node1->next;\\n        }\\n        while(node2){\\n            st2.push(node2->val);\\n            node2=node2->next;\\n        }\\n        vector<int>ans;\\n        int carry =0;\\n        while(!st1.empty() && !st2.empty()){\\n            int sum = st1.top()+st2.top()+carry;\\n            st1.pop(); st2.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        while(!st1.empty()){\\n            int sum = st1.top()+carry;\\n            st1.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        while(!st2.empty()){\\n            int sum = st2.top()+carry;\\n            st2.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        if(carry>0){\\n            ans.push_back(carry);\\n        }\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp =dummy;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            ListNode* newNode = new ListNode(ans[i]);\\n            temp->next = newNode;\\n            temp =temp->next;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        \\n        ListNode* node1 = l1;\\n        ListNode* node2= l2;\\n\\n        stack<int>st1, st2;\\n        while(node1) {\\n            st1.push(node1->val);\\n            node1=node1->next;\\n        }\\n        while(node2){\\n            st2.push(node2->val);\\n            node2=node2->next;\\n        }\\n        vector<int>ans;\\n        int carry =0;\\n        while(!st1.empty() && !st2.empty()){\\n            int sum = st1.top()+st2.top()+carry;\\n            st1.pop(); st2.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        while(!st1.empty()){\\n            int sum = st1.top()+carry;\\n            st1.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        while(!st2.empty()){\\n            int sum = st2.top()+carry;\\n            st2.pop();\\n            carry=sum/10;\\n            ans.push_back(sum%10);\\n        }\\n        if(carry>0){\\n            ans.push_back(carry);\\n        }\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp =dummy;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            ListNode* newNode = new ListNode(ans[i]);\\n            temp->next = newNode;\\n            temp =temp->next;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776164,
                "title": "c-stack-implementation",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n\\n        while (l1 != NULL) {\\n            s1.push(l1 -> val);\\n            l1 = l1 -> next;\\n        }\\n\\n        while (l2 != NULL) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        int carry = 0;\\n        int totalSum = 0;\\n        ListNode *ans = new ListNode();\\n        ListNode *temp = NULL;\\n\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) {\\n                totalSum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                totalSum += s2.top();\\n                s2.pop();\\n            }\\n            carry = totalSum / 10;\\n            ListNode* newHead = new ListNode(totalSum % 10);\\n            newHead -> next = temp;\\n            temp = newHead;\\n            totalSum = carry;\\n        }\\n\\n        if (carry != 0) {\\n            ListNode* newHead = new ListNode(carry);\\n            newHead->next = temp;\\n            temp = newHead;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1, s2;\\n\\n        while (l1 != NULL) {\\n            s1.push(l1 -> val);\\n            l1 = l1 -> next;\\n        }\\n\\n        while (l2 != NULL) {\\n            s2.push(l2->val);\\n            l2 = l2->next;\\n        }\\n\\n        int carry = 0;\\n        int totalSum = 0;\\n        ListNode *ans = new ListNode();\\n        ListNode *temp = NULL;\\n\\n        while (!s1.empty() || !s2.empty()) {\\n            if (!s1.empty()) {\\n                totalSum += s1.top();\\n                s1.pop();\\n            }\\n            if (!s2.empty()) {\\n                totalSum += s2.top();\\n                s2.pop();\\n            }\\n            carry = totalSum / 10;\\n            ListNode* newHead = new ListNode(totalSum % 10);\\n            newHead -> next = temp;\\n            temp = newHead;\\n            totalSum = carry;\\n        }\\n\\n        if (carry != 0) {\\n            ListNode* newHead = new ListNode(carry);\\n            newHead->next = temp;\\n            temp = newHead;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776100,
                "title": "easy-c-beats-94-reverse-linkedlist-adding-2-linkedlist",
                "content": "# Intuition\\nIn the question it is stated that digits of a number is stored in reverse order so for thst we need to reverse the linked list and then we can add the linked lists.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nreverse the linked list by using 3 pointers so that it takes O(N) time complexity and then to add we will run a loop by having a intger carry that holds carry after adding we will reverse the linked list again.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n       ListNode* p,*q,*r;\\n       p=head;\\n       q=NULL;\\n       r=NULL;\\n       while(p!=NULL){\\n           if(q!=NULL){\\n               q->next=r;\\n               r=q;\\n           }\\n           q=p;\\n           p=p->next;\\n       } \\n       if(q!=NULL)\\n        q->next=r;\\n        return q;\\n    }\\n     ListNode* addNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* head=NULL;\\n        ListNode* p, *q;\\n        p=l1;\\n        q=l2;\\n        ListNode* tail;\\n        int c=0;\\n        while(p!=NULL&&q!=NULL){\\n           int k= p->val+q->val+c;\\n           if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           p=p->next;\\n           q=q->next;\\n        }\\n        while(p!=NULL){\\n            int k= p->val+c;\\n            if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           p=p->next;\\n        }\\n        while(q!=NULL){\\n            int k= q->val+c;\\n            if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           q=q->next;\\n        }\\n        if(c==1){\\n            if(head==NULL){\\n               head =new ListNode();\\n               head->val=c;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=c;\\n               tail->next=t;\\n               tail=t;\\n           }\\n        }\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverseList(l1);\\n        l2=reverseList(l2);\\n        return reverseList(addNumbers(l1,l2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n       ListNode* p,*q,*r;\\n       p=head;\\n       q=NULL;\\n       r=NULL;\\n       while(p!=NULL){\\n           if(q!=NULL){\\n               q->next=r;\\n               r=q;\\n           }\\n           q=p;\\n           p=p->next;\\n       } \\n       if(q!=NULL)\\n        q->next=r;\\n        return q;\\n    }\\n     ListNode* addNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* head=NULL;\\n        ListNode* p, *q;\\n        p=l1;\\n        q=l2;\\n        ListNode* tail;\\n        int c=0;\\n        while(p!=NULL&&q!=NULL){\\n           int k= p->val+q->val+c;\\n           if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           p=p->next;\\n           q=q->next;\\n        }\\n        while(p!=NULL){\\n            int k= p->val+c;\\n            if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           p=p->next;\\n        }\\n        while(q!=NULL){\\n            int k= q->val+c;\\n            if(k>=10){\\n               c=1;\\n               k=k%10;\\n           }else{\\n               c=0;\\n           }\\n           if(head==NULL){\\n               head =new ListNode();\\n               head->val=k;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=k;\\n               tail->next=t;\\n               tail=t;\\n           }\\n           q=q->next;\\n        }\\n        if(c==1){\\n            if(head==NULL){\\n               head =new ListNode();\\n               head->val=c;\\n               tail=head;\\n           }else{\\n               ListNode* t=new ListNode();\\n               t->val=c;\\n               tail->next=t;\\n               tail=t;\\n           }\\n        }\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1=reverseList(l1);\\n        l2=reverseList(l2);\\n        return reverseList(addNumbers(l1,l2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776004,
                "title": "c-solution-for-add-two-numbers-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to perform the addition of two numbers represented as linked lists by reversing the input lists, adding the corresponding digits, and then reversing the result back to the original order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Reverse both input linked lists using the ReverseLinkedList function.\\n1. Initialize a dummy head node and a current node to build the resulting linked list.\\n1. Iterate through the reversed linked lists and add the corresponding digits along with any carry from the previous addition. Update the carry and insert the sum digit into the new linked list.\\n1. After iterating through both linked lists, check if there is any remaining carry. If so, add it as a new node to the result.\\n1. Reverse the resulting linked list using the ReverseLinkedList function to restore the original order.\\n1. Return the reversed linked list, which represents the sum of the two numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(max(N, M)), where N and M are the lengths of the input linked lists. We iterate through the lists once to reverse them and once to perform the addition.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) since we are modifying the input lists in place and using a constant amount of additional space for variables.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode reversedL1 = ReverseLinkedList(l1);\\n        ListNode reversedL2 = ReverseLinkedList(l2);\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        int carry = 0;\\n        \\n        while (reversedL1 != null || reversedL2 != null || carry != 0) {\\n            int sum = carry;\\n            if (reversedL1 != null) {\\n                sum += reversedL1.val;\\n                reversedL1 = reversedL1.next;\\n            }\\n            if (reversedL2 != null) {\\n                sum += reversedL2.val;\\n                reversedL2 = reversedL2.next;\\n            }\\n            \\n            curr.next = new ListNode(sum % 10);\\n            curr = curr.next;\\n            carry = sum / 10;\\n        }\\n        \\n        return ReverseLinkedList(dummyHead.next);\\n    }\\n\\n     private ListNode ReverseLinkedList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode reversedL1 = ReverseLinkedList(l1);\\n        ListNode reversedL2 = ReverseLinkedList(l2);\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        int carry = 0;\\n        \\n        while (reversedL1 != null || reversedL2 != null || carry != 0) {\\n            int sum = carry;\\n            if (reversedL1 != null) {\\n                sum += reversedL1.val;\\n                reversedL1 = reversedL1.next;\\n            }\\n            if (reversedL2 != null) {\\n                sum += reversedL2.val;\\n                reversedL2 = reversedL2.next;\\n            }\\n            \\n            curr.next = new ListNode(sum % 10);\\n            curr = curr.next;\\n            carry = sum / 10;\\n        }\\n        \\n        return ReverseLinkedList(dummyHead.next);\\n    }\\n\\n     private ListNode ReverseLinkedList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775749,
                "title": "java-linkedlist-reverse-o-n-easy",
                "content": "\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode ll1, ListNode ll2) {\\n        ListNode ans = new ListNode();\\n        ListNode res = ans;\\n        int c = 0;\\n        ListNode l1 = reverse(ll1);\\n        ListNode l2 = reverse(ll2);\\n        while(l1!=null || l2!=null){\\n            int s = 0;\\n            if(l1 != null){\\n                s += l1.val;\\n                l1 = l1.next;\\n            }\\n            if(l2 != null){\\n                s += l2.val;\\n                l2 = l2.next;\\n            }\\n            s += c;\\n            ans.next = new ListNode(s % 10);\\n            ans = ans.next;\\n            c = s / 10;\\n            \\n        }\\n        if(c > 0){\\n            ans.next = new ListNode(c);\\n        }\\n        return reverse(res.next);\\n        \\n    }\\n    public static ListNode reverse(ListNode node){\\n        ListNode pre = null , temp ;\\n        while(node != null){\\n            temp = node.next;\\n            node.next = pre;\\n            pre = node;\\n            node  = temp;\\n        }\\n        return pre;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode ll1, ListNode ll2) {\\n        ListNode ans = new ListNode();\\n        ListNode res = ans;\\n        int c = 0;\\n        ListNode l1 = reverse(ll1);\\n        ListNode l2 = reverse(ll2);\\n        while(l1!=null || l2!=null){\\n            int s = 0;\\n            if(l1 != null){\\n                s += l1.val;\\n                l1 = l1.next;\\n            }\\n            if(l2 != null){\\n                s += l2.val;\\n                l2 = l2.next;\\n            }\\n            s += c;\\n            ans.next = new ListNode(s % 10);\\n            ans = ans.next;\\n            c = s / 10;\\n            \\n        }\\n        if(c > 0){\\n            ans.next = new ListNode(c);\\n        }\\n        return reverse(res.next);\\n        \\n    }\\n    public static ListNode reverse(ListNode node){\\n        ListNode pre = null , temp ;\\n        while(node != null){\\n            temp = node.next;\\n            node.next = pre;\\n            pre = node;\\n            node  = temp;\\n        }\\n        return pre;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775690,
                "title": "daily-leetcoding-challenge-july-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/add-two-numbers-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using Stack\n\n  \n**Approach 2:** Reverse Given Linked Lists\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/add-two-numbers-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3769140,
                "title": "easy-to-understand-no-stacks-reverselist-c-java-explained-straight-forward",
                "content": "\\n\\n# Code in Java\\n```\\n          // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09 \\nclass Solution {\\n    \\n    ListNode reverseList(ListNode head)\\n    {\\n        ListNode p=null,c=head,n=c.next;\\n        while(c!=null)\\n        {\\n            c.next=p;\\n            p=c;\\n            c=n;\\n            if(n!=null)\\n            {\\n                n=n.next;\\n            }\\n        }\\n        return p;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2)\\n     {\\n         l1=reverseList(l1);\\n         l2=reverseList(l2);\\n         ListNode l3 = new ListNode();\\n       ListNode temp=l3;\\n       int carry=0;\\n       while(l1!=null || l2!=null ||carry >0 )\\n       {\\n           int sum=0;\\n           if(l1!=null)\\n           {\\n               sum+=l1.val;\\n               l1=l1.next;\\n           }\\n           if(l2!=null)\\n           {\\n               sum+=l2.val;\\n               l2=l2.next;\\n           }\\n           sum+=carry;\\n           carry=sum/10;\\n          ListNode node = new ListNode(sum%10);\\n           temp.next=node;\\n           temp=temp.next;\\n             //temp.next = new ListNode(sum % 10);\\n            //temp = temp.next;\\n\\n\\n         }\\n         l3=reverseList(l3.next);\\n         return l3;\\n        \\n    }\\n\\n}\\n```\\n# Code in C++\\n```\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09   \\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head )\\n     {\\n         \\n        ListNode *p= NULL, *c = head, *n=head->next;   \\n        while(c!=NULL)\\n        {\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            if(n!=NULL)\\n            {\\n            n=n->next;}\\n        }\\n        return p;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n    {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode* l3 = new ListNode(0);\\n        ListNode* temp = l3;\\n        int carry =0;\\n        while(l1 or l2 or carry){\\n        int sum =0;\\n        if(l1){\\n            sum+=l1->val;\\n            l1 = l1->next;\\n        }\\n        if(l2){\\n            sum+=l2->val;\\n            l2 = l2->next;\\n        }\\n        sum+=carry;\\n        carry = sum/10;\\n        ListNode* newnode = new ListNode(sum%10);\\n        temp->next = newnode;\\n        temp = temp->next;\\n        \\n    }\\n    l3 = reverseList(l3->next);\\n    return l3;\\n\\n    }\\n};\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code is a C++ implementation of a solution for adding two numbers represented as linked lists. The solution first reverses both input linked lists, performs the addition digit by digit, and then reverses the resulting linked list.\\n\\nLet\\'s break down the code:\\n\\n1. The reverseList function is defined to reverse a given linked list. It takes the head of the list as input and returns the new head after reversal.\\n2. Inside the reverseList function, three pointers p, c, and n are declared and initialized. p is set to NULL, c is set to the head of the input list (head), and n is set to the next node after c.\\n3. The while loop iterates until c becomes NULL, which means we have reached the end of the original list.\\n4. Inside the loop, the next pointer of the current node (c->next) is set to p, reversing the link.\\n5. Then, p is updated to the current node c, c is updated to the next node n, and if n is not NULL, n is updated to the next node after n.\\n6. After the loop, the function returns p, which is the new head of the reversed list.\\n7. The addTwoNumbers function takes two ListNode pointers, l1 and l2, as input. These represent the heads of the two linked lists containing the digits of the numbers to be added.\\n8. The function first reverses both l1 and l2 using the reverseList function.\\n9. It declares a new ListNode pointer l3 and initializes it with a new ListNode object with a value of 0. This l3 will store the result of the addition.\\n10. It also declares a temporary ListNode pointer temp and sets it to l3. This temp pointer will be used to traverse and construct the result list.\\n11. An integer variable carry is initialized to 0. This variable will store the carry value obtained during addition.\\n12. The while loop runs until either l1, l2, or carry has a non-zero value, indicating there are more digits to process or a carry is present.\\n13. Inside the loop, the code adds the corresponding digits from l1 and l2, along with the carry value, to the variable sum.\\n14. If l1 is not NULL, the current node\\'s value is added to sum, and l1 is moved to the next node.\\n15. Similarly, if l2 is not NULL, the current node\\'s value is added to sum, and l2 is moved to the next node.\\n16. The code also adds the carry value to sum.The carry value for the next iteration is updated by dividing sum by 10.\\n17. A new ListNode object newnode is created with the value sum % 10. This will be the value of the current node in the result list, as the sum of two digits cannot exceed 19 (9 + 9 + 1 carry).\\n18. The temp node\\'s next pointer is set to newnode, linking the current node to the result list. Then, temp is updated to point to the newly added node newnode.\\n19. The loop continues until either l1, l2, or carry has a non-zero value. After the loop, the resulting linked list l3 is reversed again using the reverseList function, but only the part after the initial 0 value node (l3->next).\\n20. Finally, the function returns the reversed l3, which represents the linked list containing the sum of the two input numbers.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n          // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09 \\nclass Solution {\\n    \\n    ListNode reverseList(ListNode head)\\n    {\\n        ListNode p=null,c=head,n=c.next;\\n        while(c!=null)\\n        {\\n            c.next=p;\\n            p=c;\\n            c=n;\\n            if(n!=null)\\n            {\\n                n=n.next;\\n            }\\n        }\\n        return p;\\n    }\\n\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2)\\n     {\\n         l1=reverseList(l1);\\n         l2=reverseList(l2);\\n         ListNode l3 = new ListNode();\\n       ListNode temp=l3;\\n       int carry=0;\\n       while(l1!=null || l2!=null ||carry >0 )\\n       {\\n           int sum=0;\\n           if(l1!=null)\\n           {\\n               sum+=l1.val;\\n               l1=l1.next;\\n           }\\n           if(l2!=null)\\n           {\\n               sum+=l2.val;\\n               l2=l2.next;\\n           }\\n           sum+=carry;\\n           carry=sum/10;\\n          ListNode node = new ListNode(sum%10);\\n           temp.next=node;\\n           temp=temp.next;\\n             //temp.next = new ListNode(sum % 10);\\n            //temp = temp.next;\\n\\n\\n         }\\n         l3=reverseList(l3.next);\\n         return l3;\\n        \\n    }\\n\\n}\\n```\n```\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09   \\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head )\\n     {\\n         \\n        ListNode *p= NULL, *c = head, *n=head->next;   \\n        while(c!=NULL)\\n        {\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            if(n!=NULL)\\n            {\\n            n=n->next;}\\n        }\\n        return p;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)\\n    {\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n        ListNode* l3 = new ListNode(0);\\n        ListNode* temp = l3;\\n        int carry =0;\\n        while(l1 or l2 or carry){\\n        int sum =0;\\n        if(l1){\\n            sum+=l1->val;\\n            l1 = l1->next;\\n        }\\n        if(l2){\\n            sum+=l2->val;\\n            l2 = l2->next;\\n        }\\n        sum+=carry;\\n        carry = sum/10;\\n        ListNode* newnode = new ListNode(sum%10);\\n        temp->next = newnode;\\n        temp = temp->next;\\n        \\n    }\\n    l3 = reverseList(l3->next);\\n    return l3;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708752,
                "title": "add-two-numbers-ii-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "![image](https://assets.leetcode.com/users/images/c48852bb-122b-4200-8611-7c54bc01bd6d_1688305623.9485543.png)\\n\\n```\\nclass countList {\\n    constructor() {\\n        this.counting = 0;\\n        this.tempRef = null;\\n    }\\n    count(list) {\\n        this.tempRef = list;\\n        while (this.tempRef) {\\n            this.counting += 1;\\n            this.tempRef = this.tempRef.next;\\n        }\\n        return this.counting;\\n    }\\n}\\nclass Node {\\n    constructor(data, next = null) {\\n        this.val = data;\\n        this.next = next;\\n    }\\n}\\nvar addTwoNumbers = function(l1, l2) {\\n    const l1Count = new countList().count(l1);\\n    const l2Count = new countList().count(l2);\\n    function startExploring(list1, list2, grace) {\\n        if (list1 === null && list2 === null) {\\n            return;\\n        }\\n        if (grace) {\\n            grace--;\\n            return startExploring(list1.next, list2, grace);\\n        } else {\\n            list1.val += list2.val;\\n            return startExploring(list1.next, list2.next, grace);\\n        }\\n    }\\n    function recursion(list) {\\n        let reminder = null;\\n        if (list === null) {\\n            return null;\\n        }\\n        let lastDigit = null;\\n        const rem = recursion(list.next);\\n        if (rem !== null) {\\n            list.val += rem;\\n            reminder = null;\\n        }\\n        if (list.val > 9) {\\n            lastDigit = list.val % 10;\\n            list.val = lastDigit;\\n            reminder = 1;\\n        }\\n        return reminder;\\n    }\\n    if (l1Count === l2Count || l1Count > l2Count) {\\n        startExploring(l1, l2, l1Count - l2Count);\\n        const rem = recursion(l1);\\n        if (rem !== null) {\\n            l1.val += rem * 10;\\n        }\\n        if (l1.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l1.val % 10;\\n            l1.val = modulus;\\n            newNode.next = l1;\\n            return newNode;\\n        }\\n        return l1;\\n    } else {\\n        startExploring(l2, l1, l2Count - l1Count);\\n        const rem = recursion(l2);\\n        if (rem !== null) {\\n            l2.val += rem * 10;\\n        }\\n        if (l2.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l2.val % 10;\\n            l2.val = modulus;\\n            newNode.next = l2;\\n            return newNode;\\n        }\\n        return l2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass countList {\\n    constructor() {\\n        this.counting = 0;\\n        this.tempRef = null;\\n    }\\n    count(list) {\\n        this.tempRef = list;\\n        while (this.tempRef) {\\n            this.counting += 1;\\n            this.tempRef = this.tempRef.next;\\n        }\\n        return this.counting;\\n    }\\n}\\nclass Node {\\n    constructor(data, next = null) {\\n        this.val = data;\\n        this.next = next;\\n    }\\n}\\nvar addTwoNumbers = function(l1, l2) {\\n    const l1Count = new countList().count(l1);\\n    const l2Count = new countList().count(l2);\\n    function startExploring(list1, list2, grace) {\\n        if (list1 === null && list2 === null) {\\n            return;\\n        }\\n        if (grace) {\\n            grace--;\\n            return startExploring(list1.next, list2, grace);\\n        } else {\\n            list1.val += list2.val;\\n            return startExploring(list1.next, list2.next, grace);\\n        }\\n    }\\n    function recursion(list) {\\n        let reminder = null;\\n        if (list === null) {\\n            return null;\\n        }\\n        let lastDigit = null;\\n        const rem = recursion(list.next);\\n        if (rem !== null) {\\n            list.val += rem;\\n            reminder = null;\\n        }\\n        if (list.val > 9) {\\n            lastDigit = list.val % 10;\\n            list.val = lastDigit;\\n            reminder = 1;\\n        }\\n        return reminder;\\n    }\\n    if (l1Count === l2Count || l1Count > l2Count) {\\n        startExploring(l1, l2, l1Count - l2Count);\\n        const rem = recursion(l1);\\n        if (rem !== null) {\\n            l1.val += rem * 10;\\n        }\\n        if (l1.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l1.val % 10;\\n            l1.val = modulus;\\n            newNode.next = l1;\\n            return newNode;\\n        }\\n        return l1;\\n    } else {\\n        startExploring(l2, l1, l2Count - l1Count);\\n        const rem = recursion(l2);\\n        if (rem !== null) {\\n            l2.val += rem * 10;\\n        }\\n        if (l2.val > 9) {\\n            const newNode = new Node(1);\\n            const modulus = l2.val % 10;\\n            l2.val = modulus;\\n            newNode.next = l2;\\n            return newNode;\\n        }\\n        return l2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698520,
                "title": "omg-binbin-s-best-solution-ever-beats-98-5-for-runtime-and-66-for-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        # calculate number from each list \\n        # add two num, convert val into string\\n        #loop over string\\'s each digit, create a new list\\n        def cal_num(node):\\n            num = 0\\n            while node:\\n                num = num*10 +(node.val)\\n                node = node.next\\n            return int(num)\\n            \\n        int_1 = cal_num(l1)\\n        int_2 = cal_num(l2)\\n        int_ret = str(int_1+int_2)\\n\\n        node_list = []\\n        for dig in int_ret:\\n            new_node = ListNode(int(dig))\\n            node_list.append(new_node)\\n        \\n        head = node_list[0]\\n        for j in range(len(node_list)-1):\\n            node_list[j].next = node_list[j+1]\\n        \\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        # calculate number from each list \\n        # add two num, convert val into string\\n        #loop over string\\'s each digit, create a new list\\n        def cal_num(node):\\n            num = 0\\n            while node:\\n                num = num*10 +(node.val)\\n                node = node.next\\n            return int(num)\\n            \\n        int_1 = cal_num(l1)\\n        int_2 = cal_num(l2)\\n        int_ret = str(int_1+int_2)\\n\\n        node_list = []\\n        for dig in int_ret:\\n            new_node = ListNode(int(dig))\\n            node_list.append(new_node)\\n        \\n        head = node_list[0]\\n        for j in range(len(node_list)-1):\\n            node_list[j].next = node_list[j+1]\\n        \\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360998,
                "title": "solution",
                "content": "```C++ []\\nclass Solution\\n{\\npublic:\\n    ListNode *reverse(ListNode *&head, int &count)\\n    {\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n\\n        while (curr != NULL)\\n        {\\n            count++;\\n            ListNode *next_to_curr = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next_to_curr;\\n        }\\n        return prev;\\n    }\\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\\n    {\\n        int count1 = 0, count2 = 0, carry = 0;\\n\\n        ListNode *ll1 = new ListNode(0);\\n        ListNode *ll2 = new ListNode(0);\\n\\n        ll1->next = l1;\\n        ll2->next = l2;\\n        l1 = ll1;\\n        l2 = ll2;\\n\\n        l1 = reverse(l1, count1);\\n        l2 = reverse(l2, count2);\\n        ListNode *ans, *curr;\\n\\n        if (count1 >= count2)\\n        {\\n            ans = l1;\\n            curr = l1;\\n        }\\n        else\\n        {\\n            ans = l2;\\n            curr = l2;\\n        }\\n        while (l1 != NULL && l2 != NULL)\\n        {\\n            int val1 = l1->val;\\n            int val2 = l2->val;\\n\\n            curr->val = (carry + val1 + val2) % 10;\\n            carry = (carry + val1 + val2) / 10;\\n\\n            l1 = l1->next;\\n            l2 = l2->next;\\n            curr = curr->next;\\n        }\\n        while (l1 != NULL)\\n        {\\n            int val1 = l1->val;\\n\\n            curr->val = (carry + val1) % 10;\\n            carry = (carry + val1) / 10;\\n\\n            l1 = l1->next;\\n            curr = curr->next;\\n        }\\n        while (l2 != NULL)\\n        {\\n            int val2 = l2->val;\\n\\n            curr->val = (carry + val2) % 10;\\n            carry = (carry + val2) / 10;\\n\\n            l2 = l2->next;\\n            curr = curr->next;\\n        }\\n        ans = reverse(ans, count1);\\n        if (ans->val != 0)\\n        {\\n            return (ans);\\n        }\\n        else\\n        {\\n            return (ans->next);\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        l1list,l2list = [],[]\\n        while l1:\\n            l1list.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            l2list.append(l2.val)\\n            l2 = l2.next\\n        o = None\\n        ca = 0\\n        while l1list or l2list or ca:\\n            c1 = l1list.pop() if l1list else 0\\n            c2 = l2list.pop() if l2list else 0\\n            t = c1+c2+ca\\n            ca = t//10\\n            res = t%10\\n            cur = ListNode(res)\\n            cur.next = o\\n            o = cur\\n        return o\\n```\\n\\n```Java []\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1); l2 = reverse(l2);\\n        ListNode ans = new ListNode(-1), head = ans;\\n        int carry = 0;\\n        while (l1 != null || l2 != null || carry != 0) {\\n            int sum = carry;\\n            if (l1 != null) {\\n                sum += l1.val; l1 = l1.next;\\n            }\\n            if (l2 != null) {\\n                sum += l2.val; l2 = l2.next;\\n            }\\n            head.next = new ListNode(sum % 10, null);\\n            head = head.next;\\n            carry = sum / 10;\\n        }\\n        return reverse(ans.next);\\n    }\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution\\n{\\npublic:\\n    ListNode *reverse(ListNode *&head, int &count)\\n    {\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n\\n        while (curr != NULL)\\n        {\\n            count++;\\n            ListNode *next_to_curr = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next_to_curr;\\n        }\\n        return prev;\\n    }\\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\\n    {\\n        int count1 = 0, count2 = 0, carry = 0;\\n\\n        ListNode *ll1 = new ListNode(0);\\n        ListNode *ll2 = new ListNode(0);\\n\\n        ll1->next = l1;\\n        ll2->next = l2;\\n        l1 = ll1;\\n        l2 = ll2;\\n\\n        l1 = reverse(l1, count1);\\n        l2 = reverse(l2, count2);\\n        ListNode *ans, *curr;\\n\\n        if (count1 >= count2)\\n        {\\n            ans = l1;\\n            curr = l1;\\n        }\\n        else\\n        {\\n            ans = l2;\\n            curr = l2;\\n        }\\n        while (l1 != NULL && l2 != NULL)\\n        {\\n            int val1 = l1->val;\\n            int val2 = l2->val;\\n\\n            curr->val = (carry + val1 + val2) % 10;\\n            carry = (carry + val1 + val2) / 10;\\n\\n            l1 = l1->next;\\n            l2 = l2->next;\\n            curr = curr->next;\\n        }\\n        while (l1 != NULL)\\n        {\\n            int val1 = l1->val;\\n\\n            curr->val = (carry + val1) % 10;\\n            carry = (carry + val1) / 10;\\n\\n            l1 = l1->next;\\n            curr = curr->next;\\n        }\\n        while (l2 != NULL)\\n        {\\n            int val2 = l2->val;\\n\\n            curr->val = (carry + val2) % 10;\\n            carry = (carry + val2) / 10;\\n\\n            l2 = l2->next;\\n            curr = curr->next;\\n        }\\n        ans = reverse(ans, count1);\\n        if (ans->val != 0)\\n        {\\n            return (ans);\\n        }\\n        else\\n        {\\n            return (ans->next);\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        l1list,l2list = [],[]\\n        while l1:\\n            l1list.append(l1.val)\\n            l1 = l1.next\\n        while l2:\\n            l2list.append(l2.val)\\n            l2 = l2.next\\n        o = None\\n        ca = 0\\n        while l1list or l2list or ca:\\n            c1 = l1list.pop() if l1list else 0\\n            c2 = l2list.pop() if l2list else 0\\n            t = c1+c2+ca\\n            ca = t//10\\n            res = t%10\\n            cur = ListNode(res)\\n            cur.next = o\\n            o = cur\\n        return o\\n```\n```Java []\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1); l2 = reverse(l2);\\n        ListNode ans = new ListNode(-1), head = ans;\\n        int carry = 0;\\n        while (l1 != null || l2 != null || carry != 0) {\\n            int sum = carry;\\n            if (l1 != null) {\\n                sum += l1.val; l1 = l1.next;\\n            }\\n            if (l2 != null) {\\n                sum += l2.val; l2 = l2.next;\\n            }\\n            head.next = new ListNode(sum % 10, null);\\n            head = head.next;\\n            carry = sum / 10;\\n        }\\n        return reverse(ans.next);\\n    }\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343796,
                "title": "c-easy-clean-code-100-faster-solution",
                "content": "# Intuition\\nInput Linked Lists are reversed, then added and reversed again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head){\\n        ListNode* prev = nullptr;\\n        while(head){\\n            ListNode* next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // reverse the input linked lists\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n\\n        int carry = 0;\\n        ListNode* ans = new ListNode();\\n        ListNode* tail = ans;\\n\\n        while(l1 || l2 || carry){\\n            int sum = carry;\\n            if(l1) sum += l1->val, l1 = l1->next;\\n            if(l2) sum += l2->val, l2 = l2->next;\\n            carry = sum / 10;\\n            tail->next = new ListNode(sum % 10);\\n            tail = tail->next;\\n        }\\n        ans = reverseList(ans->next);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nPlease Upvote if you find this helpful :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head){\\n        ListNode* prev = nullptr;\\n        while(head){\\n            ListNode* next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        // reverse the input linked lists\\n        l1 = reverseList(l1);\\n        l2 = reverseList(l2);\\n\\n        int carry = 0;\\n        ListNode* ans = new ListNode();\\n        ListNode* tail = ans;\\n\\n        while(l1 || l2 || carry){\\n            int sum = carry;\\n            if(l1) sum += l1->val, l1 = l1->next;\\n            if(l2) sum += l2->val, l2 = l2->next;\\n            carry = sum / 10;\\n            tail->next = new ListNode(sum % 10);\\n            tail = tail->next;\\n        }\\n        ans = reverseList(ans->next);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223760,
                "title": "simple-and-clean-solution-c",
                "content": "The idea is simple and standard.\\n1. Reverse both the list and perform addition and .\\n2. Make a list for output and insert the sum accordingly .\\n3. The key to insert is to use **insert at head** method .\\nThat\\'s it.\\n**Time  Complexity : O(l1+l2)** \\nl1 and l2 are the length of Lists.\\n**Space Complexity : O(1) (Ignoring the answer list\\'s space).**\\n**Here\\'s my code** :\\n```\\nclass Solution {\\nprivate:\\n    void reverse(ListNode * & head){\\n        ListNode * curr = head;\\n        ListNode * prev = nullptr;\\n        ListNode * next = nullptr;\\n        while(curr){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        head=prev;\\n    }\\n    void insertHead(int num,ListNode * & ans){\\n        ListNode * nodetoInsert = new  ListNode(num);\\n        if(ans==nullptr){\\n            ans = nodetoInsert;\\n            return;\\n        }\\n        else{\\n            nodetoInsert->next=ans;\\n            ans=nodetoInsert;\\n            return;\\n        }\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        reverse(l1);\\n        reverse(l2);\\n        ListNode * ans = nullptr;\\n        int carry=0;\\n        while(l1 || l2){\\n            if(l1 && l2){\\n                int num = l1->val + l2->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l1=l1->next;\\n                l2=l2->next;\\n            }\\n            if(l1 && !l2){\\n                int num = l1->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l1=l1->next;\\n            }\\n            if(!l1 && l2){\\n                int num = l2->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(carry){\\n            insertHead(carry,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nAgain I have distributed the work on function you can just do the same thing inside the main function.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void reverse(ListNode * & head){\\n        ListNode * curr = head;\\n        ListNode * prev = nullptr;\\n        ListNode * next = nullptr;\\n        while(curr){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        head=prev;\\n    }\\n    void insertHead(int num,ListNode * & ans){\\n        ListNode * nodetoInsert = new  ListNode(num);\\n        if(ans==nullptr){\\n            ans = nodetoInsert;\\n            return;\\n        }\\n        else{\\n            nodetoInsert->next=ans;\\n            ans=nodetoInsert;\\n            return;\\n        }\\n    }\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        reverse(l1);\\n        reverse(l2);\\n        ListNode * ans = nullptr;\\n        int carry=0;\\n        while(l1 || l2){\\n            if(l1 && l2){\\n                int num = l1->val + l2->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l1=l1->next;\\n                l2=l2->next;\\n            }\\n            if(l1 && !l2){\\n                int num = l1->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l1=l1->next;\\n            }\\n            if(!l1 && l2){\\n                int num = l2->val + carry;\\n                carry=num/10;\\n                insertHead((num%10),ans);\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(carry){\\n            insertHead(carry,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193439,
                "title": "easy-solution-c-reverse-lists-and-add-the-again-reverse-ans-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = l1;\\n        //reverse first list ---- l1\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        l1 = prev;\\n\\n        //reverse second list ----l2\\n        prev = NULL;\\n        curr = l2;\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        l2 = prev;\\n        \\n        //make a list for ans initilise with 0\\n        ListNode* ans = new ListNode(0);\\n        //make a curr list which traverse or store summation of list\\n        ListNode* cur = ans;\\n        int carry = 0;\\n        while(l1!=NULL||l2!=NULL||carry>0){\\n            int sum = carry;\\n            if(l1!=NULL){\\n              sum = sum+l1->val;\\n              l1 = l1->next;\\n            }\\n            if(l2!=NULL){\\n                sum = sum+l2->val;\\n                l2 = l2->next;\\n            }\\n            carry  = sum/10;\\n            cur->next = new ListNode(sum%10);\\n            cur = cur->next;\\n        }\\n        curr = ans->next;\\n        prev = NULL;\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* prev = NULL;\\n        ListNode* curr = l1;\\n        //reverse first list ---- l1\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        l1 = prev;\\n\\n        //reverse second list ----l2\\n        prev = NULL;\\n        curr = l2;\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        l2 = prev;\\n        \\n        //make a list for ans initilise with 0\\n        ListNode* ans = new ListNode(0);\\n        //make a curr list which traverse or store summation of list\\n        ListNode* cur = ans;\\n        int carry = 0;\\n        while(l1!=NULL||l2!=NULL||carry>0){\\n            int sum = carry;\\n            if(l1!=NULL){\\n              sum = sum+l1->val;\\n              l1 = l1->next;\\n            }\\n            if(l2!=NULL){\\n                sum = sum+l2->val;\\n                l2 = l2->next;\\n            }\\n            carry  = sum/10;\\n            cur->next = new ListNode(sum%10);\\n            cur = cur->next;\\n        }\\n        curr = ans->next;\\n        prev = NULL;\\n        while(curr!=NULL){\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193289,
                "title": "easy-solution-by-using-stack-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1,s2,s3;\\n        ListNode* ans = new ListNode(0);\\n        ListNode* curr = ans;\\n        while(l1!=NULL||l2!=NULL){\\n            if(l1!=NULL){\\n                s1.push(l1->val);\\n                l1 = l1->next;\\n            }\\n            if(l2!=NULL){\\n                s2.push(l2->val);\\n                l2 = l2->next;\\n            }\\n        }\\n        int carry = 0;\\n        while(!s1.empty()||!s2.empty()){\\n        int sum = carry;\\n        if(!s1.empty())\\n        {\\n          sum = sum+s1.top();\\n          s1.pop();\\n        }\\n\\n        if(!s2.empty())\\n        {\\n         sum = sum+s2.top();\\n         s2.pop();\\n        }\\n\\n        s3.push(sum%10);\\n        carry = sum/10;\\n        }\\n        if(carry>0){\\n            s3.push(carry);\\n        }\\n        while(!s3.empty()){\\n           curr->next  = new ListNode(s3.top());\\n           curr = curr->next;\\n           s3.pop();\\n        }\\n       return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        stack<int> s1,s2,s3;\\n        ListNode* ans = new ListNode(0);\\n        ListNode* curr = ans;\\n        while(l1!=NULL||l2!=NULL){\\n            if(l1!=NULL){\\n                s1.push(l1->val);\\n                l1 = l1->next;\\n            }\\n            if(l2!=NULL){\\n                s2.push(l2->val);\\n                l2 = l2->next;\\n            }\\n        }\\n        int carry = 0;\\n        while(!s1.empty()||!s2.empty()){\\n        int sum = carry;\\n        if(!s1.empty())\\n        {\\n          sum = sum+s1.top();\\n          s1.pop();\\n        }\\n\\n        if(!s2.empty())\\n        {\\n         sum = sum+s2.top();\\n         s2.pop();\\n        }\\n\\n        s3.push(sum%10);\\n        carry = sum/10;\\n        }\\n        if(carry>0){\\n            s3.push(carry);\\n        }\\n        while(!s3.empty()){\\n           curr->next  = new ListNode(s3.top());\\n           curr = curr->next;\\n           s3.pop();\\n        }\\n       return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091682,
                "title": "java-easy-approach-explained-beats-100",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        // reversing both the list \\n        ListNode h1 = reverse(l1);\\n        ListNode h2 = reverse(l2);\\n        // making the answer list here\\n        ListNode dummy = new ListNode(0);\\n        ListNode d1 = dummy;\\n        int carry =0;\\n        // first we complete addition till where it is possible \\n        while(h1!=null && h2 != null)\\n        {\\n             int sum = h1.val + h2.val + carry;\\n             int rem = sum % 10;\\n             carry = sum/ 10;\\n            ListNode node = new ListNode(rem);\\n            d1.next = node;\\n            d1 = node;\\n            h1 = h1.next;\\n            h2 = h2.next;\\n        }\\n        \\n       // now the remaining values are handled if any left for any list \\n        // important we need to keep rem and carry here too or some tc will fail\\n        while(h2!=null )\\n           {\\n               int sum = h2.val + carry;\\n               int rem = sum %10;\\n               ListNode node = new ListNode(rem);\\n               d1.next = node;\\n               d1 = node;\\n               h2= h2.next;\\n               carry = sum /10;\\n           }\\n        // same checking if any element is left for h1 list \\n        \\n            while(h1!=null)\\n           {\\n                int sum = h1.val + carry;\\n                int rem = sum%10;\\n               ListNode node = new ListNode(rem);\\n               d1.next = node;\\n               d1 = node;\\n               h1= h1.next;\\n               carry =sum/10;\\n           }\\n            \\n        // special case where there might be some carry left\\n             if(h1 ==null  && h2 == null && carry>0)\\n            {\\n               ListNode node = new ListNode(carry );\\n                d1.next = node;\\n            }\\n        \\n        // reverse then return ans \\n        return reverse(dummy.next);\\n         \\n    }\\n    \\n    // reverse function\\n    public ListNode reverse(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = head;\\n        \\n        while(curr!=null)\\n        {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        // reversing both the list \\n        ListNode h1 = reverse(l1);\\n        ListNode h2 = reverse(l2);\\n        // making the answer list here\\n        ListNode dummy = new ListNode(0);\\n        ListNode d1 = dummy;\\n        int carry =0;\\n        // first we complete addition till where it is possible \\n        while(h1!=null && h2 != null)\\n        {\\n             int sum = h1.val + h2.val + carry;\\n             int rem = sum % 10;\\n             carry = sum/ 10;\\n            ListNode node = new ListNode(rem);\\n            d1.next = node;\\n            d1 = node;\\n            h1 = h1.next;\\n            h2 = h2.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3080894,
                "title": "java-100-fast-easy",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n                l1= rev(l1);   \\n                l2= rev(l2); \\n                if(size(l1)>=size(l2)) return rev(add(l1,l2)) ;\\n                else return rev(add(l2,l1));\\n                //return rev(l1);\\n    }\\n    public ListNode add(ListNode l1,ListNode l2)\\n    {\\n                ListNode n=l1;\\n                int c=0;\\n                while(n!=null && l2!=null)\\n                {\\n                    int x=c+n.val+l2.val;\\n                    if(x>9){ n.val=x%10;\\n                    c=x/10;\\n                    }\\n                    else{ n.val=x;\\n                    c=0;\\n                    }\\n                    n=n.next;\\n                    l2=l2.next;\\n                    \\n                }\\n                while(l2==null && n!=null) \\n                {\\n                    int x=c+n.val;\\n                    if(x>9){ n.val=x%10;\\n                    c=x/10;\\n                    }\\n                    else{ n.val=x;\\n                    c=0;\\n                    }\\n                    n=n.next;\\n                    \\n                }\\n               \\n                \\n                    if(c!=0)\\n                {\\n                    //System.out.print(\"*\");\\n                    ListNode z=new ListNode(1);\\n                    ListNode m=l1;\\n                    while(m.next!=null)\\n                    {\\n                        m=m.next;\\n                    }\\n                    m.next=z;\\n                   \\n                    \\n                }\\n                \\n                return l1;\\n    }\\n    public int size(ListNode n)\\n    {\\n        int c=0;\\n        while(n!=null)\\n        {\\n            c++;\\n            n=n.next;\\n        }\\n        return c;\\n    }\\n    public ListNode rev(ListNode n) {\\n        ListNode l=null,c=n,r=null;\\n        while(c!=null)\\n        {\\n            r=c.next;\\n            c.next=l;\\n            l=c;\\n            c=r;\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n                l1= rev(l1);   \\n                l2= rev(l2); \\n                if(size(l1)>=size(l2)) return rev(add(l1,l2)) ;\\n                else return rev(add(l2,l1));\\n                //return rev(l1);\\n    }\\n    public ListNode add(ListNode l1,ListNode l2)\\n    {\\n                ListNode n=l1;\\n                int c=0;\\n                while(n!=null && l2!=null)\\n                {\\n                    int x=c+n.val+l2.val;\\n                    if(x>9){ n.val=x%10;\\n                    c=x/10;\\n                    }\\n                    else{ n.val=x;\\n                    c=0;\\n                    }\\n                    n=n.next;\\n                    l2=l2.next;\\n                    \\n                }\\n                while(l2==null && n!=null) \\n                {\\n                    int x=c+n.val;\\n                    if(x>9){ n.val=x%10;\\n                    c=x/10;\\n                    }\\n                    else{ n.val=x;\\n                    c=0;\\n                    }\\n                    n=n.next;\\n                    \\n                }\\n               \\n                \\n                    if(c!=0)\\n                {\\n                    //System.out.print(\"*\");\\n                    ListNode z=new ListNode(1);\\n                    ListNode m=l1;\\n                    while(m.next!=null)\\n                    {\\n                        m=m.next;\\n                    }\\n                    m.next=z;\\n                   \\n                    \\n                }\\n                \\n                return l1;\\n    }\\n    public int size(ListNode n)\\n    {\\n        int c=0;\\n        while(n!=null)\\n        {\\n            c++;\\n            n=n.next;\\n        }\\n        return c;\\n    }\\n    public ListNode rev(ListNode n) {\\n        ListNode l=null,c=n,r=null;\\n        while(c!=null)\\n        {\\n            r=c.next;\\n            c.next=l;\\n            l=c;\\n            c=r;\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035256,
                "title": "c-brute-force-very-easy",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* a = reverseList(l1);\\n        ListNode* b = reverseList(l2);\\n\\n        ListNode *answer = nullptr, *curr = nullptr;\\n\\n        int carry = 0;\\n        while(a && b) {\\n            int val = a->val + b->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n\\n            if(!answer) {\\n                answer = newNode;\\n                curr = newNode;\\n            }else {\\n                curr -> next = newNode;\\n                curr = newNode;\\n            }\\n            a = a->next;\\n            b = b->next;\\n        }\\n\\n        while(a) {\\n            int val = a->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n            curr -> next = newNode;\\n            curr = newNode;\\n            a = a -> next;\\n        }\\n\\n        while(b) {\\n            int val = b->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n            curr -> next = newNode;\\n            curr = newNode;\\n            b = b -> next;\\n        }\\n\\n        if(carry) curr -> next = new ListNode(carry);\\n\\n        return reverseList(answer);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* a = reverseList(l1);\\n        ListNode* b = reverseList(l2);\\n\\n        ListNode *answer = nullptr, *curr = nullptr;\\n\\n        int carry = 0;\\n        while(a && b) {\\n            int val = a->val + b->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n\\n            if(!answer) {\\n                answer = newNode;\\n                curr = newNode;\\n            }else {\\n                curr -> next = newNode;\\n                curr = newNode;\\n            }\\n            a = a->next;\\n            b = b->next;\\n        }\\n\\n        while(a) {\\n            int val = a->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n            curr -> next = newNode;\\n            curr = newNode;\\n            a = a -> next;\\n        }\\n\\n        while(b) {\\n            int val = b->val + carry;\\n            carry = val / 10;\\n            val = val % 10;\\n            ListNode* newNode = new ListNode(val);\\n            curr -> next = newNode;\\n            curr = newNode;\\n            b = b -> next;\\n        }\\n\\n        if(carry) curr -> next = new ListNode(carry);\\n\\n        return reverseList(answer);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986403,
                "title": "easy-java-solution-add-two-numbers-ii-2ms",
                "content": "# Intuition: \\n1. reverse both given lists \\n2. traverse and add the nodes as you proceed \\n3. reverse the list attained after adding the given lists\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n        ListNode head = new ListNode( (l1.val+l2.val)%10);\\n        ListNode curr = head;\\n        int carry = (l1.val+l2.val)/10;\\n        l1 = l1.next;\\n        l2 = l2.next;\\n        while(l1!=null && l2!=null){\\n            int sum = l1.val + l2.val + carry;\\n            ListNode temp = new ListNode(sum%10);\\n            carry = sum/10;\\n            curr.next = temp;\\n            curr = curr.next;\\n            l1 = l1.next;\\n            l2 = l2.next;\\n        } // this loop will be enough if both list are \\n          // of same size but if size varries so we have 2 additional\\n          // while loops.\\n\\n        while(l1!=null){\\n            ListNode temp1 = new ListNode((l1.val+carry)%10);\\n            carry = (l1.val+carry)/10;\\n            curr.next = temp1;\\n            curr = curr.next;\\n            l1 = l1.next;\\n        }\\n        while(l2!=null){\\n            ListNode temp2 = new ListNode((l2.val+carry)%10);\\n            carry = (l2.val+carry)/10;\\n            curr.next = temp2;\\n            curr = curr.next;\\n            l2 = l2.next;\\n        }\\n        while(carry>10){\\n            ListNode temp3 = new ListNode(carry%10);\\n            curr.next = temp3;\\n            curr = curr.next;\\n            carry /=10;\\n        }\\n        if(carry!=0){\\n            ListNode temp4 = new ListNode(carry);\\n            curr.next = temp4;\\n            curr = curr.next;\\n        }\\n        head = reverse(head);\\n        return head;\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        while(curr!=null){\\n            ListNode temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        l1 = reverse(l1);\\n        l2 = reverse(l2);\\n        ListNode head = new ListNode( (l1.val+l2.val)%10);\\n        ListNode curr = head;\\n        int carry = (l1.val+l2.val)/10;\\n        l1 = l1.next;\\n        l2 = l2.next;\\n        while(l1!=null && l2!=null){\\n            int sum = l1.val + l2.val + carry;\\n            ListNode temp = new ListNode(sum%10);\\n            carry = sum/10;\\n            curr.next = temp;\\n            curr = curr.next;\\n            l1 = l1.next;\\n            l2 = l2.next;\\n        } // this loop will be enough if both list are \\n          // of same size but if size varries so we have 2 additional\\n          // while loops.\\n\\n        while(l1!=null){\\n            ListNode temp1 = new ListNode((l1.val+carry)%10);\\n            carry = (l1.val+carry)/10;\\n            curr.next = temp1;\\n            curr = curr.next;\\n            l1 = l1.next;\\n        }\\n        while(l2!=null){\\n            ListNode temp2 = new ListNode((l2.val+carry)%10);\\n            carry = (l2.val+carry)/10;\\n            curr.next = temp2;\\n            curr = curr.next;\\n            l2 = l2.next;\\n        }\\n        while(carry>10){\\n            ListNode temp3 = new ListNode(carry%10);\\n            curr.next = temp3;\\n            curr = curr.next;\\n            carry /=10;\\n        }\\n        if(carry!=0){\\n            ListNode temp4 = new ListNode(carry);\\n            curr.next = temp4;\\n            curr = curr.next;\\n        }\\n        head = reverse(head);\\n        return head;\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        while(curr!=null){\\n            ListNode temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978192,
                "title": "easy-to-understand-simple-c-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head;\\n        while (curr){\\n            ListNode* forward= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr= forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2){\\n        ListNode* head= new ListNode(-1);\\n        ListNode* curr= head;\\n        int carry=0;\\n        while (l1 || l2 || carry>0){\\n            int v1=0, v2=0;\\n            if (l1)v1= l1->val;\\n            if (l2)v2= l2->val;\\n            int sum= v1+v2+carry;\\n            carry= sum/10;\\n            sum= sum%10;\\n            curr->next= new ListNode(sum);\\n            curr= curr->next;\\n            if (l1)l1= l1->next;\\n            if (l2)l2= l2->next;\\n        }\\n        head= head->next;\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1= reverse(l1);\\n        l2= reverse(l2);\\n        ListNode* ans= add(l1,l2);\\n        ans= reverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head;\\n        while (curr){\\n            ListNode* forward= curr->next;\\n            curr->next= prev;\\n            prev= curr;\\n            curr= forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* add(ListNode* l1, ListNode* l2){\\n        ListNode* head= new ListNode(-1);\\n        ListNode* curr= head;\\n        int carry=0;\\n        while (l1 || l2 || carry>0){\\n            int v1=0, v2=0;\\n            if (l1)v1= l1->val;\\n            if (l2)v2= l2->val;\\n            int sum= v1+v2+carry;\\n            carry= sum/10;\\n            sum= sum%10;\\n            curr->next= new ListNode(sum);\\n            curr= curr->next;\\n            if (l1)l1= l1->next;\\n            if (l2)l2= l2->next;\\n        }\\n        head= head->next;\\n        return head;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        l1= reverse(l1);\\n        l2= reverse(l2);\\n        ListNode* ans= add(l1,l2);\\n        ans= reverse(ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753789,
                "title": "o-n-c-reversing-easy-understanding",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseLL(ListNode *head)\\n        {\\n            ListNode *curr = head;\\n            ListNode *prev = NULL;\\n            ListNode *forward = NULL;\\n\\n            while (curr)\\n            {\\n                forward = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = forward;\\n            }\\n            return prev;\\n        }\\n    ListNode* insert_tail(ListNode *head, int val)\\n    {\\n        ListNode *ptr = new ListNode(val);\\n        ListNode *temp = head;\\n        if (head == NULL)\\n        {\\n            head = ptr;\\n            return head;\\n        }\\n        while (temp->next)\\n        {\\n            temp = temp->next;\\n        }\\n        temp->next = ptr;\\n        return head;\\n    }\\n    ListNode* adding(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ans = NULL;\\n        int carry = 0;\\n        int sum = l1->val + l2->val;\\n        while (l1 || l2 || carry)\\n        {\\n            int val1 = 0, val2 = 0;\\n            if (l1)\\n                val1 = l1->val;\\n            if (l2)\\n                val2 = l2->val;\\n            sum = val1 + val2 + carry;\\n\\n            ans = insert_tail(ans, sum % 10);\\n            carry = sum / 10;\\n\\n            if (l1)\\n                l1 = l1->next;\\n            if (l2)\\n                l2 = l2->next;\\n        }\\n        return ans;\\n    }\\n    ListNode* addTwoNumbers(ListNode *l1, ListNode *l2)\\n    {\\n       \\t//step 1\\n        l1 = reverseLL(l1);\\n        l2 = reverseLL(l2);\\n\\n       \\t//step 2\\n        ListNode *ans = adding(l1, l2);\\n\\n       \\t//step 3\\n        ans = reverseLL(ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nplease upvote",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseLL(ListNode *head)\\n        {\\n            ListNode *curr = head;\\n            ListNode *prev = NULL;\\n            ListNode *forward = NULL;\\n\\n            while (curr)\\n            {\\n                forward = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = forward;\\n            }\\n            return prev;\\n        }\\n    ListNode* insert_tail(ListNode *head, int val)\\n    {\\n        ListNode *ptr = new ListNode(val);\\n        ListNode *temp = head;\\n        if (head == NULL)\\n        {\\n            head = ptr;\\n            return head;\\n        }\\n        while (temp->next)\\n        {\\n            temp = temp->next;\\n        }\\n        temp->next = ptr;\\n        return head;\\n    }\\n    ListNode* adding(ListNode *l1, ListNode *l2)\\n    {\\n        ListNode *ans = NULL;\\n        int carry = 0;\\n        int sum = l1->val + l2->val;\\n        while (l1 || l2 || carry)\\n        {\\n            int val1 = 0, val2 = 0;\\n            if (l1)\\n                val1 = l1->val;\\n            if (l2)\\n                val2 = l2->val;\\n            sum = val1 + val2 + carry;\\n\\n            ans = insert_tail(ans, sum % 10);\\n            carry = sum / 10;\\n\\n            if (l1)\\n                l1 = l1->next;\\n            if (l2)\\n                l2 = l2->next;\\n        }\\n        return ans;\\n    }\\n    ListNode* addTwoNumbers(ListNode *l1, ListNode *l2)\\n    {\\n       \\t//step 1\\n        l1 = reverseLL(l1);\\n        l2 = reverseLL(l2);\\n\\n       \\t//step 2\\n        ListNode *ans = adding(l1, l2);\\n\\n       \\t//step 3\\n        ans = reverseLL(ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1973461,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973686,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973479,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973534,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973665,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973611,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973491,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973451,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1569438,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1974162,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973461,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973686,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973479,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973534,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973665,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973611,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973491,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1973451,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1569438,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1974162,
                "content": [
                    {
                        "username": "meow_power",
                        "content": "Hi Guys!! Good Morning I have to share a good news that<b> I got placed yesterday </b>in a good company.And I would like to thank this <b>lc community more than friends or family <b>for lifting me up and helping me.\\n\\n<b>Thank u so much guys without u all it wouldn\\'t be possible:)</b>"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "congratulations bro . Hope u fullfill all ur dreams \\n"
                    },
                    {
                        "username": "joyzies",
                        "content": "Congratulations!! May it bring a lot of joy and great technical experience for you :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "[@Rishab_sanpui](/Rishab_sanpui) best time to sell the stock "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "GG my boi ! Congo"
                    },
                    {
                        "username": "babaali196",
                        "content": "Congrats man! Wishing you greater success"
                    },
                    {
                        "username": "daring-calf",
                        "content": "You lucky bastard!"
                    },
                    {
                        "username": "sais8105",
                        "content": "congrats brother"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "congrats we need more like this"
                    },
                    {
                        "username": "kunj_gandhi889",
                        "content": "congrats buddy!!"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "congratulations....."
                    },
                    {
                        "username": "arijitdas447284",
                        "content": "Congratulations Buddy..............."
                    },
                    {
                        "username": "Rishab_sanpui",
                        "content": "congrats!"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Great! Congrats..."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Congratulation bmro!!\\uD83E\\uDD73"
                    },
                    {
                        "username": "fur_sky",
                        "content": "congratulations! hope you go way ahead "
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Congratulations bro!!"
                    },
                    {
                        "username": "Aadil42",
                        "content": "Congrates bro!!! I really feel happy to  see these kinds of comments!! God bless you!"
                    },
                    {
                        "username": "ekalavya_pc",
                        "content": "congratulations bro!!!"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Congratulations bro, Keep going. 🤘"
                    },
                    {
                        "username": "user1174mw",
                        "content": "Congratulations bro"
                    },
                    {
                        "username": "Sanchit_Agarwal1",
                        "content": "Congratulations brother! Keep going !"
                    },
                    {
                        "username": "thanhduongphan12345",
                        "content": "Cheer bro \\uD83C\\uDF89\\uD83C\\uDF89"
                    },
                    {
                        "username": "arpitsinghania8",
                        "content": "Congratulations Bro!"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Congratulations!"
                    },
                    {
                        "username": "m_srikanth_451",
                        "content": "congratulations bro!!\\n\\nplease share how to preapare, and what to  preapare for internship ??"
                    },
                    {
                        "username": "luanct",
                        "content": "Congratulations bro!"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Loved seeing your cat pics around\\n\\nCongratulations!"
                    },
                    {
                        "username": "ajv97",
                        "content": "\"When you wanna go deep and back, think stack, baby!\""
                    },
                    {
                        "username": "Baymurat",
                        "content": "Or recursion :)"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "thanks dude!"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We progress from NP-hard problems to 2nd grade arithmetic."
                    },
                    {
                        "username": "ursachu",
                        "content": "Do you mean regress?"
                    },
                    {
                        "username": "psionl0",
                        "content": "LOL I just checked out the editorial to see how they managed the addition without reversing the lists first. It turns out that they pushed each list into its own stack which automatically reverses the order. Technically achieved but to no real advantage."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I solved it genuinely without reversing the order. All I did was first of all add up the results digit by digit without doing carry over. \\nSo for example \\n1, 3, 5, 8 +\\n   4, 0, 9\\n= 1, 7, 5, 17\\nthen I went through my result and checked for each node if it needed to be updated incase the next one was bigger than 9. \\nso check 1, next is 7 so you can continue\\ncheck 7, next is 5, so you can continue, \\ncheck 5, next is 17 so 5 becomes 6\\ncheck 17, 17 becomes 7, next is null so you can continue. \\n\\nYou need to be careful if next is 9, but this still genuinely solves it without reversing order. "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It is not faster :) ( i\\'m dumb )"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Zaki-1337](/Zaki-1337) How can you tell? I wouldn\\'t have thought there was much time difference between reversing a list or emptying it into a stack. Of course the displayed run times are too unreliable to draw any real conclusions from them."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "they used space in general, Ahh what a waste of brain"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "well it is faster :)"
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "Be careful about the constraint:\\nThe number of nodes in each linked list is in the range [1, 100].\\n\\nThis means that the number can be up to 10^100 which is much larger than Integer.MAX_VALUE (~2^31) and even Long.MAX_VALUE (~2^63).\\n\\nDon\\'t try adding up l1 and l2 as two big numbers and then add them together."
                    },
                    {
                        "username": "Michael-Qu",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) True, but I don\\'t think that is the way that interviewers like"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Python users with their unlimited Int don not see a problem here at all."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Reverse the linked lists! Then perform the school arithmetic with care on carry. Just do it."
                    },
                    {
                        "username": "desertf33",
                        "content": "Why do we have to reverse?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@suren-yeager](/suren-yeager) if you want to do it without reversing the lists, you can use strings to store the values and then traverse both the strings simultaneously from the back and do the sum. Also to avoid reversing the final list, append the nodes from the front. In this way you can do better!"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "very very intuitive one! but is there any more optimization that could be done?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Don\\'t waste your time trying to store the total sum of each linked list\\'s nodes into an actual variable. The later testcases go way above what even a long can store."
                    },
                    {
                        "username": "anshu-6537",
                        "content": "[@Leaderboard](/Leaderboard)  getting error on 1560th case : [1,1,1,1,1,1,1,1,1,1,1]  [1,1,1,1,1,1,1,1,1,1,1] .  I have converted the given linked list into biginteger and then did addition operation on the bigintegers then again converted it back to linked list.\\n\\nMy code :\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n import java.math.BigInteger;\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        int len1=getCount(l1);\\n        int len2=getCount(l2);\\n        // System.out.println(len1+\";;;\"+len2);\\n        BigInteger num1 = new BigInteger(\"0\");\\n        BigInteger num2 = new BigInteger(\"0\");\\n        BigInteger res = new BigInteger(\"0\");\\n        len1--;\\n        len2--;\\n        while(l1!=null)\\n        {\\n            res=BigInteger.valueOf(l1.val);\\n            l1=l1.next;\\n            num1=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len1)))).add(num1);\\n            len1--;\\n        }\\n        while(l2!=null)\\n        {\\n            res=BigInteger.valueOf(l2.val);\\n            l2=l2.next;\\n            num2=(res.multiply(BigInteger.valueOf((int)Math.pow(10,len2)))).add(num2);\\n            len2--;\\n        }\\n        BigInteger num3=num1.add(num2);\\n        //System.out.println(num3);\\n        String s=String.valueOf(num3);\\n        ListNode list= new ListNode(0);\\n        ListNode temp=list;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int digit=Integer.parseInt(s.charAt(i)+\"\");\\n            ListNode newNode = new ListNode(digit);\\n            temp.next = newNode;\\n            temp=newNode;\\n           // System.out.println(digit+\";;;\"+temp.val);\\n        }\\n        return list.next;\\n    }\\n\\n    //count length of linked list\\n    public int getCount(ListNode head)\\n    {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@Leaderboard](/Leaderboard) You guys using biginteger or long?? i done it using simple int \\uD83D\\uDE02"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "BigInteger (for Java) is enough to work around this."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "is this week of ```linked lists``` ??"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "nah, should be just 2 days, but the schedule is missing the 2 days after"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "[@kodyczasupl1](/kodyczasupl1)  sorry my mistake"
                    },
                    {
                        "username": "ashishks777",
                        "content": "[@kodyczasupl1](/kodyczasupl1) week"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "what\\'s a weak linked list?"
                    },
                    {
                        "username": "dpinto",
                        "content": "Invalid Problem description , It says the the number in the linked list represent two non negative integers but test case has number bigger than integer limits\\n\\n[2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9]\\n[5,6,4,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,2,4,3,9,9,9,9]\\n\\nthese numbers are definately above integer limits, please correct the problem description , i wasted a whole lot of time time adjusting to int, then changed it from int to long just to find out there are bigger than long test cases. Please do keep proper problem descriptions."
                    },
                    {
                        "username": "psionl0",
                        "content": "The description clearly says, \"Add the two numbers and <B>return the sum as a linked list.</B>"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Python, yeah!"
                    },
                    {
                        "username": "raghavsharmaji",
                        "content": "I guess when they said integers, they meant integers in general sense, not just in the context of C/C++"
                    },
                    {
                        "username": "davidSantosFranca",
                        "content": "The description says that each list has between 1 and 100 nodes with a value between 1 and 9, with that we can be sure that the resulting value can overflow any integer. You must work using the linked list to do the sum."
                    },
                    {
                        "username": "Himanshi_Verma",
                        "content": "Same thing happened with me. "
                    },
                    {
                        "username": "Belyua",
                        "content": "why so many people write that you need to reverse the list?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "When sum of digits is 10 or more, carry goes to higher radix. Therefore we need to proceed from least significant digits to most significant ones, i.e. in reversed order."
                    }
                ]
            },
            {
                "id": 1878145,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1780649,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1571709,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1973636,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974971,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974923,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974810,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974749,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974609,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974558,
                "content": [
                    {
                        "username": "TheMarvelFan",
                        "content": "Note that the constraint and follow-up mention only for the lists to never be reversed. Thus, we can easily use BigInteger class (as both numbers can have at most 100 digits which is out of even the double range in Java) to solve the question in an interview. It may not be the most optimised solution but it can be done."
                    },
                    {
                        "username": "rajat_171",
                        "content": "Damn............\\nI wrote the whole solution, but in the end it goes beyond the int range \\uD83D\\uDE22"
                    },
                    {
                        "username": "ap3223",
                        "content": "same here only 2 cases are pending"
                    },
                    {
                        "username": "a1327793405",
                        "content": "\\n![](/uploads/files/1484880642436-upload-d41d29f9-5348-4d84-b77b-c1de0280b9b3.png) \\n\\nLine 57: member access within null pointer of type 'struct ListNode'\\n\\n\\n</br>\\nhighly appreciated  !"
                    },
                    {
                        "username": "nitissssh",
                        "content": "man this problem doesn\\'t even force you to think ! "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "STORE THEM IN DIFFERENT STACK AND THEN NORMAL SUM\\n ListNode newNode = new ListNode(sum % 10);\\n            newNode.next = result;\\n            result = newNode;\\nTHIS PART IS SOMEWHAT CONFUSING\\n"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "Could we solve it using recursion?  Ie depth first"
                    },
                    {
                        "username": "Baymurat",
                        "content": "I did the following:\\n1. Add 2 lists taking into account offset (different length)\\n2. In the resulting list, that contains overflowed sums, I used recursion in order to format overflows."
                    },
                    {
                        "username": "BipinThakur",
                        "content": "Solve this first [https://leetcode.com/problems/add-two-numbers/solutions/  ](https://leetcode.com/problems/add-two-numbers/solutions/  )\nthen try this one"
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "reverse, reverse, reverse"
                    },
                    {
                        "username": "johedotcom",
                        "content": "The algo (I solve it using TypeScript)\\n1. push each L1 and L2 to array\\n2. reverse the array\\n3. iterate using the largest length from the comparison between L1 and L2, then sum for each element\\n4. catch the condition where the smallest array might be NaN or undefined\\n5. fix the carry by checking whether the sum result for each element is more than 9 (if yes then add the next element by 1)\\n6. return the array of sum\\n7. reverse the array of sum then create push tail logic for the ListNode"
                    },
                    {
                        "username": "daring-calf",
                        "content": "I declare this week to be: Linked-List Week!"
                    }
                ]
            },
            {
                "id": 1974333,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1974151,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1974146,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1974075,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973952,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973871,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973650,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973554,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973550,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973544,
                "content": [
                    {
                        "username": "1dan_1609_",
                        "content": "Can someone please tell why no solution talks about simply reading the numbers in the linked list and adding them instead of making a stack or reversing the LL? Or is it considered \\'Cheating\\' even when the question never explicitly mentions the way it is needed to be solved?"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "could anyone explain the problem properly?"
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\u2728 Greetings, brave souls! Today, we\\'re embarking on a journey to unravel the mystery of adding numbers using linked lists. If you\\'ve already conquered this quest, congratulations! But if you\\'re seeking a fun and delightful explanation, you\\'re in for a treat.\\n\\nApproach Overview:\\n\\n\\uD83D\\uDD2E To tackle this problem, we\\'ll take an unconventional route. Since we don\\'t have access to the previous nodes in a singly-linked list, we\\'ll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\\n\\nLet\\'s Break it Down:\\n\\nReversing a Linked List:\\n\\n\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F To reverse a linked list, we\\'ll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\\n\\nAdding the Reversed Linked Lists:\\n\\n\\uD83D\\uDD22 Once we have the reversed linked lists, we\\'ll dive into the thrilling addition. With a wave of our wands, we\\'ll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here\\'s how :\\n\\n-Create a new node and initialize variable sum=0.\\n\\nAdd the carry to the sum.\\nIf linked list 1 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nIf linked list 2 still has nodes, add the current node\\'s value to the sum and move to the next node.\\nSet the new node\\'s value as the remainder of the sum modulo 10 (sum % 10).\\nUpdate the carry as the integer division of the sum by 10 (sum / 10).\\nAppend the new node to the result linked list.\\nMove to the next position in the result linked list.\\nReversing the Result:\\n\\n\\u2728 After completing this enchanting addition, we\\'ll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we\\'ll once again reverse this linked list using our reversal spell.\\n\\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "rahulroy74",
                        "content": "[@Belyua](/Belyua)  thank you."
                    },
                    {
                        "username": "Belyua",
                        "content": "add 2 linked lists"
                    },
                    {
                        "username": "aviralj02",
                        "content": "Yesterday\\'s question scared me but today\\'s ques made me happy \\uD83D\\uDE00"
                    },
                    {
                        "username": "aviralj02",
                        "content": "[@chihoang12345](/chihoang12345) Here bro https://leetcode.com/problems/smallest-sufficient-team/description/"
                    },
                    {
                        "username": "chihoang12345",
                        "content": "I missed yesterday\\'s question. Can you give me a link to the problem? Thanks"
                    },
                    {
                        "username": "sarveshmantri200",
                        "content": "Finally some relief \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "make each linkedlist to String and do string sum strategy just beat 5% haha"
                    },
                    {
                        "username": "oops_moment",
                        "content": "✨ Greetings, brave souls! Today, we're embarking on a journey to unravel the mystery of adding numbers using linked lists. If you've already conquered this quest, congratulations! But if you're seeking a fun and delightful explanation, you're in for a treat.\n\nApproach Overview:\n\n🔮 To tackle this problem, we'll take an unconventional route. Since we don't have access to the previous nodes in a singly-linked list, we'll first reverse both linked lists. This way, we can start our addition, just like when we manually add numbers.\n\nLet's Break it Down:\n\nReversing a Linked List:\n\n🧙‍♂️ To reverse a linked list, we'll call upon a magical helper function. This enchanting spell takes the head of the linked list and returns the head of the reversed version. It involves swapping the pointers of the nodes, flipping the order. Remember, reversing a linked list is a powerful spell to master!\n\nAdding the Reversed Linked Lists:\n\n🔢 Once we have the reversed linked lists, we'll dive into the thrilling addition. With a wave of our wands, we'll traverse the lists until the carry, linked list 1, or linked list 2 disappears. Here's how :\n\n-Create a new node and initialize variable sum=0.\n- Add the carry to the sum.\n- If linked list 1 still has nodes, add the current node's value to the sum and move to the next node.\n- If linked list 2 still has nodes, add the current node's value to the sum and move to the next node.\n- Set the new node's value as the remainder of the sum modulo 10 (sum % 10).\n- Update the carry as the integer division of the sum by 10 (sum / 10).\n- Append the new node to the result linked list.\n- Move to the next position in the result linked list.\n\nReversing the Result:\n\n✨ After completing this enchanting addition, we'll obtain a reversed linked list as the result. But fear not, for our journey is not yet complete! To reveal the final answer in the correct order, we'll once again reverse this linked list using our reversal spell. \n\nI hope this explanation has brought joy!"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode t1= reverse(l1);\\n        ListNode t2= reverse(l2);\\n        ListNode res=null;\\n        ListNode temp = null;\\n\\n        int c=0;\\n        while(t1!=null || t2!=null || c!=0){\\n            int sum=c;\\nif(t1!=null){\\n    sum+=t1.val;\\n    t1=t1.next;\\n}\\nif(t2!=null){\\n    sum+=t2.val;\\n    t2=t2.next;\\n}\\n\\nc=(sum)/10;\\nListNode node=new ListNode((sum)%10);\\nif(res==null){\\n    res=node;\\ntemp=res;\\n} else{\\n    temp.next=node;\\n    temp=temp.next;\\n}\\n\\n\\n        }\\n       return reverse(res);\\n    }\\n\\n    public ListNode reverse(ListNode node){\\n       \\nListNode curr=node;\\nListNode prev=null;\\nwhile(curr!=null){\\n    ListNode temp=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=temp;\\n}\\nreturn prev;\\n    }\\n}"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "The easy version of this problem: 415. Add Strings\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I feel today to be a relief."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "As for a bug-free solution, this is hard."
                    }
                ]
            },
            {
                "id": 1973538,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1922523,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1910974,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1875283,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1843567,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1794438,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1793169,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1761850,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1709706,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            },
            {
                "id": 1707815,
                "content": [
                    {
                        "username": "dong094724",
                        "content": "It's hard to solve in a single linked list.\nThere is just a limit to ListNode."
                    },
                    {
                        "username": "kumrvivek0710",
                        "content": "class Solution {\\npublic:\\n     ListNode* reverse( ListNode* head){\\n          if(head==nullptr || head->next==nullptr) return head;\\n           ListNode* curr=head,*prev=nullptr;\\n           while(curr){\\n                ListNode* temp=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=temp;\\n           }\\n           return prev;\\n     }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n    if(!l1 and !l2)return NULL;\\n    if(!l1)return l2;\\n    if(!l2)return l1;\\n         ListNode* l11=reverse(l1);\\n         ListNode* l22=reverse(l2);\\n        int carry=0;\\n         ListNode* l3=new  ListNode(0);\\n          ListNode* curr=l3;\\n          while(l11 && l22){\\n              int sum=l11->val+l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n              l11=l11->next;\\n          }\\n          while(l11){\\n              int sum=l11->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l11=l11->next;\\n          }\\n          while(l22){\\n              int sum=l22->val+carry;\\n              carry=sum/10;\\n              l3->next=new  ListNode(sum%10);\\n              l3=l3->next;\\n              l22=l22->next;\\n          }\\n          if(carry){\\n              l3->next=new ListNode(1);\\n          }\\n           ListNode* curr1=reverse(curr->next);\\n          return curr1;\\n    }\\n};\\n[9,9] and [9] showing wrong ans ..why???"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "I love this question"
                    },
                    {
                        "username": "ashish_2298744",
                        "content": "How okay it is to solve such questions using other data structures too like array, string, etc? \nPOV: Interview"
                    },
                    {
                        "username": "psionl0",
                        "content": "Well the editorial used stacks (to avoid reversing the lists) so I guess it\\'s ok."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "well you\\'re definitely not getting shortlisted if you do so. the motive is to check your pointer manipulation skills and problem solving abilities"
                    },
                    {
                        "username": "shoshin_02",
                        "content": "Simplest solution making multiple passes through the lists, no reversal, no extra space: https://leetcode.com/problems/add-two-numbers-ii/solutions/3341560/simplest-shortest-java-no-reversal-no-stacks-o-1-space-beats-100/"
                    },
                    {
                        "username": "dtkalla",
                        "content": "There\\'s an issue in this problem: it accepts an array as an answer instead of only accepting a linked list (at least in Ruby)."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Nope, doesn\\'t happen that with JS. I accidently did it in an array and it gave me an error. Maybe it\\'s a Ruby problem."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code ??\\nclass Solution {\\npublic:\\n   // function to reverse a number\\n    int reverse_num(int num)\\n    {\\n        int number=0 ;\\n        int remainder = num%10;\\n        int multiplier= 1;\\n        while(num!=0)\\n        {\\n            number = number + (remainder*multiplier);\\n            multiplier = multiplier*10;\\n            num = num/10;\\n        }\\n        return number;\\n    }\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) \\n    {\\n        ListNode * answer = new ListNode(0);\\n       // first the brute force approach     \\n       int multiplier = 1;\\n       int num1 = 0,num2=0;\\n       ListNode * tmp= l1;\\n       // getting reversed first number \\n       while(tmp!=NULL)\\n       {\\n           num1=num1+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       multiplier=1;\\n       tmp=l2;\\n       // getting the reversed second number\\n       while(tmp!=NULL)\\n       {\\n           num2=num2+(tmp->val)*multiplier;\\n           multiplier = multiplier*10;\\n           tmp=tmp->next;\\n       }\\n       int r_num1 = reverse_num(num1);\\n       int r_num2 = reverse_num(num2);\\n       int ans = r_num1 + r_num2;\\n       int r_ans = reverse_num(ans);\\n       // making the linked list with the reversed number \\n       ListNode * temp = answer;\\n       while(r_ans!=0)\\n       {\\n           int val = r_ans%10;\\n           ListNode * node = new ListNode(val);\\n           temp->next = node;\\n           temp=temp->next;\\n           r_ans = r_ans/10;\\n       }\\n       // making the last node of the linked list\\n       // pointing to null\\n       temp->next=NULL;\\n       return answer->next;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "WGEE",
                        "content": " `your inline code...your inline code...`\\n\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode res=new ListNode();\\n        res.next=null;\\n       int s1=size(l1);\\n       int s2=size(l2);\\n       int carry=ans(l1,l2,s1,s2,res);\\n       if(carry>0){\\n           ListNode temp=new ListNode();\\n           temp.val=carry;\\n           temp.next=res;\\n           res=temp;\\n       }\\n       return res;\\n    }\\n    public int size(ListNode temp){\\n        int count=0;\\n        while(temp!=null){\\n          count++;\\n          temp=temp.next;           \\n        }\\n        return count;\\n    }\\n    public int ans(ListNode l1,ListNode l2,int s1,int s2,ListNode res){\\n        if(l1==null || l2==null){\\n            return 0;\\n        }\\n         int sum=0;\\n       if(s1>s2){\\n           int carry=ans(l1.next,l2,s1-1,s2,res);\\n            sum=sum+carry+l1.val;\\n\\n       }else if(s2>s1){\\n          int carry=ans(l1,l2.next,s1,s2-1,res);\\n            sum=sum+carry+l2.val;\\n       }else{\\n          int carry=ans(l1.next,l2.next,s1-1,s2-1,res);\\n          sum=sum+carry+l1.val+l2.val;\\n       }\\n       int c=sum/10;\\n        int d=sum%10;\\n        ListNode temp=new ListNode();\\n        temp.val=d;\\n        temp.next=res;\\n        res=temp;\\n\\n         return c;       \\n    }\\n}\\ncan anyone tell me what is wrong in this code "
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "This is the same damn problem as add two numbers 1 ! And as it would turn out the most significant digit is remarkably  insignificant as far as the solution is concerned.  The only recognizable difference is that the values are given in the correct order. My fault for not realizing sooner"
                    }
                ]
            }
        ]
    }
]