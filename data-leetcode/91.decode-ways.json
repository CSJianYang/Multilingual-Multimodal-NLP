[
    {
        "title": "Decode Ways",
        "question_content": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n\t\"AAJF\" with the grouping (1 1 10 6)\n\t\"KJF\" with the grouping (11 10 6)\n\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\nGiven a string s containing only digits, return the number of ways to decode it.\nThe test cases are generated so that the answer fits in a 32-bit integer.\n&nbsp;\nExample 1:\n\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nExample 2:\n\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n\nExample 3:\n\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts contains only digits and may contain leading zero(s).",
        "solutions": [
            {
                "id": 30451,
                "title": "evolve-from-recursion-to-dp",
                "content": "1. Recursion O(2^n). A char may be decoded alone or by pairing with the next char.\\n* c++\\n```\\n    int numDecodings(string s) {\\n        return s.empty() ? 0: numDecodings(0,s);    \\n    }\\n    int numDecodings(int p, string& s) {\\n        int n = s.size();\\n        if(p == n) return 1;\\n        if(s[p] == \\'0\\') return 0; // sub string starting with 0 is not a valid encoding\\n        int res = numDecodings(p+1,s);\\n        if( p < n-1 && (s[p]==\\'1\\'|| (s[p]==\\'2\\'&& s[p+1]<\\'7\\'))) res += numDecodings(p+2,s);\\n        return res;\\n    }\\n```\\n* java\\n```\\n\\tpublic int numDecodings(String s) {\\n        return s.length()==0?0:numDecodings(0,s);      \\n    }\\n    private int numDecodings(int p, String s) {\\n        int n=s.length();\\n        if(p==n) return 1;\\n        if(s.charAt(p)==\\'0\\') return 0;\\n        int res=numDecodings(p+1,s);\\n        if(p<n-1&&(s.charAt(p)==\\'1\\'||s.charAt(p)==\\'2\\'&&s.charAt(p+1)<\\'7\\')) \\n\\t\\t\\tres+=numDecodings(p+2,s);\\n        return res;\\n    }\\n```\\n2. Memoization O(n)\\n* c++\\n```\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> mem(n+1,-1);\\n        mem[n]=1;\\n        return s.empty()? 0 : num(0,s,mem);   \\n    }\\n    int num(int i, string &s, vector<int> &mem) {\\n        if(mem[i]>-1) return mem[i];\\n        if(s[i]==\\'0\\') return mem[i] = 0;\\n        int res = num(i+1,s,mem);\\n        if(i<s.size()-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) res+=num(i+2,s,mem);\\n        return mem[i] = res;\\n    }\\n``` \\n* java\\n```\\n\\tpublic int numDecodings(String s) {\\n        int n=s.length();\\n        Integer[] mem=new Integer[n];\\n        return s.length()==0?0:numDecodings(0,s,mem);      \\n    }\\n    private int numDecodings(int p, String s, Integer[] mem) {\\n        int n=s.length();\\n        if(p==n) return 1;\\n        if(s.charAt(p)==\\'0\\') return 0;\\n        if(mem[p]!=null) return mem[p];\\n        int res=numDecodings(p+1,s,mem);\\n        if(p<n-1&&(s.charAt(p)==\\'1\\'||s.charAt(p)==\\'2\\'&&s.charAt(p+1)<\\'7\\')) \\n\\t\\t\\tres+=numDecodings(p+2,s,mem);\\n        return mem[p]=res;\\n    }\\n```\\n3. dp O(n) time and space, this can be converted from #2 with copy and paste.\\n* c++\\n```\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1);\\n        dp[n] = 1;\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') dp[i]=0;\\n            else {\\n                dp[i] = dp[i+1];\\n                if(i<n-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) dp[i]+=dp[i+2];\\n            }\\n        }\\n        return s.empty()? 0 : dp[0];   \\n    }\\n```\\n* java\\n```\\n\\tpublic int numDecodings(String s) {\\n        int n=s.length();\\n        int[] dp=new int[n+1];\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--)\\n            if(s.charAt(i)!=\\'0\\') {\\n                dp[i]=dp[i+1];\\n                if(i<n-1&&(s.charAt(i)==\\'1\\'||s.charAt(i)==\\'2\\'&&s.charAt(i+1)<\\'7\\')) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i+2];\\n            }\\n        return dp[0];   \\n    }\\n```\\n4. dp constant space\\n* c++\\n```\\n    int numDecodings(string s) {\\n        int p = 1, pp, n = s.size();\\n        for(int i=n-1;i>=0;i--) {\\n            int cur = s[i]==\\'0\\' ? 0 : p;\\n            if(i<n-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) cur+=pp;\\n            pp = p;\\n            p = cur;\\n        }\\n        return s.empty()? 0 : p;   \\n    }\\n```\\n* java\\n```\\n\\tpublic int numDecodings(String s) {\\n        int dp1=1, dp2=0, n=s.length();\\n        for(int i=n-1;i>=0;i--) {\\n            int dp=s.charAt(i)==\\'0\\'?0:dp1;\\n            if(i<n-1&&(s.charAt(i)==\\'1\\'||s.charAt(i)==\\'2\\'&&s.charAt(i+1)<\\'7\\'))\\n                dp+=dp2;\\n            dp2=dp1;\\n            dp1=dp;\\n        }\\n        return dp1;\\n    }\\n```\\nA follow up of the problem is[ 639. Decode Ways II](https://leetcode.com/problems/decode-ways-ii/discuss/686044/Evolve-from-recursion-to-dp).",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    int numDecodings(string s) {\\n        return s.empty() ? 0: numDecodings(0,s);    \\n    }\\n    int numDecodings(int p, string& s) {\\n        int n = s.size();\\n        if(p == n) return 1;\\n        if(s[p] == \\'0\\') return 0; // sub string starting with 0 is not a valid encoding\\n        int res = numDecodings(p+1,s);\\n        if( p < n-1 && (s[p]==\\'1\\'|| (s[p]==\\'2\\'&& s[p+1]<\\'7\\'))) res += numDecodings(p+2,s);\\n        return res;\\n    }\\n```\n```\\n\\tpublic int numDecodings(String s) {\\n        return s.length()==0?0:numDecodings(0,s);      \\n    }\\n    private int numDecodings(int p, String s) {\\n        int n=s.length();\\n        if(p==n) return 1;\\n        if(s.charAt(p)==\\'0\\') return 0;\\n        int res=numDecodings(p+1,s);\\n        if(p<n-1&&(s.charAt(p)==\\'1\\'||s.charAt(p)==\\'2\\'&&s.charAt(p+1)<\\'7\\')) \\n\\t\\t\\tres+=numDecodings(p+2,s);\\n        return res;\\n    }\\n```\n```\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> mem(n+1,-1);\\n        mem[n]=1;\\n        return s.empty()? 0 : num(0,s,mem);   \\n    }\\n    int num(int i, string &s, vector<int> &mem) {\\n        if(mem[i]>-1) return mem[i];\\n        if(s[i]==\\'0\\') return mem[i] = 0;\\n        int res = num(i+1,s,mem);\\n        if(i<s.size()-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) res+=num(i+2,s,mem);\\n        return mem[i] = res;\\n    }\\n```\n```\\n\\tpublic int numDecodings(String s) {\\n        int n=s.length();\\n        Integer[] mem=new Integer[n];\\n        return s.length()==0?0:numDecodings(0,s,mem);      \\n    }\\n    private int numDecodings(int p, String s, Integer[] mem) {\\n        int n=s.length();\\n        if(p==n) return 1;\\n        if(s.charAt(p)==\\'0\\') return 0;\\n        if(mem[p]!=null) return mem[p];\\n        int res=numDecodings(p+1,s,mem);\\n        if(p<n-1&&(s.charAt(p)==\\'1\\'||s.charAt(p)==\\'2\\'&&s.charAt(p+1)<\\'7\\')) \\n\\t\\t\\tres+=numDecodings(p+2,s,mem);\\n        return mem[p]=res;\\n    }\\n```\n```\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n+1);\\n        dp[n] = 1;\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'0\\') dp[i]=0;\\n            else {\\n                dp[i] = dp[i+1];\\n                if(i<n-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) dp[i]+=dp[i+2];\\n            }\\n        }\\n        return s.empty()? 0 : dp[0];   \\n    }\\n```\n```\\n\\tpublic int numDecodings(String s) {\\n        int n=s.length();\\n        int[] dp=new int[n+1];\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--)\\n            if(s.charAt(i)!=\\'0\\') {\\n                dp[i]=dp[i+1];\\n                if(i<n-1&&(s.charAt(i)==\\'1\\'||s.charAt(i)==\\'2\\'&&s.charAt(i+1)<\\'7\\')) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i+2];\\n            }\\n        return dp[0];   \\n    }\\n```\n```\\n    int numDecodings(string s) {\\n        int p = 1, pp, n = s.size();\\n        for(int i=n-1;i>=0;i--) {\\n            int cur = s[i]==\\'0\\' ? 0 : p;\\n            if(i<n-1 && (s[i]==\\'1\\'||s[i]==\\'2\\'&&s[i+1]<\\'7\\')) cur+=pp;\\n            pp = p;\\n            p = cur;\\n        }\\n        return s.empty()? 0 : p;   \\n    }\\n```\n```\\n\\tpublic int numDecodings(String s) {\\n        int dp1=1, dp2=0, n=s.length();\\n        for(int i=n-1;i>=0;i--) {\\n            int dp=s.charAt(i)==\\'0\\'?0:dp1;\\n            if(i<n-1&&(s.charAt(i)==\\'1\\'||s.charAt(i)==\\'2\\'&&s.charAt(i+1)<\\'7\\'))\\n                dp+=dp2;\\n            dp2=dp1;\\n            dp1=dp;\\n        }\\n        return dp1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30358,
                "title": "java-clean-dp-solution-with-explanation",
                "content": "I used a dp array of size n + 1 to save subproblem solutions.  `dp[0]` means an empty string will have one way to decode, `dp[1]` means the way to decode a string of size 1.  I then check one digit and two digit combination and save the results along the way.  In the end, `dp[n]` will be the end result.\\n\\n    public class Solution {\\n        public int numDecodings(String s) {\\n            if (s == null || s.length() == 0) {\\n                return 0;\\n            }\\n            int n = s.length();\\n            int[] dp = new int[n + 1];\\n            dp[0] = 1;\\n            dp[1] = s.charAt(0) != \\'0\\' ? 1 : 0;\\n            for (int i = 2; i <= n; i++) {\\n                int first = Integer.valueOf(s.substring(i - 1, i));\\n                int second = Integer.valueOf(s.substring(i - 2, i));\\n                if (first >= 1 && first <= 9) {\\n                   dp[i] += dp[i-1];  \\n                }\\n                if (second >= 10 && second <= 26) {\\n                    dp[i] += dp[i-2];\\n                }\\n            }\\n            return dp[n];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int numDecodings(String s) {\\n            if (s == null || s.length() == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 253018,
                "title": "python-easy-to-understand-explanation-bottom-up-dynamic-programming",
                "content": "*This is my first post. Please let me know if this is helpful and if there\\'s anything I can do to improve.*\\n\\n**Problem Reduction:**  variation of n-th staircase with n = [1, 2] steps. \\n\\n**Approach:** We generate a bottom up DP table.\\n\\nThe tricky part is handling the corner cases (e.g. s = \"30\"). \\n\\nMost elegant way to deal with those error/corner cases, is to allocate an extra space, dp[0].\\n\\nLet dp[ i ] = the number of ways to parse the string s[1: i + 1]\\n\\nFor example:\\ns = \"231\"\\nindex 0: extra base offset. dp[0] = 1\\nindex 1: # of ways to parse \"2\" => dp[1] = 1\\nindex 2: # of ways to parse \"23\" => \"2\" and \"23\",  dp[2] = 2 \\nindex 3: # of ways to parse \"231\" => \"2 3 1\" and \"23 1\" => dp[3] = 2 \\n\\n```\\ndef numDecodings(s): \\n\\tif not s:\\n\\t\\treturn 0\\n\\n\\tdp = [0 for x in range(len(s) + 1)] \\n\\t\\n\\t# base case initialization\\n\\tdp[0] = 1 \\n\\tdp[1] = 0 if s[0] == \"0\" else 1   #(1)\\n\\n\\tfor i in range(2, len(s) + 1): \\n\\t\\t# One step jump\\n\\t\\tif 0 < int(s[i-1:i]) <= 9:    #(2)\\n\\t\\t\\tdp[i] += dp[i - 1]\\n\\t\\t# Two step jump\\n\\t\\tif 10 <= int(s[i-2:i]) <= 26: #(3)\\n\\t\\t\\tdp[i] += dp[i - 2]\\n\\treturn dp[len(s)]\\n```\\n\\nNotes of Wisdom:\\n**(1)**: Handling s starting with \\'0\\'. Alternative: I would recommend treating as an error condition and immediately returning 0. It\\'s easier to keep track and it\\'s an optimization.\\n**(2) (3)**: Pay close attention to your comparators. For (1) you want 0 <, not 0 <= . For (2) you want 10 <=, not 10 <\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numDecodings(s): \\n\\tif not s:\\n\\t\\treturn 0\\n\\n\\tdp = [0 for x in range(len(s) + 1)] \\n\\t\\n\\t# base case initialization\\n\\tdp[0] = 1 \\n\\tdp[1] = 0 if s[0] == \"0\" else 1   #(1)\\n\\n\\tfor i in range(2, len(s) + 1): \\n\\t\\t# One step jump\\n\\t\\tif 0 < int(s[i-1:i]) <= 9:    #(2)\\n\\t\\t\\tdp[i] += dp[i - 1]\\n\\t\\t# Two step jump\\n\\t\\tif 10 <= int(s[i-2:i]) <= 26: #(3)\\n\\t\\t\\tdp[i] += dp[i - 2]\\n\\treturn dp[len(s)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30357,
                "title": "dp-solution-java-for-reference",
                "content": "    public class Solution {\\n        public int numDecodings(String s) {\\n            int n = s.length();\\n            if (n == 0) return 0;\\n            \\n            int[] memo = new int[n+1];\\n            memo[n]  = 1;\\n            memo[n-1] = s.charAt(n-1) != '0' ? 1 : 0;\\n            \\n            for (int i = n - 2; i >= 0; i--)\\n                if (s.charAt(i) == '0') continue;\\n                else memo[i] = (Integer.parseInt(s.substring(i,i+2))<=26) ? memo[i+1]+memo[i+2] : memo[i+1];\\n            \\n            return memo[0];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numDecodings(String s) {\\n            int n = s.length();\\n            if (n == 0) return 0;\\n            \\n            int[] memo = new int[n+1];\\n            memo[n]  = 1;\\n            memo[n-1] = s.charAt(n-1) != '0' ? 1 : 0;\\n            \\n            for (int i = n - 2; i >= 0; i--)\\n                if (s.charAt(i) == '0') continue;\\n                else memo[i] = (Integer.parseInt(s.substring(i,i+2))<=26) ? memo[i+1]+memo[i+2] : memo[i+1];\\n            \\n            return memo[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1410794,
                "title": "c-python-from-top-down-dp-to-bottom-up-dp-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- For a character `s[i]`, we have 2 ways to decode:\\n\\t- Single digit: Require `s[i] != \\'0\\'` (decoded to 1..9)\\n\\t- Two digits: Require `i + 1 < len(s)` and `(s[i] == 1` (decoded to 10..19) or `s[i] == 2 and s[i+1] <= \\'6\\')` (decoded to 20..26).\\n\\n<iframe src=\"https://leetcode.com/playground/YEAPJbDc/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F  Solution 2: Bottom-up DP**\\n- Just convert from Top-down DP to Bottom-up DP approach.\\n\\n<iframe src=\"https://leetcode.com/playground/FjD9xjqm/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-up DP (Space Optimized)**\\n- Since our dp only need to keep up to 3 following states:\\n\\t- Current state, let name `dp` corresponding to `dp[i]`\\n\\t- Last state, let name `dp1` corresponding to `dp[i+1]`\\n\\t- Last twice state, let name `dp2` corresponding to `dp[i+2]`\\n- So we can achieve `O(1)` in space.\\n\\n<iframe src=\"https://leetcode.com/playground/QJadoBKs/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- For a character `s[i]`, we have 2 ways to decode:\\n\\t- Single digit: Require `s[i] != \\'0\\'` (decoded to 1..9)\\n\\t- Two digits: Require `i + 1 < len(s)` and `(s[i] == 1` (decoded to 10..19) or `s[i] == 2 and s[i+1] <= \\'6\\')` (decoded to 20..26).\\n\\n<iframe src=\"https://leetcode.com/playground/YEAPJbDc/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F  Solution 2: Bottom-up DP**\\n- Just convert from Top-down DP to Bottom-up DP approach.\\n\\n<iframe src=\"https://leetcode.com/playground/FjD9xjqm/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom-up DP (Space Optimized)**\\n- Since our dp only need to keep up to 3 following states:\\n\\t- Current state, let name `dp` corresponding to `dp[i]`\\n\\t- Last state, let name `dp1` corresponding to `dp[i+1]`\\n\\t- Last twice state, let name `dp2` corresponding to `dp[i+2]`\\n- So we can achieve `O(1)` in space.\\n\\n<iframe src=\"https://leetcode.com/playground/QJadoBKs/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of string `s`.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 30522,
                "title": "java-2ms-dp-solution-with-detailed-explanation-and-inline-comments",
                "content": "This solution certainly isn't brand new, see similar concepts [here][1], [here][2], [here][3], and probably a few other top rated.  Mine also isn't the shortest.  However, that is kind of the point. Dynamic Programming is one of my weaknesses and making the solution shorter usually makes it more abstract and difficult to understand.  My solution below is a bit more drawn out with more descriptive variable names to help make it a bit easier to understand.  \\n\\nThe basic concept is to build up the number of ways to get to state `i` from all the previous states less than `i`.  We can do this by initializing a cache with a size of `s.length() + 1`.  We always set `waysToDecode[0]` to 1 because there is only 1 way to decode an empty string.  We can then build up the number of ways to decode starting from the first value and work our way to the end.\\n\\nWe only ever need to look at the character at `i - 1` because we can't have values greater than 26, so three digits is never possible.  There are four possibilities to consider: 1) The previous value is 0 and the current value is 0, we can't make progress, return 0.  2) The current value is 0, we have to use the previous value, if it is greater than 2, we can't make progress, return 0, otherwise we have to transition to this state from `waysToDecode[i - 1]`.  3) The previous value is 0, we can't use the previous, so the only way to transition to the current state is from the previous, so use `waysToDecode[i]`.  4) lastly, both previous and `curr` can be used so there are two ways to transition to the current state, thus at `waysToDecode[i + 1]` we can get here by using all the ways we can get to `waysToDecode[i]` + all the ways to get to `waysToDecode[i - 1]`.  \\n\\nKeep in mind that the indices are adjusted for the cache because its size differs from the string size. \\n\\n    public class Solution {\\n    public int numDecodings(String s) {\\n        if (s.isEmpty() || s.charAt(0) - '0' == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int[] waysToDecode = new int[s.length() + 1];\\n        waysToDecode[0] = 1;\\n        waysToDecode[1] = 1;\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            int curr = s.charAt(i) - '0';\\n            int prev = s.charAt(i - 1) - '0';\\n            \\n            // can't make progress, return 0\\n            if (prev == 0 && curr == 0 || (curr == 0 && (prev * 10 + curr > 26)))\\n            {\\n                return 0;\\n            }\\n            // can't use the previous value, so can only get to this state from the previous\\n            else if (prev == 0 || (prev * 10 + curr) > 26)\\n            {\\n                waysToDecode[i + 1] = waysToDecode[i];\\n            }\\n            // can't use current state, can only get to this state from i - 1 state\\n            else if (curr == 0)\\n            {\\n                waysToDecode[i + 1] = waysToDecode[i - 1];\\n            }\\n            // can get to this state from the previous two states\\n            else\\n            {\\n                waysToDecode[i + 1] = waysToDecode[i] + waysToDecode[i - 1];\\n            }\\n        }\\n        \\n        return waysToDecode[waysToDecode.length - 1];\\n    }\\n}\\n\\n\\n  [1]: https://leetcode.com/discuss/8527/dp-solution-java-for-reference\\n  [2]: https://leetcode.com/discuss/21090/a-concise-dp-solution\\n  [3]: https://leetcode.com/discuss/38735/my-c-0ms-dp-solution-o-n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numDecodings(String s) {\\n        if (s.isEmpty() || s.charAt(0) - '0' == 0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 608268,
                "title": "python-thinking-process-diagram-dp-dfs",
                "content": "First, I build a tree of possible decodings I can do from a random string.\\n* The number of leaves in the tree essentially is the number of ways the string can be decoded.\\n* We are going to build our tree with DFS from our original string, trying to decode either as:\\n\\t* A single digit (and call dfs again with remaining string)\\n\\t* Both single digit and double digit, when the double digits are less than or equal to 26 (and call dfs again with remaining strings).\\n\\nOur base case is when we have only a single digit left in our string or when we have nothing left in the string. In that case, we return 1 back up the recursion stack.\\n\\n**Growing a tree**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588418645.png)\\n\\n**Dyanmic Programming**\\n\\nWe can see that this type of tree has a lot of **redundant sub-trees**. Dynamic Programming to the rescue!! (In my code, I use `lru_cache` decorator which essentially memoizes the function calls with argument-returned value pairs. So, when I call the same function with same arguements, and if that recursive call has been made before, it is just retrieved from memoized pair).\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588418649.png)\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588418654.png)\\n\\n* After you have got a hang of the thinking process, we will have to handle issues with zeros.\\n\\t* Zeros can be in the middle or at the start.\\n\\t\\t* If it is at the start, there is no way to decode the string.\\n\\t\\t* If it is in the middle:\\n\\t\\t\\t* If it can be paired with the digit before zero (and is less than or equal to 26, then we can keep on growing our subtrees)\\n\\t\\t\\t* If it cannot be paired with the digit before zero, we have to destory that subtree. This might even render the whole string undecodable. \\n\\n\\n``` python\\nclass Solution:\\n    def numDecodings(self, s:str) -> int:\\n        if len(s) == 0 or s is None:\\n            return 0\\n\\n        @lru_cache(maxsize=None)\\n        def dfs(string):\\n            if len(string)>0:\\n                if string[0] == \\'0\\':\\n                    return 0\\n            if string == \"\" or len(string) == 1:\\n                return 1\\n            if int(string[0:2]) <= 26:\\n                first = dfs(string[1:])\\n                second = dfs(string[2:])\\n                return first+second\\n            else:\\n                return dfs(string[1:])\\n\\n        result_sum = dfs(s)\\n\\n        return result_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "``` python\\nclass Solution:\\n    def numDecodings(self, s:str) -> int:\\n        if len(s) == 0 or s is None:\\n            return 0\\n\\n        @lru_cache(maxsize=None)\\n        def dfs(string):\\n            if len(string)>0:\\n                if string[0] == \\'0\\':\\n                    return 0\\n            if string == \"\" or len(string) == 1:\\n                return 1\\n            if int(string[0:2]) <= 26:\\n                first = dfs(string[1:])\\n                second = dfs(string[2:])\\n                return first+second\\n            else:\\n                return dfs(string[1:])\\n\\n        result_sum = dfs(s)\\n\\n        return result_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30384,
                "title": "a-concise-dp-solution",
                "content": "    int numDecodings(string s) {\\n        if (!s.size() || s.front() == '0') return 0;\\n        // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] \\n        int r1 = 1, r2 = 1;\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            // zero voids ways of the last because zero cannot be used separately\\n            if (s[i] == '0') r1 = 0;\\n\\n            // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1\\n            if (s[i - 1] == '1' || s[i - 1] == '2' && s[i] <= '6') {\\n                r1 = r2 + r1;\\n                r2 = r1 - r2;\\n            }\\n\\n            // one-digit letter, no new way added\\n            else {\\n                r2 = r1;\\n            }\\n        }\\n\\n        return r1;\\n    }",
                "solutionTags": [],
                "code": "    int numDecodings(string s) {\\n        if (!s.size() || s.front() == '0') return 0;\\n        // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] \\n        int r1 = 1, r2 = 1;\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            // zero voids ways of the last because zero cannot be used separately\\n            if (s[i] == '0') r1 = 0;\\n\\n            // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1\\n            if (s[i - 1] == '1' || s[i - 1] == '2' && s[i] <= '6') {\\n                r1 = r2 + r1;\\n                r2 = r1 - r2;\\n            }\\n\\n            // one-digit letter, no new way added\\n            else {\\n                r2 = r1;\\n            }\\n        }\\n\\n        return r1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30379,
                "title": "1-liner-o-1-space",
                "content": "[This is the Python](https://xkcd.com/353/).\\n\\n    def numDecodings(self, s):\\n        return reduce(lambda(v,w,p),d:(w,(d>'0')*w+(9<int(p+d)<27)*v,d),s,(0,s>'',''))[1]*1\\n\\n---\\n\\nMore readable version:\\n\\n    def numDecodings(self, s):\\n        v, w, p = 0, int(s>''), ''\\n        for d in s:\\n            v, w, p = w, (d>'0')*w + (9<int(p+d)<27)*v, d\\n        return w\\n\\n- `w` tells the number of ways\\n- `v` tells the previous number of ways\\n- `d` is the current digit\\n- `p` is the previous digit",
                "solutionTags": [
                    "Python"
                ],
                "code": "[This is the Python](https://xkcd.com/353/).\\n\\n    def numDecodings(self, s):\\n        return reduce(lambda(v,w,p),d:(w,(d>'0')*w+(9<int(p+d)<27)*v,d),s,(0,s>'',''))[1]*1\\n\\n---\\n\\nMore readable version:\\n\\n    def numDecodings(self, s):\\n        v, w, p = 0, int(s>''), ''\\n        for d in s:\\n            v, w, p = w, (d>'0')*w + (9<int(p+d)<27)*v, d\\n        return w\\n\\n- `w` tells the number of ways\\n- `v` tells the previous number of ways\\n- `d` is the current digit\\n- `p` is the previous digit",
                "codeTag": "Python3"
            },
            {
                "id": 1411484,
                "title": "detailed-explanation-c-dp-with-memoization",
                "content": "This is one the most classic and standard DP problem on String. \\n\\nIdea is really simple, we at every index in the string we have got 2 choices : \\n\\n1. Pick only current element as a single value between [1-9]\\n2. Pick 2 elements i.e current as well as next element to make a couple. This value will be [10, 26]\\n\\nThus we solve the problem recursively with the above 2 choices and whenever we reach the end i.e index >= n simply return 1. Which means that we have got one way to decode the string.\\n\\nNow, lets understand the code in depth : \\n\\n\\t\\tCase 1 : Pick single element, so in this we pick current and call for index + 1. \\n\\t\\t\\tnote : In case of single pick, element should not be \\'0\\' as it is invalid\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t-> ways = decode(s, idx+1, n)  \\n\\t\\t\\t\\t: elements in range [1,9] is covered here in this case\\n\\t\\t\\t\\t\\n\\t\\tCase 2 : Pick couple, so that we can get elements in range [10, 26] . \\n\\t\\t\\tCatch here is that we need to check and validate values so that we do not exceed the range. \\n\\t\\t\\t\\n\\t\\t\\tconditions : \\n\\t\\t\\t\\t-> idx+1 < n , mean we are no going out of bounds.\\n\\t\\t\\t\\t-> s[idx] == \\'1\\' && s[idx+1] <= \\'9\\' , here range [10, 19] is covered\\n\\t\\t\\t\\t-> s[idx] == \\'2\\' && s[idx+1] < \\'7\\' , here range [20, 26] is covered\\n\\t\\t\\t\\n\\t\\t\\tThus final condition becomes :\\n\\t\\t\\t\\t-> if(idx+1 < n && ((s[idx] == \\'1\\' && s[idx+1] <= \\'9\\') || (s[idx]==\\'2\\' && s[idx+1] < \\'7\\')))\\n\\t\\t\\t\\n\\t\\t\\tNow, in this case, we need to increment index+2, since we have already included next element along with current element. \\n\\t\\t\\t\\t=> ways += decode(s, idx+2, n)\\n\\t\\n    \\nNow that we have taken care of all the cases, but wait, where is the base condition?  \\nLets see where and how we will terminate the recursion and return. \\n\\n\\tCase 1 : If current element is 0, we simply return 0 as it is not possible to get a character using 0. \\n\\t\\t\\tZero will only be used in couple with some number occuring before it. Ex : 1 0 , or 2 0 \\n\\t\\n\\t\\t-> if(idx < n && s[idx] < 0) return 0;\\n\\t\\t->This means that we cannot move further in decoding the string. Need to find some other way.\\n\\n\\tCase 2 : This is most important condition which gives us our answer. When we reach the end of the string this means that we have found a possible way to decode. \\n\\t\\tThus this will contribute to answer and return 1. \\n\\t\\t\\n\\t\\t-> if(idx >= n) return 1;  \\n\\t\\t-> Ex : s = \"1 2 0 2 5\" , so if reach \\'5\\' somehow , that the decoded string required. Thus return 1\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    \\n    int decode(string& s, int idx, int n)\\n    {\\n        if(idx < n && s[idx] == \\'0\\') return 0;\\n        if(idx >= n)\\n            return 1;\\n        \\n        int ways = 0;\\n        \\n        // Pick single\\n        if(s[idx] != \\'0\\') ways = decode(s, idx+1, n);\\n            \\n        // Pick couple\\n        if(idx+1 < n && ((s[idx] == \\'1\\' && s[idx+1] <= \\'9\\') || (s[idx]==\\'2\\' && s[idx+1] < \\'7\\')))\\n           ways += decode(s, idx+2, n);\\n           \\n        return ways;\\n    }\\n    \\n    int numDecodings(string s) {\\n       \\n        int n = s.size();\\n        return decode(s, 0, n);\\n    }\\n};\\n```\\n\\n* Above code will give TLE, since there are overlapping substructure and we are calculating it over and over again. For that we need to do **Memoization**. Whenever we calculate a new value of decode(i), simply store that value in : `dp[i] = decode(i)`. \\n\\n* Now, whenever we reach a index i, look into the dp table . If its value already exist no need to calcuate again. Just return dp[i].\\n\\n* Rest everything remains same. Read the code you will understand. \\n\\n# Code with Memoization: \\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[102];\\n    int decode(string& s, int idx, int n)\\n    {\\n        if(idx < n && s[idx] == \\'0\\') return 0;\\n        if(idx >= n)\\n            return 1;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int ways = 0;\\n        \\n        // Pick single\\n        if(s[idx] != \\'0\\') ways = decode(s, idx+1, n);\\n            \\n        // Pick couple\\n        if(idx+1 < n && ((s[idx] == \\'1\\' && s[idx+1] <= \\'9\\') || (s[idx]==\\'2\\' && s[idx+1] < \\'7\\')))\\n           ways += decode(s, idx+2, n);\\n           \\n        return dp[idx] = ways;\\n    }\\n    \\n    int numDecodings(string s) {\\n       \\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return decode(s, 0, n);\\n    }\\n};\\n```\\n\\n**Time : O(N)\\nSpace : O(N)**\\n\\nFollow Up : \\n\\n* Try to optimize more on Space. Also try iterative approach. \\n* [Decode Ways II](https://leetcode.com/problems/decode-ways-ii/)\\n\\n*I hope my explanation was clear. Feel free to ask or correct me.\\nIf you liked this, do upvote :) *",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int decode(string& s, int idx, int n)\\n    {\\n        if(idx < n && s[idx] == \\'0\\') return 0;\\n        if(idx >= n)\\n            return 1;\\n        \\n        int ways = 0;\\n        \\n        // Pick single\\n        if(s[idx] != \\'0\\') ways = decode(s, idx+1, n);\\n            \\n        // Pick couple\\n        if(idx+1 < n && ((s[idx] == \\'1\\' && s[idx+1] <= \\'9\\') || (s[idx]==\\'2\\' && s[idx+1] < \\'7\\')))\\n           ways += decode(s, idx+2, n);\\n           \\n        return ways;\\n    }\\n    \\n    int numDecodings(string s) {\\n       \\n        int n = s.size();\\n        return decode(s, 0, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[102];\\n    int decode(string& s, int idx, int n)\\n    {\\n        if(idx < n && s[idx] == \\'0\\') return 0;\\n        if(idx >= n)\\n            return 1;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int ways = 0;\\n        \\n        // Pick single\\n        if(s[idx] != \\'0\\') ways = decode(s, idx+1, n);\\n            \\n        // Pick couple\\n        if(idx+1 < n && ((s[idx] == \\'1\\' && s[idx+1] <= \\'9\\') || (s[idx]==\\'2\\' && s[idx+1] < \\'7\\')))\\n           ways += decode(s, idx+2, n);\\n           \\n        return dp[idx] = ways;\\n    }\\n    \\n    int numDecodings(string s) {\\n       \\n        int n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        return decode(s, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740182,
                "title": "c-recursion-recursion-with-memoization-dp-explained",
                "content": "***Please like the post if you found it helpful***\\nBelow is the sequential thought process for this problem. First, I tried to solve it with recursion. \\nRecursion (TLE, Not Accepted)\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int ans=0;\\n        ans = recur(s,0);\\n        return ans;\\n    }\\n    int recur(string s, int pos){\\n        if(pos==s.size())return 1;\\n        if(s[pos]==\\'0\\')return 0;\\n        if(pos==s.size()-1)return 1;\\n        string b = s.substr(pos,2);\\n        \\n        int way1 = recur(s,pos+1);\\n        int way2=0;\\n        if(stoi(b)<=26&&stoi(b)>0){\\n            way2 = recur(s,pos+2);\\n        }\\n        return way1+way2;\\n    }\\n};\\n```\\nThen, I made a decision tree and saw that some values keep repeating and hence the need to store some values and reduce the extra processing. \\nRecursion with memoization (Accepted but took too much time)\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> hg(s.size()+1,0);\\n        int ans=0;\\n        ans = recur(s,0,hg);\\n        return ans;\\n    }\\n    int recur(string s, int pos, vector<int>& hg){\\n        if(pos==s.size())return 1;\\n        if(s[pos]==\\'0\\')return 0;\\n        if(pos==s.size()-1)return 1;\\n        if(hg[pos]>0)return hg[pos];\\n        string b = s.substr(pos,2);\\n        \\n        int way1 = recur(s,pos+1,hg);\\n        int way2=0;\\n        if(stoi(b)<=26&&stoi(b)>0){\\n            way2 = recur(s,pos+2,hg);\\n        }\\n        hg[pos]= way1+way2;\\n        return hg[pos];\\n    }\\n};\\n```\\nFinally the DP solution which is the best of all. \\nDP Solution (Best method)\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.size()+1);\\n        dp[0]=1;\\n        if(s[0]==\\'0\\')dp[1]=0;\\n        else dp[1]=1;\\n        for(int i=2;i<=s.size();i++){\\n            int way1,way2;\\n            if(s[i-1]==\\'0\\')way1=0;\\n            else way1=dp[i-1];\\n            if(stoi(s.substr(i-2,2))<=26&&stoi(s.substr(i-2,2))>0&&s[i-2]!=\\'0\\')way2=dp[i-2];\\n            else way2=0;\\n            dp[i]=way1+way2;\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int ans=0;\\n        ans = recur(s,0);\\n        return ans;\\n    }\\n    int recur(string s, int pos){\\n        if(pos==s.size())return 1;\\n        if(s[pos]==\\'0\\')return 0;\\n        if(pos==s.size()-1)return 1;\\n        string b = s.substr(pos,2);\\n        \\n        int way1 = recur(s,pos+1);\\n        int way2=0;\\n        if(stoi(b)<=26&&stoi(b)>0){\\n            way2 = recur(s,pos+2);\\n        }\\n        return way1+way2;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> hg(s.size()+1,0);\\n        int ans=0;\\n        ans = recur(s,0,hg);\\n        return ans;\\n    }\\n    int recur(string s, int pos, vector<int>& hg){\\n        if(pos==s.size())return 1;\\n        if(s[pos]==\\'0\\')return 0;\\n        if(pos==s.size()-1)return 1;\\n        if(hg[pos]>0)return hg[pos];\\n        string b = s.substr(pos,2);\\n        \\n        int way1 = recur(s,pos+1,hg);\\n        int way2=0;\\n        if(stoi(b)<=26&&stoi(b)>0){\\n            way2 = recur(s,pos+2,hg);\\n        }\\n        hg[pos]= way1+way2;\\n        return hg[pos];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.size()+1);\\n        dp[0]=1;\\n        if(s[0]==\\'0\\')dp[1]=0;\\n        else dp[1]=1;\\n        for(int i=2;i<=s.size();i++){\\n            int way1,way2;\\n            if(s[i-1]==\\'0\\')way1=0;\\n            else way1=dp[i-1];\\n            if(stoi(s.substr(i-2,2))<=26&&stoi(s.substr(i-2,2))>0&&s[i-2]!=\\'0\\')way2=dp[i-2];\\n            else way2=0;\\n            dp[i]=way1+way2;\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30474,
                "title": "my-c-0ms-dp-solution-o-n",
                "content": "     int n = s.size();\\n        if(n == 0 || s[0] == '0') return 0;\\n        if(n == 1) return 1;\\n        int res = 0,fn_1 = 1,fn_2 = 1;\\n        for(int i = 1;i < n;i++){\\n            int temp = fn_1;\\n            if(isValid(s[i])&&isValid(s[i-1],s[i]))  res+=fn_1+fn_2;\\n            if(!isValid(s[i])&&isValid(s[i-1],s[i])) res+=fn_2;\\n            if(isValid(s[i])&&!isValid(s[i-1],s[i])) res+=fn_1;\\n            if(!isValid(s[i])&&!isValid(s[i-1],s[i]))  return 0;\\n            fn_1 = res;\\n            fn_2 = temp;\\n            res = 0;\\n        }\\n        return fn_1;\\n    }\\n    bool isValid(char a,char b){\\n        return a == '1'||(a == '2' && b <='6');\\n    }\\n    bool isValid(char a){\\n        return a != '0';\\n    }",
                "solutionTags": [],
                "code": "     int n = s.size();\\n        if(n == 0 || s[0] == '0') return 0;\\n        if(n == 1) return 1;\\n        int res = 0,fn_1 = 1,fn_2 = 1;\\n        for(int i = 1;i < n;i++){\\n            int temp = fn_1;\\n            if(isValid(s[i])&&isValid(s[i-1],s[i]))  res+=fn_1+fn_2;\\n            if(!isValid(s[i])&&isValid(s[i-1],s[i])) res+=fn_2;\\n            if(isValid(s[i])&&!isValid(s[i-1],s[i])) res+=fn_1;\\n            if(!isValid(s[i])&&!isValid(s[i-1],s[i]))  return 0;\\n            fn_1 = res;\\n            fn_2 = temp;\\n            res = 0;\\n        }\\n        return fn_1;\\n    }\\n    bool isValid(char a,char b){\\n        return a == '1'||(a == '2' && b <='6');\\n    }\\n    bool isValid(char a){\\n        return a != '0';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30352,
                "title": "accpeted-python-dp-solution",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        def numDecodings(self, s):\\n            #dp[i] = dp[i-1] if s[i] != \"0\"\\n            #       +dp[i-2] if \"09\" < s[i-1:i+1] < \"27\"\\n            if s == \"\": return 0\\n            dp = [0 for x in range(len(s)+1)]\\n            dp[0] = 1\\n            for i in range(1, len(s)+1):\\n                if s[i-1] != \"0\":\\n                    dp[i] += dp[i-1]\\n                if i != 1 and s[i-2:i] < \"27\" and s[i-2:i] > \"09\":  #\"01\"ways = 0\\n                    dp[i] += dp[i-2]\\n            return dp[len(s)]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        def numDecodings(self, s):\\n            #dp[i] = dp[i-1] if s[i] != \"0\"\\n            #       +dp[i-2] if \"09\" < s[i-1:i+1] < \"27\"\\n            if s == \"\": return 0\\n            dp = [0 for x in range(len(s)+1)]\\n            dp[0] = 1\\n            for i in range(1, len(s)+1):\\n                if s[i-1] != \"0\":\\n                    dp[i] += dp[i-1]\\n                if i != 1 and s[i-2:i] < \"27\" and s[i-2:i] > \"09\":  #\"01\"ways = 0\\n                    dp[i] += dp[i-2]\\n            return dp[len(s)]",
                "codeTag": "Java"
            },
            {
                "id": 30644,
                "title": "concise-cpp-solution-with-o-1-space-and-o-n-time",
                "content": "    int numDecodings(string s) {\\n        // empty string or leading zero means no way\\n        if (!s.size() || s.front() == '0') return 0;\\n    \\n        // r1 and r2 store ways of the last and the last of the last\\n        int r1 = 1, r2 = 1;\\n    \\n        for (int i = 1; i < s.size(); i++) {\\n            // zero voids ways of the last because zero cannot be used separately\\n            if (s[i] == '0') r1 = 0;\\n            \\n            // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1\\n            if (s[i - 1] == '1' || s[i - 1] == '2' && s[i] <= '6') {\\n                r1 = r2 + r1;\\n                r2 = r1 - r2;\\n            }\\n    \\n            // one-digit letter, no new way added\\n            else {\\n                r2 = r1;\\n            }\\n        }\\n    \\n        return r1;\\n    }",
                "solutionTags": [],
                "code": "    int numDecodings(string s) {\\n        // empty string or leading zero means no way\\n        if (!s.size() || s.front() == '0') return 0;\\n    \\n        // r1 and r2 store ways of the last and the last of the last\\n        int r1 = 1, r2 = 1;\\n    \\n        for (int i = 1; i < s.size(); i++) {\\n            // zero voids ways of the last because zero cannot be used separately\\n            if (s[i] == '0') r1 = 0;\\n            \\n            // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1\\n            if (s[i - 1] == '1' || s[i - 1] == '2' && s[i] <= '6') {\\n                r1 = r2 + r1;\\n                r2 = r1 - r2;\\n            }\\n    \\n            // one-digit letter, no new way added\\n            else {\\n                r2 = r1;\\n            }\\n        }\\n    \\n        return r1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1029225,
                "title": "simple-and-detail-solution-with-explanation",
                "content": "Hey everyone, so I was just doing this one and it took me a lot of time to understand what had to be done in this question , mostly because no solution that I found was thoroughly explained, so here I am going to try doing that.\\n\\n**Intuition:** The problem asks us to calculate the numebr of ways to decode a certain string, but to do that, we                   have to calculate all possible **subsequences present in the string**.\\n**That** will give us the number of diffferent decodings. Hence the problem can be **reduced** down to finding the **number of substrings** in this string.\\n\\nNow, number of substrings of any substring can be found in two ways: \\n* By using `for` loops(resulting in `O(n^2)`\\n* By using `dp`(resulting in `O(n)`\\n\\t\\nThe only change in this problem with the usual problem of substrings is that we have to take care of edge cases like `0` in front of a number, and use a map to map the values,instead of reporting the number directly. \\n\\nNow that we know the intuition, lets look at Code :)\\n\\n**Code:**\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s) + 1)             \\n\\t\\tdp[0],dp[1]=1,1\\n        if s[0] == \"0\":            \\n\\t\\t\\treturn 0\\n        for i in range(2, len(s) + 1):\\n\\t\\t\\tif 1<=int(s[i-1])<=9:\\n\\t\\t\\t\\tdp[i]+ = dp[i - 1]\\n\\t\\t\\tif 10 <= int(s[i - 2] + s[i - 1]) <= 26 :\\n\\t\\t\\t\\tdp[i]+=dp[i - 2] \\n        return dp[-1]\\n```\\nNow lets try to see it step by step:\\n* First we create a list dp, which we have initized to 0.\\n* Now, `dp[i]`==> This denotes the number of decodings possible upto `[i-1]th` element of s. In other words, to calculate decoding upto ith character of s, we need to know `dp[i+1]`.  Hence , **when we calculate** `dp[len(s)]` or `dp[-1]` , it will give us the **number of decodings till `s[len(s)-1]`, hence the answer**\\n*  Now, try to understand this one: \\n`dp[i-1]` ==> gives the number of decodings until `[i-2]` element of s in consideration , and since we are considering till `s[i-1]` ,hence only one letter can be placed at the end, resulting in new sequences. This is the number of sequences which are formed by using the last one character.\\n\\n* `dp[i-2]`==>gives the number of decodings until `[i-3]` element of s in consideration , and since we are considering till `s[i-1]` ,hence two letters can be placed at the end, resulting in new sequences. This is the number of sequences which are formed by using the last two characters.\\n\\n* Now the edge cases:\\n1.  If `s[i-1]==0`==> means that the last character cannot be used for making new decodings, as we dont have code for 0, hence we test this condition using \\n\\t\\t\\t`if 1<=int(s[i-1])<=9`\\n\\t\\t\\t\\n2. If the last two digits in consideration add up to give more than 26, we have the same problem as before with having no code assigned to them and hence no decodings possible for this case either. We check **this** using\\n\\t\\t\\t`if 10 <= int(s[i - 2] + s[i - 1]) <= 26 `\\nAfter these two edge cases, all conditions have been acounted for and we simply return the result.\\n\\nI hope it helped you!!!\\nIf you like, please **UPVOTE**, it motivates me to write posts like these more :)\\nHappy Coding :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s) + 1)             \\n\\t\\tdp[0],dp[1]=1,1\\n        if s[0] == \"0\":            \\n\\t\\t\\treturn 0\\n        for i in range(2, len(s) + 1):\\n\\t\\t\\tif 1<=int(s[i-1])<=9:\\n\\t\\t\\t\\tdp[i]+ = dp[i - 1]\\n\\t\\t\\tif 10 <= int(s[i - 2] + s[i - 1]) <= 26 :\\n\\t\\t\\t\\tdp[i]+=dp[i - 2] \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645299,
                "title": "java-easy-to-understand-detailed-solution-recursion-memoization",
                "content": "![image](https://assets.leetcode.com/users/images/d348e28e-d75c-40de-8e59-833f6d1eb955_1664617586.5914717.png)\\n\\n\\n### How to identify if this is a dynamic programming question?\\n#### Consider this:\\n* Suppose you have a number **`226`**. When you pick `2`, you are left with `26`. But you have a choice to pick `22` as well which leaves you with `6`. So, at the first step you have **a choice to either choose 1 digit or 2 digits**.\\n* Moving forward, if you choose `2`, you have `26`. Now again you can choose `2` or `6` or `26`. The second step again gives you more **choices**.\\n\\n#### Conclusion:\\n* Whenever in a problem you are given **choices** and **making those choices impact/contribute to your answer**, then that problem could be a dynamic programming problem.\\n\\n* The first and best approach (I personally believe) to apply in these problems is **recursion**. And if you want to optimise, you should use memoization on top of that.\\n### How to write a recursive solution\\n* **FAITH**: Any recursive solution works on faith. The faith that your recursive method/function would give you correct answer if applied on a smaller input.\\n\\n* **BASE CONDITION**: Because recursive calls are placed on an internal stack and if it goes on and on without any base condition, you\\'ll see `StackOverflowException`. So, you always need a base condition in recursive solution.\\n\\n* **SOME ADDITIONAL CODE**: In most of the cases, when we assume that our recursive function would give us the correct answer, we add some logic for it to work at some place in the code. Don\\'t worry if you didn\\'t understand this. I\\'ll explain this later.\\n\\n\\n### **Now let\\'s solve this question**.\\n* The question asks us to either select 1 or 2 digits at any point. So we\\'ll write a function which gives us the count of ways:\\n\\n\\t\\tpublic int numDecodings(String s) {...}\\n\\n* This function gives us the count of ways a number can be decoded. We would need to apply the **same function to a smaller input and have faith that it\\'d work**. For that we take an index **`i`** which goes from `0` to `n - 1` where `n` is the length of string. Now this function becomes:\\n\\n\\t\\tpublic int numDecodings(String s, int i) {...}\\n\\n* Now we need to write a **base condition**. Base condition can be derived from thinking of the **smallest possible input** for the question. Question gives us that the minimum length of string is `1`. If we start from `i = 0` and reach `i = 1`, then we see that there is just one way to decode. So, the base condition becomes:\\n\\n\\t\\tif(i == n) return 1;\\t//for example, think that you are given \"2\" as the input.\\n\\n* Another condition that\\'s given in question is **if 0 is leading, there is no possible way**. So suppose we have **`\"06`\"**. In this scenario when `i = 0`, we can simply return `0`. This condition becomes:\\n\\n\\t\\tif(s.charAt(i) == \\'0\\') return 0;\\n\\nThis ends the base condition part.\\n\\n* Now for the faith part, we move `i` to next position by either `i + 1` or `i + 2` (because these are the two **choices** and **we code for our choices in recursion**). *Note that the string becomes smaller as I move forward*.\\n\\n* When I code for these two choices, the recursive calls become:\\n\\n\\t\\tnumDecodings(s, i + 1);\\n\\nand\\n\\n\\t\\tnumDecodings(s, i + 2);\\n\\n* **We\\'d get two numbers from these two calls which we can add and return.**\\n\\nThis ends our faith part. Great.\\n\\nNow comes the additional logic in code that we\\'ve discussed.\\n\\n* The question has another condition when you take two characters at once : it should be less than or equal to 26 (alphabets have 26 characters). \\n\\nSo, before taking two digits at once, we can check if these two digits do make a number `<= 26` or simply `< 27`.\\n\\nThis is how we can do it:\\n\\n\\t\\t((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27\\n\\n**BUT** - we need to add a check for `i + 1` also to avoid `OutOfBoundException`. Since our length of string is `n`, `i + 1` cannot be greater than `n` when we do `s.charAt(i + 1)`. So, adding this condition: \\n\\n\\t\\ti + 1 < n OR SIMPLY i < n - 1\\ngives us our final condition:\\n\\n\\t\\ti < n - 1 && ((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27\\n**That\\'s it! That was the last logic we had to add to make our recursive code work.**\\n\\n### So let\\'s code it:\\n\\n```\\npublic int numDecodings(String s) {\\n\\tint n = s.length();\\n\\tint[] mem = new int[n];\\n\\tArrays.fill(mem, -1);\\n\\treturn numDecodings(s, 0, mem);\\n}\\n\\nprivate int numDecodings(String s, int i) {\\n\\tint n = s.length();\\n\\tif (i == n)\\t\\t//base condition\\n\\t\\treturn 1;\\n\\tif (s.charAt(i) == \\'0\\')\\t//condition imposed by question\\n\\t\\treturn 0;\\n\\tint count = numDecodings(s, i + 1);\\t\\t//choice number 1 : take one digit\\n\\tif (i < n - 1 && ((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27) {\\n\\t\\tcount += numDecodings(s, i + 2);\\t//choice number 2 : take two digits but before making this choice, check for <= 26 or < 27 and i < n - 1 conditions. Add the result from here to the count from first choice.\\n\\t}\\n\\treturn count;\\t//return the count\\n}\\n```\\n\\n* **To make this recursive code memoized**, we can use a 1D array of size `n` to cache the intermediate results. Recursive code usually calculates multiple scenario answers again and again which could result in **TLE**. To avoid this, if a count for a choice has already been calculated, we store the value and return when request by code (instead of making more recursive calls). \\n\\n*To understand memoization, the best code is that of Fibonacci\\'s series. That problem is simple and will make you understand the need of memoization*.\\n\\n* Memoization code remains exactly same except for an extra memoization array. There is no change in logic.\\n* Here is the memoized code for the problem:\\n\\n```\\npublic int numDecodings(String s) {\\n\\tint n = s.length();\\n\\tint[] mem = new int[n];\\n\\tArrays.fill(mem, -1);\\n\\treturn numDecodings(s, 0, mem);\\n}\\n\\nprivate int numDecodings(String s, int i, int[] mem) {\\n\\tint n = s.length();\\n\\tif (i == n)\\n\\t\\treturn 1;\\n\\tif (s.charAt(i) == \\'0\\')\\n\\t\\treturn 0;\\n\\tif (mem[i] != -1)//if this sub-problem has already been solved, don\\'t go and invoke another series of recursive call. Get the result from cache\\n\\t\\treturn mem[i];\\n\\tint count = numDecodings(s, i + 1, mem);\\n\\tif (i < n - 1 && ((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27) {\\n\\t\\tcount += numDecodings(s, i + 2, mem);\\n\\t}\\n\\t\\treturn mem[i] = count;//store result for each sub-problem\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic int numDecodings(String s) {\\n\\tint n = s.length();\\n\\tint[] mem = new int[n];\\n\\tArrays.fill(mem, -1);\\n\\treturn numDecodings(s, 0, mem);\\n}\\n\\nprivate int numDecodings(String s, int i) {\\n\\tint n = s.length();\\n\\tif (i == n)\\t\\t//base condition\\n\\t\\treturn 1;\\n\\tif (s.charAt(i) == \\'0\\')\\t//condition imposed by question\\n\\t\\treturn 0;\\n\\tint count = numDecodings(s, i + 1);\\t\\t//choice number 1 : take one digit\\n\\tif (i < n - 1 && ((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27) {\\n\\t\\tcount += numDecodings(s, i + 2);\\t//choice number 2 : take two digits but before making this choice, check for <= 26 or < 27 and i < n - 1 conditions. Add the result from here to the count from first choice.\\n\\t}\\n\\treturn count;\\t//return the count\\n}\\n```\n```\\npublic int numDecodings(String s) {\\n\\tint n = s.length();\\n\\tint[] mem = new int[n];\\n\\tArrays.fill(mem, -1);\\n\\treturn numDecodings(s, 0, mem);\\n}\\n\\nprivate int numDecodings(String s, int i, int[] mem) {\\n\\tint n = s.length();\\n\\tif (i == n)\\n\\t\\treturn 1;\\n\\tif (s.charAt(i) == \\'0\\')\\n\\t\\treturn 0;\\n\\tif (mem[i] != -1)//if this sub-problem has already been solved, don\\'t go and invoke another series of recursive call. Get the result from cache\\n\\t\\treturn mem[i];\\n\\tint count = numDecodings(s, i + 1, mem);\\n\\tif (i < n - 1 && ((s.charAt(i) - \\'0\\') * 10 + (s.charAt(i + 1) - \\'0\\')) < 27) {\\n\\t\\tcount += numDecodings(s, i + 2, mem);\\n\\t}\\n\\t\\treturn mem[i] = count;//store result for each sub-problem\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644238,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/24UtgARN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/24UtgARN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 30490,
                "title": "7-lines-cpp-solution",
                "content": "    int numDecodings(string s) {\\n          int n = s.size();\\n          if(!n || s[0] == '0')\\n              return 0;\\n          int f[n+1] = {1, 1}, i;\\n          for(i = 2; i <= n; ++i)\\n               f[i] = (int)(s[i-1] != '0')*f[i-1] + (int)((s[i-2] == '1') || (s[i-2] == '2' && s[i-1] < '7'))*f[i-2];\\n        return f[n];\\n    }\\n\\n\\nSlightly Modified O(1) space method:\\n\\n    int numDecodings(string s) {\\n          int n = s.size();\\n          if(!n || s[0] == '0')\\n              return 0;\\n          int f0 = 1, f1 = 1, f2, i;\\n          for(i = 2; i <= n; ++i)\\n          {\\n               f2 = (int)(s[i-1] != '0')*f1 + (int)((s[i-2] == '1') || (s[i-2] == '2' && s[i-1] < '7'))*f0;\\n               f0 = f1;\\n               f1 = f2;\\n          }\\n        return f1;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int numDecodings(string s) {\\n          int n = s.size();\\n          if(!n || s[0] == '0')\\n              return 0;\\n          int f[n+1] = {1, 1}, i;\\n          for(i = 2; i <= n; ++i)\\n               f[i] = (int)(s[i-1] != '0')*f[i-1] + (int)((s[i-2] == '1') || (s[i-2] == '2' && s[i-1] < '7'))*f[i-2];\\n        return f[n];\\n    }\\n\\n\\nSlightly Modified O(1) space method:\\n\\n    int numDecodings(string s) {\\n          int n = s.size();\\n          if(!n || s[0] == '0')\\n              return 0;\\n          int f0 = 1, f1 = 1, f2, i;\\n          for(i = 2; i <= n; ++i)\\n          {\\n               f2 = (int)(s[i-1] != '0')*f1 + (int)((s[i-2] == '1') || (s[i-2] == '2' && s[i-1] < '7'))*f0;\\n               f0 = f1;\\n               f1 = f2;\\n          }\\n        return f1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568178,
                "title": "java-solution-with-recursion-memoization",
                "content": "```\\npublic int numDecodings(String s) {\\n\\tInteger[] memo = new Integer[s.length() + 1];\\n\\treturn numDecodings(s, 0, memo);\\n}\\n\\nprivate int numDecodings(String s, int index, Integer[] memo) {\\n\\tif (index == s.length()) {\\n\\t\\treturn 1;\\n\\t}\\n\\tif (s.charAt(index) == \\'0\\') {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[index] != null) {\\n\\t\\treturn memo[index];\\n\\t}\\n\\tint way1 = numDecodings(s, index + 1, memo);\\n\\tint way2 = 0;\\n\\tif (index < s.length() - 1 && Integer.parseInt(s.substring(index, index + 2)) <= 26) {\\n\\t\\tway2 = numDecodings(s, index + 2, memo);\\n\\t}\\n\\tmemo[index] = way1 + way2;\\n\\treturn memo[index];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic int numDecodings(String s) {\\n\\tInteger[] memo = new Integer[s.length() + 1];\\n\\treturn numDecodings(s, 0, memo);\\n}\\n\\nprivate int numDecodings(String s, int index, Integer[] memo) {\\n\\tif (index == s.length()) {\\n\\t\\treturn 1;\\n\\t}\\n\\tif (s.charAt(index) == \\'0\\') {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[index] != null) {\\n\\t\\treturn memo[index];\\n\\t}\\n\\tint way1 = numDecodings(s, index + 1, memo);\\n\\tint way2 = 0;\\n\\tif (index < s.length() - 1 && Integer.parseInt(s.substring(index, index + 2)) <= 26) {\\n\\t\\tway2 = numDecodings(s, index + 2, memo);\\n\\t}\\n\\tmemo[index] = way1 + way2;\\n\\treturn memo[index];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831041,
                "title": "c-apni-bhasha-mein-seedhi-baat-no-bakwaas-dp-1d-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n\\n       \\tLOGIC\\n\\n       \\tKARNA KYA HAIN\\u2753\\n       \\t1. Ek message diya hain string(alphabets) format usko ham encode kar sakte\\n       \\thain number format mein according to particular scheme.\\n       \\t2. Ab ques mein vo \"number format string\" diya hain ab usko wapis se \\n       \\t\"decode\" karna hain to alphabets string according to particular scheme.\\n       \\t3. We have to return the \"number of ways\" to decode it.\\n\\n       \\tTHINGS TO REMEMBER\\n       \\t1. Grouping of letter can be done in \"single\" and \"double\" not more or less.\\n       \\t2. Starting of any \"single\" or \"double\" cannot be \"0\".\\n       \\t3. The encodings range from \"1\" to \"26\" so we can decode in this range only.\\n\\n       \\tINTUITION &APPROACH\\n       \\t1. Ab message ko decode kar sakte hain \"single\" aur \"double\" letters leke.\\n       \\t2. Matlab hamare paas choice hain ki kin tariko se ham decode kare.\\n       \\t3. Choice meaning \"RECURSION\".\\n       \\t4. RECURRENCE RELATION\\n       \\t- BASE CASE:- If the size of string is 1 then return 1.(Yaani index string\\n       \\tke last char tak pahuch gaya hain aur hamare paas lene ke liye ek char\\n       \\tbacha hain)\\n       \\t- Single character lene ki choice Choice(s,i+1)\\n       \\tWhere Choice(s,i+1) denotes the number of ways to decode s till (i+1)th index.\\n       \\t- Double character lene ki choice Choice(s,i+2)\\n       \\t- Choices ke lene ke tariko ko previous tariko mein add kar denge ans+=\\n       \\tKyoki we have to find \"total no of ways\" thats why addition.\\n       \\t- Choices lene ke rules bhi follow karne hain:-\\n       \\t1)Single char le rahe to first index 0 nahin hoga\\n       \\t2)Double char le rahe to utne char hone chahiye,first index 1 ya 2 hoga\\n       \\taur doosra index 1 se 6 ke beech mein.\\n       \\t5. Ab there will be \"overlapping subproblems\" so we will use \\uD83D\\uDCA5DP.\\n       \\t6. RECURSION -> MEMOIZATION -> TABULATION -> SPACE OPTIMIZATION\\n       \\t7. Memoization Steps\\n       \\t- What params are changing\\u2753(Here \"index\" of string is changing only)\\n       \\t- Size of sp array \\u2753(1D only 1 param is changing)\\n       \\t- Check if the problem is solved previously\\n       \\t- store the result in dp array\\n       \\t8. Meaning of dp[i]-> No of ways to decode till ith index in string s.\\n       \\t9. TABULATION STEPS\\n       \\t- Declare dp array.(Here 1D)\\n       \\t- Declare base cases.(Here dp[0]=1,dp[1]=1)\\n       \\t- Will loop from index 2 to n-1 of s.\\n       \\t- Will check for single chars and double chars.\\n       \\t- More info is in the code below.\\n       \\t10. SPACE OPTIMIZED TABULATION STEPS\\n       \\t- Check if we need the dp array for our calc\\u2753\\n       \\t- From tabulation are we able to find any pattern.\\n       \\t- If there is pattern then remove the dp array and replace with variables.\\n       \\t- Check code below for more insights.\\n//===============================================================================================================\\n\\n       \\t//Memoization\\n        int Choices(string s, int index, vector<int> &dp)\\n        {\\n            if (index == s.size())\\n               \\t//Only 1 char is left as we have reached the end so no choice\\n               \\t//other than taking it\\n                return 1;\\n            if (dp[index] != -1)\\n               \\t//If sub-problem is solved earlier\\n                return dp[index];\\n            int res = 0;\\n            if (s[index] != \\'0\\')\\n                res += Choices(s, index + 1, dp);\\n           \\t//Solving for single character\\n            if (index + 1 < s.size() && (s[index] == \\'1\\' || s[index] == \\'2\\' && s[index + 1] <= \\'6\\'))\\n               \\t//Solving for double character\\n                res += Choices(s, index + 2, dp);\\n            return dp[index] = res;\\n        }\\n    int numDecodings(string s)\\n    {\\n        int n = s.size();\\n        vector<int> dp(n + 1, -1);\\n        return Choices(s, 0, dp);\\n    }\\n\\n//=====================================================================================================\\n   \\t//TABULATION\\n   \\tint numDecodings(string s)\\n   \\t{\\n   \\t    int n = s.size();\\n   \\t    vector<int> dp(n + 1, 0);\\n   \\t    dp[0] = 1;\\n   \\t    dp[1] = s[0] != \\'0\\' ? 1 : 0;\\t// Initialize dp[1] based on the first character\\n\\n   \\t    for (int index = 2; index <= n; index++)\\n   \\t    {\\n   \\t       \\t// Single-digit case\\n   \\t        if (s[index - 1] != \\'0\\')\\n   \\t            dp[index] += dp[index - 1];\\n\\n   \\t       \\t// Two-digit case\\n   \\t        int twoDigitNum = stoi(s.substr(index - 2, 2));\\n   \\t        if (twoDigitNum >= 10 && twoDigitNum <= 26)\\n   \\t            dp[index] += dp[index - 2];\\n   \\t    }\\n\\n   \\t    return dp[n];\\n   \\t}\\n\\n//=====================================================================================================\\n\\n   \\t//SPACE-OPTIMIZED TABULATION\\n    int numDecodings(string s)\\n    {\\n        int n = s.size();\\n\\n        int two_index_back = 1;\\n       \\t//dp[0]=0(dp val 2 index back from index)\\n        int one_index_back = s[0] != \\'0\\' ? 1 : 0;\\n       \\t//dp[1]=1(dp val 1 index back from index)\\n        int curr_index = 0;\\n\\n        for (int index = 2; index <= n; index++)\\n        {\\n           \\t// Single-digit case\\n            if (s[index - 1] != \\'0\\')\\n                curr_index += one_index_back;\\n\\n           \\t// Two-digit case\\n            int twoDigitNum = stoi(s.substr(index - 2, 2));\\n            if (twoDigitNum >= 10 && twoDigitNum <= 26)\\n                curr_index += two_index_back;\\n\\n           \\t//Swapping\\n            two_index_back = one_index_back;\\n            one_index_back = curr_index;\\n            curr_index = 0;\\n        }\\n\\n        return one_index_back;\\n    }\\n};\\n```\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\tLOGIC\\n\\n       \\tKARNA KYA HAIN\\u2753\\n       \\t1. Ek message diya hain string(alphabets) format usko ham encode kar sakte\\n       \\thain number format mein according to particular scheme.\\n       \\t2. Ab ques mein vo \"number format string\" diya hain ab usko wapis se \\n       \\t\"decode\" karna hain to alphabets string according to particular scheme.\\n       \\t3. We have to return the \"number of ways\" to decode it.\\n\\n       \\tTHINGS TO REMEMBER\\n       \\t1. Grouping of letter can be done in \"single\" and \"double\" not more or less.\\n       \\t2. Starting of any \"single\" or \"double\" cannot be \"0\".\\n       \\t3. The encodings range from \"1\" to \"26\" so we can decode in this range only.\\n\\n       \\tINTUITION &APPROACH\\n       \\t1. Ab message ko decode kar sakte hain \"single\" aur \"double\" letters leke.\\n       \\t2. Matlab hamare paas choice hain ki kin tariko se ham decode kare.\\n       \\t3. Choice meaning \"RECURSION\".\\n       \\t4. RECURRENCE RELATION\\n       \\t- BASE CASE:- If the size of string is 1 then return 1.(Yaani index string\\n       \\tke last char tak pahuch gaya hain aur hamare paas lene ke liye ek char\\n       \\tbacha hain)\\n       \\t- Single character lene ki choice Choice(s,i+1)\\n       \\tWhere Choice(s,i+1) denotes the number of ways to decode s till (i+1)th index.\\n       \\t- Double character lene ki choice Choice(s,i+2)\\n       \\t- Choices ke lene ke tariko ko previous tariko mein add kar denge ans+=\\n       \\tKyoki we have to find \"total no of ways\" thats why addition.\\n       \\t- Choices lene ke rules bhi follow karne hain:-\\n       \\t1)Single char le rahe to first index 0 nahin hoga\\n       \\t2)Double char le rahe to utne char hone chahiye,first index 1 ya 2 hoga\\n       \\taur doosra index 1 se 6 ke beech mein.\\n       \\t5. Ab there will be \"overlapping subproblems\" so we will use \\uD83D\\uDCA5DP.\\n       \\t6. RECURSION -> MEMOIZATION -> TABULATION -> SPACE OPTIMIZATION\\n       \\t7. Memoization Steps\\n       \\t- What params are changing\\u2753(Here \"index\" of string is changing only)\\n       \\t- Size of sp array \\u2753(1D only 1 param is changing)\\n       \\t- Check if the problem is solved previously\\n       \\t- store the result in dp array\\n       \\t8. Meaning of dp[i]-> No of ways to decode till ith index in string s.\\n       \\t9. TABULATION STEPS\\n       \\t- Declare dp array.(Here 1D)\\n       \\t- Declare base cases.(Here dp[0]=1,dp[1]=1)\\n       \\t- Will loop from index 2 to n-1 of s.\\n       \\t- Will check for single chars and double chars.\\n       \\t- More info is in the code below.\\n       \\t10. SPACE OPTIMIZED TABULATION STEPS\\n       \\t- Check if we need the dp array for our calc\\u2753\\n       \\t- From tabulation are we able to find any pattern.\\n       \\t- If there is pattern then remove the dp array and replace with variables.\\n       \\t- Check code below for more insights.\\n//===============================================================================================================\\n\\n       \\t//Memoization\\n        int Choices(string s, int index, vector<int> &dp)\\n        {\\n            if (index == s.size())\\n               \\t//Only 1 char is left as we have reached the end so no choice\\n               \\t//other than taking it\\n                return 1;\\n            if (dp[index] != -1)\\n               \\t//If sub-problem is solved earlier\\n                return dp[index];\\n            int res = 0;\\n            if (s[index] != \\'0\\')\\n                res += Choices(s, index + 1, dp);\\n           \\t//Solving for single character\\n            if (index + 1 < s.size() && (s[index] == \\'1\\' || s[index] == \\'2\\' && s[index + 1] <= \\'6\\'))\\n               \\t//Solving for double character\\n                res += Choices(s, index + 2, dp);\\n            return dp[index] = res;\\n        }\\n    int numDecodings(string s)\\n    {\\n        int n = s.size();\\n        vector<int> dp(n + 1, -1);\\n        return Choices(s, 0, dp);\\n    }\\n\\n//=====================================================================================================\\n   \\t//TABULATION\\n   \\tint numDecodings(string s)\\n   \\t{\\n   \\t    int n = s.size();\\n   \\t    vector<int> dp(n + 1, 0);\\n   \\t    dp[0] = 1;\\n   \\t    dp[1] = s[0] != \\'0\\' ? 1 : 0;\\t// Initialize dp[1] based on the first character\\n\\n   \\t    for (int index = 2; index <= n; index++)\\n   \\t    {\\n   \\t       \\t// Single-digit case\\n   \\t        if (s[index - 1] != \\'0\\')\\n   \\t            dp[index] += dp[index - 1];\\n\\n   \\t       \\t// Two-digit case\\n   \\t        int twoDigitNum = stoi(s.substr(index - 2, 2));\\n   \\t        if (twoDigitNum >= 10 && twoDigitNum <= 26)\\n   \\t            dp[index] += dp[index - 2];\\n   \\t    }\\n\\n   \\t    return dp[n];\\n   \\t}\\n\\n//=====================================================================================================\\n\\n   \\t//SPACE-OPTIMIZED TABULATION\\n    int numDecodings(string s)\\n    {\\n        int n = s.size();\\n\\n        int two_index_back = 1;\\n       \\t//dp[0]=0(dp val 2 index back from index)\\n        int one_index_back = s[0] != \\'0\\' ? 1 : 0;\\n       \\t//dp[1]=1(dp val 1 index back from index)\\n        int curr_index = 0;\\n\\n        for (int index = 2; index <= n; index++)\\n        {\\n           \\t// Single-digit case\\n            if (s[index - 1] != \\'0\\')\\n                curr_index += one_index_back;\\n\\n           \\t// Two-digit case\\n            int twoDigitNum = stoi(s.substr(index - 2, 2));\\n            if (twoDigitNum >= 10 && twoDigitNum <= 26)\\n                curr_index += two_index_back;\\n\\n           \\t//Swapping\\n            two_index_back = one_index_back;\\n            one_index_back = curr_index;\\n            curr_index = 0;\\n        }\\n\\n        return one_index_back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455337,
                "title": "python-as-simple-as-i-can-make-it-recursive-memo",
                "content": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        self.memo = {}\\n        return self.helper(s)\\n\\n    def helper(self, s: str) -> int:\\n        if len(s) == 0: return 1\\n        if s in self.memo: return self.memo[s]\\n        \\n        takeOne = takeTwo = 0\\n        \\n        if int(s[:1]) >= 1 and int(s[:1]) <= 9:\\n            takeOne = self.helper(s[1:])\\n        \\n        if int(s[:2]) >= 10 and int(s[:2]) <= 26: \\n            takeTwo = self.helper(s[2:])\\n        \\n        self.memo[s] = takeOne + takeTwo\\n        \\n        return self.memo[s]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        self.memo = {}\\n        return self.helper(s)\\n\\n    def helper(self, s: str) -> int:\\n        if len(s) == 0: return 1\\n        if s in self.memo: return self.memo[s]\\n        \\n        takeOne = takeTwo = 0\\n        \\n        if int(s[:1]) >= 1 and int(s[:1]) <= 9:\\n            takeOne = self.helper(s[1:])\\n        \\n        if int(s[:2]) >= 10 and int(s[:2]) <= 26: \\n            takeTwo = self.helper(s[2:])\\n        \\n        self.memo[s] = takeOne + takeTwo\\n        \\n        return self.memo[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991162,
                "title": "c-simple-dp-solution-explained-100-time-100-space",
                "content": "I came to this solution trying sequences of `2`s and seeing that the result was increasing like a Fibonacci number; some more testing and tweaking, until I finally got it right.\\n\\nFirst of all we need to check for an annoying edge cases - a leading `\\'0\\'`, which is not valid and if so we just return `0` combinations; similarly, any other single character (ie: other than `\\'0\\'`, since we put the second condition after that check) will always mean just `1` combination.\\n\\nThen we declare our support variables:\\n* `len` will store the length of our input;\\n* `dp` is an array of length `len` where we will store our precomputed results as we parse the string.\\n\\nBut first we want to initialise `dp` a bit:\\n* at index `0`, we can be sure we will have just `1` possible combination to consider (since we excluded a leading `0` before);\\n* at index `1` things are a bit more complicated and we need to start using our main logic in 2 steps:\\n\\t* if the first and the second character compose a number in the `10 - 26` range, we store `1`, `0` otherwise;\\n\\t* similarly, any character `!= \\'0\\'` will mean one extra combination obtained here.\\n\\nWe can see it in other ways: if the first two digits are in the valid range, that means we we can read them in 2 different ways (for example: `\"13\"` can be seen as either the character with index `13` or the characters with indexes `1` and `3`); that is always the case, unless the second digit is a `\\'0\\'`, since that cannot be alone to make a valid combination.\\n\\nYou can also see the code as adding `2` if the first two digits are in the `10 - 26` range and, in case, subtracting `1` when the `s[1] == \\'0\\'`, for the reason explained above.\\n\\nWith this ground prepared, we can move on with the main loop, going with `i` from `2` up to `len` (excluded) to populate `dp`. At each step, we will:\\n* first of all check if we encountered the second consecutive `\\'0\\'`, in which case there is no point in moving forward and we can just `return 0`, as done above for invalid coded strings;\\n* we will then give the value of `dp[i - 1]` (the previous value) to `dp[i]`, unless our current character is a `\\'0\\'`, in which case we just set it to `0`, since no single character combination can be counted this way;\\n* if the last two digits are in the valid `10 -26` range, then we will also add the value of two positions before (`dp[i - 2]`) to `dp[i]` - again try to think in terms of a Fibonacci sequence if that helps you make more sense of it.\\n\\nOnce we are done, we can return `dp[len - 1]` as the correct result of all the cumulated combinations :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // edge cases out - leading zero and single character string\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        // support variables\\n        int len = s.size(), dp[len];\\n        // preparing dp\\n        dp[0] = 1;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2; i < len; i++) {\\n            // edge case: we quit for 2 consecutive zeros\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) return 0;\\n            // base case: we always keep the previous set of combinations, unless we met a 0\\n            dp[i] = s[i] != \\'0\\' ? dp[i - 1] : 0;\\n            // we go and look 2 positions behind if we can make a digit in the 10-26 range\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') dp[i] += dp[i - 2];\\n        }\\n        return dp[len - 1];\\n    }\\n};\\n```\\n\\nBut, wait a moment: can we do better?\\n\\nWell, after all we need only the last 3 values of `dp` at each step, so I will declare it to have only 3 slots and adjust the rest with some neat modulo operation; saving even more memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // edge cases out - leading zero and single character string\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        // support variables\\n        int len = s.size(), dp[3];\\n        // preparing dp\\n        dp[0] = 1;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2, curr, prev; i < len; i++) {\\n            curr = i % 3;\\n            prev = curr ? curr - 1 : 2;\\n            // edge case: we quit for 2 consecutive zeros\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) return 0;\\n            // base case: we always keep the previous set of combinations, unless we met a 0\\n            dp[curr] = s[i] != \\'0\\' ? dp[prev] : 0;\\n            // we go and look 2 positions behind if we can make a digit in the 10-26 range\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') dp[curr] += dp[prev ? prev - 1 : 2];\\n        }\\n        return dp[(len - 1) % 3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // edge cases out - leading zero and single character string\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        // support variables\\n        int len = s.size(), dp[len];\\n        // preparing dp\\n        dp[0] = 1;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2; i < len; i++) {\\n            // edge case: we quit for 2 consecutive zeros\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) return 0;\\n            // base case: we always keep the previous set of combinations, unless we met a 0\\n            dp[i] = s[i] != \\'0\\' ? dp[i - 1] : 0;\\n            // we go and look 2 positions behind if we can make a digit in the 10-26 range\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') dp[i] += dp[i - 2];\\n        }\\n        return dp[len - 1];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // edge cases out - leading zero and single character string\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        // support variables\\n        int len = s.size(), dp[3];\\n        // preparing dp\\n        dp[0] = 1;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2, curr, prev; i < len; i++) {\\n            curr = i % 3;\\n            prev = curr ? curr - 1 : 2;\\n            // edge case: we quit for 2 consecutive zeros\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) return 0;\\n            // base case: we always keep the previous set of combinations, unless we met a 0\\n            dp[curr] = s[i] != \\'0\\' ? dp[prev] : 0;\\n            // we go and look 2 positions behind if we can make a digit in the 10-26 range\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') dp[curr] += dp[prev ? prev - 1 : 2];\\n        }\\n        return dp[(len - 1) % 3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30529,
                "title": "readable-python-dp-solution",
                "content": "    def numDecodings(self, s):\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)]\\n        dp[0] = 1\\n        dp[1] = 1 if 0 < int(s[0]) <= 9 else 0\\n\\n        for i in range(2, len(s) + 1):\\n            if 0 < int(s[i-1:i]) <= 9:\\n                dp[i] += dp[i - 1]\\n            if s[i-2:i][0] != '0' and int(s[i-2:i]) <= 26:\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def numDecodings(self, s):\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)]\\n        dp[0] = 1\\n        dp[1] = 1 if 0 < int(s[0]) <= 9 else 0\\n\\n        for i in range(2, len(s) + 1):\\n            if 0 < int(s[i-1:i]) <= 9:\\n                dp[i] += dp[i - 1]\\n            if s[i-2:i][0] != '0' and int(s[i-2:i]) <= 26:\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]",
                "codeTag": "Python3"
            },
            {
                "id": 1410880,
                "title": "c-simple-and-short-0ms-solution-with-explanation-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nWe keep three variables:\\n`prev_i_ways` is the number of ways to decode s up to index i-1.\\n`i_ways` is the number of ways to decode s up to index i.\\n`prev` is a temporary variable to save the `i_ways` in each iteration.\\n\\nWe initialize `i_ways` and `prev_i_ways` with 1 because we are starting the loop from index 1.\\nIf the first digit iz 0 we just return 0 because it\\'s impossible to decode the string.\\n\\n**In each iteration:**\\n1. Save the previous i_ways in prev, to remember it.\\n2. If the current digit is 0, the new i_ways is 0 because we can\\'t add any new decode way.\\n3. Else, if the current digit is part of a 2 digit number, we add the prev_i_ways to the new i_ways, because we have another prev_i_ways ways to decode.\\n4. For the next iteration, prev_i_ways becomes the i_ways that we saved.\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int prev_i_ways = 1, i_ways = 1, prev;\\n        if (!s.size()) return 0;\\n        if (s[0] == \\'0\\') return 0;\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            prev = i_ways;\\n            if (s[i] == \\'0\\') i_ways = 0;\\n            if ((s[i-1] == \\'1\\') || (s[i-1] == \\'2\\' && s[i] < \\'7\\')) i_ways += prev_i_ways;\\n            prev_i_ways = prev;\\n        }\\n        return i_ways;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int prev_i_ways = 1, i_ways = 1, prev;\\n        if (!s.size()) return 0;\\n        if (s[0] == \\'0\\') return 0;\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            prev = i_ways;\\n            if (s[i] == \\'0\\') i_ways = 0;\\n            if ((s[i-1] == \\'1\\') || (s[i-1] == \\'2\\' && s[i] < \\'7\\')) i_ways += prev_i_ways;\\n            prev_i_ways = prev;\\n        }\\n        return i_ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987013,
                "title": "python-o-n-time-o-1-space-dp-explained",
                "content": "Let us use dynamic programming for this problem, where we keep `3` values on each step:\\n\\n1. `dp[0]` is total numbers to decode number `s[:i]`.\\n2. `dp[1]` is number of ways to decode number `s[:i]`, if it ends with `1` and last digit is **part of 2-digit number**. This is important point.\\n3. `dp[2]` is number of ways to decode number `s[:i]`, if it ends with `2` and last digit is **part of 2-digit number**.\\n\\nNow, we need to understand how to update our numbers:\\n1. For `dp_new[0]` we can have `3` options: if last digit is more than `0`, than we can take it as `1-digit number` (by definition each part is number between 1 and 26). Also, we can take last number as 2-digit number if it starts with `1`: this is exactly `dp[1]`. and if it starts with `2` and last digit is less or equal to `6`.\\n2. For `dp_new[1]` we have only one option: we need to have last symbol equal to `1`. \\n3. Similar for `dp_new[2]`, we need to have last symbol equal to `2`.\\n\\n**Complexity**: time complexity is `O(n)`: we iterate over each symbol once. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s):\\n        dp = [1, 0, 0]\\n        for c in s:\\n            dp_new = [0,0,0]\\n            dp_new[0]  = (c > \\'0\\') * dp[0] + dp[1] + (c <= \\'6\\') * dp[2]\\n            dp_new[1]  = (c == \\'1\\') * dp[0]\\n            dp_new[2]  = (c == \\'2\\') * dp[0]\\n            dp = dp_new\\n        return dp[0]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s):\\n        dp = [1, 0, 0]\\n        for c in s:\\n            dp_new = [0,0,0]\\n            dp_new[0]  = (c > \\'0\\') * dp[0] + dp[1] + (c <= \\'6\\') * dp[2]\\n            dp_new[1]  = (c == \\'1\\') * dp[0]\\n            dp_new[2]  = (c == \\'2\\') * dp[0]\\n            dp = dp_new\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397369,
                "title": "clean-javascript-solution",
                "content": "```\\n// e.g. \\'226\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 3]\\n//\\n// e.g. \\'236\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 2]\\n//\\n// e.g. \\'101\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 1, 0]\\n// [1, 1, 1, 1]\\n//\\n// e.g. \\'110\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 1]\\n\\nfunction numDecodings(s) {\\n  if (s == null || s.length === 0) return 0;\\n  if (s[0] === \\'0\\') return 0;\\n\\n  const dp = new Array(s.length + 1).fill(0);\\n\\n  dp[0] = 1;\\n  dp[1] = 1;\\n\\n  for (let i = 2; i <= s.length; i++) {\\n    const a = Number(s.slice(i - 1, i));  // last one digit\\n    if (a >= 1 && a <= 9) {\\n      dp[i] += dp[i - 1];\\n    }\\n\\n    const b = Number(s.slice(i - 2, i));  // last two digits\\n    if (b >= 10 && b <= 26) {\\n      dp[i] += dp[i - 2];\\n    }\\n  }\\n\\n  return dp[s.length];\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n// e.g. \\'226\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 3]\\n//\\n// e.g. \\'236\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 2]\\n//\\n// e.g. \\'101\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 1, 0]\\n// [1, 1, 1, 1]\\n//\\n// e.g. \\'110\\'\\n// dp =\\n// [1, 1, 0, 0]\\n// [1, 1, 2, 0]\\n// [1, 1, 2, 1]\\n\\nfunction numDecodings(s) {\\n  if (s == null || s.length === 0) return 0;\\n  if (s[0] === \\'0\\') return 0;\\n\\n  const dp = new Array(s.length + 1).fill(0);\\n\\n  dp[0] = 1;\\n  dp[1] = 1;\\n\\n  for (let i = 2; i <= s.length; i++) {\\n    const a = Number(s.slice(i - 1, i));  // last one digit\\n    if (a >= 1 && a <= 9) {\\n      dp[i] += dp[i - 1];\\n    }\\n\\n    const b = Number(s.slice(i - 2, i));  // last two digits\\n    if (b >= 10 && b <= 26) {\\n      dp[i] += dp[i - 2];\\n    }\\n  }\\n\\n  return dp[s.length];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117143,
                "title": "the-art-of-dynamic-programming",
                "content": "[`\\uD83C\\uDFA8`  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory Optimization, ie. O(1) instead of O(N) via sliding window `a = dp[i]`, `b = dp[i + 1]`, `c = dp[i + 2]`\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Kotlin:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var ok = { x: Int -> x in 1..26 }\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) (\"${s[i]}${s[i + 1]}\").toInt() else 0\\n            if (ok(one)) cnt += go(i + 1)\\n            if (ok(two)) cnt += go(i + 2)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        var N = s.length\\n        var ok = { x: Int -> x in 1..26 }\\n        fun go(i: Int = 0): Int {\\n            if (m.contains(i))\\n                return m[i]!!\\n            if (i == N)\\n                return 1\\n            m[i] = 0\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) (\"${s[i]}${s[i + 1]}\").toInt() else 0\\n            if (ok(one)) m[i] = m[i]!! + go(i + 1)\\n            if (ok(two)) m[i] = m[i]!! + go(i + 2)\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var dp = IntArray(N + 2)\\n        dp[N] = 1\\n        var ok = { x: Int -> x in 1..26 }\\n        for (i in N - 1 downTo 0) {\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) \"${s[i]}${s[i + 1]}\".toInt() else 0\\n            if (ok(one)) dp[i] += dp[i + 1]\\n            if (ok(two)) dp[i] += dp[i + 2]\\n        }\\n        return dp[0]\\n    }\\n}\\n```\\n\\n4. Memory Optimization, ie. O(1) instead of O(N) via sliding window `a = dp[i]`, `b = dp[i + 1]`, `c = dp[i + 2]`\\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var a = 0\\n        var b = 1\\n        var c = 0\\n        var ok = { x: Int -> x in 1..26 }\\n        for (i in N - 1 downTo 0) {\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) \"${s[i]}${s[i + 1]}\".toInt() else 0\\n            a = 0\\n            if (ok(one)) a += b\\n            if (ok(two)) a += c\\n            c = b; b = a\\n        }\\n        return a\\n    }\\n}\\n```\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Javascript:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet numDecodings = s => {\\n    let N = s.length;\\n    let ok = x => 1 <= x && x <= 26;\\n    let go = i => {\\n        if (i == N)\\n            return 1;\\n        let cnt = 0,\\n            one = Number(s[i]),\\n            two = one && i + 1 < N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) cnt += go(i + 1);\\n        if (ok(two)) cnt += go(i + 2);\\n        return cnt;\\n    };\\n    return go(0);\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet numDecodings = (s, m = new Map()) => {\\n    let N = s.length;\\n    let ok = x => 1 <= x && x <= 26;\\n    let go = i => {\\n        if (m.has(i))\\n            return m.get(i);\\n        if (i == N)\\n            return 1;\\n        let cnt = 0,\\n            one = Number(s[i]),\\n            two = one && i + 1 < N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) cnt += go(i + 1);\\n        if (ok(two)) cnt += go(i + 2);\\n        return m.set(i, cnt).get(i);\\n    };\\n    return go(0);\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet numDecodings = s => {\\n    let N = s.length;\\n    let dp = Array(N + 2).fill(0);\\n    dp[N] = 1;\\n    let ok = x => 1 <= x && x <= 26;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let one = Number(s[i]),\\n            two = one && i + 1 <= N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) dp[i] += dp[i + 1];\\n        if (ok(two)) dp[i] += dp[i + 2];\\n    }\\n    return dp[0];\\n};\\n```\\n\\n4. Memory Optimization, ie. O(1) instead of O(N) via sliding window `a = dp[i]`, `b = dp[i + 1]`, `c = dp[i + 2]`\\n```\\nlet numDecodings = s => {\\n    let N = s.length,\\n        a = 0,\\n        b = 1,\\n        c = 0;\\n    let ok = x => 1 <= x && x <= 26;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let one = Number(s[i]),\\n            two = one && i + 1 <= N ? Number(s[i] + s[i + 1]) : 0;\\n        a = 0;\\n        if (ok(one)) a += b;\\n        if (ok(two)) a += c;\\n        c = b, b = a;\\n    }\\n    return a;\\n};\\n```\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Python3:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        def go(i = 0):\\n            if i == N:\\n                return 1\\n            cnt = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): cnt += go(i + 1)\\n            if ok(two): cnt += go(i + 2)\\n            return cnt\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        m = {}\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        def go(i = 0):\\n            if i in m:\\n                return m[i]\\n            if i == N:\\n                return 1\\n            m[i] = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): m[i] += go(i + 1)\\n            if ok(two): m[i] += go(i + 2)\\n            return m[i]\\n        return go()\\n```\\n\\n* Note: we can also simply use `@cache` to more concisely perform memo-ization in Python3:\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        m = {}\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return 1\\n            cnt = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): cnt += go(i + 1)\\n            if ok(two): cnt += go(i + 2)\\n            return cnt\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        dp = [0] * (N + 2)\\n        dp[N] = 1\\n        ok = lambda x: 1 <= x <= 26\\n        for i in range(N - 1, -1, -1):\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): dp[i] += dp[i + 1]\\n            if ok(two): dp[i] += dp[i + 2]\\n        return dp[0]\\n```\\n\\n4. Memory Optimization, ie. O(1) instead of O(N) via sliding window `a = dp[i]`, `b = dp[i + 1]`, `c = dp[i + 2]`\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        a = 0\\n        b = 1\\n        c = 0\\n        ok = lambda x: 1 <= x <= 26\\n        for i in range(N - 1, -1, -1):\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            a = 0\\n            if ok(one): a += b\\n            if ok(two): a += c\\n            c = b; b = a\\n        return a\\n```\\n\\n---\\n\\n**`\\u2B50\\uFE0F` C++:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        auto N = s.size();\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0,\\n                 one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) cnt += go(i + 1);\\n            if (ok(two)) cnt += go(i + 2);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s, Map m = {}) {\\n        auto N = s.size();\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        fun go = [&](auto i) {\\n            if (m.find(i) != m.end())\\n                return m[i];\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0,\\n                 one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) cnt += go(i + 1);\\n            if (ok(two)) cnt += go(i + 2);\\n            return m[i] = cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        int N = s.size();\\n        VI dp(N + 2);\\n        dp[N] = 1;\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) dp[i] += dp[i + 1];\\n            if (ok(two)) dp[i] += dp[i + 2];\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n4. Memory Optimization, ie. O(1) instead of O(N) via sliding window `a = dp[i]`, `b = dp[i + 1]`, `c = dp[i + 2]`\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        int N = s.size(),\\n            a = 0,\\n            b = 1,\\n            c = 0;\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            a = 0;\\n            if (ok(one)) a += b;\\n            if (ok(two)) a += c;\\n            c = b, b = a;\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\n---",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var ok = { x: Int -> x in 1..26 }\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) (\"${s[i]}${s[i + 1]}\").toInt() else 0\\n            if (ok(one)) cnt += go(i + 1)\\n            if (ok(two)) cnt += go(i + 2)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        var N = s.length\\n        var ok = { x: Int -> x in 1..26 }\\n        fun go(i: Int = 0): Int {\\n            if (m.contains(i))\\n                return m[i]!!\\n            if (i == N)\\n                return 1\\n            m[i] = 0\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) (\"${s[i]}${s[i + 1]}\").toInt() else 0\\n            if (ok(one)) m[i] = m[i]!! + go(i + 1)\\n            if (ok(two)) m[i] = m[i]!! + go(i + 2)\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var dp = IntArray(N + 2)\\n        dp[N] = 1\\n        var ok = { x: Int -> x in 1..26 }\\n        for (i in N - 1 downTo 0) {\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) \"${s[i]}${s[i + 1]}\".toInt() else 0\\n            if (ok(one)) dp[i] += dp[i + 1]\\n            if (ok(two)) dp[i] += dp[i + 2]\\n        }\\n        return dp[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun numDecodings(s: String): Int {\\n        var N = s.length\\n        var a = 0\\n        var b = 1\\n        var c = 0\\n        var ok = { x: Int -> x in 1..26 }\\n        for (i in N - 1 downTo 0) {\\n            var one = \"${s[i]}\".toInt()\\n            var two = if (one != 0 && i + 1 < N) \"${s[i]}${s[i + 1]}\".toInt() else 0\\n            a = 0\\n            if (ok(one)) a += b\\n            if (ok(two)) a += c\\n            c = b; b = a\\n        }\\n        return a\\n    }\\n}\\n```\n```\\nlet numDecodings = s => {\\n    let N = s.length;\\n    let ok = x => 1 <= x && x <= 26;\\n    let go = i => {\\n        if (i == N)\\n            return 1;\\n        let cnt = 0,\\n            one = Number(s[i]),\\n            two = one && i + 1 < N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) cnt += go(i + 1);\\n        if (ok(two)) cnt += go(i + 2);\\n        return cnt;\\n    };\\n    return go(0);\\n};\\n```\n```\\nlet numDecodings = (s, m = new Map()) => {\\n    let N = s.length;\\n    let ok = x => 1 <= x && x <= 26;\\n    let go = i => {\\n        if (m.has(i))\\n            return m.get(i);\\n        if (i == N)\\n            return 1;\\n        let cnt = 0,\\n            one = Number(s[i]),\\n            two = one && i + 1 < N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) cnt += go(i + 1);\\n        if (ok(two)) cnt += go(i + 2);\\n        return m.set(i, cnt).get(i);\\n    };\\n    return go(0);\\n};\\n```\n```\\nlet numDecodings = s => {\\n    let N = s.length;\\n    let dp = Array(N + 2).fill(0);\\n    dp[N] = 1;\\n    let ok = x => 1 <= x && x <= 26;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let one = Number(s[i]),\\n            two = one && i + 1 <= N ? Number(s[i] + s[i + 1]) : 0;\\n        if (ok(one)) dp[i] += dp[i + 1];\\n        if (ok(two)) dp[i] += dp[i + 2];\\n    }\\n    return dp[0];\\n};\\n```\n```\\nlet numDecodings = s => {\\n    let N = s.length,\\n        a = 0,\\n        b = 1,\\n        c = 0;\\n    let ok = x => 1 <= x && x <= 26;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let one = Number(s[i]),\\n            two = one && i + 1 <= N ? Number(s[i] + s[i + 1]) : 0;\\n        a = 0;\\n        if (ok(one)) a += b;\\n        if (ok(two)) a += c;\\n        c = b, b = a;\\n    }\\n    return a;\\n};\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        def go(i = 0):\\n            if i == N:\\n                return 1\\n            cnt = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): cnt += go(i + 1)\\n            if ok(two): cnt += go(i + 2)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        m = {}\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        def go(i = 0):\\n            if i in m:\\n                return m[i]\\n            if i == N:\\n                return 1\\n            m[i] = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): m[i] += go(i + 1)\\n            if ok(two): m[i] += go(i + 2)\\n            return m[i]\\n        return go()\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        m = {}\\n        N = len(s)\\n        ok = lambda x: 1 <= x <= 26\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return 1\\n            cnt = 0\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): cnt += go(i + 1)\\n            if ok(two): cnt += go(i + 2)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        dp = [0] * (N + 2)\\n        dp[N] = 1\\n        ok = lambda x: 1 <= x <= 26\\n        for i in range(N - 1, -1, -1):\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            if ok(one): dp[i] += dp[i + 1]\\n            if ok(two): dp[i] += dp[i + 2]\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        N = len(s)\\n        a = 0\\n        b = 1\\n        c = 0\\n        ok = lambda x: 1 <= x <= 26\\n        for i in range(N - 1, -1, -1):\\n            one = int(s[i])\\n            two = int(s[i:i + 2]) if one and i + 2 <= N else 0\\n            a = 0\\n            if ok(one): a += b\\n            if ok(two): a += c\\n            c = b; b = a\\n        return a\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        auto N = s.size();\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0,\\n                 one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) cnt += go(i + 1);\\n            if (ok(two)) cnt += go(i + 2);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s, Map m = {}) {\\n        auto N = s.size();\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        fun go = [&](auto i) {\\n            if (m.find(i) != m.end())\\n                return m[i];\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0,\\n                 one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) cnt += go(i + 1);\\n            if (ok(two)) cnt += go(i + 2);\\n            return m[i] = cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        int N = s.size();\\n        VI dp(N + 2);\\n        dp[N] = 1;\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            if (ok(one)) dp[i] += dp[i + 1];\\n            if (ok(two)) dp[i] += dp[i + 2];\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int numDecodings(string s) {\\n        int N = s.size(),\\n            a = 0,\\n            b = 1,\\n            c = 0;\\n        auto ok = [](auto x) { return 1 <= x && x <= 26; };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto one = stoi(s.substr(i, 1)),\\n                 two = one && i + 1 < N ? stoi(s.substr(i, 2)) : 0;\\n            a = 0;\\n            if (ok(one)) a += b;\\n            if (ok(two)) a += c;\\n            c = b, b = a;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30625,
                "title": "sharing-my-java-memoized-solution",
                "content": "    public class Solution {\\n        public int numDecodings(String s) {\\n            \\n            if (s == null || s.length() == 0)\\n                return 0;\\n                \\n            Set<String> symbols = new HashSet<String>();\\n            for (int i=1; i<=26; i++){\\n            \\tsymbols.add(String.valueOf(i));\\n            }\\n          \\n            Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            return numDec(s, 0,  map, symbols);\\n        }\\n        \\n        private int numDec(String str, int start,  Map<Integer, Integer> map, Set<String> symbols) {\\n            Integer count = map.get(start);\\n            if (count != null){\\n                return count;\\n            }\\n    \\n            if (start == str.length()){\\n                return 1;\\n            }\\n            \\n            int numWays = 0;\\n            if ((start + 1 <= str. length()) &&\\n                symbols.contains(str.substring(start, start + 1)) && symbols.contains(str.substring(start, start + 1)))   \\n                numWays += numDec(str, start + 1, map, symbols);\\n    \\n            if ((start + 2 <= str. length()) &&\\n                    symbols.contains(str.substring(start, start + 2)) && symbols.contains(str.substring(start, start + 2)))   \\n                numWays += numDec(str, start + 2, map, symbols);\\n                \\n            map.put(start, numWays);\\n            \\n            return numWays;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numDecodings(String s) {\\n            \\n            if (s == null || s.length() == 0)\\n                return 0;\\n                \\n            Set<String> symbols = new HashSet<String>();\\n            for (int i=1; i<=26; i++){\\n            \\tsymbols.add(String.valueOf(i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1496546,
                "title": "java-tc-o-n-sc-o-1-constant-space-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Dynamic Programming\\n *\\n * DP[i] = Number of ways to decode the string from 0 to i.\\n *\\n * DP[i] = DP[i-1] (when i is from 1 to 9) + DP[i-2] (when (i-1,i) is from 10 to\\n * 26)\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string.\\n */\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n        if (s.length() == 0 || s.charAt(0) == \\'0\\') {\\n            return 0;\\n        }\\n\\n        int pre = 1; // dp[i-2]\\n        int cur = 1; // dp[i-1]\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            int sum = 0; // dp[i]\\n            if (s.charAt(i) != \\'0\\') {\\n                sum = cur;\\n            }\\n            int num = Integer.parseInt(s.substring(i - 1, i + 1));\\n            if (num >= 10 && num <= 26) {\\n                sum += pre;\\n            }\\n\\n            pre = cur;\\n            cur = sum;\\n        }\\n\\n        return cur;\\n    }\\n}\\n```\\n\\nSolution for Part II: [639. Decode Ways II](https://leetcode.com/problems/decode-ways-ii/discuss/1496550/Java-or-TC:-O(N)-or-SC:-O(1)-or-Constant-Space-Dynamic-Programming-solution)",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Dynamic Programming\\n *\\n * DP[i] = Number of ways to decode the string from 0 to i.\\n *\\n * DP[i] = DP[i-1] (when i is from 1 to 9) + DP[i-2] (when (i-1,i) is from 10 to\\n * 26)\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string.\\n */\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n        if (s.length() == 0 || s.charAt(0) == \\'0\\') {\\n            return 0;\\n        }\\n\\n        int pre = 1; // dp[i-2]\\n        int cur = 1; // dp[i-1]\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            int sum = 0; // dp[i]\\n            if (s.charAt(i) != \\'0\\') {\\n                sum = cur;\\n            }\\n            int num = Integer.parseInt(s.substring(i - 1, i + 1));\\n            if (num >= 10 && num <= 26) {\\n                sum += pre;\\n            }\\n\\n            pre = cur;\\n            cur = sum;\\n        }\\n\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410825,
                "title": "decode-ways-3-approach-w-explanation-dp-iterative-c-python-java",
                "content": "**Top Down DP**\\n* For a character s[i], we have 2 ways to form:\\n\\t* Single digit: Require `s[i] != \\'0\\'` (forms 1..9)\\n\\t* Two digits: Require `i + 1 < len(s)` and `s[i] == 1 (forms 10..19) or s[i] == 2 and s[i+1] <= \\'6\\' (forms 20..26)`.\\n\\n*Time Complexity -* `O(N)`\\n*Space Complexity -* `O(N)`\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        vector<int> dp(n+1) ;\\n        dp[n] = 1 ;\\n        for(int i =n-1; i >= 0 ; i--) \\n        {\\n            if(s[i]==\\'0\\') \\n                dp[i]=0;\\n            else \\n            {\\n                dp[i] = dp[i+1];\\n                if(i < n-1 && (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1]<\\'7\\')) \\n                    dp[i]+=dp[i+2];\\n            }\\n        }\\n        return s.empty()? 0 : dp[0];   \\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int n=s.length() ;\\n        int[] dp=new int[n+1] ;\\n        dp[n]=1 ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n            if(s.charAt(i)!=\\'0\\') \\n            {\\n                dp[i] = dp[i+1] ;\\n                if(i < n-1 && (s.charAt(i)==\\'1\\' || s.charAt(i)==\\'2\\' && s.charAt(i+1)<\\'7\\')) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i+2];\\n            }\\n        return dp[0];   \\n    }\\n}\\n```\\n`In Python3` \\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == len(s): \\n                return 1\\n            ans = 0\\n            if s[i] != \\'0\\':  # Single digit\\n                ans += dp(i + 1)\\n            if i + 1 < len(s) and (s[i] == \\'1\\' or s[i] == \\'2\\' and ord(s[i + 1]) <= ord(\\'6\\')):  # Two digits\\n                ans += dp(i + 2)\\n            return ans\\n\\n        return dp(0) \\n```\\n\\n**Bottom Up DP**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int len = s.length() ; \\n        int dp[len+1] ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2; i < len; i++) \\n        {\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) \\n                return 0;\\n            dp[i] = s[i] != \\'0\\' ? dp[i - 1] : 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') \\n                dp[i] += dp[i - 2];\\n        }\\n        return s.empty() || s.front() == \\'0\\'? 0 : dp[len - 1];   \\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)]\\n        dp[0] = 1\\n        if 0 < int(s[0]) <= 9:\\n            dp[1] = 1\\n        else:\\n            dp[1] = 0 \\n\\n        for i in range(2, len(s) + 1):\\n            if 0 < int(s[i-1:i]) <= 9:\\n                dp[i] += dp[i - 1]\\n            if s[i-2:i][0] != \\'0\\' and int(s[i-2:i]) <= 26:\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]\\n```\\n\\n**Iterative Solution**\\nIn each iteration:\\n* If the current digit is `0`\\n\\t* the `r1` is 0 because we can\\'t add any new decode way.\\n* Else if the current digit is part of a 2 digit number\\n\\t* \\twe add the `r2` to `r1`, because we have `r2` ways to decode.\\n* Else `r2` is equal to `r1` since there are no other ways to decode it.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] \\n        int r1 = 1, r2 = 1;\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\'0\\') \\n                r1 = 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] <= \\'6\\') \\n            {\\n                r1 += r2 ;\\n                r2 = r1 - r2;\\n            }\\n            else \\n            {\\n                r2 = r1;\\n            }\\n        }\\n        return s.empty() || s.front() == \\'0\\'? 0 : r1;   \\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        r1 = 1 \\n        r2 = 1 \\n        for i in range(1 , len(s)):\\n            if s[i] == \\'0\\':\\n                r1 = 0 \\n            if s[i - 1] == \\'1\\' or s[i - 1] == \\'2\\' and s[i] <= \\'6\\':\\n                r1 = r1 + r2 \\n                r2 = r1 - r2 \\n            else:\\n                r2 = r1 \\n        if  not len(s) or s[0] == \\'0\\':\\n            return 0 \\n        else:\\n            return r1\\n```\\n\\n\\n**Similar questions for practice:**\\n[62. Unique Paths](https://leetcode.com/problems/unique-paths)\\n[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        vector<int> dp(n+1) ;\\n        dp[n] = 1 ;\\n        for(int i =n-1; i >= 0 ; i--) \\n        {\\n            if(s[i]==\\'0\\') \\n                dp[i]=0;\\n            else \\n            {\\n                dp[i] = dp[i+1];\\n                if(i < n-1 && (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1]<\\'7\\')) \\n                    dp[i]+=dp[i+2];\\n            }\\n        }\\n        return s.empty()? 0 : dp[0];   \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int n=s.length() ;\\n        int[] dp=new int[n+1] ;\\n        dp[n]=1 ;\\n        for(int i = n-1 ; i >= 0 ; i--)\\n            if(s.charAt(i)!=\\'0\\') \\n            {\\n                dp[i] = dp[i+1] ;\\n                if(i < n-1 && (s.charAt(i)==\\'1\\' || s.charAt(i)==\\'2\\' && s.charAt(i+1)<\\'7\\')) \\n\\t\\t\\t\\t\\tdp[i]+=dp[i+2];\\n            }\\n        return dp[0];   \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == len(s): \\n                return 1\\n            ans = 0\\n            if s[i] != \\'0\\':  # Single digit\\n                ans += dp(i + 1)\\n            if i + 1 < len(s) and (s[i] == \\'1\\' or s[i] == \\'2\\' and ord(s[i + 1]) <= ord(\\'6\\')):  # Two digits\\n                ans += dp(i + 2)\\n            return ans\\n\\n        return dp(0) \\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int len = s.length() ; \\n        int dp[len+1] ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'1\\' || s[0] == \\'2\\' && s[1] < \\'7\\' ? 1 : 0) + (s[1] != \\'0\\');\\n        for (int i = 2; i < len; i++) \\n        {\\n            if (s[i] == \\'0\\' && (s[i - 1] > \\'2\\' || s[i - 1] == \\'0\\')) \\n                return 0;\\n            dp[i] = s[i] != \\'0\\' ? dp[i - 1] : 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] < \\'7\\') \\n                dp[i] += dp[i - 2];\\n        }\\n        return s.empty() || s.front() == \\'0\\'? 0 : dp[len - 1];   \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)]\\n        dp[0] = 1\\n        if 0 < int(s[0]) <= 9:\\n            dp[1] = 1\\n        else:\\n            dp[1] = 0 \\n\\n        for i in range(2, len(s) + 1):\\n            if 0 < int(s[i-1:i]) <= 9:\\n                dp[i] += dp[i - 1]\\n            if s[i-2:i][0] != \\'0\\' and int(s[i-2:i]) <= 26:\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]\\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] \\n        int r1 = 1, r2 = 1;\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\'0\\') \\n                r1 = 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] <= \\'6\\') \\n            {\\n                r1 += r2 ;\\n                r2 = r1 - r2;\\n            }\\n            else \\n            {\\n                r2 = r1;\\n            }\\n        }\\n        return s.empty() || s.front() == \\'0\\'? 0 : r1;   \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        r1 = 1 \\n        r2 = 1 \\n        for i in range(1 , len(s)):\\n            if s[i] == \\'0\\':\\n                r1 = 0 \\n            if s[i - 1] == \\'1\\' or s[i - 1] == \\'2\\' and s[i] <= \\'6\\':\\n                r1 = r1 + r2 \\n                r2 = r1 - r2 \\n            else:\\n                r2 = r1 \\n        if  not len(s) or s[0] == \\'0\\':\\n            return 0 \\n        else:\\n            return r1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151379,
                "title": "javascript-dp-solution",
                "content": "```js\\nfunction numDecodings(s) {\\n  if (s.length === 0) return 0;\\n\\n  const N = s.length;\\n  const dp = Array(N+1).fill(0);\\n\\n  dp[0] = 1;\\n  dp[1] = s[0] === \\'0\\' ? 0 : 1;\\n\\n  for (let i = 2; i <= N; i++) {\\n    if (s[i-1] !== \\'0\\') {\\n      dp[i] += dp[i-1];\\n    }\\n    if (s[i-2] === \\'1\\' || s[i-2] === \\'2\\' && s[i-1] <= \\'6\\') {\\n      dp[i] += dp[i-2];\\n    }\\n  }\\n\\n  return dp[N];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction numDecodings(s) {\\n  if (s.length === 0) return 0;\\n\\n  const N = s.length;\\n  const dp = Array(N+1).fill(0);\\n\\n  dp[0] = 1;\\n  dp[1] = s[0] === \\'0\\' ? 0 : 1;\\n\\n  for (let i = 2; i <= N; i++) {\\n    if (s[i-1] !== \\'0\\') {\\n      dp[i] += dp[i-1];\\n    }\\n    if (s[i-2] === \\'1\\' || s[i-2] === \\'2\\' && s[i-1] <= \\'6\\') {\\n      dp[i] += dp[i-2];\\n    }\\n  }\\n\\n  return dp[N];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30382,
                "title": "python-recursive-and-dp-solution",
                "content": "recursive - LTE even with cache - no go\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        # 8:19\\n        def numDecodings(self, s):\\n            if s == '':\\n                return 1\\n    \\n            if s[0] == '0':\\n                return 0\\n    \\n            possibleDouble = True if self.isPossibleDouble(s[:2]) else False\\n    \\n            if possibleDouble:\\n                return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n            else:\\n                return self.numDecodings(s[1:])\\n    \\n        def isPossibleDouble(self, num):\\n            return len(num) == 2 and (num[0] == '1' or (num[0] == '2' and num[1] <= '6'))\\n\\nDP\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        def numDecodings(self, s):\\n            if not s:\\n                return 0\\n    \\n            n = len(s)\\n            dp = [0] * (n + 1)\\n            dp[0] = 1\\n            \\n            for i in range(1, n + 1):\\n                if s[i-1] != '0':\\n                    dp[i] += dp[i-1]\\n                if len(s[i-2:i]) == 2 and '10' <= s[i-2:i] <= '26':\\n                    dp[i] += dp[i-2]\\n    \\n            return dp[n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "recursive - LTE even with cache - no go\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        # 8:19\\n        def numDecodings(self, s):\\n            if s == '':\\n                return 1\\n    \\n            if s[0] == '0':\\n                return 0\\n    \\n            possibleDouble = True if self.isPossibleDouble(s[:2]) else False\\n    \\n            if possibleDouble:\\n                return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n            else:\\n                return self.numDecodings(s[1:])\\n    \\n        def isPossibleDouble(self, num):\\n            return len(num) == 2 and (num[0] == '1' or (num[0] == '2' and num[1] <= '6'))\\n\\nDP\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return an integer\\n        def numDecodings(self, s):\\n            if not s:\\n                return 0\\n    \\n            n = len(s)\\n            dp = [0] * (n + 1)\\n            dp[0] = 1\\n            \\n            for i in range(1, n + 1):\\n                if s[i-1] != '0':\\n                    dp[i] += dp[i-1]\\n                if len(s[i-2:i]) == 2 and '10' <= s[i-2:i] <= '26':\\n                    dp[i] += dp[i-2]\\n    \\n            return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 987114,
                "title": "c-easy-dp-solution-0ms-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0] == \\'0\\') return 0;\\n        if(n==1) return 1;\\n        vector<int> dp(n+1,0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=n;i++) {\\n            int onedigit = s[i-1] -\\'0\\';\\n            int twodigit = (s[i-2]-\\'0\\')*10 + (s[i-1]-\\'0\\');\\n            if(onedigit>=1) \\n                dp[i] += dp[i-1];\\n            if(twodigit>=10 && twodigit <=26)\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0] == \\'0\\') return 0;\\n        if(n==1) return 1;\\n        vector<int> dp(n+1,0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=n;i++) {\\n            int onedigit = s[i-1] -\\'0\\';\\n            int twodigit = (s[i-2]-\\'0\\')*10 + (s[i-1]-\\'0\\');\\n            if(onedigit>=1) \\n                dp[i] += dp[i-1];\\n            if(twodigit>=10 && twodigit <=26)\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408212,
                "title": "javascript-recursive-dp-solution-w-comments",
                "content": "``` javascript\\nvar numDecodings = function(s) {\\n    if (s.length < 1) return 0;\\n    let memo = [];\\n    var recur = function (index) {\\n        let result = 0\\n        if (index == s.length) return 1; // base case 1: reach the end = correct path\\n        if (memo[index]!=null) return memo[index]; // base case 2: if we already have the information on this index, return it\\n        if (s[index] > 0) { // as long as its bigger than 0, we can at least  use it as a single digit\\n            result += recur(index+1); // move forward by 1\\n        }\\n\\t\\t\\n\\t\\t// as long as 1. we are not starting with 0 etc. `04`\\n\\t\\t//            2. our next digit isn\\'t null\\n\\t\\t//            3. we can form a two digit number thats smaller than 27\\n        if (s[index] != 0 && s[index+1] != null && s[index]+s[index+1] < 27) {\\n\\t\\t\\t// lets make this two digit together and move forward by 2\\n            result += recur(index+2);\\n        }\\n        memo[index] = result; // given the current index, store how many different ways we can decode\\n        return result;\\n    }\\n    return recur(0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "``` javascript\\nvar numDecodings = function(s) {\\n    if (s.length < 1) return 0;\\n    let memo = [];\\n    var recur = function (index) {\\n        let result = 0\\n        if (index == s.length) return 1; // base case 1: reach the end = correct path\\n        if (memo[index]!=null) return memo[index]; // base case 2: if we already have the information on this index, return it\\n        if (s[index] > 0) { // as long as its bigger than 0, we can at least  use it as a single digit\\n            result += recur(index+1); // move forward by 1\\n        }\\n\\t\\t\\n\\t\\t// as long as 1. we are not starting with 0 etc. `04`\\n\\t\\t//            2. our next digit isn\\'t null\\n\\t\\t//            3. we can form a two digit number thats smaller than 27\\n        if (s[index] != 0 && s[index+1] != null && s[index]+s[index+1] < 27) {\\n\\t\\t\\t// lets make this two digit together and move forward by 2\\n            result += recur(index+2);\\n        }\\n        memo[index] = result; // given the current index, store how many different ways we can decode\\n        return result;\\n    }\\n    return recur(0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30592,
                "title": "dp-solution-with-detailed-explanation-python-sample-code",
                "content": "The problem is totally the same concept with [Paint Fence][1], except for some interesting condition to check.\\n\\nThe thoughts are simple, every time you encounter a new char `c`, you only need to think: \\n\\n - If I `(can)` decode it with the previous char `p`, what will it affect the resulting answer?\\n - If I `don't` decode it with the previous char `p`, what will it affect the resulting answer?\\n\\nSo, the DP is simple, I keep track of two variables: \\n\\n - Variable `care` means the combinations that I decode `c with p` for the substring toward `c`.\\n - Variable `dont` means the combinations that I decode `c without p` for the substring toward `c`.\\n\\nHere comes the interesting part, what circumstances we `\"can\"` decode `p` with `c`? And the other way around? What if we encounter `\"0\"`?\\n\\n - Since A-Z is **two** digits number, if we want to consider string `\"pc\"`, then `p` must not decode with p's previous number, so the combination of **current** `care` is from the **previous** `dont`\\n - If  we simply decode `c` alone, the combination would come from both of previous `care` and `dont`, since we don't care about either `p` is decoded with its previous char.\\n - If we simply `can't` consider `c` with `p`, then current `care` would become `0` as it should be. For example: `p` is \"0\", or `\"pc\"` > \"26\"\\n - If we `most` consider `c` with `p`,  then current `dont`would become `0`. For example: `c` is `\"0\"`, then `p` must be either 1 or 2 to form the legal `10`or `20`\\n\\nThese analysis pretty much cover all the cases to consider, following is the sample code:\\n\\n        \\n    def numDecodings(self, s):\\n        if not s or s == \"0\":\\n            return 0\\n        care, dont = 0, 1\\n        for i in range(1, len(s)):\\n            p, c = s[i-1], s[i] # p for previous, c for current\\n            if c == \"0\": # \"must\" consider \"pc\" together\\n                if not (p == \"1\" or p == \"2\"):\\n                    return 0\\n                else:\\n                    care, dont = dont, 0\\n            elif p == \"0\": # \"must\" consider \"c\" alone\\n                care, dont = 0, care\\n            else:\\n                if 11 <= int(p+c) <= 26: # we \"can\" consider \"pc\" together \\n                    care, dont = dont, dont + care\\n                else: # we \"cant\" consider \"pc\" together\\n                    care, dont = 0, dont + care\\n        return dont + care\\n\\n \\n\\n  [1]: https://leetcode.com/problems/paint-fence/",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The problem is totally the same concept with [Paint Fence][1], except for some interesting condition to check.\\n\\nThe thoughts are simple, every time you encounter a new char `c`, you only need to think: \\n\\n - If I `(can)` decode it with the previous char `p`, what will it affect the resulting answer?\\n - If I `don't` decode it with the previous char `p`, what will it affect the resulting answer?\\n\\nSo, the DP is simple, I keep track of two variables: \\n\\n - Variable `care` means the combinations that I decode `c with p` for the substring toward `c`.\\n - Variable `dont` means the combinations that I decode `c without p` for the substring toward `c`.\\n\\nHere comes the interesting part, what circumstances we `\"can\"` decode `p` with `c`? And the other way around? What if we encounter `\"0\"`?\\n\\n - Since A-Z is **two** digits number, if we want to consider string `\"pc\"`, then `p` must not decode with p's previous number, so the combination of **current** `care` is from the **previous** `dont`\\n - If  we simply decode `c` alone, the combination would come from both of previous `care` and `dont`, since we don't care about either `p` is decoded with its previous char.\\n - If we simply `can't` consider `c` with `p`, then current `care` would become `0` as it should be. For example: `p` is \"0\", or `\"pc\"` > \"26\"\\n - If we `most` consider `c` with `p`,  then current `dont`would become `0`. For example: `c` is `\"0\"`, then `p` must be either 1 or 2 to form the legal `10`or `20`\\n\\nThese analysis pretty much cover all the cases to consider, following is the sample code:\\n\\n        \\n    def numDecodings(self, s):\\n        if not s or s == \"0\":\\n            return 0\\n        care, dont = 0, 1\\n        for i in range(1, len(s)):\\n            p, c = s[i-1], s[i] # p for previous, c for current\\n            if c == \"0\": # \"must\" consider \"pc\" together\\n                if not (p == \"1\" or p == \"2\"):\\n                    return 0\\n                else:\\n                    care, dont = dont, 0\\n            elif p == \"0\": # \"must\" consider \"c\" alone\\n                care, dont = 0, care\\n            else:\\n                if 11 <= int(p+c) <= 26: # we \"can\" consider \"pc\" together \\n                    care, dont = dont, dont + care\\n                else: # we \"cant\" consider \"pc\" together\\n                    care, dont = 0, dont + care\\n        return dont + care\\n\\n \\n\\n  [1]: https://leetcode.com/problems/paint-fence/",
                "codeTag": "Python3"
            },
            {
                "id": 1410879,
                "title": "python-dp-using-lru-cache-explained",
                "content": "In this problem we can see some repeating subproblems, so we can apply dynamic programming.\\n\\nLet `dp(i)` is number of ways to decode string `s[:i]`. Then we can have the following cases:\\n\\n1. `if i == -1`, we return `1`, because there is unique way to decode empty string.\\n2. If last digit is not equal to `0`, we need to add `dp(i-1)` to our answer.\\n3. If last two digits form number from `10` to `26`, we can use last `2` symbols for decoding, so we add `dp(i-2)` to our answer.\\n\\n#### Complexity\\nTime complexity is `O(n)`, we have `n` states and at most `2` transactions from one to another. Space complexity is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def numDecodings(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1: return 1\\n            ans = 0\\n            if s[i] > \"0\": ans += dp(i-1)\\n            if i >= 1 and \"10\" <= s[i-1:i+1] <= \"26\":\\n                ans += dp(i-2)\\n            return ans\\n        \\n        return dp(len(s) - 1)\\n```\\n\\n#### Remark\\nSee my post for problem **639. Decode Ways II**: https://leetcode.com/problems/decode-ways-ii/discuss/1328138/Python-dp-solution-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numDecodings(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1: return 1\\n            ans = 0\\n            if s[i] > \"0\": ans += dp(i-1)\\n            if i >= 1 and \"10\" <= s[i-1:i+1] <= \"26\":\\n                ans += dp(i-2)\\n            return ans\\n        \\n        return dp(len(s) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621312,
                "title": "python-dp-recursion-w-explanation",
                "content": "To generate the DP siolution, I find it best to generate the recursive solution first and then optimize it.\\n\\nHere, idea is to take either only the first or first two digits of the given number and recurse through the rest in a similar manner. \\n\\nFirst two digits can be decoded if they are greater than 10 and less than 26 as everything below 10 is about considering the first digit only and everything above 26 can\\'t be decoded. \\nThe first digit can be decoded if its between 1 and 9, inclusive. \\n\\nThe base case is when the user inputs an empty string, there will be exactly one way to decode it. \\n\\nThus, the recursive solution is as under: \\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        return self._rec_helper(s)\\n\\n    def _rec_helper(self, data):\\n        # Base Case 1: Empty string\\n        if not data:\\n            return 1\\n\\n        first_call, second_call = 0, 0\\n\\n        if 1 <= int(data[:1]) <= 9:\\n            first_call = self._rec_helper(data[1:])\\n\\n        if 10 <= int(data[:2]) <= 26:\\n            second_call = self._rec_helper(data[2:])\\n\\n        return first_call + second_call\\n\\n```\\n\\nNow, we can see that in the recursive solution, the \\'\\\\_rec\\\\_helper\\' function is called repeteadly to compute the same values. Thus, we can create a dictionary beforehand to store the new values computed and use it whenever needed. \\nThus, we intruduce a dictionary \\'dp\\'. \\n\\nThe Dynamic Programming Implementation is as under:\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = {}\\n        return self._dp_helper(s, dp)\\n\\n    def _dp_helper(self, data, dp):\\n        # Base Case 1: Empty string\\n        if not data:\\n            return 1\\n\\n        first_call, second_call = 0, 0\\n\\n        if data in dp:\\n            return dp[data]\\n\\n        if 1 <= int(data[:1]) <= 9:\\n            first_call = self._dp_helper(data[1:], dp)\\n\\n        if 10 <= int(data[:2]) <= 26:\\n            second_call = self._dp_helper(data[2:], dp)\\n\\n        dp[data] = first_call + second_call\\n\\n        return dp[data]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        return self._rec_helper(s)\\n\\n    def _rec_helper(self, data):\\n        # Base Case 1: Empty string\\n        if not data:\\n            return 1\\n\\n        first_call, second_call = 0, 0\\n\\n        if 1 <= int(data[:1]) <= 9:\\n            first_call = self._rec_helper(data[1:])\\n\\n        if 10 <= int(data[:2]) <= 26:\\n            second_call = self._rec_helper(data[2:])\\n\\n        return first_call + second_call\\n\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = {}\\n        return self._dp_helper(s, dp)\\n\\n    def _dp_helper(self, data, dp):\\n        # Base Case 1: Empty string\\n        if not data:\\n            return 1\\n\\n        first_call, second_call = 0, 0\\n\\n        if data in dp:\\n            return dp[data]\\n\\n        if 1 <= int(data[:1]) <= 9:\\n            first_call = self._dp_helper(data[1:], dp)\\n\\n        if 10 <= int(data[:2]) <= 26:\\n            second_call = self._dp_helper(data[2:], dp)\\n\\n        dp[data] = first_call + second_call\\n\\n        return dp[data]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162837,
                "title": "java-3-solutions-with-clear-explanation-brute-force-dp",
                "content": "# Intuition\\nUnique Paths is a classic Dynamic Programming problem where you need to find the number of ways to decode a given string of digits. The digits in the string represent a sequence of alphabet letters, and each digit map to a unique letter in the alphabet.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are a couple of approaches to solve this problem:\\n1.\\tBrute force: generate all possible decoded string and count the number of valid ones. This solution is not efficient because it to consider two options at each digit: either decode it as a single digit or as two digits. This leads to an exponential running time.\\n\\n2.\\tDynamic Programming: Use an array to store the number of ways to decode substrings of the input string and use this data to compute the number of ways to decode the entire string.\\n\\n# Code\\n#### \\u274C **1) Brute force solution (Recursive) [TLE] \\u274C**\\n\\n\\uD83D\\uDD25**Base case:** \\uD83D\\uDD25\\n1.\\tIf `index` is equal to the length of the string, then the function returns 1, meaning that a complete decoded message has been generated.\\n\\n2.\\tIf the character at position `index` in the strings is `0`, the function returns 0, meaning that combination is invalid because `0` can only be decoded as `10` or `20`.\\n\\n\\uD83D\\uDD25**Explain:** \\uD83D\\uDD25\\n\\nInside the function, the variable `count` is initialized to the result of calling DFS on `s` and `index+1`, representing the first decoded character at position `index`. \\n\\nAfter the execution, if `index` is less than `s.length() \\u2013 1` and the characters at position `index` and `index+1` in the string can form a valid two-digit code, then `count` is updated.\\n\\n****Explanation:*** Note that a digit cannot exceed 26, as it would exceed the limits of the alphabet. As a result, the first digit must be either 1 or 2, and the second digit must be less than 6.\\n\\nFinally, the function returns the value of `count`, representing the total number of decoded messages that can be generated.\\n\\n\\uD83D\\uDD25**Code:** \\uD83D\\uDD25\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        return DFS(s, 0);\\n    }\\n    public int DFS(String s, int index)\\n    {\\n        if(index == s.length()) return 1;\\n        if(s.charAt(index) == \\'0\\') return 0;\\n        int count = DFS(s, index + 1);\\n        if(index < s.length()-1 && (s.charAt(index) == \\'1\\' || s.charAt(index) == \\'2\\' && s.charAt(index + 1) < \\'7\\'))\\n        {\\n            count += DFS(s, index + 2);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\\n\\n- Time complexity: $$O(2^n)$$ where n is the length of the given string. At each position in the string, there are two options: decode one digit or decode two digits.\\n\\n- Space complexity: $$O(N)$$ where n is the length of the input string. This is because the maximum of function calls will be equal to the length of the input string. Each function call requires a constant amount of space on the call stack.\\n\\n\\n\\n#### **2) Dynamic programming solutions**\\n##### \\u2705 1. Recursive - Memoization - Top Down \\u2705\\n\\nThis solution is built on top of the previous solution. By using an array `dp` to store the results of previously computed subproblems, we can avoid redundant computations and improve the time complexity.\\n\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int [] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return DFS(s, 0,dp);\\n    }\\n    public int DFS(String s, int index, int [] dp)\\n    {\\n        if(index == s.length()) return 1;\\n        if(s.charAt(index) == \\'0\\') return 0;\\n        if(dp[index] != -1) return dp[index];\\n        int count = DFS(s, index + 1,dp);\\n        if(index < s.length()-1 && (s.charAt(index) == \\'1\\' || s.charAt(index) == \\'2\\' && s.charAt(index + 1) < \\'7\\'))\\n        {\\n            count += DFS(s, index + 2,dp);\\n        }\\n        dp[index] = count;\\n        return dp[index];\\n    }\\n    \\n}\\n```\\n\\n- Time complexity: $$O(N)$$ where n is the length of the given string `s`\\n\\n- Space complexity: $$O(N)$$, where n is the length of the given string `s`. This is because we use an array `dp` of size `s.length()+1` to store the result of previously computed subproblems.\\n\\n##### \\u2705 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\nThis approach uses bottom-up approach to store the previously computed result. Starting from the end of the string and works backwards to the beginning. \\n\\nThe value of `dp[len]` is initialized to `1`, which means there is only one way to decode an empty string. \\n\\nIf `k < len -1` and  `s.charAt(k) ==  1 || s.charAt(k) == 2 && s.charAt(k-2)` is less than 7, then it is possible to use `s.charAt(k)` and `s.charAt(k+1)` together as a two digit number in the decoding. \\n\\nFinally, return `dp[0]` which represents the number of ways to decode the entire string.\\n\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int len = s.length();\\n        int [] dp = new int[len + 1];\\n        dp[len] = 1;\\n        for(int k = len -1; k >= 0; k--)\\n        {\\n            if(s.charAt(k) == \\'0\\') \\n            {\\n                continue;\\n            }\\n            int res = dp[k + 1];\\n            if(k < len - 1 && (s.charAt(k) == \\'1\\' || s.charAt(k) == \\'2\\' && s.charAt(k+1) < \\'7\\')) \\n            {\\n                res += dp[k + 2];\\n            }\\n            dp[k] = res;\\n\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\\n\\n\\nSame as above, but starting from the beginning of the string\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int len = s.length();\\n        int [] dp = new int[len+1];\\n        dp[0] = 1;\\n        for(int k = 1; k <= len; k++)\\n        {\\n            if(s.charAt(k-1) == \\'0\\') \\n            {\\n                continue;\\n            }\\n\\n            int res = dp[k  - 1];\\n            if(k > 1 && (s.charAt(k-2) == \\'1\\' || s.charAt(k-2) == \\'2\\' && s.charAt(k-1) < \\'7\\')) \\n            {\\n                res += dp[k - 2];\\n            }\\n            dp[k] = res;\\n\\n        }\\n        return dp[len];\\n\\n    }\\n}\\n\\n```\\n\\n- Time complexity: $$O(n)$$, where n is the length of the input string. \\n\\n- Space complexity: $$O(n)$$, where n is the length of the input string. This is because we use an array `dp` of size `s.length()-1` to store result of the previously computed subproblems.\\n\\n\\n# Application\\n\\n###### The Decode Ways problem have several real-life applications, including the following: \\n\\n1. **Encoding and decoding messages:** messages are usually encoded into a specific format before being transmitted. This algorithm can help determine the number of ways to decode and encoded message.\\n\\n2. **Compression and decompression algorithms:** some data compression algorithms use encoding to reduce the size of the data being stored or transmitted. The decode ways problem can be used to determine the number of possible decompressed messages from an encoded data stream.\\n\\n3. **Error correction in digital storage:** in some digital storage systems, data is encoded to provide error correction in case some bits get corrupted. The decode ways problem can be used to determine the number of possible original messages that can be obtained from an encoded data stream that has been partially corrupted.\\n\\n4. **Cryptography**: the decode ways problem can be used to determine the number of possible decryptions of a coded message using different keys.\\n\\n5. **Natural Language Processing (NLP):** decode ambigious text messages, for example, in SMS or chat applications.\\n\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        return DFS(s, 0);\\n    }\\n    public int DFS(String s, int index)\\n    {\\n        if(index == s.length()) return 1;\\n        if(s.charAt(index) == \\'0\\') return 0;\\n        int count = DFS(s, index + 1);\\n        if(index < s.length()-1 && (s.charAt(index) == \\'1\\' || s.charAt(index) == \\'2\\' && s.charAt(index + 1) < \\'7\\'))\\n        {\\n            count += DFS(s, index + 2);\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int [] dp = new int[s.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return DFS(s, 0,dp);\\n    }\\n    public int DFS(String s, int index, int [] dp)\\n    {\\n        if(index == s.length()) return 1;\\n        if(s.charAt(index) == \\'0\\') return 0;\\n        if(dp[index] != -1) return dp[index];\\n        int count = DFS(s, index + 1,dp);\\n        if(index < s.length()-1 && (s.charAt(index) == \\'1\\' || s.charAt(index) == \\'2\\' && s.charAt(index + 1) < \\'7\\'))\\n        {\\n            count += DFS(s, index + 2,dp);\\n        }\\n        dp[index] = count;\\n        return dp[index];\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int len = s.length();\\n        int [] dp = new int[len + 1];\\n        dp[len] = 1;\\n        for(int k = len -1; k >= 0; k--)\\n        {\\n            if(s.charAt(k) == \\'0\\') \\n            {\\n                continue;\\n            }\\n            int res = dp[k + 1];\\n            if(k < len - 1 && (s.charAt(k) == \\'1\\' || s.charAt(k) == \\'2\\' && s.charAt(k+1) < \\'7\\')) \\n            {\\n                res += dp[k + 2];\\n            }\\n            dp[k] = res;\\n\\n        }\\n        return dp[0];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int len = s.length();\\n        int [] dp = new int[len+1];\\n        dp[0] = 1;\\n        for(int k = 1; k <= len; k++)\\n        {\\n            if(s.charAt(k-1) == \\'0\\') \\n            {\\n                continue;\\n            }\\n\\n            int res = dp[k  - 1];\\n            if(k > 1 && (s.charAt(k-2) == \\'1\\' || s.charAt(k-2) == \\'2\\' && s.charAt(k-1) < \\'7\\')) \\n            {\\n                res += dp[k - 2];\\n            }\\n            dp[k] = res;\\n\\n        }\\n        return dp[len];\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339104,
                "title": "python-standard-dp-solution",
                "content": "Please see and vote for my solutions for these two problems.\\n[91. Decode Ways](https://leetcode.com/problems/decode-ways/discuss/339104/Python-standard-DP-solution)\\n[639. Decode Ways II](https://leetcode.com/problems/decode-ways-ii/discuss/339105/Python-standard-DP-solution)\\n\\n\\n```\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\':\\n            return 0\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        dp[0] = dp[1] = 1\\n        for i in range(1, n):\\n            if s[i] != \\'0\\':\\n                dp[i+1] += dp[i]\\n            if s[i-1] != \\'0\\' and 1 <= int(s[i-1:i+1]) <= 26:\\n                dp[i+1] += dp[i-1]\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\':\\n            return 0\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        dp[0] = dp[1] = 1\\n        for i in range(1, n):\\n            if s[i] != \\'0\\':\\n                dp[i+1] += dp[i]\\n            if s[i-1] != \\'0\\' and 1 <= int(s[i-1:i+1]) <= 26:\\n                dp[i+1] += dp[i-1]\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30544,
                "title": "9-line-python-solution-dp",
                "content": "    def numDecodings(self, s):\\n        if not s: return 0\\n        len_s = len(s)\\n        dp = [1] + [0] * len_s\\n        for i in xrange(1, len_s + 1):\\n            if s[i - 1] != '0': \\n                dp[i] += dp[i - 1]\\n            if i >= 2 and 10 <= int(s[i - 2: i]) <= 26: \\n                dp[i] += dp[i - 2]\\n        return dp[len_s]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def numDecodings(self, s):\\n        if not s: return 0\\n        len_s = len(s)\\n        dp = [1] + [0] * len_s\\n        for i in xrange(1, len_s + 1):\\n            if s[i - 1] != '0': \\n                dp[i] += dp[i - 1]\\n            if i >= 2 and 10 <= int(s[i - 2: i]) <= 26: \\n                dp[i] += dp[i - 2]\\n        return dp[len_s]",
                "codeTag": "Python3"
            },
            {
                "id": 30416,
                "title": "simple-java-solution-with-o-1-space",
                "content": "    public int numDecodings(String s) {\\n        int n1 =1, n2=1, n3=0;\\n        if(s.length()==0||s.charAt(0)=='0') return 0;\\n        for(int i=2; i<=s.length(); i++)\\n        {\\n            n3=0;\\n            if(s.charAt(i-1)!='0') n3=n2;\\n            int num = Integer.parseInt(s.substring(i-2,i));\\n            if(num>=10 && num<=26) n3+=n1;\\n            n1=n2;\\n            n2=n3;\\n        }\\n        return n2;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int numDecodings(String s) {\\n        int n1 =1, n2=1, n3=0;\\n        if(s.length()==0||s.charAt(0)=='0') return 0;\\n        for(int i=2; i<=s.length(); i++)\\n        {\\n            n3=0;\\n            if(s.charAt(i-1)!='0') n3=n2;\\n            int num = Integer.parseInt(s.substring(i-2,i));\\n            if(num>=10 && num<=26) n3+=n1;\\n            n1=n2;\\n            n2=n3;\\n        }\\n        return n2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30519,
                "title": "share-my-4-ms-simple-c-code",
                "content": "I use n1 to record the ways to the index i, and n0 to record the ways to the index i-1;\\nO(n) time and O(1) space.\\n\\n    class Solution {\\n    public:\\n        int numDecodings(string s) {\\n            int n=s.size();\\n            if(n==0)\\n                return 0;\\n            int n0=1;\\n            int n1=(s[0]=='0')?0:1;\\n            for(int i=1;i<n;i++)\\n            {\\n                int tmp=n1;\\n                if(s[i]=='0')\\n                    n1=0;\\n                if((s[i-1]=='2'&&s[i]<='6')||s[i-1]=='1')\\n                    n1+=n0;\\n                if(n1==0)\\n                    return 0;\\n                n0=tmp;\\n            }\\n            return n1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numDecodings(string s) {\\n            int n=s.size();\\n            if(n==0)\\n                return 0;\\n            int n0=1;\\n            int n1=(s[0]=='0')?0:1;\\n            for(int i=1;i<n;i++)\\n            {\\n                int tmp=n1;\\n                if(s[i]=='0')\\n                    n1=0;\\n                if((s[i-1]=='2'&&s[i]<='6')||s[i-1]=='1')\\n                    n1+=n0;\\n                if(n1==0)\\n                    return 0;\\n                n0=tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1921947,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n\\n    func numDecodings(_ s: String) -> Int {\\n        let message = Array(s).compactMap { Int(String($0)) }\\n        let n = message.count\\n        \\n        guard n > 0, message[0] != 0 else { return 0 }\\n        guard n > 1 else { return 1 }\\n        \\n        var pre1 = 1\\n        var pre2 = 1\\n        var cur = 0\\n        \\n        for i in 1..<n {\\n            cur = 0\\n            if message[i] >= 1, message[i] <= 9 { cur += pre1 }\\n            \\n            let tmp = message[i-1] * 10 + message[i]\\n            if tmp >= 10, tmp <= 26 { cur += pre2 }\\n            \\n            pre2 = pre1\\n            pre1 = cur\\n        }\\n        \\n        return cur\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n\\n    func numDecodings(_ s: String) -> Int {\\n        let message = Array(s).compactMap { Int(String($0)) }\\n        let n = message.count\\n        \\n        guard n > 0, message[0] != 0 else { return 0 }\\n        guard n > 1 else { return 1 }\\n        \\n        var pre1 = 1\\n        var pre2 = 1\\n        var cur = 0\\n        \\n        for i in 1..<n {\\n            cur = 0\\n            if message[i] >= 1, message[i] <= 9 { cur += pre1 }\\n            \\n            let tmp = message[i-1] * 10 + message[i]\\n            if tmp >= 10, tmp <= 26 { cur += pre2 }\\n            \\n            pre2 = pre1\\n            pre1 = cur\\n        }\\n        \\n        return cur\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584181,
                "title": "java-dp-diagrammatic-explanation-code-with-comments-memoization-tabulation",
                "content": "**Memoization: (Top-down approach)**\\n\\n![image](https://assets.leetcode.com/users/images/41ab9ff9-3bab-4f35-88cd-3e2913c3ae48_1637217569.187871.jpeg)\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return decodeWays(s, 0, memo);\\n    }\\n    \\n    int decodeWays(String s, int idx, Map<String, Integer> memo){\\n        // If the first char is \\'0\\' of the current substring is 0, then we cannot form any valid string with it\\n        // Care should be taken to check if that is not the last character in which case it can still be part of a valid string\\n        if(idx < s.length() && s.charAt(idx) == \\'0\\')\\n            return 0;\\n        \\n        // If idx has reached the last character\\n        if(idx >= s.length() - 1)\\n            return 1;\\n        \\n        // If already found this string earlier\\n        String key = s.substring(idx);\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n    \\n        // Choice 1: when considering the current char as single alphabet\\n        int choice1 = decodeWays(s, idx + 1, memo);\\n        \\n        // Choice 2: when considering the current char and the next char together and checking if that is a valid alphabet\\n        int combined = (s.charAt(idx) - 48) * 10 + (s.charAt(idx+1) - 48);\\n        int choice2 = 0;\\n        if(combined <= 26)\\n            choice2 = decodeWays(s, idx+2, memo);\\n        memo.put(key, choice1 + choice2);\\n        return choice1 + choice2;\\n    }\\n}\\n```\\n\\n<br/>\\n\\n**Tabulation: (Bottom-up approach)**\\n\\n![image](https://assets.leetcode.com/users/images/fbe1f9b8-7de9-4f7b-873c-c845be8ba88e_1637217581.8708253.jpeg)\\n\\n**Note: In the below solution the ith index of `dp[]` corresponds to the (i-1)th character in the string and while iterating `i` represents the current character of the string, hence we populate (i+1)th index in `dp[]`**\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int[] dp = new int[s.length() + 1];\\n        \\n        // There is one way of decoding an empty string, which is empty\\n        dp[0] = 1; \\n        \\n        // If the first char is 0, we cannot decode that string, or else we can only decode it one way\\n        if(s.charAt(0) != \\'0\\')\\n            dp[1] = 1;\\n        else return 0;\\n        \\n        // We start iterating from the second character (1st index) in the string till end of string\\n        // For every character we have 2 choices\\n        for(int i=1; i < s.length(); i++){\\n            int choice1=0, choice2=0;\\n            // Choice 1: If the current char is not \\'0\\', then we can consider this alphabet separately, \\n            // in which case the number of ways will be same as the previous character\\n            if(s.charAt(i) != \\'0\\')\\n                choice1 = dp[i];\\n            \\n            // Choice 2: If the previous char is not \\'0\\', then we can combine the current char with previous \\n            // and check if the numeric value is less than equal to 26 (the number of possible English alphabets)\\n            if(s.charAt(i-1) != \\'0\\' && ((s.charAt(i-1) - 48) * 10 + (s.charAt(i) - 48)) <= 26)\\n                choice2 = dp[i-1];\\n            \\n            // If none of the choices were chosen because of the constraints, then definitely we cannot decode the string\\n            if(choice1 + choice2 == 0)\\n                return 0;            \\n            // Else we update our dp array with the sum of the choices\\n            dp[i+1] = choice1 + choice2;\\n        }\\n        \\n        // The last index of dp[] will have our desired result\\n        return dp[dp.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        Map<String, Integer> memo = new HashMap<>();\\n        return decodeWays(s, 0, memo);\\n    }\\n    \\n    int decodeWays(String s, int idx, Map<String, Integer> memo){\\n        // If the first char is \\'0\\' of the current substring is 0, then we cannot form any valid string with it\\n        // Care should be taken to check if that is not the last character in which case it can still be part of a valid string\\n        if(idx < s.length() && s.charAt(idx) == \\'0\\')\\n            return 0;\\n        \\n        // If idx has reached the last character\\n        if(idx >= s.length() - 1)\\n            return 1;\\n        \\n        // If already found this string earlier\\n        String key = s.substring(idx);\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n    \\n        // Choice 1: when considering the current char as single alphabet\\n        int choice1 = decodeWays(s, idx + 1, memo);\\n        \\n        // Choice 2: when considering the current char and the next char together and checking if that is a valid alphabet\\n        int combined = (s.charAt(idx) - 48) * 10 + (s.charAt(idx+1) - 48);\\n        int choice2 = 0;\\n        if(combined <= 26)\\n            choice2 = decodeWays(s, idx+2, memo);\\n        memo.put(key, choice1 + choice2);\\n        return choice1 + choice2;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        int[] dp = new int[s.length() + 1];\\n        \\n        // There is one way of decoding an empty string, which is empty\\n        dp[0] = 1; \\n        \\n        // If the first char is 0, we cannot decode that string, or else we can only decode it one way\\n        if(s.charAt(0) != \\'0\\')\\n            dp[1] = 1;\\n        else return 0;\\n        \\n        // We start iterating from the second character (1st index) in the string till end of string\\n        // For every character we have 2 choices\\n        for(int i=1; i < s.length(); i++){\\n            int choice1=0, choice2=0;\\n            // Choice 1: If the current char is not \\'0\\', then we can consider this alphabet separately, \\n            // in which case the number of ways will be same as the previous character\\n            if(s.charAt(i) != \\'0\\')\\n                choice1 = dp[i];\\n            \\n            // Choice 2: If the previous char is not \\'0\\', then we can combine the current char with previous \\n            // and check if the numeric value is less than equal to 26 (the number of possible English alphabets)\\n            if(s.charAt(i-1) != \\'0\\' && ((s.charAt(i-1) - 48) * 10 + (s.charAt(i) - 48)) <= 26)\\n                choice2 = dp[i-1];\\n            \\n            // If none of the choices were chosen because of the constraints, then definitely we cannot decode the string\\n            if(choice1 + choice2 == 0)\\n                return 0;            \\n            // Else we update our dp array with the sum of the choices\\n            dp[i+1] = choice1 + choice2;\\n        }\\n        \\n        // The last index of dp[] will have our desired result\\n        return dp[dp.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30637,
                "title": "python-dp-solution",
                "content": "    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def numDecodings(self, s):\\n        if not s or s.startswith('0'):\\n            return 0\\n        stack = [1, 1]\\n        for i in range(1, len(s)):\\n            if s[i] == '0':\\n                if s[i-1] == '0' or s[i-1] > '2':  # only '10', '20' is valid\\n                    return 0\\n                stack.append(stack[-2])\\n            elif 9 < int(s[i-1:i+1]) < 27:         # '01 - 09' is not allowed\\n                stack.append(stack[-2]+stack[-1])\\n            else:                                  # other case '01, 09, 27'\\n                stack.append(stack[-1])\\n        return stack[-1]\\n\\nA digit from index 1 have three condition\\n\\n1.   '?10' or '?20'  this can only divide into '10'   or   '20' , f(n) = f(n-2)\\n\\n2.   '?26'  this can divide into '6' or '26', f(n) = f(n-2)+f(n-1)\\n\\n3.   '?09', '?27' this can only divide into '9'    or   '7' , f(n) = f(n-1)",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def numDecodings(self, s):\\n        if not s or s.startswith('0'):\\n            return 0\\n        stack = [1, 1]\\n        for i in range(1, len(s)):\\n            if s[i] == '0':\\n                if s[i-1] == '0' or s[i-1] > '2':  # only '10', '20' is valid\\n                    return 0\\n                stack.append(stack[-2])\\n            elif 9 < int(s[i-1:i+1]) < 27:         # '01 - 09' is not allowed\\n                stack.append(stack[-2]+stack[-1])\\n            else:                                  # other case '01, 09, 27'\\n                stack.append(stack[-1])\\n        return stack[-1]\\n\\nA digit from index 1 have three condition\\n\\n1.   '?10' or '?20'  this can only divide into '10'   or   '20' , f(n) = f(n-2)\\n\\n2.   '?26'  this can divide into '6' or '26', f(n) = f(n-2)+f(n-1)\\n\\n3.   '?09', '?27' this can only divide into '9'    or   '7' , f(n) = f(n-1)",
                "codeTag": "Java"
            },
            {
                "id": 1708270,
                "title": "c-recursion-memoization-tabulation-clean-and-concise",
                "content": "### 1. Brute Force => Recursive Approach ( TLE )\\n\\n```\\nclass Solution {\\npublic:\\n    int recur(string s,int idx)\\n    {\\n        if(idx==s.size())\\n            return 1;\\n        if(s[idx]==\\'0\\')\\n            return 0;\\n        if(idx==s.size()-1)\\n            return 1;\\n        \\n        string temp=s.substr(idx,2);\\n        \\n        int op1=recur(s,idx+1);\\n        int op2=(stoi(temp)>=1 and stoi(temp)<=26)?recur(s,idx+2):0;\\n        \\n        return op1+op2;\\n    }\\n    int numDecodings(string s) {\\n        \\n        \\n        return recur(s,0);\\n    }\\n};\\n```\\n\\n### 2. Better Approach => Memoization ( AC )\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101];\\n    int recur(string s,int idx)\\n    {\\n        if(idx==s.size())\\n            return 1;\\n        if(s[idx]==\\'0\\')\\n            return 0;\\n        if(idx==s.size()-1)\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        string temp=s.substr(idx,2);\\n        \\n        int op1=recur(s,idx+1);\\n        int op2=(stoi(temp)>=1 and stoi(temp)<=26)?recur(s,idx+2):0;\\n        \\n        return dp[idx]=op1+op2;\\n    }\\n    int numDecodings(string s) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return recur(s,0);\\n    }\\n};\\n```\\n\\n\\n### 3. Optimal Approach => Tabulation ( AC ) \\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101];\\n\\n    int numDecodings(string s) {\\n        \\n       \\n        memset(dp,0,sizeof dp);\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        int i,j;\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(i=2;i<=n;i++)\\n        {\\n            int one=s[i-1]-\\'0\\';\\n            string temp=s.substr(i-2,2);\\n             if(one>=1)\\n                dp[i]+=dp[i-1];\\n            if(stoi(temp)>=10 and stoi(temp)<=26)\\n            {\\n                dp[i]+=dp[i-2];\\n            }\\n           \\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Pls upvote if you found useful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(string s,int idx)\\n    {\\n        if(idx==s.size())\\n            return 1;\\n        if(s[idx]==\\'0\\')\\n            return 0;\\n        if(idx==s.size()-1)\\n            return 1;\\n        \\n        string temp=s.substr(idx,2);\\n        \\n        int op1=recur(s,idx+1);\\n        int op2=(stoi(temp)>=1 and stoi(temp)<=26)?recur(s,idx+2):0;\\n        \\n        return op1+op2;\\n    }\\n    int numDecodings(string s) {\\n        \\n        \\n        return recur(s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101];\\n    int recur(string s,int idx)\\n    {\\n        if(idx==s.size())\\n            return 1;\\n        if(s[idx]==\\'0\\')\\n            return 0;\\n        if(idx==s.size()-1)\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        string temp=s.substr(idx,2);\\n        \\n        int op1=recur(s,idx+1);\\n        int op2=(stoi(temp)>=1 and stoi(temp)<=26)?recur(s,idx+2):0;\\n        \\n        return dp[idx]=op1+op2;\\n    }\\n    int numDecodings(string s) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return recur(s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[101];\\n\\n    int numDecodings(string s) {\\n        \\n       \\n        memset(dp,0,sizeof dp);\\n        int n=s.size();\\n        if(s[0]==\\'0\\')\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        int i,j;\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(i=2;i<=n;i++)\\n        {\\n            int one=s[i-1]-\\'0\\';\\n            string temp=s.substr(i-2,2);\\n             if(one>=1)\\n                dp[i]+=dp[i-1];\\n            if(stoi(temp)>=10 and stoi(temp)<=26)\\n            {\\n                dp[i]+=dp[i-2];\\n            }\\n           \\n            \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650945,
                "title": "python-dp-o-1-space-clear-explanation",
                "content": "# Logic\\nConsider this example:\\n```\\n\"12121\"\\n```\\nLength 1: ```\"1\"``` => ```[1]```\\nLength 2: ```\"12\"``` =>```[1,2] [12]```\\nLength 3: ```\"121\"``` => ```[1,2,1], [12,1], [1,21]```\\nLength 4: ```\"1212\"``` =>  ```[1,2,1,2], [1,21,2], [12,1,2], [1,2,12], [12,12]```\\n...\\nLet\\'s look closer at length 3 and 4.\\n\\nLength 3: ```\"121\"``` => ```[1,2,1], [12,1], [1,21]```\\nWe can decompose the three combinations into two parts:\\n1. Append self\\n\\tThat is, append \"1\" to all the combinations in len 2: \\n\\t```[1,2] [12]``` + ```[1]``` =>  ```[1,2,1], [12,1] ```\\n2. Append self and the previous digit, if valid (10 to 26)\\n\\tThat is, append \"21\" to all the combinations in len 1:\\n\\t```[1]``` + ```[21]``` => ```[1,21]```\\n\\nLength 4: ```\"1212\"``` => ```[1,2,1,2], [1,21,2], [12,1,2], [1,2,12], [12,12]```\\nWe can again decompose the five combinations into two parts:\\n1. Append self\\n\\tThat is, append \"2\" to all the combinations in len 3:\\n\\t ```[1,2,1], [12,1], [1,21]``` + ```[2]``` =>  ```[1,2,1,2], [1,21,2], [12,1,2]```\\n2. Append self and the previous digit, if valid (10 to 26)\\n\\tThat is, append \"12\" to all the combinations in len 2: \\n\\t```[1,2], [12]``` + ```[12]``` =>  ```[1,2,12], [12,12]```\\n\\t\\nTherefore, we can generlize the logic into the following:\\n1. ```f(i) = f(i-1)``` if we found valid one-digit num, i.e. 1 to 9 (0 is an edge case)\\n2. ```f(i) += f(i-2)``` if we found valid two-digit num, i.e. 10 to 26\\n\\nSimilar as in fibonacci problem, we just need a constant space dp to store the previous two states.\\n# Code\\n\\n```python\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\':\\n            return 0\\n        dp = [1, 1]\\n        for i in range(1, len(s)):\\n            temp = 0\\n            if 1 <= int(s[i]) <= 9:\\n                temp = dp[1]\\n            if 10 <= int(s[i-1:i+1]) <= 26:\\n                temp += dp[0]\\n            dp = [dp[1], temp]\\n        return dp[1]\\n```\\nTime complexity: O(n)\\nSpace: O(1)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n\"12121\"\\n```\n```\"1\"```\n```[1]```\n```\"12\"```\n```[1,2] [12]```\n```\"121\"```\n```[1,2,1], [12,1], [1,21]```\n```\"1212\"```\n```[1,2,1,2], [1,21,2], [12,1,2], [1,2,12], [12,12]```\n```\"121\"```\n```[1,2,1], [12,1], [1,21]```\n```[1,2] [12]```\n```[1]```\n```[1,2,1], [12,1] ```\n```[1]```\n```[21]```\n```[1,21]```\n```\"1212\"```\n```[1,2,1,2], [1,21,2], [12,1,2], [1,2,12], [12,12]```\n```[1,2,1], [12,1], [1,21]```\n```[2]```\n```[1,2,1,2], [1,21,2], [12,1,2]```\n```[1,2], [12]```\n```[12]```\n```[1,2,12], [12,12]```\n```f(i) = f(i-1)```\n```f(i) += f(i-2)```\n```python\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\':\\n            return 0\\n        dp = [1, 1]\\n        for i in range(1, len(s)):\\n            temp = 0\\n            if 1 <= int(s[i]) <= 9:\\n                temp = dp[1]\\n            if 10 <= int(s[i-1:i+1]) <= 26:\\n                temp += dp[0]\\n            dp = [dp[1], temp]\\n        return dp[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1082132,
                "title": "dp-is-easy-c-a-good-question-to-understand-memoization",
                "content": "**WARNING**: This will not be a tabulated, perfectly optimized DP solution. We have enough of those.\\n\\n**Inspiration**: (Optional) Go through this to get idea of approach [Target Sum discussion](https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions)\\n\\npos is index in the array. We start with 0 index from left side.\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[101];\\n\\n    int numDecodings(string &S) {\\n        s = S;\\n        memset(dp, -1, sizeof dp);\\n        ll ans = help(0);\\n        return ans;\\n    }\\n\\t\\n\\tll help(int pos){\\n        //If we reach the end means it is valid decoding\\n        if(pos >= s.size()){\\n            return 1;\\n        }\\n        \\n        //result is available to us in cache\\n        if(dp[pos] != -1) return dp[pos];\\n        \\n        //No decoding is possible if current character = 0\\n        if(s[pos] == \\'0\\'){\\n            return dp[pos] = 0;\\n        }\\n        \\n        //decode normally\\n        ll ans = help(pos+1);\\n        \\n        //10 to 19 case\\n        if(s[pos] == \\'1\\' && pos +1 < s.size()){\\n            ans += help(pos+2);\\n        }\\n        //20 to 26 case\\n        else if(s[pos] == \\'2\\' && pos +1 < s.size() && s[pos+1] <= \\'6\\'){\\n            ans += help(pos+2);\\n        }\\n        \\n        return  dp[pos] = ans;\\n    }\\n};\\n```\\n\\nPlease stop posting 4-5 lines of tabulated solutions **without explanations**.\\nThanks \\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[101];\\n\\n    int numDecodings(string &S) {\\n        s = S;\\n        memset(dp, -1, sizeof dp);\\n        ll ans = help(0);\\n        return ans;\\n    }\\n\\t\\n\\tll help(int pos){\\n        //If we reach the end means it is valid decoding\\n        if(pos >= s.size()){\\n            return 1;\\n        }\\n        \\n        //result is available to us in cache\\n        if(dp[pos] != -1) return dp[pos];\\n        \\n        //No decoding is possible if current character = 0\\n        if(s[pos] == \\'0\\'){\\n            return dp[pos] = 0;\\n        }\\n        \\n        //decode normally\\n        ll ans = help(pos+1);\\n        \\n        //10 to 19 case\\n        if(s[pos] == \\'1\\' && pos +1 < s.size()){\\n            ans += help(pos+2);\\n        }\\n        //20 to 26 case\\n        else if(s[pos] == \\'2\\' && pos +1 < s.size() && s[pos+1] <= \\'6\\'){\\n            ans += help(pos+2);\\n        }\\n        \\n        return  dp[pos] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856042,
                "title": "sequential-thought-recursion-memo-dp-faster-easy-understanding",
                "content": "```\\n// sequential thought process for this problem\\n\\n//1) If the last digit is non-zero, recur for remaining (n-1) digits and add the result to total count.\\n//2) If the last two digits form a valid char (or smaller than 27), recur for remaining (n-2) digits and add the result to total count.\\n\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int size) {\\n        if (s[0]==\\'0\\') \\n          return 0;\\n        if (size == 0 || size == 1) \\n            return 1; \\n\\t\\t// for base condition \"01123\" should return 0 \\t\\n        int output=0;\\n        if (s[size-1] > \\'0\\') \\n           output=numDecodings(s,size-1);\\n        if (s[size-2] == \\'1\\' ||  (s[size-2] == \\'2\\' && s[size-1] < \\'7\\') ) {\\n            output+=numDecodings(s,size-2);\\n        }\\n        return output;\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        cout<<s.size();\\n        return numDecodings(s,s.size());\\n    }\\n\\t\\n};\\n\\n//2.memoization[faster than 100.00%]\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int size,vector<int> &vec) {\\n        if (s[0]==\\'0\\') \\n          return 0;\\n        if (size == 0 || size == 1) \\n            return 1;\\n        if(vec[size]!=-1){\\n            return vec[size];\\n        }\\n        int output=0;\\n        if (s[size-1] > \\'0\\') \\n           output=numDecodings(s,size-1,vec);\\n        if (s[size-2] == \\'1\\' ||  (s[size-2] == \\'2\\' && s[size-1] < \\'7\\') )\\n           output+=numDecodings(s,size-2,vec);\\n        vec[size]=output;\\n        return output;\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        vector<int> vec(s.size()+1,-1);\\n        return numDecodings(s,s.size(),vec);\\n    }\\n\\t\\n};\\n\\n//3. Dynamic Programming [ faster than 100.00% ] [ TC: (n) ]\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int n) {\\n\\t    //table to store results of subproblems \\n         int count[n+1];  \\n        count[0] = 1; \\n        count[1] = 1; \\n\\t\\t\\n\\t\\t// for base condition \"01123\" should return 0 \\t\\n        if(s[0]==\\'0\\')   \\n             return 0; \\n\\t\\t\\t \\n       for (int i = 2; i <= n; i++){ \\n            count[i] = 0; \\n  \\n        // If the last digit is not 0,   then last digit must add to the number of words \\n\\t\\t\\n        if (s[i-1] > \\'0\\') \\n            count[i] = count[i-1]; \\n  \\n        // If second last digit is smaller  than 2 and last digit is smaller than 7,  then last two digits form a valid character \\n\\t\\t\\n        if (s[i-2] == \\'1\\' || (s[i-2] == \\'2\\' && s[i-1] < \\'7\\') ) \\n            count[i] += count[i-2]; \\n    } \\n    return count[n];\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        return numDecodings(s,s.size());\\n    }\\n\\t\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// sequential thought process for this problem\\n\\n//1) If the last digit is non-zero, recur for remaining (n-1) digits and add the result to total count.\\n//2) If the last two digits form a valid char (or smaller than 27), recur for remaining (n-2) digits and add the result to total count.\\n\\n\\n//1.Recursion(TLE) [time complexity of the code is exponential]\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int size) {\\n        if (s[0]==\\'0\\') \\n          return 0;\\n        if (size == 0 || size == 1) \\n            return 1; \\n\\t\\t// for base condition \"01123\" should return 0 \\t\\n        int output=0;\\n        if (s[size-1] > \\'0\\') \\n           output=numDecodings(s,size-1);\\n        if (s[size-2] == \\'1\\' ||  (s[size-2] == \\'2\\' && s[size-1] < \\'7\\') ) {\\n            output+=numDecodings(s,size-2);\\n        }\\n        return output;\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        cout<<s.size();\\n        return numDecodings(s,s.size());\\n    }\\n\\t\\n};\\n\\n//2.memoization[faster than 100.00%]\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int size,vector<int> &vec) {\\n        if (s[0]==\\'0\\') \\n          return 0;\\n        if (size == 0 || size == 1) \\n            return 1;\\n        if(vec[size]!=-1){\\n            return vec[size];\\n        }\\n        int output=0;\\n        if (s[size-1] > \\'0\\') \\n           output=numDecodings(s,size-1,vec);\\n        if (s[size-2] == \\'1\\' ||  (s[size-2] == \\'2\\' && s[size-1] < \\'7\\') )\\n           output+=numDecodings(s,size-2,vec);\\n        vec[size]=output;\\n        return output;\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        vector<int> vec(s.size()+1,-1);\\n        return numDecodings(s,s.size(),vec);\\n    }\\n\\t\\n};\\n\\n//3. Dynamic Programming [ faster than 100.00% ] [ TC: (n) ]\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s,int n) {\\n\\t    //table to store results of subproblems \\n         int count[n+1];  \\n        count[0] = 1; \\n        count[1] = 1; \\n\\t\\t\\n\\t\\t// for base condition \"01123\" should return 0 \\t\\n        if(s[0]==\\'0\\')   \\n             return 0; \\n\\t\\t\\t \\n       for (int i = 2; i <= n; i++){ \\n            count[i] = 0; \\n  \\n        // If the last digit is not 0,   then last digit must add to the number of words \\n\\t\\t\\n        if (s[i-1] > \\'0\\') \\n            count[i] = count[i-1]; \\n  \\n        // If second last digit is smaller  than 2 and last digit is smaller than 7,  then last two digits form a valid character \\n\\t\\t\\n        if (s[i-2] == \\'1\\' || (s[i-2] == \\'2\\' && s[i-1] < \\'7\\') ) \\n            count[i] += count[i-2]; \\n    } \\n    return count[n];\\n    }\\n\\t\\n    int numDecodings(string s) {\\n        return numDecodings(s,s.size());\\n    }\\n\\t\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 378996,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        //Corner case - \\n        if(s[0]==\\'0\\')return 0;\\n        \\n        //General case - \\n        vector<int>dp(s.length()+1);\\n        //dp[i] = number of ways to decode the array till i\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=s.length();i++){\\n            int one = stoi(s.substr(i-1,1));\\n            int two = stoi(s.substr(i-2,2));\\n            \\n            if(one>=1)dp[i]=dp[i]+dp[i-1];\\n            if(two>=10 && two<=26)dp[i]=dp[i]+dp[i-2];\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        //Corner case - \\n        if(s[0]==\\'0\\')return 0;\\n        \\n        //General case - \\n        vector<int>dp(s.length()+1);\\n        //dp[i] = number of ways to decode the array till i\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2;i<=s.length();i++){\\n            int one = stoi(s.substr(i-1,1));\\n            int two = stoi(s.substr(i-2,2));\\n            \\n            if(one>=1)dp[i]=dp[i]+dp[i-1];\\n            if(two>=10 && two<=26)dp[i]=dp[i]+dp[i-2];\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060702,
                "title": "5-lines-of-code-dp-memoiazation-javascript-solution",
                "content": "```\\nconst numDecodings = function(s, i = 0, memo = {}) {\\n  if (i in memo) return memo[i];\\n  if (s[i] === \\'0\\') return 0;\\n  if (i >= s.length - 1) return 1;\\n  memo[i] = numDecodings(s, i + 1, memo) + (s[i] + s[i + 1] < 27 ? numDecodings(s, i + 2, memo) : 0);\\n  return memo[i];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nconst numDecodings = function(s, i = 0, memo = {}) {\\n  if (i in memo) return memo[i];\\n  if (s[i] === \\'0\\') return 0;\\n  if (i >= s.length - 1) return 1;\\n  memo[i] = numDecodings(s, i + 1, memo) + (s[i] + s[i + 1] < 27 ? numDecodings(s, i + 2, memo) : 0);\\n  return memo[i];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347813,
                "title": "readable-python-dp-7-lines-with-the-best-detailed-explanation-of-the-logic",
                "content": "O(N) time and O(1) space, similar to Fibonacci Sequence (https://leetcode.com/problems/fibonacci-number/discuss/347444/python-on-time-o1-space-this-question-should-be-labeled-as-super-easy), except that we only add prev and prev_prev if certain conditions on the last two digits are met.\\n\\nWe only add prev_prev if the digits are between 10 and 26. We always add prev except for 10 and 20. If the digits are 00 or 30, 40,...,90, the message is invalid and we return 0. If that made sense, scroll down for the code... if not, keep reading...\\n\\n**Detailed explanation:**\\n\\nPretend we know how many codes are possible for a given message, let\\'s say 132. We know that 2 codes are possible with 132: 1,3,2 and 13,2. Now we want to process the result of adding two more digits to the message.\\n\\nLet\\'s say we want to add the two digits 12 to our message of 132. 12 can be interpreted as the 12th letter L or the 1st letter A plus 2nd letter B.\\n\\nWe can either add 12 to the previous codes:\\n\\n1,3,2,12\\n13,2,12\\n\\nor we can add 1,2:\\n\\n1,3,2,1,2\\n13,2,1,2\\n\\n...but we forgot these:\\n\\n1,3,21,2\\n13,21,2\\n\\nAgain, there are 2 codes possible from 132, and we need to include both of those since ,12 can be appended to both.\\n\\nBut there are 4 codes possible from 1321: 1,3,2,1, 13,2,1, 1,3,21, 13,21. We need to include all 4 of those since ,2 can be appended to all.\\n\\nThe count of codes possible from 132 is labeled in my code as \\'prev_prev\\' and the count of codes possible from 1321 is labeled as \\'prev\\'. So the total count for 13212 is prev_prev + prev = 2 + 4 = 6.\\n\\nWhen we add a number larger than 26, let\\'s say 65, there only 26 letters in the alphabet, so we have to split up the 6 and 5. The count will remain the same as prev, which is the count of codes from 1326 = 4:\\n\\n1,3,2,6,5\\n13,2,6,5\\n1,3,26,5\\n13,26,5\\n\\nSo adding 65 to 132 should actually be thought of as adding 5 to 1326. If we think of it as simply adding 6,5 to 132, we wil miss 1,3,26,5 and 13,26,5.\\n\\nIf we add digits 10 or 20 to our message, things change, we can only use: 1,3,2,10 or 13,2,10. We can\\'t split up 10 to 1,0 since 0 is invalid. So the count remains the same as prev_prev = 2.\\n\\nAdding a multiple of 10 greater than or equal to 30 is invalid, since 1,3,2,30, 1,3,2,3,0, etc. are all invalid.\\n```\\n    def numDecodings(self, s):\\n        prev_prev = prev = result = int(s[0] != \\'0\\')\\n        for i in range(1, len(s)):\\n            last_two = int(s[i-1:i+1])\\n            if not last_two or (last_two >= 30 and not last_two % 10): return 0\\n            result = (last_two not in [10, 20])*prev + (10 <= last_two <= 26)*prev_prev\\n            prev_prev, prev = prev, result\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def numDecodings(self, s):\\n        prev_prev = prev = result = int(s[0] != \\'0\\')\\n        for i in range(1, len(s)):\\n            last_two = int(s[i-1:i+1])\\n            if not last_two or (last_two >= 30 and not last_two % 10): return 0\\n            result = (last_two not in [10, 20])*prev + (10 <= last_two <= 26)*prev_prev\\n            prev_prev, prev = prev, result\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110982,
                "title": "accepted-python-dp-solution-w-explanation",
                "content": "The question might be simple for many, however it took me quite some time to find a clean and easy way to understand and implement the solution. Thought to share with those that are new like me. \\n\\nIt's a typical DP question,  with additional checks to consider: \\n\\n1. dp[i]: The number of ways to decode a substring in S between index 0..(i-1)\\n2. dp[i] is the sum of dp[i-1] if\\n    S[i] is a valid decode, i.e. '1' <= S[i] <= '9', and dp[i-2] if substring S[i-1]S[i] is a valid decode, i.e. '10' <= S[i-1]S[i] <= '26'\\n\\nAfter handling special case, dp[1] = 1 as it contains ways to decode for S[0].  dp[0] is initialized to 1 as well to be used by dp[2] iteration and makes it easier. The code is as below:\\n\\n```\\ndef numDecodings(self, s):\\n        \\n        if not s or s[0] == \"0\": return 0\\n        \\n        dp = [0] * (len(s) + 1)\\n        dp[0] = dp[1] = 1\\n        for i, c in enumerate(s[1:], 1):\\n            if c >= \"1\" and c <= \"9\": \\n                dp[i+1] = dp[i] \\n            if s[i-1:i+1] and s[i-1:i+1] <= \"26\" and s[i-1:i+1] >= \"10\" : \\n                dp[i+1] += dp[i-1]\\n            \\n        return dp[-1]\\n            \\n````",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numDecodings(self, s):\\n        \\n        if not s or s[0] == \"0\": return 0\\n        \\n        dp = [0] * (len(s) + 1)\\n        dp[0] = dp[1] = 1\\n        for i, c in enumerate(s[1:], 1):\\n            if c >= \"1\" and c <= \"9\": \\n                dp[i+1] = dp[i] \\n            if s[i-1:i+1] and s[i-1:i+1] <= \"26\" and s[i-1:i+1] >= \"10\" : \\n                dp[i+1] += dp[i-1]\\n            \\n        return dp[-1]\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30405,
                "title": "dp-with-easy-understand-java-solution",
                "content": "\\n    public class Solution {\\n        public int numDecodings(String s) {\\n            int n = s.length();\\n            if (n == 0 || s.startsWith(\"0\")) {\\n                return 0;\\n            }\\n            int[] ways = new int[n+1];\\n            ways[0] = 1;\\n            ways[1] = 1;\\n            for (int i = 2; i <= n; i++) {\\n                int first = Integer.parseInt(s.substring(i-2, i));\\n                int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n                int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n                ways[i] = prev + plus;\\n            }\\n            return ways[n];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int numDecodings(String s) {\\n            int n = s.length();\\n            if (n == 0 || s.startsWith(\"0\")) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2236851,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "**data structure**\\n\\n`int[ ] dp = new int[n+1]` It\\'s n+1 because we need to use dp[0] to hold the empty string.\\n\\n**Intuition**\\n  1. `dp[0] = 1` since s = \"\" empty String can only be decoded as empty string. (It also provides the baton to be passed but I feel the statement is ridiculous. )\\n  2. `dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1` If s =\"6\" then we can decode it as 6. If s = \"0\" then there\\'s no number matches it.\\n  3. `dp[i] = dp[i-1] if s.charAt(i-1) != 0`\\n      `s = \"99999\"` then dp[i]\\'s result depends on previous result. dp[0] = 1. dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1 which is 1. dp[2] = dp[1]. dp[3] = dp[2]. dp[4] = dp[3]. \\n 4. `dp[i] += dp[i-2]` if it\\'s two digits. \\n    `s = \"926\"` then **dp[0]** = 1. **dp[1]** = 1. **dp[2]** = dp[1] = 1. \\n\\t**dp[3]** = d[2] + d[3-2] = 1 + 1 = 2 because \"26\" is twoDigits where 10 <= twoDigits <= 26.\\n\\t\\n```\\nclass Solution\\n{\\n    public int numDecodings(String s) \\n    {\\n        // O(n) time | O(n) space\\n        if(s == null)    return 0;\\n        \\n        int[] dp = new int[s.length() + 1];\\n        \\n        // dp[0] = 1 to provide the baton to be passed.\\n        // empty string can only be decoded as an empty string\\n        dp[0] = 1;\\n        \\n        dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1;\\n        \\n        for(int i = 2; i < dp.length; i++)\\n        {\\n            if(s.charAt(i-1) != \\'0\\')\\n                dp[i] = dp[i-1];\\n\\n            // check if successful two digit decode is possible\\n            int twoDigit = Integer.valueOf(s.substring(i-2, i));\\n            \\n            if(twoDigit >= 10 && twoDigit <= 26)\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int numDecodings(String s) \\n    {\\n        // O(n) time | O(n) space\\n        if(s == null)    return 0;\\n        \\n        int[] dp = new int[s.length() + 1];\\n        \\n        // dp[0] = 1 to provide the baton to be passed.\\n        // empty string can only be decoded as an empty string\\n        dp[0] = 1;\\n        \\n        dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1;\\n        \\n        for(int i = 2; i < dp.length; i++)\\n        {\\n            if(s.charAt(i-1) != \\'0\\')\\n                dp[i] = dp[i-1];\\n\\n            // check if successful two digit decode is possible\\n            int twoDigit = Integer.valueOf(s.substring(i-2, i));\\n            \\n            if(twoDigit >= 10 && twoDigit <= 26)\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044214,
                "title": "java-recursion-tree-figure",
                "content": "This post just analyze the problem from recursion tree.\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return helper(0, s, memo);\\n    }\\n    \\n    private int helper(int index, String s, Map<Integer, Integer> memo) {\\n        \\n        //base case for left case\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        //find calcaluted value in memo\\n        if (memo.containsKey(index)) {\\n            return memo.get(index);\\n        }\\n        \\n        //base case when char is \\'0\\'\\n        if (s.charAt(index) == \\'0\\') {\\n            return 0;\\n        }\\n        \\n        //base case for right branch\\n        if (index == s.length() - 1) {\\n            return 1;\\n        }\\n        //left branch\\n        int ans = helper(index + 1, s, memo);\\n        //right branch\\n        if ((s.charAt(index) - \\'0\\') * 10 + (s.charAt(index + 1) - \\'0\\') <= 26) {\\n            ans += helper(index + 2, s, memo);\\n        }\\n        // add to memo\\n        memo.put(index, ans);\\n        \\n        return ans;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1081a54d-023d-4eb2-8622-2f98d6995fa7_1612126033.3681498.png)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return helper(0, s, memo);\\n    }\\n    \\n    private int helper(int index, String s, Map<Integer, Integer> memo) {\\n        \\n        //base case for left case\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        \\n        //find calcaluted value in memo\\n        if (memo.containsKey(index)) {\\n            return memo.get(index);\\n        }\\n        \\n        //base case when char is \\'0\\'\\n        if (s.charAt(index) == \\'0\\') {\\n            return 0;\\n        }\\n        \\n        //base case for right branch\\n        if (index == s.length() - 1) {\\n            return 1;\\n        }\\n        //left branch\\n        int ans = helper(index + 1, s, memo);\\n        //right branch\\n        if ((s.charAt(index) - \\'0\\') * 10 + (s.charAt(index + 1) - \\'0\\') <= 26) {\\n            ans += helper(index + 2, s, memo);\\n        }\\n        // add to memo\\n        memo.put(index, ans);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953623,
                "title": "recursion-recursion-memo-dp-dp-optimized-space",
                "content": "Approach 01: **Recursion** (TLE)\\n\\n```\\n public int numDecodings(String s) {\\n        if(s == null || s.isEmpty()) return 0;\\n        return numDecodingHelper(s, 0);\\n    }\\n\\n    public int numDecodingHelper(String s, int index) {\\n        if(index == s.length()){\\n            return 1;\\n        }\\n\\n        if(s.charAt(index) == \\'0\\'){\\n            return 0;\\n        }\\n\\n        if(index == s.length() -1) {\\n            return 1;\\n        }\\n\\n        int ans = numDecodingHelper(s, index+1);\\n        if(Integer.parseInt(s.substring(index, index+2)) <=26){\\n            ans+= numDecodingHelper(s, index+2);\\n        }\\n        return ans;\\n    }\\n```\\n\\nOf course it will result in TLE as there are lots of overlapping subproblems.\\n\\nApproach 02: **Recursion with Memoization**\\n\\n```\\npublic int numDecodings(String s) {\\n        if(s == null || s.isEmpty()) return 0;\\n        int[] cache = new int[s.length()+1];\\n        return numDecodingHelper(s, 0, cache);\\n    }\\n\\n    public int numDecodingHelper(String s, int index, int[] cache) {\\n        if(index == s.length()){\\n            return 1;\\n        }\\n\\n        if(s.charAt(index) == \\'0\\'){\\n            return 0;\\n        }\\n\\n        if(index == s.length() -1) {\\n            return 1;\\n        }\\n\\n        if(cache[index]>0) return cache[index];\\n\\n        int ans = numDecodingHelper(s, index+1, cache);\\n        if(Integer.parseInt(s.substring(index, index+2)) <=26){\\n            ans+= numDecodingHelper(s, index+2, cache);\\n        }\\n        cache[index] = ans;\\n        return ans;\\n    }\\n```\\n\\nTC :  O(N) where N is the length of the string. \\nSC: O(N); The dictionary used for memoization would take the space equal to the length of the string. \\n\\n**Note**: Why Not \\nif(index == s.length() || index == s.length() -1){\\n            return 1;\\n        }\\nRundown with \\u201C10\\u201D to get the answer. For 10 it outputs 2 but answer is 1.\\nnumDecodingHelper(s, index+1, cache) checks recursively for every digit. For 10 it would check for 1 and then 0. But 0 condition is below the above if cognition, so it will be missed. That\\'s why the above two conditions are separated. It also handles the leading 0 cases. \\n\\n**Why**  if(index == s.length() -1) {\\n            return 1;\\n        }\\nRundown with 2326 to get a clear idea. Every step single digit is processed and called recursively. First 2 then 3 then 2 and 6. When it\\u2019s in index 3 all digits are processed and can be decoded as single digit each. So return 1.\\n\\nFirstly, it makes sure you do not go out of bounds when doing Integer.parseInt(str.substring(index, index+2)).\\nSecond, the reason why it returns 1 is because when the index is at last character, you only have one character to process and it\\'s already checked that it\\'s not 0, we simply return 1. You may ask why do we return 1, when index == str.length(), it handles double digit cases.\\n\\nApproach 03: **DP**\\n\\n```\\n  public int numDecodings(String s) {\\n        if (s == null || s.isEmpty() || s.charAt(0) == \\'0\\') return 0;\\n        int[] dp = new int[s.length()+1];\\n        dp[0] = 1;\\n        dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1; //if there is only char and if it\\'s not 0 then 1. Base case\\n\\n        for (int i = 2; i < dp.length; i++) {\\n            if(s.charAt(i-1)!=\\'0\\'){\\n                dp[i] = dp[i] + dp[i-1];\\n            }\\n            int twoDigit = Integer.parseInt(s.substring(i-2, i));\\n            if(twoDigit>=10 && twoDigit<=26) {\\n                dp[i] = dp[i] + dp[i-2];\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\nTC and SC: O(N)\\n\\nWhy is dp[0] = 1 needed?\\n\\ndp[i] = dp[i] + dp[i-2]; will fail if not provided in the beginning of the loop.\\n\\n**Note**: Only dp[i-1] and dp[i-2] is needed for cache. So instead of array two variables can be used.\\n\\n**Rundown:** For 2326 dp would be 1 1 2 2 4\\n\\n**Special Note:** The problem has some sort of similarities to [Climbing Statirs](httphttps://leetcode.com/problems/climbing-stairs/://)\\n numDecodingHelper(s, index+1) is like taking single step and numDecodingHelper(s, index+2) is like taking two steps.\\n\\n\\n\\n*I couldn\\'t come up with this solution. I tried to grasp the solution from existing solutions and gathered the best soultion seemed appropriate to me comprehend. Hope it will help me solve similar kind of problems in future.*\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numDecodings(String s) {\\n        if(s == null || s.isEmpty()) return 0;\\n        return numDecodingHelper(s, 0);\\n    }\\n\\n    public int numDecodingHelper(String s, int index) {\\n        if(index == s.length()){\\n            return 1;\\n        }\\n\\n        if(s.charAt(index) == \\'0\\'){\\n            return 0;\\n        }\\n\\n        if(index == s.length() -1) {\\n            return 1;\\n        }\\n\\n        int ans = numDecodingHelper(s, index+1);\\n        if(Integer.parseInt(s.substring(index, index+2)) <=26){\\n            ans+= numDecodingHelper(s, index+2);\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int numDecodings(String s) {\\n        if(s == null || s.isEmpty()) return 0;\\n        int[] cache = new int[s.length()+1];\\n        return numDecodingHelper(s, 0, cache);\\n    }\\n\\n    public int numDecodingHelper(String s, int index, int[] cache) {\\n        if(index == s.length()){\\n            return 1;\\n        }\\n\\n        if(s.charAt(index) == \\'0\\'){\\n            return 0;\\n        }\\n\\n        if(index == s.length() -1) {\\n            return 1;\\n        }\\n\\n        if(cache[index]>0) return cache[index];\\n\\n        int ans = numDecodingHelper(s, index+1, cache);\\n        if(Integer.parseInt(s.substring(index, index+2)) <=26){\\n            ans+= numDecodingHelper(s, index+2, cache);\\n        }\\n        cache[index] = ans;\\n        return ans;\\n    }\\n```\n```\\n  public int numDecodings(String s) {\\n        if (s == null || s.isEmpty() || s.charAt(0) == \\'0\\') return 0;\\n        int[] dp = new int[s.length()+1];\\n        dp[0] = 1;\\n        dp[1] = s.charAt(0) == \\'0\\' ? 0 : 1; //if there is only char and if it\\'s not 0 then 1. Base case\\n\\n        for (int i = 2; i < dp.length; i++) {\\n            if(s.charAt(i-1)!=\\'0\\'){\\n                dp[i] = dp[i] + dp[i-1];\\n            }\\n            int twoDigit = Integer.parseInt(s.substring(i-2, i));\\n            if(twoDigit>=10 && twoDigit<=26) {\\n                dp[i] = dp[i] + dp[i-2];\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 808992,
                "title": "4-lines-solution-91-faster-easy-dp-time-o-n",
                "content": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [1] * (len(s) + 1)             # DP Array of size (n+1) initialized to 1\\n        if s[0] == \"0\": dp[1] = 0           # Check s[0] is valid encoding\\n\\n        for i in range(2, len(s) + 1):\\n            dp[i] = (dp[i - 1] if 1 <= int(s[i - 1]) <= 26 else 0) + (dp[i - 2] if 10 <= int(s[i - 2] + s[i - 1]) <= 26 else 0)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [1] * (len(s) + 1)             # DP Array of size (n+1) initialized to 1\\n        if s[0] == \"0\": dp[1] = 0           # Check s[0] is valid encoding\\n\\n        for i in range(2, len(s) + 1):\\n            dp[i] = (dp[i - 1] if 1 <= int(s[i - 1]) <= 26 else 0) + (dp[i - 2] if 10 <= int(s[i - 2] + s[i - 1]) <= 26 else 0)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597202,
                "title": "without-dp-c-o-n-solution",
                "content": "I saw some of the solutions of this question (post-solving) and didn\\'t find my approach. So, I am posting this.\\nI apolozise in advance if someone had posted the same approach beforehand.\\n\\n### **Solution Apporoach**\\n\\n* Basically, we divide given string into substrings (I am calling them clusters), whose each character(digit) can form another alphabet using next digit.\\n* If a digit cannot form different alphabet using next digit then it marks the end of that cluster.\\n\\nFor example,  `s = \"1231156\"`\\nHere clusters will be `\"123\"`, `\"115\"`, `\"6\"`.\\nAs for `\"123\"`\\n* `1` can form `1` and `12`,\\n* `2` can form `2` and `23`,\\n* `3` can form `3`, (but cannot form `31` using `\\'1\\'` present after `\\'3\\'` in `string s`, so digit `\\'3\\'` ends cluster `\"123\"`).\\n\\n#### **Now finding no. of possibilities for each cluster**\\nUpon investigating, we can see a pattern in **no. of digits in cluster v/s no. of possible ways**.\\nLet us see this by\\n\\n* `s = \"12\"` - > It has 2 possible ways\\n* `s = \"123\"` - > It has 3 possible ways\\n* `s = \"1229\"` - > It has 5 possible ways\\n* `s = \"12114\"` - > It has 8 possible ways\\n\\n**So, no. of possible ways is equal to `(n+2)th` fibonacci no.**  where,\\n* `n` = size of cluster\\n* and fibonacci series is as : `0` `1` `1` `2` `3` `5` `8`...\\n_____________________at `n` : `0` `1` `2` `3` `4` `5` `6`... respectively.\\n\\n##### But, there is this slight error. We have to **deal with zero** also.\\nTo do so, we can see that zero always goes with previous **valid** digit. (Valid digit are only \\'1\\' and \\'2\\', other digits are invalid resulting answer to be zero).\\nSo zero and previous valid digit seems to be forming their cluster **with only one possible way.**\\n\\nAnd so, finally, our **output will be product of no. of possible ways** for each cluster.\\n\\nThe code is below:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int fib(int n) {\\n        double num = (sqrt(5) + 1) / 2;\\n        return round(pow(num, n) / sqrt(5));\\n    }\\n    \\n    int numDecodings(string s) {\\n        int n = s.size(), prev = 0, res = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                if(i == 0 || (s[i-1] == \\'0\\' || s[i-1] >= \\'3\\'))\\t\\t// checking for valid previous digit\\n                    return 0;\\n                else\\t\\t\\t\\t\\t\\t\\t                    // if previous digit is valid, then update the output\\n                    res = res * fib(((i+1)-2) - prev + 1);\\t\\t    // for cluster preceding cluster containing zero\\n            }\\n\\n            else if(i == n-1)\\t\\t\\t\\t\\t\\t                // for last position\\n                res = res * fib(i+1 - prev + 1);\\n\\n            else if((s[i] == \\'2\\') && (i+1 < n) && (s[i+1] > \\'6\\'))\\t// if current digit is \\'2\\' and next digit is > \\'6\\'\\n                res = res * fib(i+1 - prev + 1);\\t\\t\\t        // then digit \\'2\\' marks the end of cluster\\n\\n            else if(s[i] >= \\'3\\')\\t\\t\\t\\t\\t                // digits >= \\'3\\' marks the end of cluster\\n                res = res * fib(i+1 - prev + 1);\\n\\n            else\\n                continue;\\n            \\n            prev = i+1;       // if any \\'if\\' or \\'else if\\' condition works then prev marks the end of current cluster\\n        }                     // which is used to find no. of digits in next cluster\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\nIf there seems to be error somewhere, please let me know.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fib(int n) {\\n        double num = (sqrt(5) + 1) / 2;\\n        return round(pow(num, n) / sqrt(5));\\n    }\\n    \\n    int numDecodings(string s) {\\n        int n = s.size(), prev = 0, res = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                if(i == 0 || (s[i-1] == \\'0\\' || s[i-1] >= \\'3\\'))\\t\\t// checking for valid previous digit\\n                    return 0;\\n                else\\t\\t\\t\\t\\t\\t\\t                    // if previous digit is valid, then update the output\\n                    res = res * fib(((i+1)-2) - prev + 1);\\t\\t    // for cluster preceding cluster containing zero\\n            }\\n\\n            else if(i == n-1)\\t\\t\\t\\t\\t\\t                // for last position\\n                res = res * fib(i+1 - prev + 1);\\n\\n            else if((s[i] == \\'2\\') && (i+1 < n) && (s[i+1] > \\'6\\'))\\t// if current digit is \\'2\\' and next digit is > \\'6\\'\\n                res = res * fib(i+1 - prev + 1);\\t\\t\\t        // then digit \\'2\\' marks the end of cluster\\n\\n            else if(s[i] >= \\'3\\')\\t\\t\\t\\t\\t                // digits >= \\'3\\' marks the end of cluster\\n                res = res * fib(i+1 - prev + 1);\\n\\n            else\\n                continue;\\n            \\n            prev = i+1;       // if any \\'if\\' or \\'else if\\' condition works then prev marks the end of current cluster\\n        }                     // which is used to find no. of digits in next cluster\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355796,
                "title": "golang-recursive-iterative-solutions",
                "content": "# Recursive Way\\nIf the string is `\"1234\"`, we can tell that we have 2 ways to decode.\\n1. Take the first num\\n2. Take the first two nums\\n\\nThen it seems to like a recursion: `f(\"1234\") = f(\"234\") + f(\"34\")`. When it comes to recursion, we think about our base case. \\n1. string is `\"\"`, we return `1`.\\n2. string is `\"0\"` or start with `\"0\"`, we return `0`. `\"0\"` is not a valid num.\\n\\nAnother thing we need to consider is that if there is any dulplicated computation. In this case, we do. Let\\'s consider `\"11111\"`.\\n`f(\"11111\") = f(\"1111\") + f(\"111\")`  We can tell that `f(\"1111\")  = f(\"111\") + f(\"11\")`, so we are calculating `f(\"111\")` again. Then we can use memoization to prevent duplicated calculations.\\n\\n```\\nfunc numDecodings(s string) int {\\n\\tsol := Solution{mp: map[string]int{}}\\n\\treturn sol.Decode(s)\\n}\\n\\ntype Solution struct {\\n\\tmp map[string]int\\n}\\n\\nfunc (sol *Solution) Decode(s string) int {\\n\\tif n, ok := sol.mp[s]; ok {\\n\\t\\treturn n\\n\\t}\\n\\tif len(s) <= 1 && s != \"0\" {\\n\\t\\treturn 1\\n\\t}\\n\\tif s[0] == \\'0\\' {\\n\\t\\treturn 0\\n\\t}\\n\\tnum := sol.Decode(s[1:])\\n\\tif n, _ := strconv.Atoi(s[:2]); n >= 10 && n <= 26 {\\n\\t\\tnum += sol.Decode(s[2:])\\n\\t}\\n\\tsol.mp[s] = num\\n\\treturn num\\n}\\n```\\n\\n# Iterative Way\\nFirst, we need to define our `dp[i]`. In this case, `dp[i]` is the num of decode ways. Then we need to define our dp formula.\\n1. Obviously, when we move only one num, `dp[i] = dp[i-1]`.  `\"12\"` => `[1, 2]`. \\n2. When we try to move two nums, `dp[i] += dp[i-2]`. `\"12\"` => `[1, 2]` + `[12]`.\\n\\n```\\nfunc numDecodings(s string) int {\\n\\tif s == \"0\" {\\n\\t\\treturn 0\\n\\t}\\n\\tif len(s) <= 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp := make([]int, len(s)+1)\\n\\tdp[0], dp[1] = 1, 1\\n\\tif s[0] == \\'0\\' {\\n\\t\\tdp[1] = 0\\n\\t}\\n\\tfor i := 2; i <= len(s); i++ {\\n\\t\\tif single, _ := strconv.Atoi(s[i-1 : i]); single > 0 {\\n\\t\\t\\tdp[i] = dp[i-1]\\n\\t\\t}\\n\\t\\tif double, _ := strconv.Atoi(s[i-2 : i]); double >= 10 && double <= 26 {\\n\\t\\t\\tdp[i] += dp[i-2]\\n\\t\\t}\\n\\t}\\n\\treturn dp[len(s)]\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunc numDecodings(s string) int {\\n\\tsol := Solution{mp: map[string]int{}}\\n\\treturn sol.Decode(s)\\n}\\n\\ntype Solution struct {\\n\\tmp map[string]int\\n}\\n\\nfunc (sol *Solution) Decode(s string) int {\\n\\tif n, ok := sol.mp[s]; ok {\\n\\t\\treturn n\\n\\t}\\n\\tif len(s) <= 1 && s != \"0\" {\\n\\t\\treturn 1\\n\\t}\\n\\tif s[0] == \\'0\\' {\\n\\t\\treturn 0\\n\\t}\\n\\tnum := sol.Decode(s[1:])\\n\\tif n, _ := strconv.Atoi(s[:2]); n >= 10 && n <= 26 {\\n\\t\\tnum += sol.Decode(s[2:])\\n\\t}\\n\\tsol.mp[s] = num\\n\\treturn num\\n}\\n```\n```\\nfunc numDecodings(s string) int {\\n\\tif s == \"0\" {\\n\\t\\treturn 0\\n\\t}\\n\\tif len(s) <= 1 {\\n\\t\\treturn 1\\n\\t}\\n\\tdp := make([]int, len(s)+1)\\n\\tdp[0], dp[1] = 1, 1\\n\\tif s[0] == \\'0\\' {\\n\\t\\tdp[1] = 0\\n\\t}\\n\\tfor i := 2; i <= len(s); i++ {\\n\\t\\tif single, _ := strconv.Atoi(s[i-1 : i]); single > 0 {\\n\\t\\t\\tdp[i] = dp[i-1]\\n\\t\\t}\\n\\t\\tif double, _ := strconv.Atoi(s[i-2 : i]); double >= 10 && double <= 26 {\\n\\t\\t\\tdp[i] += dp[i-2]\\n\\t\\t}\\n\\t}\\n\\treturn dp[len(s)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240757,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\n- Here we use an array of size `n + 1` to save sub-problem solutions. `dp[0]` means an empty string will have one way to decode, `dp[1]` means the number of ways to decode a string of size `1` and so on. \\n- Then we will check one digit and two digit combination and save the results along the way. Finally, `dp[n]` will be the end result.\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n\\n```\\nclass Solution\\n{\\n    public int numDecodings(String s)\\n\\t{\\n        if(s.isEmpty() || s.charAt(0) == \\'0\\')\\n            return 0;\\n\\n\\t\\tint n = s.length();\\n        int[] dp = new int[s.length() + 1];\\n\\t\\tdp[0] = dp[1] = 1;\\n\\n\\t\\tfor(int i = 2; i <= n; i++)\\n\\t\\t{\\n            int first  = Integer.parseInt(s.substring(i - 1, i));\\n            int second = Integer.parseInt(s.substring(i - 2, i));\\n\\n\\t\\t\\tif(first >= 1 && first <= 9)     dp[i] += dp[i - 1];\\n\\t\\t\\tif(second >= 10 && second <= 26) dp[i] += dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int numDecodings(String s)\\n\\t{\\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\tint prev = 26;\\n\\t\\tint result = 0;\\n\\t\\tint first = 1, second = 1;\\n\\t\\t\\n\\t\\tfor(int i = s.length() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tint digit = s.charAt(i) - \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\tif(digit == 0)\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tresult = first + (digit * 10 + prev <= 26 ? second : 0);\\n\\t\\t\\t\\n\\t\\t\\tsecond = first;\\n\\t\\t\\tfirst = result; \\n\\t\\t\\tprev = digit;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int numDecodings(String s)\\n\\t{\\n        if(s.isEmpty() || s.charAt(0) == \\'0\\')\\n            return 0;\\n\\n\\t\\tint n = s.length();\\n        int[] dp = new int[s.length() + 1];\\n\\t\\tdp[0] = dp[1] = 1;\\n\\n\\t\\tfor(int i = 2; i <= n; i++)\\n\\t\\t{\\n            int first  = Integer.parseInt(s.substring(i - 1, i));\\n            int second = Integer.parseInt(s.substring(i - 2, i));\\n\\n\\t\\t\\tif(first >= 1 && first <= 9)     dp[i] += dp[i - 1];\\n\\t\\t\\tif(second >= 10 && second <= 26) dp[i] += dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int numDecodings(String s)\\n\\t{\\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\tint prev = 26;\\n\\t\\tint result = 0;\\n\\t\\tint first = 1, second = 1;\\n\\t\\t\\n\\t\\tfor(int i = s.length() - 1; i >= 0; i--)\\n\\t\\t{\\n\\t\\t\\tint digit = s.charAt(i) - \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\tif(digit == 0)\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tresult = first + (digit * 10 + prev <= 26 ? second : 0);\\n\\t\\t\\t\\n\\t\\t\\tsecond = first;\\n\\t\\t\\tfirst = result; \\n\\t\\t\\tprev = digit;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645397,
                "title": "c-simple-dp-solution-with-explanation-recursion-tree",
                "content": "```\\nALGORITHM\\n1 start from index 0\\n2 we can take 1 char or  2 char from current index depending on condition\\n3 if we take 1 char that char should not be zero otherwise we return 0 because that is not valid encoding  and increment index to index++ if char is not zero \\n4 if we take 2 char, number representaion of two char should be less than equal to 26 and increment index to index=index+2 if it is less than or equal to 26\\n5 store the answer in dp table for current index (overlapping sub problems) shown in attached Image\\n6 return the answer obtain by taking 1 char at time + answer obtain by taking 2 char at time\\n7 base condition => index can reach to last index that is N-1 or can reach to string length that is N depending on example shown in attached Image\\n```\\n\\n![image](https://assets.leetcode.com/users/images/99baf817-a414-4316-81b8-47ef7735ed74_1664619113.416189.jpeg)\\n![image](https://assets.leetcode.com/users/images/50d8cb9e-6a3e-43c3-ac80-2205151f7c49_1664619159.7111208.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int recursion(int cur_ind,  string& str, int& len, vector<int>& dp){\\n        \\n        // if we reach at index where value of char is zero\\n        if(cur_ind<=len-1 and str[cur_ind]==\\'0\\'){\\n            return dp[cur_ind]=0;\\n        }\\n        \\n        // if we reach last index or reach to string length\\n        if(cur_ind==len-1 or cur_ind==len){\\n            return 1;\\n        }\\n        \\n        // if we already have an entry on dp table\\n        if(dp[cur_ind]!=0){\\n            return dp[cur_ind];\\n        }\\n        \\n        // store the one and two char in integer form \\n        int char1=str[cur_ind]-\\'0\\', char2=10*(str[cur_ind]-\\'0\\')+(str[cur_ind+1]-\\'0\\');\\n        \\n        // we can always take 1 char except when it is zero and for zero we already return from above code\\n        dp[cur_ind]=recursion(cur_ind+1, str, len, dp);\\n        \\n        // we can take two char if form interger value less than or equal to 26\\n        if(char2<=26){\\n             // as answer always fits in a 32-bit integer so we dont have to take long long \\n            dp[cur_ind]+=recursion(cur_ind+2, str, len, dp);\\n        }\\n        \\n        return dp[cur_ind];\\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        // length of string\\n        int n=s.size();\\n        \\n        // declaring 1D dp table \\n        vector<int>dp(n,0);\\n        \\n        return recursion(0,s,n,dp);\\n    }\\n};\\n```\\n```\\nTIME COMPLEXITY \\nas we calculate answer for each index only once therefore time complexity is O(N)\\n\\nSPACE COMPLEXITY \\nas we use dp table of length N therefore space complexity is also O(N)\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nALGORITHM\\n1 start from index 0\\n2 we can take 1 char or  2 char from current index depending on condition\\n3 if we take 1 char that char should not be zero otherwise we return 0 because that is not valid encoding  and increment index to index++ if char is not zero \\n4 if we take 2 char, number representaion of two char should be less than equal to 26 and increment index to index=index+2 if it is less than or equal to 26\\n5 store the answer in dp table for current index (overlapping sub problems) shown in attached Image\\n6 return the answer obtain by taking 1 char at time + answer obtain by taking 2 char at time\\n7 base condition => index can reach to last index that is N-1 or can reach to string length that is N depending on example shown in attached Image\\n```\n```\\nclass Solution {\\npublic:\\n    int recursion(int cur_ind,  string& str, int& len, vector<int>& dp){\\n        \\n        // if we reach at index where value of char is zero\\n        if(cur_ind<=len-1 and str[cur_ind]==\\'0\\'){\\n            return dp[cur_ind]=0;\\n        }\\n        \\n        // if we reach last index or reach to string length\\n        if(cur_ind==len-1 or cur_ind==len){\\n            return 1;\\n        }\\n        \\n        // if we already have an entry on dp table\\n        if(dp[cur_ind]!=0){\\n            return dp[cur_ind];\\n        }\\n        \\n        // store the one and two char in integer form \\n        int char1=str[cur_ind]-\\'0\\', char2=10*(str[cur_ind]-\\'0\\')+(str[cur_ind+1]-\\'0\\');\\n        \\n        // we can always take 1 char except when it is zero and for zero we already return from above code\\n        dp[cur_ind]=recursion(cur_ind+1, str, len, dp);\\n        \\n        // we can take two char if form interger value less than or equal to 26\\n        if(char2<=26){\\n             // as answer always fits in a 32-bit integer so we dont have to take long long \\n            dp[cur_ind]+=recursion(cur_ind+2, str, len, dp);\\n        }\\n        \\n        return dp[cur_ind];\\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        // length of string\\n        int n=s.size();\\n        \\n        // declaring 1D dp table \\n        vector<int>dp(n,0);\\n        \\n        return recursion(0,s,n,dp);\\n    }\\n};\\n```\n```\\nTIME COMPLEXITY \\nas we calculate answer for each index only once therefore time complexity is O(N)\\n\\nSPACE COMPLEXITY \\nas we use dp table of length N therefore space complexity is also O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645274,
                "title": "c-4-different-approaches-backtracking-top-down-and-bottom-up-dp",
                "content": "### Approach 1: backtracking (TLE)\\n\\nOur first naiive approach is to use backtracking, but obviosuly this is way too slow to be accepted.\\n\\n```cpp\\n    static int numDecodings(const string& s) {\\n        int ans = 0;\\n        bt(0, s, ans);\\n        return ans;\\n    }\\n \\n    static void bt(int i, const string& s, int& ans) {\\n        if (i == s.size()) {\\n            ++ans;\\n            return;\\n        }\\n        \\n        char ch = s[i];\\n        if (ch == \\'1\\') {\\n            // just A\\n            bt(i + 1, s, ans);\\n            // 10 .. 19\\n            if (i + 1 < s.size()) {\\n                bt(i + 2, s, ans);\\n            }\\n        } else if (ch == \\'2\\') {\\n            // just B\\n            bt(i + 1, s, ans);\\n            // 20 .. 26\\n            if (i + 1 < s.size()) {\\n                ch = s[i + 1];\\n                if (\\'0\\' <= ch && ch <= \\'6\\') {\\n                    bt(i + 2, s, ans);\\n                } else {\\n                    return;\\n                }\\n            }\\n        } else if (ch == \\'0\\') {\\n            // nothing starts with 0\\n            return;\\n        } else {\\n            // for 3 .. 9 there is only one way\\n            bt(i + 1, s, ans);\\n        }\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(2^n)$$ as the worst case would be string with all \\'1\\'s or similar.\\n  * Space Complexity: $$O(n)$$ for the recursion stack space\\n\\n### Approach 2: top down DP with memoization\\n\\nWe can easily improve approach 1 by adding memoization.\\n\\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> memo(size(s), -1);\\n        return dp(s, 0, memo);\\n    }\\n    \\n    static int dp(const string& s, int i, vector<int>& memo) {\\n        if (i == size(s)) return 1;\\n        \\n        if (memo[i] != -1) return memo[i];\\n        int ans = 0;\\n        \\n        if (s[i] == \\'0\\') {\\n            // Nothing starts with 0.\\n            ans = 0;\\n        } else if (s[i] == \\'1\\') {\\n            // Just \\'A\\'\\n            ans = dp(s, i + 1, memo);\\n            // 10..19\\n            if (i + 1 < size(s)) {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        } else if (s[i] == \\'2\\') {\\n            // Just \\'B\\'\\n            ans = dp(s, i + 1, memo);\\n            // 20..26\\n            if (i + 1 < size(s) && s[i + 1] <= \\'6\\') {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        } else {\\n            // 3..9 there is only one way\\n            ans = dp(s, i + 1, memo);\\n        }\\n        \\n        return memo[i] = ans;\\n    }\\n ```\\n\\nWe could make the logic a bit more compact:\\n\\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> memo(size(s), -1);\\n        return dp(s, 0, memo);\\n    }\\n    \\n    static int dp(const string& s, int i, vector<int>& memo) {\\n        if (i == size(s)) return 1;\\n        \\n        if (memo[i] != -1) return memo[i];\\n        int ans = 0;\\n        \\n        if (s[i] == \\'0\\') {\\n            ans = 0;\\n        } else {\\n            ans = dp(s, i + 1, memo);\\n            if (i + 1 < size(s) && (s[i] == \\'1\\'  || s[i] == \\'2\\' && s[i + 1] <= \\'6\\')) {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        }\\n        \\n        return memo[i] = ans;\\n    }\\n ```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ with $$n$$ being the length of the string. Memoization helps to prune the recurision tree and makes the differenc here.\\n  * Space Complexity: $$O(n)$$ for ```memo``` but also for the the recursion stack.\\n\\n### Approach 3: bottom up DP\\n\\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> dp(size(s) + 1, 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] != \\'0\\';\\n        for (int i = 2; i < size(dp); ++i) {\\n            if (s[i - 1] != \\'0\\')  {\\n                dp[i] = dp[i - 1];\\n            }\\n            if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\' && s[i - 1] <= \\'6\\') {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[size(s)];\\n    }\\n ```\\n\\n**Complexity Analsysis**\\n  * Time complexity: $$O(n)$$ we loop once of the string.\\n  * Space complexity: $$O(n)$$ for ```dp```.\\n\\n### Approach 4: constant space bottom up DP\\n\\nWe can improve over approach 3, because we are only ever looking back 2 in the ```dp``` vector, by just using explict variables for looking back 1 resp. looking back 2.\\n\\n```cpp\\n    static int numDecodings(const string& s) {\\n        if (s[0] == \\'0\\') return 0;\\n        \\n        int back_1 = 1;\\n        int back_2 = 1;\\n        for (int i = 1; i < size(s); ++i) {\\n            int current = s[i] != \\'0\\' ? back_1 : 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] <= \\'6\\') {\\n                current += back_2;\\n            }\\n            back_2 = back_1;\\n            back_1 = current;\\n        }\\n\\n        return back_1;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n_As alwasy: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy. :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n    static int numDecodings(const string& s) {\\n        int ans = 0;\\n        bt(0, s, ans);\\n        return ans;\\n    }\\n \\n    static void bt(int i, const string& s, int& ans) {\\n        if (i == s.size()) {\\n            ++ans;\\n            return;\\n        }\\n        \\n        char ch = s[i];\\n        if (ch == \\'1\\') {\\n            // just A\\n            bt(i + 1, s, ans);\\n            // 10 .. 19\\n            if (i + 1 < s.size()) {\\n                bt(i + 2, s, ans);\\n            }\\n        } else if (ch == \\'2\\') {\\n            // just B\\n            bt(i + 1, s, ans);\\n            // 20 .. 26\\n            if (i + 1 < s.size()) {\\n                ch = s[i + 1];\\n                if (\\'0\\' <= ch && ch <= \\'6\\') {\\n                    bt(i + 2, s, ans);\\n                } else {\\n                    return;\\n                }\\n            }\\n        } else if (ch == \\'0\\') {\\n            // nothing starts with 0\\n            return;\\n        } else {\\n            // for 3 .. 9 there is only one way\\n            bt(i + 1, s, ans);\\n        }\\n    }\\n```\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> memo(size(s), -1);\\n        return dp(s, 0, memo);\\n    }\\n    \\n    static int dp(const string& s, int i, vector<int>& memo) {\\n        if (i == size(s)) return 1;\\n        \\n        if (memo[i] != -1) return memo[i];\\n        int ans = 0;\\n        \\n        if (s[i] == \\'0\\') {\\n            // Nothing starts with 0.\\n            ans = 0;\\n        } else if (s[i] == \\'1\\') {\\n            // Just \\'A\\'\\n            ans = dp(s, i + 1, memo);\\n            // 10..19\\n            if (i + 1 < size(s)) {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        } else if (s[i] == \\'2\\') {\\n            // Just \\'B\\'\\n            ans = dp(s, i + 1, memo);\\n            // 20..26\\n            if (i + 1 < size(s) && s[i + 1] <= \\'6\\') {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        } else {\\n            // 3..9 there is only one way\\n            ans = dp(s, i + 1, memo);\\n        }\\n        \\n        return memo[i] = ans;\\n    }\\n ```\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> memo(size(s), -1);\\n        return dp(s, 0, memo);\\n    }\\n    \\n    static int dp(const string& s, int i, vector<int>& memo) {\\n        if (i == size(s)) return 1;\\n        \\n        if (memo[i] != -1) return memo[i];\\n        int ans = 0;\\n        \\n        if (s[i] == \\'0\\') {\\n            ans = 0;\\n        } else {\\n            ans = dp(s, i + 1, memo);\\n            if (i + 1 < size(s) && (s[i] == \\'1\\'  || s[i] == \\'2\\' && s[i + 1] <= \\'6\\')) {\\n                ans += dp(s, i + 2, memo);\\n            }\\n        }\\n        \\n        return memo[i] = ans;\\n    }\\n ```\n```memo```\n```cpp\\n    static int numDecodings(const string& s) {\\n        vector<int> dp(size(s) + 1, 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] != \\'0\\';\\n        for (int i = 2; i < size(dp); ++i) {\\n            if (s[i - 1] != \\'0\\')  {\\n                dp[i] = dp[i - 1];\\n            }\\n            if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\' && s[i - 1] <= \\'6\\') {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[size(s)];\\n    }\\n ```\n```dp```\n```dp```\n```cpp\\n    static int numDecodings(const string& s) {\\n        if (s[0] == \\'0\\') return 0;\\n        \\n        int back_1 = 1;\\n        int back_2 = 1;\\n        for (int i = 1; i < size(s); ++i) {\\n            int current = s[i] != \\'0\\' ? back_1 : 0;\\n            if (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\' && s[i] <= \\'6\\') {\\n                current += back_2;\\n            }\\n            back_2 = back_1;\\n            back_1 = current;\\n        }\\n\\n        return back_1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987092,
                "title": "decode-ways-c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        //only one character available\\n        dp[1]=1;\\n        \\n        //dp[i] denotes number of ways possible with i length string\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            //check if previous character is greater than zero\\n            if(s[i-1]-\\'0\\'>0){\\n                dp[i]=dp[i-1];\\n            }\\n            \\n            //taking 2 characters at once \\n            if(s[i-2]==\\'1\\' || (s[i-2]-\\'0\\'==2 && s[i-1]-\\'0\\'<7)){\\n                dp[i]+=dp[i-2];\\n            }   \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.length();\\n        if(s[0]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        //only one character available\\n        dp[1]=1;\\n        \\n        //dp[i] denotes number of ways possible with i length string\\n        \\n        for(int i=2;i<=n;i++){\\n            \\n            //check if previous character is greater than zero\\n            if(s[i-1]-\\'0\\'>0){\\n                dp[i]=dp[i-1];\\n            }\\n            \\n            //taking 2 characters at once \\n            if(s[i-2]==\\'1\\' || (s[i-2]-\\'0\\'==2 && s[i-1]-\\'0\\'<7)){\\n                dp[i]+=dp[i-2];\\n            }   \\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224956,
                "title": "dp-explained-clearly",
                "content": "**Solution0 (TLE)**\\nWe will start from the first char and at each char, we have two choices - decode single char or decode this char and the next combined. If we are able to decode, we move the index `i` accordingly and make recursive call on the subproblem (substring).\\nSo if we reach end of the string or past the end, we know we are able to decode, otherwise we would have quit at earlier index where decoding failed.\\nWhat does decoding failed mean? If it is a single char, corrsponding int value should be `[1-9]`.\\ndouble char int val should be `[10-26]` and it shouldn\\'t start with `0` ( I mean \"01\" is not \"1\", so can\\'t decode).\\n\\n```\\npublic int numDecodings(String s) {\\n        return helper(s, 0);\\n    }\\n    private int helper(String s, int i){\\n        if(i >= s.length()) return 1;\\n        int count = 0;\\n        int val = Integer.parseInt(s.substring(i, i+1));\\n        if(1 <= val && val <= 9)\\n            count +=  helper(s, i+1);\\n        if(s.charAt(i) != \\'0\\' && i+1 < s.length() && Integer.parseInt(s.substring(i, i+2)) <= 26)\\n            count += helper(s, i+2);\\n        return count;\\n    }\\n```\\n**Solution1** Add memoization for overlapping subproblems\\n```\\nclass Solution {\\n    Integer[] dp = null;\\n    public int numDecodings(String s) {\\n        dp = new Integer[s.length()+1];\\n        return helper(s, 0);\\n    }\\n    private int helper(String s, int i){\\n        if(i >= s.length()) return 1;\\n        if(dp[i] != null) return dp[i];\\n        dp[i] = 0;\\n        int val = Integer.parseInt(s.substring(i, i+1));\\n        if(1 <= val && val <= 9)\\n            dp[i] +=  helper(s, i+1);\\n        if(s.charAt(i) != \\'0\\' && i+1 < s.length() && Integer.parseInt(s.substring(i, i+2)) <= 26)\\n            dp[i] += helper(s, i+2);\\n        return dp[i];\\n    }\\n}\\n```\\n**Solution2** Another way to look at the problem is in bottom-up fashion.\\nSuppose you give me a string which can be decoded in 50 different ways. I can prefix my char to all those 50 ways and I can combine my char with your first char and see that can be decoded (i.e. <= 26) if yes, that decoded part can be prefixed with whatever # of ways the substring from `i+2` can be decoded.\\n\\n```\\npublic int numDecodings(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        if(s.charAt(n-1) != \\'0\\') \\n            dp[n-1] = 1;\\n        for(int i=n-2; i >= 0; i--){\\n            if(s.charAt(i) == \\'0\\') continue;\\n            dp[i] = dp[i+1];\\n            if(i+2 <= n){\\n                int num = Integer.parseInt(s.substring(i, i+2));\\n                if(num <= 26)\\n                    if(i+2 < n)\\n                        dp[i] += dp[i+2];\\n                    else\\n                        dp[i] += 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numDecodings(String s) {\\n        return helper(s, 0);\\n    }\\n    private int helper(String s, int i){\\n        if(i >= s.length()) return 1;\\n        int count = 0;\\n        int val = Integer.parseInt(s.substring(i, i+1));\\n        if(1 <= val && val <= 9)\\n            count +=  helper(s, i+1);\\n        if(s.charAt(i) != \\'0\\' && i+1 < s.length() && Integer.parseInt(s.substring(i, i+2)) <= 26)\\n            count += helper(s, i+2);\\n        return count;\\n    }\\n```\n```\\nclass Solution {\\n    Integer[] dp = null;\\n    public int numDecodings(String s) {\\n        dp = new Integer[s.length()+1];\\n        return helper(s, 0);\\n    }\\n    private int helper(String s, int i){\\n        if(i >= s.length()) return 1;\\n        if(dp[i] != null) return dp[i];\\n        dp[i] = 0;\\n        int val = Integer.parseInt(s.substring(i, i+1));\\n        if(1 <= val && val <= 9)\\n            dp[i] +=  helper(s, i+1);\\n        if(s.charAt(i) != \\'0\\' && i+1 < s.length() && Integer.parseInt(s.substring(i, i+2)) <= 26)\\n            dp[i] += helper(s, i+2);\\n        return dp[i];\\n    }\\n}\\n```\n```\\npublic int numDecodings(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        if(s.charAt(n-1) != \\'0\\') \\n            dp[n-1] = 1;\\n        for(int i=n-2; i >= 0; i--){\\n            if(s.charAt(i) == \\'0\\') continue;\\n            dp[i] = dp[i+1];\\n            if(i+2 <= n){\\n                int num = Integer.parseInt(s.substring(i, i+2));\\n                if(num <= 26)\\n                    if(i+2 < n)\\n                        dp[i] += dp[i+2];\\n                    else\\n                        dp[i] += 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30546,
                "title": "here-s-a-long-and-easy-solution-for-reference",
                "content": "    int numDecodings(string s) {\\n        if(s.size() == 0 || s[0] == '0')\\n            return 0;\\n        int len = s.size();\\n        vector<int> dp(len+1, 0);\\n        dp[0] = dp[1] = 1;\\n        for(int i=2; i<=len; i++){\\n            int a = s[i-2] - '0';\\n            int b = s[i-1] - '0';\\n            if(a == 0 && b == 0)\\n                return 0;\\n            if(a == 0 && b != 0){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            if(a != 0 && b == 0){\\n                if(a > 2)\\n                    return 0;\\n                else{\\n                    dp[i] = dp[i-2];\\n                    continue;\\n                }\\n            }\\n            int temp = a * 10 + b;\\n            if(temp > 26)\\n                dp[i] = dp[i-1];\\n            else\\n                dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[len];\\n    }",
                "solutionTags": [],
                "code": "    int numDecodings(string s) {\\n        if(s.size() == 0 || s[0] == '0')\\n            return 0;\\n        int len = s.size();\\n        vector<int> dp(len+1, 0);\\n        dp[0] = dp[1] = 1;\\n        for(int i=2; i<=len; i++){\\n            int a = s[i-2] - '0';\\n            int b = s[i-1] - '0';\\n            if(a == 0 && b == 0)\\n                return 0;\\n            if(a == 0 && b != 0){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            if(a != 0 && b == 0){\\n                if(a > 2)\\n                    return 0;\\n                else{\\n                    dp[i] = dp[i-2];\\n                    continue;\\n                }\\n            }\\n            int temp = a * 10 + b;\\n            if(temp > 26)\\n                dp[i] = dp[i-1];\\n            else\\n                dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[len];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30462,
                "title": "accepted-solution-to-decode-ways-no-need-to-take-care-of-0-case",
                "content": "This is my accepted solution. Please let me if there is any problem.\\n\\n\\n  \\n\\n    int numDecodings(string s) {\\n        int rows = s.size()+1;\\n        if (rows == 1) return 0;\\n        vector<int> A(rows, 0);\\n        A[0] = 1;\\n        for(int i = 1; i < rows; i++){\\n            // from one-digit number , range is from 1 to 9\\n            if (s[i-1] >= '1' && s[i-1] <= '9') A[i] += A[i-1];\\n            // form two-digit number, the range is from 10 to 26\\n            if (i-2 >= 0 && s.substr(i-2, 2) <= \"26\" && s.substr(i-2, 2) >= \"10\"){\\n                A[i] += A[i-2];\\n            }\\n        }\\n        return A[rows-1];\\n    }",
                "solutionTags": [],
                "code": "This is my accepted solution. Please let me if there is any problem.\\n\\n\\n  \\n\\n    int numDecodings(string s) {\\n        int rows = s.size()+1;\\n        if (rows == 1) return 0;\\n        vector<int> A(rows, 0);\\n        A[0] = 1;\\n        for(int i = 1; i < rows; i++){\\n            // from one-digit number , range is from 1 to 9\\n            if (s[i-1] >= '1' && s[i-1] <= '9') A[i] += A[i-1];\\n            // form two-digit number, the range is from 10 to 26\\n            if (i-2 >= 0 && s.substr(i-2, 2) <= \"26\" && s.substr(i-2, 2) >= \"10\"){\\n                A[i] += A[i-2];\\n            }\\n        }\\n        return A[rows-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3185762,
                "title": "decode-ways-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- First, check if the first character is \\'0\\' or the string is empty, return 0.\\n- Initialize two variables dp[0] and dp[1] to 1, representing the number of ways to decode the empty string and 1 character respectively.\\n- Then, for each character s[i] starting from the second character, check if it can be decoded as a single digit or with the previous character, if yes, add the number of ways to decode the corresponding substrings ending at i - 1 and i - 2.\\n- Finally, return dp[n] which is the number of ways to decode the complete string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\': # if the first character is \\'0\\', return 0\\n            return 0\\n        n = len(s)\\n        dp = [0] * (n + 1) # create an array of length n + 1 to store number of ways\\n        dp[0], dp[1] = 1, 1 # initialize the first two elements as 1, as there is 1 way to decode empty string and 1 character\\n        for i in range(2, n + 1):\\n            if s[i - 1] != \\'0\\': # if current character is not \\'0\\', then it can be a single digit\\n                dp[i] += dp[i - 1] # add the number of ways to decode the substring ending at i - 1\\n            if s[i - 2] == \\'1\\' or (s[i - 2] == \\'2\\' and s[i - 1] <= \\'6\\'): # if the current and previous character together can be decoded\\n                dp[i] += dp[i - 2] # add the number of ways to decode the substring ending at i - 2\\n        return dp[n] # return the number of ways to decode the complete string\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if not s or s[0] == \\'0\\': # if the first character is \\'0\\', return 0\\n            return 0\\n        n = len(s)\\n        dp = [0] * (n + 1) # create an array of length n + 1 to store number of ways\\n        dp[0], dp[1] = 1, 1 # initialize the first two elements as 1, as there is 1 way to decode empty string and 1 character\\n        for i in range(2, n + 1):\\n            if s[i - 1] != \\'0\\': # if current character is not \\'0\\', then it can be a single digit\\n                dp[i] += dp[i - 1] # add the number of ways to decode the substring ending at i - 1\\n            if s[i - 2] == \\'1\\' or (s[i - 2] == \\'2\\' and s[i - 1] <= \\'6\\'): # if the current and previous character together can be decoded\\n                dp[i] += dp[i - 2] # add the number of ways to decode the substring ending at i - 2\\n        return dp[n] # return the number of ways to decode the complete string\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884637,
                "title": "three-levels-of-solving-dp-problems",
                "content": "### Recursion Technique (TLE)\\nThe simple technique of recursion is that we check whether this particular string set of len 1 and len 2 is valid or not. If found valid we recurse on the path\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1)\\n            return (i >= 1 && i <= 9);\\n        else\\n            return (i >= 10 && i <= 26);\\n    }\\n    int cnt(int i , string& s){\\n        if(i >= s.size()){\\n            return 1;\\n        }\\n        int ans = 0;\\n        if(isValid(s[i] - \\'0\\' , 1)){\\n            ans += cnt(i+1 , s);\\n        }\\n        if(i<s.size() - 1 && isValid(((s[i] - \\'0\\')*10 + (s[i+1] - \\'0\\')) , 2)){\\n            ans += cnt(i+2 , s); \\n        }\\n        return ans;\\n    }\\n    int numDecodings(string s) {\\n        return cnt(0 , s);\\n    }\\n};\\n```\\nwe have to keep in mind to check at the last char as there might be a case like we are on last index and checking for nth position as it doesnt exist.\\n\\n### Top-Down Meomoization Based Solution \\nAs we all know that there would be many overlapping sub-problems in the recursive approch so we memoize it by using an array/vector and check if this problem we are facing is new or already solved.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1)\\n            return (i >= 1 && i <= 9);\\n        else\\n            return (i >= 10 && i <= 26);\\n    }\\n    int cnt(int i , string& s , vector<int>& dp){\\n        if(i >= s.size()){\\n            return 1;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        dp[i] = 0;\\n        if(isValid(s[i] - \\'0\\' , 1)){\\n            dp[i] += cnt(i+1 , s , dp);\\n        }\\n        if(i<s.size() - 1 && isValid(((s[i] - \\'0\\')*10 + (s[i+1] - \\'0\\')) , 2)){\\n            dp[i] += cnt(i+2 , s , dp); \\n        }\\n        return dp[i];\\n    }\\n    int numDecodings(string s) {\\n        vector<int> dp(s.size(), -1);\\n        return cnt(0 , s , dp);\\n    }\\n};\\n```\\n### Bottom-Up Approach \\nAs we all know there would be a bottom-up approch too to solve a dp problem so here it is.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1){\\n            return (i >= 1 && i <= 9);\\n        }\\n        else{\\n            return (i >= 10 && i <= 26);\\n        }\\n    }\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n);\\n        dp[0] = isValid(s[0] - \\'0\\' , 1)? 1 : 0;\\n        if(n == 1){\\n            return dp[0];\\n        }\\n        dp[1] = 0;\\n        if(isValid((s[1] - \\'0\\') , 1)){\\n            dp[1] += dp[0];\\n        }\\n        if(isValid((s[0] - \\'0\\')*10 + (s[1] - \\'0\\') , 2)){\\n            dp[1] += 1;\\n        }\\n        for(int i = 2 ; i < n ; i++){\\n            dp[i] = 0;\\n            if(isValid((s[i] - \\'0\\') , 1)){\\n                dp[i] += dp[i-1];\\n            }\\n            if(isValid((s[i-1] - \\'0\\')*10 + s[i] - \\'0\\' , 2)){\\n                dp[i] += dp[i-2];\\n            }   \\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\nThank you for reading. If you like it do Up-Vote . Thank You",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1)\\n            return (i >= 1 && i <= 9);\\n        else\\n            return (i >= 10 && i <= 26);\\n    }\\n    int cnt(int i , string& s){\\n        if(i >= s.size()){\\n            return 1;\\n        }\\n        int ans = 0;\\n        if(isValid(s[i] - \\'0\\' , 1)){\\n            ans += cnt(i+1 , s);\\n        }\\n        if(i<s.size() - 1 && isValid(((s[i] - \\'0\\')*10 + (s[i+1] - \\'0\\')) , 2)){\\n            ans += cnt(i+2 , s); \\n        }\\n        return ans;\\n    }\\n    int numDecodings(string s) {\\n        return cnt(0 , s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1)\\n            return (i >= 1 && i <= 9);\\n        else\\n            return (i >= 10 && i <= 26);\\n    }\\n    int cnt(int i , string& s , vector<int>& dp){\\n        if(i >= s.size()){\\n            return 1;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        dp[i] = 0;\\n        if(isValid(s[i] - \\'0\\' , 1)){\\n            dp[i] += cnt(i+1 , s , dp);\\n        }\\n        if(i<s.size() - 1 && isValid(((s[i] - \\'0\\')*10 + (s[i+1] - \\'0\\')) , 2)){\\n            dp[i] += cnt(i+2 , s , dp); \\n        }\\n        return dp[i];\\n    }\\n    int numDecodings(string s) {\\n        vector<int> dp(s.size(), -1);\\n        return cnt(0 , s , dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int len){\\n        if(len == 1){\\n            return (i >= 1 && i <= 9);\\n        }\\n        else{\\n            return (i >= 10 && i <= 26);\\n        }\\n    }\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n);\\n        dp[0] = isValid(s[0] - \\'0\\' , 1)? 1 : 0;\\n        if(n == 1){\\n            return dp[0];\\n        }\\n        dp[1] = 0;\\n        if(isValid((s[1] - \\'0\\') , 1)){\\n            dp[1] += dp[0];\\n        }\\n        if(isValid((s[0] - \\'0\\')*10 + (s[1] - \\'0\\') , 2)){\\n            dp[1] += 1;\\n        }\\n        for(int i = 2 ; i < n ; i++){\\n            dp[i] = 0;\\n            if(isValid((s[i] - \\'0\\') , 1)){\\n                dp[i] += dp[i-1];\\n            }\\n            if(isValid((s[i-1] - \\'0\\')*10 + s[i] - \\'0\\' , 2)){\\n                dp[i] += dp[i-2];\\n            }   \\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455062,
                "title": "0-ms-faster-than-100-c-solution-with-explanation",
                "content": "Explanation : At every position, we can create next character by 2 ways, First --> taking current value , Second--> taking last and current value.\\nNow coming to checking 2 ways, that is pretty simple, if last and current value are => (10, 11, 12, 13,  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26) .. Basically forming ASCII value of a character, but not (01, 02, 03 ...).\\nAnd we have 1 corner case that is --> if two or more zeroes are consectutive or first value is zero, in case our total ways will be 0.\\n\\nFor Implementation of above logic see code.\\n\\n\\tIF YOU LIKE MY CODE & EXPLANATION, PLEASE DO UPVOTE (<>)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.length();\\n        int dp[n + 1];\\n        memset(dp, 0, sizeof dp);\\n        dp[0] = 1;\\n        \\n        /*\\n\\n            11106\\n        idx 0 1 2 3 4 5        \\n        val 1 1 2 2 2 2\\n\\n        */\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                // if first character is 0 or consecutive 2 0s.\\n                if(!i || s[i - 1] == \\'0\\') {\\n                    return 0;\\n                }\\n                // if last and current is 10, 20.\\n                if(s[i - 1] == \\'1\\' or s[i - 1] == \\'2\\') {\\n                    dp[i + 1] = dp[i - 1];\\n                }\\n            } else if(s[i] >= \\'1\\' && s[i] <= \\'6\\') {\\n                dp[i + 1] = dp[i];\\n                // if last and current forms a valid ASCII\\n                if(i && (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\')) {\\n                    dp[i + 1] += dp[i - 1];\\n                }\\n            } else {\\n                dp[i + 1] = dp[i];\\n                // if last and current forms a valid ASCII\\n                if(i && s[i - 1] == \\'1\\') {\\n                    dp[i + 1] += dp[i - 1];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.length();\\n        int dp[n + 1];\\n        memset(dp, 0, sizeof dp);\\n        dp[0] = 1;\\n        \\n        /*\\n\\n            11106\\n        idx 0 1 2 3 4 5        \\n        val 1 1 2 2 2 2\\n\\n        */\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'0\\') {\\n                // if first character is 0 or consecutive 2 0s.\\n                if(!i || s[i - 1] == \\'0\\') {\\n                    return 0;\\n                }\\n                // if last and current is 10, 20.\\n                if(s[i - 1] == \\'1\\' or s[i - 1] == \\'2\\') {\\n                    dp[i + 1] = dp[i - 1];\\n                }\\n            } else if(s[i] >= \\'1\\' && s[i] <= \\'6\\') {\\n                dp[i + 1] = dp[i];\\n                // if last and current forms a valid ASCII\\n                if(i && (s[i - 1] == \\'1\\' || s[i - 1] == \\'2\\')) {\\n                    dp[i + 1] += dp[i - 1];\\n                }\\n            } else {\\n                dp[i + 1] = dp[i];\\n                // if last and current forms a valid ASCII\\n                if(i && s[i - 1] == \\'1\\') {\\n                    dp[i + 1] += dp[i - 1];\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328204,
                "title": "dp-solution-in-c-very-easy-to-understand",
                "content": "Let\\'s try to undersatand with one example, suppose we want to decode 1 2 2 6 \\nwhile decoding we have to remember that whatever number we will decode it must be lies between 1 to 26 (inclusive)\\n\\nas shown in fig1 every time we have to option either we consider  it as single digit and decode or consider it as valid two digit number and decode \\n\\nin this way we have generated all the possible ways \\n\\n![image](https://assets.leetcode.com/users/images/9b8ae529-f100-45f7-b27a-c7df35d13850_1625978366.5669765.jpeg)\\n\\nnow the question is how it is depend on previous decodes for that just see fig2 in which we find possible ways for 1 2 2 and 1 2 as decode number is either 1 digit or 2 digit\\n\\n![image](https://assets.leetcode.com/users/images/7bdf913b-545c-43d6-9fc6-d75e3969d75d_1625978466.0447922.jpeg)\\n\\n\\nnow from above figure we can easily conclude that whatever the no of ways to decode 1 2 2 similar no of ways are for 1 2 2 **6** if we consider 6 and for 26 whatever no of ways for 1 2 that no of ways for 1 2 **26**\\n\\njust we are adding upcombing digit to previous case either indivisually or combined with previous digit (if all this is valid we are checking that in code )\\n\\n\\n**code:**\\n\\nclass Solution \\n{\\n\\tpublic:\\n\\t\\tint numDecodings(string s) \\n\\t\\t{\\n         \\n\\t\\tint n=s.size();\\n\\t\\t\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;  // if string is empty there is  1 way to decode it i.e string is empty\\n        if(s[0]!=\\'0\\')\\n            dp[1]=1; //if the first digit is 0(zero) then there is no way to decode it as invisually or combined with other digit as (06 !=6)\\n        for(int i=2;i<=n;i++)\\n        {\\n            int op1=(s[i-1]-\\'0\\');\\n            int op2=(s[i-2]-\\'0\\')*10+(s[i-1]-\\'0\\');\\n            \\n            if(op1>=1)\\n                dp[i]+=dp[i-1];\\n            if(op2>=10&&op2<=26)\\n                dp[i]+=dp[i-2];   \\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nThanks !!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution \\n{\\n\\tpublic:\\n\\t\\tint numDecodings(string s) \\n\\t\\t{\\n         \\n\\t\\tint n=s.size();\\n\\t\\t\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;  // if string is empty there is  1 way to decode it i.e string is empty\\n        if(s[0]!=\\'0\\')\\n            dp[1]=1; //if the first digit is 0(zero) then there is no way to decode it as invisually or combined with other digit as (06 !=6)\\n        for(int i=2;i<=n;i++)\\n        {\\n            int op1=(s[i-1]-\\'0\\');\\n            int op2=(s[i-2]-\\'0\\')*10+(s[i-1]-\\'0\\');\\n            \\n            if(op1>=1)\\n                dp[i]+=dp[i-1];\\n            if(op2>=10&&op2<=26)\\n                dp[i]+=dp[i-2];   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1173373,
                "title": "javascript-top-down-memoization-solution-whiteboard",
                "content": "![image](https://assets.leetcode.com/users/images/9f426544-c9b7-4ed9-aa9b-7350c3d795cb_1619207097.408678.jpeg)\\n\\n```\\nvar numDecodings = function(s) {\\n  return count(s,0);\\n};\\n\\nvar count = function(str, i, memo=[]) {\\n  if (str[i] == \"0\") return 0;\\n  if (i >= str.length - 1) return 1;\\n  if (memo[i]) return memo[i];\\n\\n  // try to take 1 and 2\\n  let res = count(str, i+1, memo);\\n  if (parseInt(str[i] + str[i+1]) <= 26) {\\n      res += count(str, i+2, memo);\\n  }\\n\\n  memo[i] = res;\\n  return res;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numDecodings = function(s) {\\n  return count(s,0);\\n};\\n\\nvar count = function(str, i, memo=[]) {\\n  if (str[i] == \"0\") return 0;\\n  if (i >= str.length - 1) return 1;\\n  if (memo[i]) return memo[i];\\n\\n  // try to take 1 and 2\\n  let res = count(str, i+1, memo);\\n  if (parseInt(str[i] + str[i+1]) <= 26) {\\n      res += count(str, i+2, memo);\\n  }\\n\\n  memo[i] = res;\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459700,
                "title": "easy-python3-dp",
                "content": "![image](https://assets.leetcode.com/users/romavlasov/image_1577185293.png)\\n\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s) + 1)\\n        dp[0] = 1\\n        dp[1] = 1 if \\'1\\' <= s[0] <= \\'9\\' else 0\\n        \\n        for i in range(2, len(dp)):\\n            \\n            if \\'1\\' <= s[i - 1] <= \\'9\\':\\n                dp[i] += dp[i - 1]\\n                \\n            if \\'10\\' <= s[i - 2:i] <= \\'26\\':\\n                dp[i] += dp[i - 2]\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s) + 1)\\n        dp[0] = 1\\n        dp[1] = 1 if \\'1\\' <= s[0] <= \\'9\\' else 0\\n        \\n        for i in range(2, len(dp)):\\n            \\n            if \\'1\\' <= s[i - 1] <= \\'9\\':\\n                dp[i] += dp[i - 1]\\n                \\n            if \\'10\\' <= s[i - 2:i] <= \\'26\\':\\n                dp[i] += dp[i - 2]\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372420,
                "title": "python-o-n-time-o-1-space-detail-explanation-turtle-code",
                "content": "**Solution Credit to: [@forestsong](https://leetcode.com/problems/decode-ways/discuss/365232/Python-with-O(1)-space)**\\n\\n**I personaly had some hard time understanding this problem. Here is some intuitions that might help understanding.**\\n\\n.\\n.\\n# **Main Idea**\\n**============================ SIMULATION ===============================**\\n**Given Input: \\'12345\\'**\\n- Let there be a **function num_ways(str)** that returns number of ways to decode an str.\\n- The number of ways to decode the input string up to **index i = 3** will be sum of following cases:\\n\\t**- num_ways(\\'12\\') + \\'C\\' given that \\'3\\'= \\'C\\' is valid**\\n\\t**- num_ways(\\'1\\') + \\'W\\' given that \\'23\\' = \\'W\\' is also valid**\\n\\n- Looking at the first case: **\\'C\\' + num_ways(\\'12\\')**. This can futher be decompose into:\\n\\t**- num_ways(\\'1\\') + \\'BC\\' => return 1** (num ways to decode 1 char is always 1)\\n\\t**- num_ways(\\'\\') + \\'LC\\' => return 1** (num ways to decode 0 char is 1)\\n\\n- Looking at case: **\\'num_ways(\\'1\\') + \\'BC\\'**:\\n\\t**- \\'\\'num_ways(\\'\\') + \\'ABC\\' => return 1**\\n- Thus we got totatl 3 ways to decode string \\'123\\'\\n\\n**=========================== SIMULATION ENDS============================**\\n.\\n.\\n# **Formula**\\n```\\n\\'\\'\\'At any index i, we can get the total way to decode the input string up to and including index i by taking the sum of:\\'\\'\\'\\'\\'\\'\\'\\'\\'\\n\\t# if string[i] is valid, meaning its not \\'0\\' \\n\\t\\t- num_ways(string[ : i-1])\\n\\t# if \\'10\\' <= string[i-1:i+1] <= \\'26\\'\\n\\t\\t- num_ways(string[ : i-2])\\n```\\n.\\n.\\n# **Python 3 Code:**\\nWe can use **memorization** technique to improve the time complexity of fetching the number of ways to decode previous 2 levels.\\n```\\ndef numDecodings(self, s: str) -> int:\\n\\t\\t# no solution cases\\n        if not s or s[0] == \\'0\\': return 0\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tGiven a index i that we currently at:\\n\\t\\t\\tl1 : records number of ways to decode chars from index [0,i)\\n\\t\\t\\tl2 : records number of ways to decode chars from index [0, i-1)\\n\\t\\t\\tcur : records number of ways to decode chars from [0, i]\\n\\t\\t\\'\\'\\'\\'\\'\\'\\'\\'\\'\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n\\t\\tstarting with l1, l2 = 1, 1 because there is only 1 way to decode empty string a string with 1 char\\n\\t\\t\\'\\'\\'\\n        l1, l2, cur = 1, 1, 0\\n        for i in range(1, len(s)):\\n\\t\\t\\t# current char at index i is valid, update num way decode by l1\\n            if s[i] != \\'0\\':\\n                cur = l1\\n\\t\\t\\t# (current char) + (previous char) is valid, update num way decode by l2\\n            if \\'10\\' <= s[i-1:i+1] <= \\'26\\':\\n                cur += l2\\n\\t\\t\\t# update memorization values\\n            l1, l2, cur = cur, l1, 0\\n        \\n        return l1\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'At any index i, we can get the total way to decode the input string up to and including index i by taking the sum of:\\'\\'\\'\\'\\'\\'\\'\\'\\'\\n\\t# if string[i] is valid, meaning its not \\'0\\' \\n\\t\\t- num_ways(string[ : i-1])\\n\\t# if \\'10\\' <= string[i-1:i+1] <= \\'26\\'\\n\\t\\t- num_ways(string[ : i-2])\\n```\n```\\ndef numDecodings(self, s: str) -> int:\\n\\t\\t# no solution cases\\n        if not s or s[0] == \\'0\\': return 0\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tGiven a index i that we currently at:\\n\\t\\t\\tl1 : records number of ways to decode chars from index [0,i)\\n\\t\\t\\tl2 : records number of ways to decode chars from index [0, i-1)\\n\\t\\t\\tcur : records number of ways to decode chars from [0, i]\\n\\t\\t\\'\\'\\'\\'\\'\\'\\'\\'\\'\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n\\t\\tstarting with l1, l2 = 1, 1 because there is only 1 way to decode empty string a string with 1 char\\n\\t\\t\\'\\'\\'\\n        l1, l2, cur = 1, 1, 0\\n        for i in range(1, len(s)):\\n\\t\\t\\t# current char at index i is valid, update num way decode by l1\\n            if s[i] != \\'0\\':\\n                cur = l1\\n\\t\\t\\t# (current char) + (previous char) is valid, update num way decode by l2\\n            if \\'10\\' <= s[i-1:i+1] <= \\'26\\':\\n                cur += l2\\n\\t\\t\\t# update memorization values\\n            l1, l2, cur = cur, l1, 0\\n        \\n        return l1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 240637,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: \\'str\\') -> \\'int\\':\\n        def helper(i):\\n            if i in dic:\\n                return dic[i]\\n            if i >= len(s):\\n                return 1\\n            res = 0\\n            if 1 <= int(s[i]) <= 9:\\n                res += helper(i+1)\\n            if 10 <= int(s[i:i+2]) <= 26:\\n                res += helper(i+2)\\n            dic[i] = res\\n            return res\\n        dic = {}\\n        return helper(0) if s else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: \\'str\\') -> \\'int\\':\\n        def helper(i):\\n            if i in dic:\\n                return dic[i]\\n            if i >= len(s):\\n                return 1\\n            res = 0\\n            if 1 <= int(s[i]) <= 9:\\n                res += helper(i+1)\\n            if 10 <= int(s[i:i+2]) <= 26:\\n                res += helper(i+2)\\n            dic[i] = res\\n            return res\\n        dic = {}\\n        return helper(0) if s else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30661,
                "title": "my-java-dp-solution",
                "content": "This is my DP solution for this problem. The code is kind of long, which is not necessary. \\n\\nMy thought process is like this:\\n\\nFor the last digit in the string, \\n\\nif we take it as an individual letter, then the possibility depends on the rest of the string, \\n\\nif we take it along with the last but 1 digit to form one letter (which is from 10 to 26), the possibility depends on the rest of the but the last 2. \\n\\nIf we sum these 2 possibility, we can get the total possibility.\\n\\nSo `f(s) = f(s-last letter) + f(s - last 2 letters)`\\n\\nBut there are special cases:\\n\\nif the last 2 digits are not a letter, which is not from 10 to 26, then `f(s) = f(s-last letter)`\\n\\nif the last digital is 0, which means it has to go with the previous letter, then `f(s) = f(s - last 2 letter)`.\\n\\nThen having these on hand, using memorization, we can calculate from the first letter to the end.\\n\\n\\n\\n    public class Solution {\\n        public int numDecodings(String s) {\\n            if(s == null || s.isEmpty()){\\n                return 0;\\n            }\\n            \\n            if(s.length() == 1){\\n                if(isZero(s, 0)){\\n                    return 0;\\n                }else{\\n                    return 1;\\n                }\\n            }\\n            \\n            int[] a = new int[s.length()];\\n            \\n            if(isZero(s, 0)){\\n                return 0;\\n            }else{\\n                a[0] = 1;\\n            }\\n    \\n            \\n            if(isZero(s, 1)){\\n                if(isLetter(s, 1)){\\n                    a[1] = 1;\\n                }else{\\n                    return 0;\\n                }\\n                \\n            }else if(isLetter(s, 1)){\\n                a[1] = 2;\\n            }else{\\n                a[1] = 1;\\n            }\\n            \\n            for (int i = 2; i < s.length(); i++){\\n                \\n                if(isZero(s, i)){\\n                    if(isLetter(s, i)){\\n                        a[i] = a[i-2];\\n                    }else{\\n                        return 0;\\n                    }\\n                    \\n                }else if(isLetter(s, i)){\\n                    a[i] = a[i-1] + a[i-2];\\n                }else{\\n                    a[i] = a[i-1];\\n                }\\n            }\\n            return a[s.length()-1];\\n        }\\n        \\n        private boolean isZero(String s, int index){\\n            return s.charAt(index) == '0';\\n        }\\n        \\n        /**\\n         * return true if it is a 2 digital number < 26\\n         */\\n        private boolean isLetter(String s, int index){\\n            char c1 = s.charAt(index);\\n            char c2 = s.charAt(index - 1);\\n            \\n            if(c2 == '1'){\\n                return (c1>='0' && c1 <= '9');\\n            }else if(c2 =='2'){\\n                return (c1>='0' && c1 <= '6');\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int numDecodings(String s) {\\n            if(s == null || s.isEmpty()){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3431692,
                "title": "c-bottom-up-approach-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        std::vector<int> curr(2, 0);\\n        std::vector<int> prev(2, 0);\\n\\n        int n = s.size();\\n\\n        prev[false] = 1;\\n        prev[true] = s.back() != \\'0\\';\\n\\n        for(int i = n-1; i >= 0; --i) {\\n            for(int isPrevSelected = 0; isPrevSelected <= 1; ++isPrevSelected) {\\n                if(isPrevSelected == 0) {\\n                    curr[isPrevSelected] = prev[true];\\n                    continue;\\n                }\\n\\n                if(i > 0 && s[i-1] == \\'0\\') {\\n                    curr[isPrevSelected] = 0;\\n                    continue;\\n                }\\n                \\n                int takeCurrent = prev[true];\\n                int takeNext = 0;\\n                if(i > 0 && (std::string(1,s[i-1]) + s[i]) <= \"26\") {\\n                    takeNext = prev[false];\\n                }\\n                curr[isPrevSelected] = takeCurrent + takeNext;\\n            }\\n            prev = curr;\\n        }\\n\\n        return prev[0];\\n    }\\n};\\n```\\n![kevyn-monkey.gif](https://assets.leetcode.com/users/images/17f18be7-43b7-4348-a0ae-c1757489cd18_1681833611.0105467.gif)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        std::vector<int> curr(2, 0);\\n        std::vector<int> prev(2, 0);\\n\\n        int n = s.size();\\n\\n        prev[false] = 1;\\n        prev[true] = s.back() != \\'0\\';\\n\\n        for(int i = n-1; i >= 0; --i) {\\n            for(int isPrevSelected = 0; isPrevSelected <= 1; ++isPrevSelected) {\\n                if(isPrevSelected == 0) {\\n                    curr[isPrevSelected] = prev[true];\\n                    continue;\\n                }\\n\\n                if(i > 0 && s[i-1] == \\'0\\') {\\n                    curr[isPrevSelected] = 0;\\n                    continue;\\n                }\\n                \\n                int takeCurrent = prev[true];\\n                int takeNext = 0;\\n                if(i > 0 && (std::string(1,s[i-1]) + s[i]) <= \"26\") {\\n                    takeNext = prev[false];\\n                }\\n                curr[isPrevSelected] = takeCurrent + takeNext;\\n            }\\n            prev = curr;\\n        }\\n\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385178,
                "title": "easy-clear-solution-python-dp-memo",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if  s[0]==\"0\":\\n            return 0\\n        tab=[]\\n        test=False\\n        memo = [0 for _ in range(len(s))]\\n        def dp(i):\\n            if memo[i]>0:\\n                return memo[i]\\n            if i<=0:\\n                memo[0]=1\\n                return 1\\n            if s[i]==\"0\":\\n                if int(s[i-1:i+1])>26 or s[i-1]==\"0\":\\n                    test=True\\n                    return 0\\n                else:\\n                    memo[i]= dp(i-2)\\n            elif int(s[i-1:i+1])<=26 and s[i-1]!=\"0\":\\n                x= dp(i-1)+dp(i-2)\\n                memo[i]=x\\n            else:\\n                memo[i]= dp(i-1)\\n            return memo[i]\\n        res=dp(len(s)-1)\\n        \\n        if test: return 0\\n        else: return memo[len(s)-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if  s[0]==\"0\":\\n            return 0\\n        tab=[]\\n        test=False\\n        memo = [0 for _ in range(len(s))]\\n        def dp(i):\\n            if memo[i]>0:\\n                return memo[i]\\n            if i<=0:\\n                memo[0]=1\\n                return 1\\n            if s[i]==\"0\":\\n                if int(s[i-1:i+1])>26 or s[i-1]==\"0\":\\n                    test=True\\n                    return 0\\n                else:\\n                    memo[i]= dp(i-2)\\n            elif int(s[i-1:i+1])<=26 and s[i-1]!=\"0\":\\n                x= dp(i-1)+dp(i-2)\\n                memo[i]=x\\n            else:\\n                memo[i]= dp(i-1)\\n            return memo[i]\\n        res=dp(len(s)-1)\\n        \\n        if test: return 0\\n        else: return memo[len(s)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644156,
                "title": "java-simple-and-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public int numDecodings(String s) {\\n       int n = s.length(), oneStep = 1, twoStep = 0;\\n\\t\\tif(n==0 || s.charAt(0)==\\'0\\') return 0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\tint oneDigit = Character.getNumericValue(s.charAt(i));\\n\\t\\t\\tint twoDigit = Character.getNumericValue(s.charAt(i-1))*10 + oneDigit;\\n            int curStep = 0;\\n\\t\\t\\tif(oneDigit != 0) curStep+=oneStep; \\n\\t\\t\\tif(twoDigit >=10 && twoDigit <= 26){\\n\\t\\t\\t\\tif(i<2) curStep++; // two step is not evaluated until after 2 steps\\n\\t\\t\\t\\telse curStep+=twoStep;\\n\\t\\t\\t}\\n            twoStep = oneStep;\\n            oneStep = curStep;\\n\\t\\t}\\t\\n\\t\\treturn oneStep;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int numDecodings(String s) {\\n       int n = s.length(), oneStep = 1, twoStep = 0;\\n\\t\\tif(n==0 || s.charAt(0)==\\'0\\') return 0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\tint oneDigit = Character.getNumericValue(s.charAt(i));\\n\\t\\t\\tint twoDigit = Character.getNumericValue(s.charAt(i-1))*10 + oneDigit;\\n            int curStep = 0;\\n\\t\\t\\tif(oneDigit != 0) curStep+=oneStep; \\n\\t\\t\\tif(twoDigit >=10 && twoDigit <= 26){\\n\\t\\t\\t\\tif(i<2) curStep++; // two step is not evaluated until after 2 steps\\n\\t\\t\\t\\telse curStep+=twoStep;\\n\\t\\t\\t}\\n            twoStep = oneStep;\\n            oneStep = curStep;\\n\\t\\t}\\t\\n\\t\\treturn oneStep;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412865,
                "title": "easiest-way-to-solve-in-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s.length() == 0 || s.charAt(0)==\\'0\\')\\n            return 0;\\n        if(s.length()==1)\\n            return 1;\\n        int count1 = 1;\\n        int count2 =1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            int currentDigit = s.charAt(i)-\\'0\\';\\n            int doubleDigits = (s.charAt(i-1)-\\'0\\')*10 + currentDigit;\\n            int count = 0;\\n            if(currentDigit>0)\\n            {\\n                count += count2;\\n            }\\n            if(doubleDigits>=10 && doubleDigits<=26)\\n            {\\n                count += count1;\\n\\n            }\\n            count1 = count2;\\n            count2 = count;\\n        }\\n        return count2;\\n    }\\n}\\n```\\n\\nDo upvote if you like this solution",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s.length() == 0 || s.charAt(0)==\\'0\\')\\n            return 0;\\n        if(s.length()==1)\\n            return 1;\\n        int count1 = 1;\\n        int count2 =1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            int currentDigit = s.charAt(i)-\\'0\\';\\n            int doubleDigits = (s.charAt(i-1)-\\'0\\')*10 + currentDigit;\\n            int count = 0;\\n            if(currentDigit>0)\\n            {\\n                count += count2;\\n            }\\n            if(doubleDigits>=10 && doubleDigits<=26)\\n            {\\n                count += count1;\\n\\n            }\\n            count1 = count2;\\n            count2 = count;\\n        }\\n        return count2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337193,
                "title": "easy-c-100-faster-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        //dp [i] stores the result for substring i-len\\n        //i.e., dp[i] stores the number of ways in which we can decode the substring from i to len-1\\n\\n        int len=s.length();\\n        vector<int> dp(len,-1);\\n        helper(s,0,len,dp);\\n        return dp[0]==-1 ? 0 : dp[0];\\n    }\\n    int  helper(string& s,int ind,int n,vector<int>& dp)\\n    {\\n        if(ind==n)\\n            return 1;\\n        if(s[ind]==\\'0\\') //since we cannot decode it\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int sum=0;\\n        //consider a single number to decode\\n        sum+=helper(s,ind+1,n,dp);\\n        \\n        //consider two digits if they are in range from 1-26\\n        if(ind+1<n && (s[ind]-\\'0\\')*10 + (s[ind+1]-\\'0\\') <=26)\\n        {\\n            sum+=helper(s,ind+2,n,dp);\\n        }\\n        dp[ind]=sum;\\n        return dp[ind];\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        //dp [i] stores the result for substring i-len\\n        //i.e., dp[i] stores the number of ways in which we can decode the substring from i to len-1\\n\\n        int len=s.length();\\n        vector<int> dp(len,-1);\\n        helper(s,0,len,dp);\\n        return dp[0]==-1 ? 0 : dp[0];\\n    }\\n    int  helper(string& s,int ind,int n,vector<int>& dp)\\n    {\\n        if(ind==n)\\n            return 1;\\n        if(s[ind]==\\'0\\') //since we cannot decode it\\n            return 0;\\n        if(dp[ind]!=-1)\\n            return dp[ind];\\n        int sum=0;\\n        //consider a single number to decode\\n        sum+=helper(s,ind+1,n,dp);\\n        \\n        //consider two digits if they are in range from 1-26\\n        if(ind+1<n && (s[ind]-\\'0\\')*10 + (s[ind+1]-\\'0\\') <=26)\\n        {\\n            sum+=helper(s,ind+2,n,dp);\\n        }\\n        dp[ind]=sum;\\n        return dp[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30364,
                "title": "thought-process-solution-in-js",
                "content": "My thought process:\\nLet's start with an example,\\n```\\nconst digits = \"1220421\"\\n```\\nThis can be decoded in the following way\\n```\\n/*\\n1-2-20-4-2-1\\n12-20-4-2-1\\n1-2-30-4-21\\n12-20-4-21\\n*/\\n```\\n\\nGiven an input string, we'll look at the first digit and first-two digits, in this case\\nfirst digit = 1, first-two digit = 12. We can decode these as \"A\", \"J\", respectively.\\nAfter decoding these characters, we are left with the same type of problem with a smaller input. (\"220421\", \"20421\"). \\nThis **Overlapping subproblems** property indicates that we can use Dynamic Programming to solve this problem.\\nWe are using **suffixes** of the original input as subproblems.\\n\\nThe base case is easy. When we have one digit.\\nIf the digit is \"0\" then the number of ways to decode the input is 0.\\nOtherwise, 1 way to decode the input.\\n\\nFor longer suffixes, we have the following recurrence relation.\\nLet's define DP[i] to be the number of ways to decode x[i:] (suffix of the original input x starting at index i)\\n```\\n/* pseudocode\\n   if firstDigit ==  0:\\n     DP[i] = 0\\n   else if  firstTwoDigit < 27:\\n     DP[i] = DP[i+1] + DP[i+2] \\n   else:\\n     DP[i] = DP[i+1]\\n*/\\n\\n  ```\\n\\nAlso, to simplify our code a bit, we can have DP[n] = 1.\\nBelow is my solution writting in JS.\\n```\\nconst numDecodings = (digits) => {\\n  const n = digits.length;\\n  if (n === 0) return 0;\\n  \\n  const dp = new Array(n+1);\\n  \\n  dp[n] = 1;\\n  dp[n - 1] = digits[n-1] === '0' ? 0 : 1;\\n  \\n  for (let i = n - 2; i >= 0; i--) {\\n    if (digits[i] === '0') {\\n      dp[i] = 0;\\n    } else if (parseInt(digits.slice(i, i+2)) < 27) {\\n      dp[i] = dp[i+1] + dp[i+2];\\n    } else {\\n      dp[i] = dp[i+1];\\n    }\\n  }\\n  \\n  return dp[0];\\n}\\n```\\n\\nTime complexity of this implementation is O(N) time; (N being the length of the input)",
                "solutionTags": [],
                "code": "```\\nconst digits = \"1220421\"\\n```\n```\\n/*\\n1-2-20-4-2-1\\n12-20-4-2-1\\n1-2-30-4-21\\n12-20-4-21\\n*/\\n```\n```\\n/* pseudocode\\n   if firstDigit ==  0:\\n     DP[i] = 0\\n   else if  firstTwoDigit < 27:\\n     DP[i] = DP[i+1] + DP[i+2] \\n   else:\\n     DP[i] = DP[i+1]\\n*/\\n\\n  ```\n```\\nconst numDecodings = (digits) => {\\n  const n = digits.length;\\n  if (n === 0) return 0;\\n  \\n  const dp = new Array(n+1);\\n  \\n  dp[n] = 1;\\n  dp[n - 1] = digits[n-1] === '0' ? 0 : 1;\\n  \\n  for (let i = n - 2; i >= 0; i--) {\\n    if (digits[i] === '0') {\\n      dp[i] = 0;\\n    } else if (parseInt(digits.slice(i, i+2)) < 27) {\\n      dp[i] = dp[i+1] + dp[i+2];\\n    } else {\\n      dp[i] = dp[i+1];\\n    }\\n  }\\n  \\n  return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30547,
                "title": "java-1ms-very-easy-ac-solution",
                "content": "    public int numDecodings(String s) {\\n        if(s.length() == 0) return 0;\\n        int pre = 27, digit, answer = 0, first = 1, second = 1;\\n        for(int i = s.length()-1; i >= 0; i--){\\n            digit = s.charAt(i) - '0';\\n            if(digit == 0) answer = 0;\\n            else answer = first + (digit*10 + pre < 27 ? second : 0);\\n            second = first; first = answer; pre = digit;\\n        }\\n        return answer;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int numDecodings(String s) {\\n        if(s.length() == 0) return 0;\\n        int pre = 27, digit, answer = 0, first = 1, second = 1;\\n        for(int i = s.length()-1; i >= 0; i--){\\n            digit = s.charAt(i) - '0';\\n            if(digit == 0) answer = 0;\\n            else answer = first + (digit*10 + pre < 27 ? second : 0);\\n            second = first; first = answer; pre = digit;\\n        }\\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114367,
                "title": "recursion-memoization-in-c",
                "content": "**RECURSION**\\nTLE\\n```\\nclass Solution\\n{\\npublic:\\n\\tint numDecodings(string s)\\n\\t{\\n\\t\\tif (s.empty())\\n\\t\\t\\treturn 0;\\n\\t\\treturn rec(0, s);\\n\\t}\\n\\tint rec(int p, string &s)\\n\\t{\\n\\n\\t\\tint n = s.size();\\n\\n\\t\\tif (p == n)\\n\\t\\t\\treturn 1;\\n\\n\\t\\tif (s[p] == \\'0\\')\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint res = rec(p + 1, s);\\n\\n\\t\\tif (p < n - 1 && (s[p] == \\'1\\' || (s[p] == \\'2\\' && s[p + 1] < \\'7\\')))\\n\\t\\t\\tres += rec(p + 2, s);\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\nMemoization-\\n```\\nclass Solution\\n{\\n\\tint memo[101];\\n\\npublic:\\n\\tint numDecodings(string s)\\n\\t{\\n\\t\\tmemset(memo, -1, sizeof(memo));\\n\\t\\tif (s.empty())\\n\\t\\t\\treturn 0;\\n\\t\\treturn rec(0, s);\\n\\t}\\n\\tint rec(int p, string &s)\\n\\t{\\n\\n\\t\\tint n = s.size();\\n\\n\\t\\tif (p == n)\\n\\t\\t\\treturn memo[p] = 1;\\n\\n\\t\\tif (s[p] == \\'0\\')\\n\\t\\t\\treturn memo[p] = 0;\\n\\t\\tif (memo[p] != -1)\\n\\t\\t\\treturn memo[p];\\n\\t\\tint res = rec(p + 1, s);\\n\\n\\t\\tif (p < n - 1 && (s[p] == \\'1\\' || (s[p] == \\'2\\' && s[p + 1] < \\'7\\')))\\n\\t\\t\\tres += rec(p + 2, s);\\n\\n\\t\\treturn memo[p] = res;\\n\\t}\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint numDecodings(string s)\\n\\t{\\n\\t\\tif (s.empty())\\n\\t\\t\\treturn 0;\\n\\t\\treturn rec(0, s);\\n\\t}\\n\\tint rec(int p, string &s)\\n\\t{\\n\\n\\t\\tint n = s.size();\\n\\n\\t\\tif (p == n)\\n\\t\\t\\treturn 1;\\n\\n\\t\\tif (s[p] == \\'0\\')\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint res = rec(p + 1, s);\\n\\n\\t\\tif (p < n - 1 && (s[p] == \\'1\\' || (s[p] == \\'2\\' && s[p + 1] < \\'7\\')))\\n\\t\\t\\tres += rec(p + 2, s);\\n\\n\\t\\treturn res;\\n\\t}\\n};\\n```\n```\\nclass Solution\\n{\\n\\tint memo[101];\\n\\npublic:\\n\\tint numDecodings(string s)\\n\\t{\\n\\t\\tmemset(memo, -1, sizeof(memo));\\n\\t\\tif (s.empty())\\n\\t\\t\\treturn 0;\\n\\t\\treturn rec(0, s);\\n\\t}\\n\\tint rec(int p, string &s)\\n\\t{\\n\\n\\t\\tint n = s.size();\\n\\n\\t\\tif (p == n)\\n\\t\\t\\treturn memo[p] = 1;\\n\\n\\t\\tif (s[p] == \\'0\\')\\n\\t\\t\\treturn memo[p] = 0;\\n\\t\\tif (memo[p] != -1)\\n\\t\\t\\treturn memo[p];\\n\\t\\tint res = rec(p + 1, s);\\n\\n\\t\\tif (p < n - 1 && (s[p] == \\'1\\' || (s[p] == \\'2\\' && s[p + 1] < \\'7\\')))\\n\\t\\t\\tres += rec(p + 2, s);\\n\\n\\t\\treturn memo[p] = res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010426,
                "title": "python-dp-thought-process-explained-with-comments",
                "content": "<u><b>Thought process explained</b></u>:\\n\\n Goal: we need to count to number of ways can decode a string\\n We\\'ll initiate **dp** with size of len(s). **dp[i]** is indicating the number of ways we can decode our string upto index i.\\n \\n What\\'s the number of ways we can decode a string upto index i?\\n1.  if **s[i]** is not a zero **(1-9)**, than the decoding of **s[i]** could be the next character in each of the previous decoding ways.\\n In that case, we can set **dp[i] = dp[i-1]**\\n2. Lets look at the number formed by **s[i-1] and s[i]**, it could be any number between **\\'01\\' to \\'99\\'**. The only valid numbers of this range are **10 -> 26**. \\n\\n\\t* In these cases, the number formed by these 2 digits could be added to the number of ways we decoded the i-2 position (because i-1 is used to form the number). \\n\\tWe\\'ll do **dp[i] += dp[i-2]**\\n\\n\\t* One edge case we need to mention: if the case I\\'ve mentioned above occured in i=1 than dp[i-2] does not exists. Instead, we can just do **dp[i] += 1**.\\n3. Eventually, we\\'ll return **dp[-1]**, which is the number of ways we can decode our string upto the last index -> the entire string.\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n# bottom up approach\\n\\t\\t# string starting with 0 is not valid\\n        if s[0] == \\'0\\': return 0\\n\\n\\t\\t# string of len 1 could be decoded in only one way\\n        if len(s) == 1: return 1\\n\\t\\t\\n\\t\\t# init dp\\n        dp = [0] * len(s)                \\n        dp[0] = 1\\n        \\n        for i in range(1, len(s)):            \\n            # if current index is number in 1->9 range, we can make dp[i] = dp[i-1]\\n            if s[i] != \\'0\\':\\n                dp[i] = dp[i-1]\\n                \\n            # if current index and the prev index make a number in 0 -> 26 range, we can add dp[i-2]\\n            if 10 <= int(s[i-1:i+1]) <= 26:\\n                if i > 1:\\n                    dp[i] += dp[i-2]\\n                else:\\n                    dp[i] += 1\\n                 \\n        return dp[-1]\\n```\\n<p>\\n<b><u>Note</u>:</b> you might notice that we don\\'t actually need the entire dp array. For calculating dp[i] we only require dp[i-1] and dp[i-2]. Therefore, this code section could be simplified to O(1) space complexity like that:\\n</p>\\n\\n```\\nclass Solution:\\n\\tdef numDecodings(self, s: str) -> int:\\n\\t\\tif s[0] == \\'0\\': return 0\\n\\n\\t\\tprev_1, prev_2 = 1, 1\\n\\n\\t\\tfor i in range(1, len(s)):            \\n\\t\\t\\tcurr = 0\\n\\t\\t\\t# if current index is number in 1->9 range, we can make dp[i] = dp[i-1]\\n\\t\\t\\tif s[i] != \\'0\\':\\n\\t\\t\\t\\tcurr += prev_2\\n\\n\\t\\t\\t# if current index and the prev index make a number in 0 -> 26 range, we can add dp[i-2]\\n\\t\\t\\tif 10 <= int(s[i-1:i+1]) <= 26:\\n\\t\\t\\t\\tif i > 1:\\n\\t\\t\\t\\t\\tcurr += prev_1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcurr +=1\\n\\n\\t\\t\\tprev_1 = prev_2\\n\\t\\t\\tprev_2 = curr\\n\\n\\t\\treturn prev_2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n# bottom up approach\\n\\t\\t# string starting with 0 is not valid\\n        if s[0] == \\'0\\': return 0\\n\\n\\t\\t# string of len 1 could be decoded in only one way\\n        if len(s) == 1: return 1\\n\\t\\t\\n\\t\\t# init dp\\n        dp = [0] * len(s)                \\n        dp[0] = 1\\n        \\n        for i in range(1, len(s)):            \\n            # if current index is number in 1->9 range, we can make dp[i] = dp[i-1]\\n            if s[i] != \\'0\\':\\n                dp[i] = dp[i-1]\\n                \\n            # if current index and the prev index make a number in 0 -> 26 range, we can add dp[i-2]\\n            if 10 <= int(s[i-1:i+1]) <= 26:\\n                if i > 1:\\n                    dp[i] += dp[i-2]\\n                else:\\n                    dp[i] += 1\\n                 \\n        return dp[-1]\\n```\n```\\nclass Solution:\\n\\tdef numDecodings(self, s: str) -> int:\\n\\t\\tif s[0] == \\'0\\': return 0\\n\\n\\t\\tprev_1, prev_2 = 1, 1\\n\\n\\t\\tfor i in range(1, len(s)):            \\n\\t\\t\\tcurr = 0\\n\\t\\t\\t# if current index is number in 1->9 range, we can make dp[i] = dp[i-1]\\n\\t\\t\\tif s[i] != \\'0\\':\\n\\t\\t\\t\\tcurr += prev_2\\n\\n\\t\\t\\t# if current index and the prev index make a number in 0 -> 26 range, we can add dp[i-2]\\n\\t\\t\\tif 10 <= int(s[i-1:i+1]) <= 26:\\n\\t\\t\\t\\tif i > 1:\\n\\t\\t\\t\\t\\tcurr += prev_1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcurr +=1\\n\\n\\t\\t\\tprev_1 = prev_2\\n\\t\\t\\tprev_2 = curr\\n\\n\\t\\treturn prev_2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731463,
                "title": "python-memoization-with-image",
                "content": "\\n![image](https://assets.leetcode.com/users/images/7e50d6f2-d0a8-4f32-ba91-be45ef62d4b4_1643544031.5391963.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/e933fe4f-3272-4370-9698-e76778142220_1643544049.9935431.jpeg)\\n\\n\\n```\\n# Recursion (time complexity -> 2^n) =>\\n\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0def dfs(i): \\n            if i==len(s): \\n                return 1 \\n            if s[i]==\"0\": \\n                return 0 \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans = dfs(i+1) \\n            if (i+1<len(s) and (s[i]==\"1\" or s[i]==\"2\" and s[i+1] in \"0123456\")): \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += dfs(i+2) \\n            return ans \\n \\xA0 \\xA0 \\xA0 \\xA0return dfs(0)\\n\\t\\t\\n\\n# Memoization (time & space complexity -> O(n)) =>\\n\\t\\t\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp={}\\n \\xA0 \\xA0 \\xA0 \\xA0def dfs(i): \\n            if i==len(s): \\n                return 1 \\n            if s[i]==\"0\": \\n                return 0 \\n            if i in dp: \\n                return dp[i]\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans = dfs(i+1) \\n            if (i+1<len(s) and (s[i]==\"1\" or s[i]==\"2\" and s[i+1] in \"0123456\")): \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += dfs(i+2)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0dp[i]=ans\\n            return ans \\n \\xA0 \\xA0 \\xA0 \\xA0return dfs(0) \\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def numDecodings(self, s: str) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0def dfs(i): \\n            if i==len(s): \\n                return 1 \\n            if s[i]==\"0\": \\n                return 0 \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans = dfs(i+1) \\n            if (i+1<len(s) and (s[i]==\"1\" or s[i]==\"2\" and s[i+1] in \"0123456\")): \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += dfs(i+2) \\n            return ans \\n \\xA0 \\xA0 \\xA0 \\xA0return dfs(0)\\n\\t\\t\\n\\n# Memoization (time & space complexity -> O(n)) =>\\n\\t\\t\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp={}",
                "codeTag": "Java"
            },
            {
                "id": 1410823,
                "title": "java-clean-concise-optimal-code-dynamic-programming-technique",
                "content": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        \\n        if (s == null || s.length () == 0 || s.charAt (0) == \\'0\\') {\\n            return 0;\\n        }\\n        \\n        int length = s.length ();\\n        int[] dp = new int[length + 1];\\n        dp[length] = 1;\\n        if (s.charAt (length - 1) != \\'0\\') {\\n            dp[length - 1] = 1;\\n        }\\n        \\n        for (int i = length - 2; i >= 0; i--) {\\n            if (s.charAt (i) != \\'0\\') {\\n                dp[i] = dp[i + 1];\\n            }\\n            if (s.charAt (i) == \\'1\\') {\\n                dp[i] += dp[i + 2];\\n            }\\n            if (s.charAt (i) == \\'2\\' && s.charAt (i + 1) >= \\'0\\' && s.charAt (i + 1) <= \\'6\\') {\\n                dp[i] += dp[i + 2];\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        \\n        if (s == null || s.length () == 0 || s.charAt (0) == \\'0\\') {\\n            return 0;\\n        }\\n        \\n        int length = s.length ();\\n        int[] dp = new int[length + 1];\\n        dp[length] = 1;\\n        if (s.charAt (length - 1) != \\'0\\') {\\n            dp[length - 1] = 1;\\n        }\\n        \\n        for (int i = length - 2; i >= 0; i--) {\\n            if (s.charAt (i) != \\'0\\') {\\n                dp[i] = dp[i + 1];\\n            }\\n            if (s.charAt (i) == \\'1\\') {\\n                dp[i] += dp[i + 2];\\n            }\\n            if (s.charAt (i) == \\'2\\' && s.charAt (i + 1) >= \\'0\\' && s.charAt (i + 1) <= \\'6\\') {\\n                dp[i] += dp[i + 2];\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910112,
                "title": "my-java-solution-with-comments-and-explanation-using-dynamic-programming",
                "content": "```\\n// so here we are having certain states that we need the numbers to be 1 - 9 for single digits and the double digit number should not exceed 26\\n// we can make use of dynamic programming to keep track of this states and count the number\\n// we will be having only either 1 digit combination or 2 digit combination and not more than that\\n// I used a dp array of size n + 1 to save subproblem solutions. dp[0] means an empty string will have one way to decode, dp[1] means the way to decode a string of size 1. I then check one digit and two digit combination and save the results along the way. In the end, dp[n] will be the end result.\\n\\n\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.length() == 0 || s.length() == 1 && s.equals(\"0\"))\\n\\t\\treturn 0;\\n\\tif (s.length() == 1 && s.equals(\"1\"))\\n\\t\\treturn 1;\\n        if (s.charAt(0) == \\'0\\')\\n            return 0;\\n\\tint [] dp = new int [s.length() + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = s.charAt(0) != 0 ? 1 : 0;\\n\\tfor (int i=2; i<=s.length(); i++) {\\n\\t\\t// take the first and second letter\\n\\t\\tint first = Integer.valueOf(s.substring(i-1, i));\\n\\t\\tint second = Integer.valueOf(s.substring(i-2, i));\\n\\t\\t// check first between 1-9\\n\\t\\tif (first > 0 && first < 10)\\n\\t\\t\\tdp[i] += dp[i-1];\\n\\t\\t// check for the 2 digit combination\\n\\t\\tif (second > 9 && second < 27)\\n\\t\\t\\tdp[i] += dp[i-2];\\n\\t}\\n\\treturn dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// so here we are having certain states that we need the numbers to be 1 - 9 for single digits and the double digit number should not exceed 26\\n// we can make use of dynamic programming to keep track of this states and count the number\\n// we will be having only either 1 digit combination or 2 digit combination and not more than that\\n// I used a dp array of size n + 1 to save subproblem solutions. dp[0] means an empty string will have one way to decode, dp[1] means the way to decode a string of size 1. I then check one digit and two digit combination and save the results along the way. In the end, dp[n] will be the end result.\\n\\n\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.length() == 0 || s.length() == 1 && s.equals(\"0\"))\\n\\t\\treturn 0;\\n\\tif (s.length() == 1 && s.equals(\"1\"))\\n\\t\\treturn 1;\\n        if (s.charAt(0) == \\'0\\')\\n            return 0;\\n\\tint [] dp = new int [s.length() + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = s.charAt(0) != 0 ? 1 : 0;\\n\\tfor (int i=2; i<=s.length(); i++) {\\n\\t\\t// take the first and second letter\\n\\t\\tint first = Integer.valueOf(s.substring(i-1, i));\\n\\t\\tint second = Integer.valueOf(s.substring(i-2, i));\\n\\t\\t// check first between 1-9\\n\\t\\tif (first > 0 && first < 10)\\n\\t\\t\\tdp[i] += dp[i-1];\\n\\t\\t// check for the 2 digit combination\\n\\t\\tif (second > 9 && second < 27)\\n\\t\\t\\tdp[i] += dp[i-2];\\n\\t}\\n\\treturn dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863721,
                "title": "simple-recursive-iterative-optimal-c-soln",
                "content": "(1) Recursive\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> memo;\\n    int decodeWaysHelper(string s, int pos){\\n        if(pos>=s.size()){\\n            if(pos==s.size())\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(memo[pos]>=0)\\n            return memo[pos];\\n        \\n        memo[pos] = 0;\\n        \\n        int partial = stoi(s.substr(pos, 1));\\n        if(partial!=0)\\n            memo[pos] = decodeWaysHelper(s, pos+1);\\n        \\n        partial = stoi(s.substr(pos, 2));\\n        if(partial>9 && partial<=26)\\n            memo[pos] += decodeWaysHelper(s, pos+2);\\n        \\n        return memo[pos];\\n    }\\n    \\n    int numDecodings(string s) {\\n        memo = vector<int> (s.size(), -1);\\n        return decodeWaysHelper(s, 0);\\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\ni or i,i+1, backtracking\\n\\n1. Backtr()\\n2. i or i,i+1 substr in range\\n3. rest substr is called\\n4. result++ when end\\n\\n*/\\n\\n```\\n\\n(2) Iterative\\n```\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.size(), first=0, second=0, third=0;\\n        \\n        first=1;\\n        second=(s[0]!=\\'0\\')?1:0;\\n        \\n        for(int i=1; i<n; i++){\\n            if(s[i]!=\\'0\\')\\n                third=second;\\n            else\\n                third=0;\\n            \\n            string partial = s.substr(i-1, 2);\\n            \\n            if(partial>=\"10\" && partial<=\"26\")\\n                third+=first;\\n            \\n            first=second;\\n            second=third;\\n            third=0;\\n        }\\n        \\n        return second;\\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\n1. calc for i=1\\n2. check for \\'0\\'\\n3. check 2 digit\\n4. return ans\\n*/\\n\\n```\\n\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> memo;\\n    int decodeWaysHelper(string s, int pos){\\n        if(pos>=s.size()){\\n            if(pos==s.size())\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(memo[pos]>=0)\\n            return memo[pos];\\n        \\n        memo[pos] = 0;\\n        \\n        int partial = stoi(s.substr(pos, 1));\\n        if(partial!=0)\\n            memo[pos] = decodeWaysHelper(s, pos+1);\\n        \\n        partial = stoi(s.substr(pos, 2));\\n        if(partial>9 && partial<=26)\\n            memo[pos] += decodeWaysHelper(s, pos+2);\\n        \\n        return memo[pos];\\n    }\\n    \\n    int numDecodings(string s) {\\n        memo = vector<int> (s.size(), -1);\\n        return decodeWaysHelper(s, 0);\\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\ni or i,i+1, backtracking\\n\\n1. Backtr()\\n2. i or i,i+1 substr in range\\n3. rest substr is called\\n4. result++ when end\\n\\n*/\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n=s.size(), first=0, second=0, third=0;\\n        \\n        first=1;\\n        second=(s[0]!=\\'0\\')?1:0;\\n        \\n        for(int i=1; i<n; i++){\\n            if(s[i]!=\\'0\\')\\n                third=second;\\n            else\\n                third=0;\\n            \\n            string partial = s.substr(i-1, 2);\\n            \\n            if(partial>=\"10\" && partial<=\"26\")\\n                third+=first;\\n            \\n            first=second;\\n            second=third;\\n            third=0;\\n        }\\n        \\n        return second;\\n    }\\n};\\n\\n/*\\nAlgorithm Outline:\\n\\n1. calc for i=1\\n2. check for \\'0\\'\\n3. check 2 digit\\n4. return ans\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557071,
                "title": "c-dp-o-n-time-o-1-space",
                "content": "Let\\'s take a look on an edge case: s=\"1111\"\\nIn this case, for each char we have two options:\\n1. Decode number itself\\n2. Combine number with next one, and decode them together.\\n\\nWe can say that DP formula will look like:\\n`dp[i] = dp[i+1] + dp[i+2]`\\nwith base cases:\\n`dp[last] = 1`\\n`dp[last-1] = 2`\\n\\nNow we can add couple additional rules in our formula:\\n1. We cannot decode string that starts from `0`, thus `if s[i]==0 then dp[i]=0`;\\n2. We can add `dp[i+2]` only `if s[i] == \\'1\\' || s[i]==\\'2\\' && s[i+1]<=\\'6\\'` To guaranty that two chars may be converted to one letter together.\\n\\n![image](https://assets.leetcode.com/users/tifon/image_1585596617.png)\\n\\n\\nFrom initial formula we see that we never use/update previously calculated values, but only for calculation next one.\\nWe can do calculation bottom to up, moreover, we don\\'t need to store them.\\n\\n\\n\\n```\\nint numDecodings(string s) {\\n\\tint dp2 = 1;  // base case\\n\\tint dp1 = s.back() == \\'0\\' ? 0 : 1;  // initialize for last char\\n\\tint dp = dp1;\\n\\n\\tfor (int i=s.size()-2; i>=0; --i) {\\n\\t\\tif (s[i]==\\'0\\') {\\n\\t\\t\\tdp=0;\\n\\t\\t} else {\\n\\t\\t\\tdp = dp1;\\n\\t\\t\\tif (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1] <=\\'6\\') {\\n\\t\\t\\t\\tdp += dp2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp2 = dp1;\\n\\t\\tdp1 = dp;\\n\\t}\\n\\n\\treturn dp;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numDecodings(string s) {\\n\\tint dp2 = 1;  // base case\\n\\tint dp1 = s.back() == \\'0\\' ? 0 : 1;  // initialize for last char\\n\\tint dp = dp1;\\n\\n\\tfor (int i=s.size()-2; i>=0; --i) {\\n\\t\\tif (s[i]==\\'0\\') {\\n\\t\\t\\tdp=0;\\n\\t\\t} else {\\n\\t\\t\\tdp = dp1;\\n\\t\\t\\tif (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1] <=\\'6\\') {\\n\\t\\t\\t\\tdp += dp2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp2 = dp1;\\n\\t\\tdp1 = dp;\\n\\t}\\n\\n\\treturn dp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244911,
                "title": "java-slow-but-easy-dfs-solution",
                "content": "### pure DFS solution\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        Map<String, Character> codes = new HashMap<>();\\n        initMap(codes);\\n        return helper(s, 0, 0, codes);\\n    }\\n    private int helper(String s, int result, int start, Map<String, Character> map){\\n        if(start >= s.length()){\\n            return result + 1;\\n        }\\n\\t\\t/* The first decode way (use only first character) */\\n        if(start + 1 <= s.length() && map.containsKey(s.substring(start, start + 1))){\\n            result = helper(s, result, start + 1, map);\\n        }\\n\\t\\t/* The second decode way (use both first and second character if it is valid (27 is not valid for example) */\\n        if(start + 2 <= s.length() && map.containsKey(s.substring(start, start + 2))){\\n            result = helper(s, result, start + 2, map);\\n        }\\n        return result;\\n    }\\n    private void initMap(Map<String, Character> codes){\\n        for(int i = 1; i <= 26; i++){\\n            char c = (char) ((int)\\'A\\' + (i - 1));\\n            codes.put(String.valueOf(i), c);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0){\\n            return 0;\\n        }\\n        Map<String, Character> codes = new HashMap<>();\\n        initMap(codes);\\n        return helper(s, 0, 0, codes);\\n    }\\n    private int helper(String s, int result, int start, Map<String, Character> map){\\n        if(start >= s.length()){\\n            return result + 1;\\n        }\\n\\t\\t/* The first decode way (use only first character) */\\n        if(start + 1 <= s.length() && map.containsKey(s.substring(start, start + 1))){\\n            result = helper(s, result, start + 1, map);\\n        }\\n\\t\\t/* The second decode way (use both first and second character if it is valid (27 is not valid for example) */\\n        if(start + 2 <= s.length() && map.containsKey(s.substring(start, start + 2))){\\n            result = helper(s, result, start + 2, map);\\n        }\\n        return result;\\n    }\\n    private void initMap(Map<String, Character> codes){\\n        for(int i = 1; i <= 26; i++){\\n            char c = (char) ((int)\\'A\\' + (i - 1));\\n            codes.put(String.valueOf(i), c);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227606,
                "title": "c-o-1-space-dp",
                "content": "To apply DP, we define `dp[i]` to be the number of decoding ways for `s[0..i)`. For empty strings or those starting with `\\'0\\'`, we can immediately return a `0`. Otherwise, we set `dp[0] = dp[1] = 1`: `dp[0]` serves as a sentinel and `dp[1]` means `s[0]` has one way of decoding.\\n\\nThen, for `dp[i] (i > 1)`, we have two cases depending on whether `s[i] = \\'0\\'`.\\n\\n* If `s[i] = \\'0\\'`, then `s[i]` must be combined with `s[i - 1]` and `s[i - 1]` must be `\\'1\\'` or `\\'2\\'` to have a valid encoding. In this case, `dp[i] = dp[i - 2]`.\\n* If `s[i] != \\'0\\'`, then we may or may not combine `s[i]` with `s[i - 1]`, depending on whether `s[i - 1..i]` falls between `\\'11\\'` and `\\'26\\'`. If it does, then `dp[i] = dp[i - 1] + dp[i - 2]`; otherwise, `dp[i] = dp[i - 1]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        if (s.empty() || s[0] == \\'0\\') {\\n            return 0;\\n        }\\n        int n = s.size(), *dp = new int[n + 1];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            if (s[i - 1] == \\'0\\') {\\n                if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\') {\\n                    dp[i] = dp[i - 2];\\n                } else {\\n                    return 0;\\n                }                \\n            } else {\\n                int num = atoi(s.substr(i - 2, 2).c_str());\\n                dp[i] = dp[i - 1] + (num >= 11 && num <= 26 ? dp[i - 2] : 0);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\nThe above code uses `O(n)` space, which can be further optimized since each time when we update `dp[i]`, we only need `dp[i - 1]` and `dp[i - 2]`. We can just store them into two variables and udpate them throughout the loop.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        if (s.empty() || s[0] == \\'0\\') {\\n            return 0;\\n        }\\n        int n = s.size(), pre = 1, cur = 1;\\n        for (int i = 2; i <= n; i++) {\\n            if (s[i - 1] == \\'0\\') {\\n                if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\') {\\n                    cur = pre;\\n                } else {\\n                    return 0;\\n                }                \\n            } else {\\n                int num = atoi(s.substr(i - 2, 2).c_str());\\n                int temp = cur;\\n                cur = cur + (num >= 11 && num <= 26 ? pre : 0);\\n                pre = temp;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        if (s.empty() || s[0] == \\'0\\') {\\n            return 0;\\n        }\\n        int n = s.size(), *dp = new int[n + 1];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            if (s[i - 1] == \\'0\\') {\\n                if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\') {\\n                    dp[i] = dp[i - 2];\\n                } else {\\n                    return 0;\\n                }                \\n            } else {\\n                int num = atoi(s.substr(i - 2, 2).c_str());\\n                dp[i] = dp[i - 1] + (num >= 11 && num <= 26 ? dp[i - 2] : 0);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        if (s.empty() || s[0] == \\'0\\') {\\n            return 0;\\n        }\\n        int n = s.size(), pre = 1, cur = 1;\\n        for (int i = 2; i <= n; i++) {\\n            if (s[i - 1] == \\'0\\') {\\n                if (s[i - 2] == \\'1\\' || s[i - 2] == \\'2\\') {\\n                    cur = pre;\\n                } else {\\n                    return 0;\\n                }                \\n            } else {\\n                int num = atoi(s.substr(i - 2, 2).c_str());\\n                int temp = cur;\\n                cur = cur + (num >= 11 && num <= 26 ? pre : 0);\\n                pre = temp;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199694,
                "title": "java-ac-memoized-recursion",
                "content": "The idea is simple:\\n\\t- Follow the backtracking template (Choose, explore, unchoose).\\n\\t- But, since we\\'re not adding the chosen element to any datastructure, we don\\'t need to unchoose it. The recursion stack will take care of it. \\n\\t- The time complexity of this will be O(2^n) since we can chose either one digit or two digits each time and we need to do this n times\\n\\t- To reduce the repetition of the computations, use a memo (a hashmap in this case), this makes the time complexity O(n)\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n        \\n        // Index to NumOfWays mapping\\n        Map<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n        \\n        return helper(s, 0, memo);\\n    }\\n    \\n    private int helper(String s, int start, Map<Integer, Integer> memo){\\n        if(start > s.length() + 1) return 0;\\n        if(start == s.length()){\\n            return 1;\\n        } \\n                    \\n        int total = 0;\\n        \\n        if(memo.containsKey(start)) return memo.get(start);\\n        \\n        //choose single digit\\n        String currStr = s.substring(start, start + 1);\\n        Integer currInt = Integer.valueOf(currStr);\\n        if(currInt == 0) return 0;\\n        if(currInt >= 1 && currInt <= 26)\\n            total = helper(s, start + 1, memo);\\n\\n        //choose two digits (if possible)\\n        if(start < s.length() - 1){\\n            currStr = s.substring(start, start + 2);\\n            currInt = Integer.valueOf(currStr);\\n            if(currInt >= 1 && currInt <= 26)\\n                total += helper(s, start + 2, memo);\\n        }\\n        \\n        memo.put(start, total);\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n        \\n        // Index to NumOfWays mapping\\n        Map<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n        \\n        return helper(s, 0, memo);\\n    }\\n    \\n    private int helper(String s, int start, Map<Integer, Integer> memo){\\n        if(start > s.length() + 1) return 0;\\n        if(start == s.length()){\\n            return 1;\\n        } \\n                    \\n        int total = 0;\\n        \\n        if(memo.containsKey(start)) return memo.get(start);\\n        \\n        //choose single digit\\n        String currStr = s.substring(start, start + 1);\\n        Integer currInt = Integer.valueOf(currStr);\\n        if(currInt == 0) return 0;\\n        if(currInt >= 1 && currInt <= 26)\\n            total = helper(s, start + 1, memo);\\n\\n        //choose two digits (if possible)\\n        if(start < s.length() - 1){\\n            currStr = s.substring(start, start + 2);\\n            currInt = Integer.valueOf(currStr);\\n            if(currInt >= 1 && currInt <= 26)\\n                total += helper(s, start + 2, memo);\\n        }\\n        \\n        memo.put(start, total);\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904337,
                "title": "set-dp-simple-easy-python3",
                "content": "# Approach\\n1. Store all the digits from 1 to 26 inclusive.\\n2. A Single Number will always be valid decode way if digit is not `0`.\\n3. Then try for 2 digits, if curr index `i` and `i + 1` together makes a valid decode way.\\n\\n\\n# Complexity\\n- `Time: O(N)`\\n- `Space: O(N)`\\n- Where, N is length of S\\n\\n# Code\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        hashT = {str(num) for num in range(1, 27)}\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i == len(s): return 1\\n            if s[i] == \\'0\\': return 0\\n            res = dfs(i + 1)\\n            if i + 1 < len(s) and s[i: i + 2] in hashT:\\n                res += dfs(i + 2)\\n            return res\\n\\n        return dfs(0)\\n```\\n**UpVote,** if you found it helpful.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        hashT = {str(num) for num in range(1, 27)}\\n\\n        @lru_cache(None)\\n        def dfs(i):\\n            if i == len(s): return 1\\n            if s[i] == \\'0\\': return 0\\n            res = dfs(i + 1)\\n            if i + 1 < len(s) and s[i: i + 2] in hashT:\\n                res += dfs(i + 2)\\n            return res\\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795116,
                "title": "python-solution-explained-intuition-and-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This question is difficult because you need to understand the question clearly\\n- Supposed we have **s=\\'2222\\'**\\n    - Permutations for \\'2\\'\\n        ```\\n        2\\n        ```\\n    - Permutations for \\'22\\' \\n        ```\\n        2, 2 #These are the permutations from 2\\n             # BUT we add 2 infront\\n\\n        22\\n        ```\\n    - Permutations for \\'222\\' \\n        ```\\n        2, 2,2 #These are the permutations from 22\\n        2, 22  #BUT we add a 2 infront\\n\\n        22, 2 #These are the permutations from 2\\n             #BUT we add a 22 infront\\n        ```\\n    - Permutations for \\'2222\\' \\n        ```\\n        2, 2,2,2 #These are the permutations from 222\\n        2, 2,22  #BUT we add a 2 infront\\n        2, 22,2\\n\\n        22, 2,2 #These are the permutations from 22\\n        22, 22  #BUT we add a 22 infront\\n        ```\\n    - Therefore, there are 5 permutations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- From the above, we can deduce that this is a fibonacci dp question and a bottom up dp question\\n- We can deduce an algorithm\\n    - Loop through s (i)\\n        - if s[i] is a valid number (not 0) then we can include the previous permutation (s[i+1] permutation)\\n        - if s[i] can be expressed as 10-26 then we include previous previous permutation (s[i+2] permutation)\\n        - *Note: it is s[i+1] because we are going reverse*\\n    - return the last permutation\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(for optimised)* $$O(n)$$ *(for traditional)* \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n### Traditional DP Array\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0]*len(s)\\n        dp.append(1)\\n\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                continue\\n            dp[i] += dp[i+1]\\n            if i+1 < len(s) and (s[i] <= \\'1\\' or (s[i] == \\'2\\' and s[i+1] <= \\'6\\')):\\n                dp[i] += dp[i+2]\\n        return dp[0]\\n```\\n\\n### Optimised\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        left, right = 1, 0\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            ans = 0\\n            if s[i] != \\'0\\':\\n                ans += left\\n            if i+1 < len(s) and (s[i] == \\'1\\' or (s[i] == \\'2\\' and s[i+1] <= \\'6\\')):\\n                ans += right\\n            left, right = ans, left\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n        2\\n        ```\n```\\n        2, 2 #These are the permutations from 2\\n             # BUT we add 2 infront\\n\\n        22\\n        ```\n```\\n        2, 2,2 #These are the permutations from 22\\n        2, 22  #BUT we add a 2 infront\\n\\n        22, 2 #These are the permutations from 2\\n             #BUT we add a 22 infront\\n        ```\n```\\n        2, 2,2,2 #These are the permutations from 222\\n        2, 2,22  #BUT we add a 2 infront\\n        2, 22,2\\n\\n        22, 2,2 #These are the permutations from 22\\n        22, 22  #BUT we add a 22 infront\\n        ```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0]*len(s)\\n        dp.append(1)\\n\\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == \\'0\\':\\n                continue\\n            dp[i] += dp[i+1]\\n            if i+1 < len(s) and (s[i] <= \\'1\\' or (s[i] == \\'2\\' and s[i+1] <= \\'6\\')):\\n                dp[i] += dp[i+2]\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        left, right = 1, 0\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            ans = 0\\n            if s[i] != \\'0\\':\\n                ans += left\\n            if i+1 < len(s) and (s[i] == \\'1\\' or (s[i] == \\'2\\' and s[i+1] <= \\'6\\')):\\n                ans += right\\n            left, right = ans, left\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644026,
                "title": "java-solution-recursion-memoization-tabulation-spaceoptimization",
                "content": "```\\nclass Solution {\\n\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        return spaceOptimization(s.toCharArray(), n);\\n    }\\n\\n    // i == s.length() - 1;\\n    private int recursion(char[] s, int i) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        int pickOne = 0;\\n        int pickTwo = 0;\\n        if (s[i] != \\'0\\') {\\n            pickOne = recursion(s, i - 1);\\n        }\\n        if ((i - 1) >= 0 && ((s[i] <= \\'9\\' && s[i - 1] == \\'1\\') || (s[i] <= \\'6\\' && s[i - 1] == \\'2\\'))) {\\n            pickTwo = recursion(s, i - 2);\\n        }\\n        return pickOne + pickTwo;\\n    }\\n\\n    // i = s.length()-1, int[] dp = new int[s.length()]  dp[i] = -1 (0 <= i < s.length())\\n    private int memoization(char[] s, int i, int[] dp) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        if (dp[i] != -1)\\n            return dp[i];\\n\\n        int pickOne = 0;\\n        int pickTwo = 0;\\n        if (s[i] != \\'0\\') {\\n            pickOne = memoization(s, i - 1, dp);\\n        }\\n        if ((i - 1) >= 0 && ((s[i] <= \\'9\\' && s[i - 1] == \\'1\\') || (s[i] <= \\'6\\' && s[i - 1] == \\'2\\'))) {\\n            pickTwo = memoization(s, i - 2, dp);\\n        }\\n        return dp[i] = pickOne + pickTwo;\\n    }\\n\\n    // int[] dp = new int[s.length() + 2] , shift indices by 2 to handle base case\\n    private int tabulation(char[] s, int[] dp, int n) {\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for (int i = 2; i < n + 2; i++) {\\n            int pickOne = 0;\\n            int pickTwo = 0;\\n            if (s[i - 2] != \\'0\\') {\\n                pickOne = dp[i - 1];\\n            }\\n            if ((i - 1 - 2) >= 0\\n                    && ((s[i - 2] <= \\'9\\' && s[i - 1 - 2] == \\'1\\') || (s[i - 2] <= \\'6\\' && s[i - 1 - 2] == \\'2\\'))) {\\n                pickTwo = dp[i - 2];\\n            }\\n            dp[i] = pickOne + pickTwo;\\n        }\\n\\n        return dp[n + 1];\\n    }\\n\\t// shift indices by 2 to handle base case\\n    private int spaceOptimization(char[] s, int n) {\\n        int last = 1;\\n        int secondLast = 1;\\n        for (int i = 2; i < n + 2; i++) {\\n            int pickOne = 0;\\n            int pickTwo = 0;\\n            if (s[i - 2] != \\'0\\') {\\n                pickOne = last;\\n            }\\n            if ((i - 1 - 2) >= 0\\n                    && ((s[i - 2] <= \\'9\\' && s[i - 1 - 2] == \\'1\\') || (s[i - 2] <= \\'6\\' && s[i - 1 - 2] == \\'2\\'))) {\\n                pickTwo = secondLast;\\n            }\\n            secondLast = last;\\n            last = pickOne + pickTwo;\\n        }\\n\\n        return last;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        return spaceOptimization(s.toCharArray(), n);\\n    }\\n\\n    // i == s.length() - 1;\\n    private int recursion(char[] s, int i) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        int pickOne = 0;\\n        int pickTwo = 0;\\n        if (s[i] != \\'0\\') {\\n            pickOne = recursion(s, i - 1);\\n        }\\n        if ((i - 1) >= 0 && ((s[i] <= \\'9\\' && s[i - 1] == \\'1\\') || (s[i] <= \\'6\\' && s[i - 1] == \\'2\\'))) {\\n            pickTwo = recursion(s, i - 2);\\n        }\\n        return pickOne + pickTwo;\\n    }\\n\\n    // i = s.length()-1, int[] dp = new int[s.length()]  dp[i] = -1 (0 <= i < s.length())\\n    private int memoization(char[] s, int i, int[] dp) {\\n        if (i < 0) {\\n            return 1;\\n        }\\n        if (dp[i] != -1)\\n            return dp[i];\\n\\n        int pickOne = 0;\\n        int pickTwo = 0;\\n        if (s[i] != \\'0\\') {\\n            pickOne = memoization(s, i - 1, dp);\\n        }\\n        if ((i - 1) >= 0 && ((s[i] <= \\'9\\' && s[i - 1] == \\'1\\') || (s[i] <= \\'6\\' && s[i - 1] == \\'2\\'))) {\\n            pickTwo = memoization(s, i - 2, dp);\\n        }\\n        return dp[i] = pickOne + pickTwo;\\n    }\\n\\n    // int[] dp = new int[s.length() + 2] , shift indices by 2 to handle base case\\n    private int tabulation(char[] s, int[] dp, int n) {\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for (int i = 2; i < n + 2; i++) {\\n            int pickOne = 0;\\n            int pickTwo = 0;\\n            if (s[i - 2] != \\'0\\') {\\n                pickOne = dp[i - 1];\\n            }\\n            if ((i - 1 - 2) >= 0\\n                    && ((s[i - 2] <= \\'9\\' && s[i - 1 - 2] == \\'1\\') || (s[i - 2] <= \\'6\\' && s[i - 1 - 2] == \\'2\\'))) {\\n                pickTwo = dp[i - 2];\\n            }\\n            dp[i] = pickOne + pickTwo;\\n        }\\n\\n        return dp[n + 1];\\n    }\\n\\t// shift indices by 2 to handle base case\\n    private int spaceOptimization(char[] s, int n) {\\n        int last = 1;\\n        int secondLast = 1;\\n        for (int i = 2; i < n + 2; i++) {\\n            int pickOne = 0;\\n            int pickTwo = 0;\\n            if (s[i - 2] != \\'0\\') {\\n                pickOne = last;\\n            }\\n            if ((i - 1 - 2) >= 0\\n                    && ((s[i - 2] <= \\'9\\' && s[i - 1 - 2] == \\'1\\') || (s[i - 2] <= \\'6\\' && s[i - 1 - 2] == \\'2\\'))) {\\n                pickTwo = secondLast;\\n            }\\n            secondLast = last;\\n            last = pickOne + pickTwo;\\n        }\\n\\n        return last;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644022,
                "title": "c-dp-diagram",
                "content": "**Approach**\\n- Initialize a dp vector with 0.\\n- When we get single digit, we add `dp[i + 1]` to `dp[i]`.\\n- When we get two digit number less than or equal to 26, we add `dp[i + 2]` to `dp[i]`.\\n- If we encounter any zero as single digit, we will simply ignore it.\\n\\n**Diagram Explanation**\\n![image](https://assets.leetcode.com/users/images/057ef7a5-8946-410d-8b62-04c3f17fce54_1664591018.3017912.png)\\n\\n**C++ Code**\\n```cpp\\nint numDecodings(const string& s) {\\n    int N = s.size();\\n    vector<int> dp(N + 1, 0);\\n    dp[N] = 1;\\n\\n    for (int i = N - 1; i >= 0; --i) {\\n        if (s[i] != \\'0\\') {\\n          dp[i] += dp[i + 1];\\n        }\\n\\n        if (i+1 < N && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] <= \\'6\\')) {\\n          dp[i] += dp[i + 2];\\n        }\\n    }\\n    return dp[0];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint numDecodings(const string& s) {\\n    int N = s.size();\\n    vector<int> dp(N + 1, 0);\\n    dp[N] = 1;\\n\\n    for (int i = N - 1; i >= 0; --i) {\\n        if (s[i] != \\'0\\') {\\n          dp[i] += dp[i + 1];\\n        }\\n\\n        if (i+1 < N && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] <= \\'6\\')) {\\n          dp[i] += dp[i + 2];\\n        }\\n    }\\n    return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643933,
                "title": "python-easily-understood-faster-than-96-using-dp",
                "content": "Please ***UPVOTE*** if this is helpful and if there\\'s anything I can do to improve.\\n\\nProblem Reduction: variation of n-th staircase with n = [1, 2] steps.\\n\\nApproach: We generate a bottom up DP table.\\n\\nThe tricky part is handling the corner cases (e.g. s = \"30\").\\n\\nMost elegant way to deal with those error/corner cases, is to allocate an extra space, dp[0].\\n\\nLet dp[ i ] = the number of ways to parse the string s[1: i + 1]\\n\\nFor example:\\ns = \"231\"\\nindex 0: extra base offset. dp[0] = 1\\nindex 1: # of ways to parse \"2\" => dp[1] = 1\\nindex 2: # of ways to parse \"23\" => \"2\" and \"23\", dp[2] = 2\\nindex 3: # of ways to parse \"231\" => \"2 3 1\" and \"23 1\" => dp[3] = 2\\n``` \\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)] \\n\\n        # base case initialization\\n        dp[0] = 1 \\n        dp[1] = 0 if s[0] == \"0\" else 1   #(1)\\n\\n        for i in range(2, len(s) + 1): \\n            # One step jump\\n            if 0 < int(s[i-1:i]) <= 9:    #(2)\\n                dp[i] += dp[i - 1]\\n            # Two step jump\\n            if 10 <= int(s[i-2:i]) <= 26: #(3)\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]\\n``` \\nNotes of Wisdom:\\n(1): Handling s starting with \\'0\\'. Alternative: I would recommend treating as an error condition and immediately returning 0. It\\'s easier to keep track and it\\'s an optimization.\\n(2) (3): Pay close attention to your comparators. For (1) you want 0 <, not 0 <= . For (2) you want 10 <=, not 10 <",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        if not s:\\n            return 0\\n\\n        dp = [0 for x in range(len(s) + 1)] \\n\\n        # base case initialization\\n        dp[0] = 1 \\n        dp[1] = 0 if s[0] == \"0\" else 1   #(1)\\n\\n        for i in range(2, len(s) + 1): \\n            # One step jump\\n            if 0 < int(s[i-1:i]) <= 9:    #(2)\\n                dp[i] += dp[i - 1]\\n            # Two step jump\\n            if 10 <= int(s[i-2:i]) <= 26: #(3)\\n                dp[i] += dp[i - 2]\\n        return dp[len(s)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396552,
                "title": "c-recursive-dp-memoized-simple-solution",
                "content": "**1. Recursive Brute Force Solution(Gives TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(string s, int i, int n){\\n        \\n        if(i==n) return 1;\\n        \\n        if(s[i]==\\'0\\') return 0;\\n                \\n        string st = s.substr(i, 2);\\n        \\n        int path1 = f(s, i+1, n);\\n        \\n        int path2 = 0;\\n        \\n        if(stoi(st)>9 and stoi(st)<=26)\\n            path2 = f(s, i+2, n);\\n        \\n        return path1+path2;        \\n        \\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        return f(s, 0, s.size());\\n        \\n    }\\n};\\n\\n```\\n\\n**2. Memoized DP solution**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(string s, int i, int n, vector<int> &dp){\\n        \\n        if(i==n) return 1;\\n        \\n        if(s[i]==\\'0\\') return 0;\\n                \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        string st = s.substr(i, 2);\\n        \\n        int path1 = f(s, i+1, n, dp);\\n        \\n        int path2 = 0;\\n        \\n        if(stoi(st)>9 and stoi(st)<=26)\\n            path2 = f(s, i+2, n, dp);\\n        \\n        return dp[i]=path1+path2;        \\n        \\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        vector<int> dp(s.size(), -1);\\n        return f(s, 0, s.size(), dp);\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(string s, int i, int n){\\n        \\n        if(i==n) return 1;\\n        \\n        if(s[i]==\\'0\\') return 0;\\n                \\n        string st = s.substr(i, 2);\\n        \\n        int path1 = f(s, i+1, n);\\n        \\n        int path2 = 0;\\n        \\n        if(stoi(st)>9 and stoi(st)<=26)\\n            path2 = f(s, i+2, n);\\n        \\n        return path1+path2;        \\n        \\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        return f(s, 0, s.size());\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(string s, int i, int n, vector<int> &dp){\\n        \\n        if(i==n) return 1;\\n        \\n        if(s[i]==\\'0\\') return 0;\\n                \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        string st = s.substr(i, 2);\\n        \\n        int path1 = f(s, i+1, n, dp);\\n        \\n        int path2 = 0;\\n        \\n        if(stoi(st)>9 and stoi(st)<=26)\\n            path2 = f(s, i+2, n, dp);\\n        \\n        return dp[i]=path1+path2;        \\n        \\n    }\\n    \\n    int numDecodings(string s) {\\n        \\n        vector<int> dp(s.size(), -1);\\n        return f(s, 0, s.size(), dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179501,
                "title": "c-solution-0ms-beats-100",
                "content": "class Solution {\\npublic:\\n\\n    int numDecodings(string str) {\\n        vector<long long> dp(str.size()+1,0);\\n\\t    dp[str.size()] = 1;\\n\\t    \\n\\t    for(int i=str.size()-1; i>=0; i--) {\\n\\t        if(str[i] != \\'0\\') {\\n\\t            dp[i] = dp[i+1];\\n\\t        \\n    \\t        if(i+1<str.size()) {\\n    \\t            string tmp = \"\";\\n        \\t        tmp += str[i];\\n        \\t        tmp += str[i+1];\\n        \\t        if(stoi(tmp)<=26) {\\n        \\t            dp[i] += dp[i+2];\\n        \\t        }\\n    \\t        }\\n\\t        }\\n\\t    }\\n\\t    return dp[0];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numDecodings(string str) {\\n        vector<long long> dp(str.size()+1,0);\\n\\t    dp[str.size()] = 1;\\n\\t    \\n\\t    for(int i=str.size()-1; i>=0; i--) {\\n\\t        if(str[i] != \\'0\\') {\\n\\t            dp[i] = dp[i+1];\\n\\t        \\n    \\t        if(i+1<str.size()) {\\n    \\t            string tmp = \"\";\\n        \\t        tmp += str[i];\\n        \\t        tmp += str[i+1];\\n        \\t        if(stoi(tmp)<=26) {\\n        \\t            dp[i] += dp[i+2];\\n        \\t        }",
                "codeTag": "Java"
            },
            {
                "id": 1927223,
                "title": "python-dp-solution-simple-and-easy",
                "content": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s)+1)\\n        dp[0] = 1\\n        if s[0] != \\'0\\': \\n            dp[1] = 1\\n        for i in range(2, len(s)+1):\\n            if int(s[i-1]) >= 1 and int(s[i-1]) <= 9:\\n                dp[i] += dp[i-1]\\n            second = int(s[i-2:i])\\n            if second >= 10 and second <= 26:\\n                dp[i] += dp[i-2]\\n        return dp[-1]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [0] * (len(s)+1)\\n        dp[0] = 1\\n        if s[0] != \\'0\\': \\n            dp[1] = 1\\n        for i in range(2, len(s)+1):\\n            if int(s[i-1]) >= 1 and int(s[i-1]) <= 9:\\n                dp[i] += dp[i-1]\\n            second = int(s[i-2:i])\\n            if second >= 10 and second <= 26:\\n                dp[i] += dp[i-2]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643936,
                "title": "clean-python-solution-self-explained-o-n",
                "content": "```python\\n\"\"\"\\nTime: O(N), due to the \"memo\", the time can reduce from O(2^N) to O(N).\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        def helper(s, i):\\n            if (s, i) in memo: return memo[(s, i)]\\n            if i>=len(s): return 1\\n            if s[i]==\\'0\\': return 0\\n            \\n            count = 0\\n            count += helper(s, i+1)\\n            if len(s)-i>=2 and int(s[i:i+2])<=26: count += helper(s, i+2)\\n            memo[(s, i)] = count\\n            return count\\n                \\n        memo = {}\\n        return helper(s, 0)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N), due to the \"memo\", the time can reduce from O(2^N) to O(N).\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def numDecodings(self, s):\\n        def helper(s, i):\\n            if (s, i) in memo: return memo[(s, i)]\\n            if i>=len(s): return 1\\n            if s[i]==\\'0\\': return 0\\n            \\n            count = 0\\n            count += helper(s, i+1)\\n            if len(s)-i>=2 and int(s[i:i+2])<=26: count += helper(s, i+2)\\n            memo[(s, i)] = count\\n            return count\\n                \\n        memo = {}\\n        return helper(s, 0)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517430,
                "title": "most-simple-solution-ever-simple-approach-dynamic-programming",
                "content": "dp[i] stands for how many different decode ways at position i so far.\\ndp[1] = 1, since s.charAt(0) = 2, which has only 1 way of decoding\\ndp[2] = ?\\nFirst, there are at least 1 way. Because \"22\" -> \"BB\" as dp[1] = 1 = dp[2-1]\\nSecond, \"22\" is also equivalent to \"V\" as dp[0] = 1 = dp[2-2]\\nTherefore, in total, dp[2] = 1 + 1 = 2. Let\\'s continue...\\n\\n**How about dp[3] = ?**\\nFirst, there are at least 2 ways, Because we have already known dp[2] = 2, and \"22\" can be decoded to \"BB\" or \"V\". Alternatively, \"226\" can be decode to \"BBF\" or \"VF\", 2 ways.\\nSecond, \"226\" can also be separate into \"2\" and \"26\", so this is 1 more way.\\n\\nHowever, if we take a closer look at \"2\" and \"26\".\\nThis is 1 way of separation because we have already defined at where \"2\" => dp[1] => dp[3-2] = 1 way\\n\\n**Why we should initialize dp[0]=1 instead of 0?**\\n\\nAnswer: So dp[0] means the number ways to decode the empty string? Then 1 is correct. Because the empty string can be decoded. To the empty string.\\n\\n\\n\\n```\\npublic class Solution {\\n    public int numDecodings(String s) {\\n        /*first check if our string is valid or the length is bigger than zero*/  \\n       if(s==null || s.length()==0) return 0;\\n        int len=s.length();\\n       /*Second we will build or DP array with size of s.length()+1*/\\n       int []dp= new int [len+1];\\n       /*We need to put our intial cases when I have string with length 0 I can decode with only value 1*/\\n       dp[0]=1;\\n       /*then we want to check if the  string with length 1 and has value instead of \"0\" I will use ternary coondition here*/\\n       dp[1]= (s.charAt(0)!=\\'0\\')?1:0;\\n       /*Now we need to handel if the string length is bigger than 1 we can use a for loop and then reproduce all possible combination using substring(start,end) function , I will start my loop from i=2 becasue I already handled the first char of the string */\\n\\n       for(int i=2;i<=s.length();i++)\\n       {\\n           int oneDigit= Integer.valueOf(s.substring(i-1,i)); \\n           int TwoDigit= Integer.valueOf(s.substring(i-2,i));\\n            if (oneDigit >= 1 && oneDigit <= 9) {\\n               dp[i] += dp[i-1];  \\n            }\\n            if (TwoDigit >= 10 && TwoDigit <= 26) {\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int numDecodings(String s) {\\n        /*first check if our string is valid or the length is bigger than zero*/  \\n       if(s==null || s.length()==0) return 0;\\n        int len=s.length();\\n       /*Second we will build or DP array with size of s.length()+1*/\\n       int []dp= new int [len+1];\\n       /*We need to put our intial cases when I have string with length 0 I can decode with only value 1*/\\n       dp[0]=1;\\n       /*then we want to check if the  string with length 1 and has value instead of \"0\" I will use ternary coondition here*/\\n       dp[1]= (s.charAt(0)!=\\'0\\')?1:0;\\n       /*Now we need to handel if the string length is bigger than 1 we can use a for loop and then reproduce all possible combination using substring(start,end) function , I will start my loop from i=2 becasue I already handled the first char of the string */\\n\\n       for(int i=2;i<=s.length();i++)\\n       {\\n           int oneDigit= Integer.valueOf(s.substring(i-1,i)); \\n           int TwoDigit= Integer.valueOf(s.substring(i-2,i));\\n            if (oneDigit >= 1 && oneDigit <= 9) {\\n               dp[i] += dp[i-1];  \\n            }\\n            if (TwoDigit >= 10 && TwoDigit <= 26) {\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516278,
                "title": "my-c-soln-with-explanation",
                "content": "So here we will first count the possible ways for n-1 digits and see if the last digit is greater than 0 so than we can add the no to all the possible ways in the last and then if the last two digits is greater than 10 and smaller than 26 so we will add that in n-2 possible ways and return the total till now.........\\n\\n**Example**\\n\\n* 1, 4, 2, 2 so its ways possible ways are 1, 4, 2, 2.......14, 2, 2.....14, 22.....1, 4, 22....so its 4 ways now \\n* suppose last digit is 3 so now 3>0 so we will add 3 in last 4 ways ie....1, 4,  2, 2, 3.....14, 2, 2, 3.....14, 22, 3.....1, 4, 22, 3.........\\n* and then we will see the last two digits 23 is smaller than 26 so we will add that in last n-2 ways ie.......1, 4, 2.......14, 2......adding last two digits will be->  1, 4, 2, 23.......14, 2, 23......\\n* so it is 2 ways.....now total ways are **4+2=6 ans.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n\\t\\tint n=s.size();\\n        if(n== 0 || s[0] == \\'0\\') \\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n        if(n == 1)\\n\\t\\t\\treturn 1;\\n        \\n        int count1 = 1, count2 = 1;\\n        for(int i = 1; i <n; ++i) \\n\\t\\t{\\n            int last_digit = s[i] - \\'0\\';\\n            int last_two_digit = (s[i-1] - \\'0\\')*10 + d;\\n            int count = 0;\\n            if( last_digit > 0) \\n\\t\\t\\t\\tcount += count2;\\n\\t\\n            if(last_two_digit>= 10 && last_two_digit <= 26) \\n\\t\\t\\t\\tcount += count1;\\n\\t\\t\\t\\t\\n            count1 = count2;  // prev to prev\\n            count2 = count;  // count2 prev sol\\n        }\\n        return count2;\\n    }\\n};\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n\\t\\tint n=s.size();\\n        if(n== 0 || s[0] == \\'0\\') \\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n        if(n == 1)\\n\\t\\t\\treturn 1;\\n        \\n        int count1 = 1, count2 = 1;\\n        for(int i = 1; i <n; ++i) \\n\\t\\t{\\n            int last_digit = s[i] - \\'0\\';\\n            int last_two_digit = (s[i-1] - \\'0\\')*10 + d;\\n            int count = 0;\\n            if( last_digit > 0) \\n\\t\\t\\t\\tcount += count2;\\n\\t\\n            if(last_two_digit>= 10 && last_two_digit <= 26) \\n\\t\\t\\t\\tcount += count1;\\n\\t\\t\\t\\t\\n            count1 = count2;  // prev to prev\\n            count2 = count;  // count2 prev sol\\n        }\\n        return count2;\\n    }\\n};\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170829,
                "title": "recursive-memoization-approach-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/073e7f92-3fe3-422b-93ec-8421bcbbcdc1_1619074839.8427038.png)![image](https://assets.leetcode.com/users/images/9bc34815-2568-4c1c-9842-5bb0dce09b4a_1619075048.7259173.jpeg)\\nclass Solution {\\npublic:\\n   \\n    int count = 0;\\n    bool isvalid(string some){\\n   \\n           int a = 0;\\n        if (some[0] == \\'0\\')\\n            return false;      // suppose we get a string like \"06\" so we return zero if we dont write this here our below loop will give us 6 we will give us wrong ans //\\n\\n        for (auto x : some){\\n            a = (a*10) + (x - \\'0\\');\\n        }\\n        if (a>=1 && 26>=a){\\n            return true;\\n        }\\n        return false;\\n        \\n   }\\n      \\n   int solve (string str , int i , vector<long long>&dp){\\n       \\n       if ( i > str.size()){\\n            return 0;\\n        }\\n        if ( i == str.size()) {\\n            return 1;\\n        }\\n        if (dp[i] != -1){\\n            return dp[i];\\n        } \\n       \\n        string one , two;\\n        if (i+1 <= str.size())\\n            one = str.substr(i , 1);  // taking substring of size 1\\n        if (i+2 <= str.size())\\n            two = str.substr(i , 2); //taking substring of size 2 //\\n\\n\\n        long long op1 = 0 , op2 = 0 ;\\n        if (isvalid(one)){\\n           op1 = solve ( str , i+1 , dp);\\n        }\\n        if (isvalid(two)){\\n           op2 =  solve (str , i+2 , dp);\\n        }\\n       return dp[i] = (op1+op2);\\n     \\n   }\\n    \\n    int numDecodings(string s) {\\n        vector<long long>dp(s.size() , -1);\\n       return solve(s , 0 , dp);\\n       \\n    }\\n    };\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    int count = 0;\\n    bool isvalid(string some){\\n   \\n           int a = 0;\\n        if (some[0] == \\'0\\')\\n            return false;      // suppose we get a string like \"06\" so we return zero if we dont write this here our below loop will give us 6 we will give us wrong ans //\\n\\n        for (auto x : some){\\n            a = (a*10) + (x - \\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988320,
                "title": "go-golang-dp-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Decode Ways.\\nMemory Usage: 2 MB, less than 51.15% of Go online submissions for Decode Ways.\\n\\n```go\\nfunc numDecodings(s string) int {\\n    dp := make([]int, len(s) + 1)\\n    dp[0] = 1\\n    if s[0] != \\'0\\' { dp[1] = 1 }\\n    for i := 2; i < len(dp); i++ {\\n        oneD, _ := strconv.Atoi(s[i - 1:i])\\n        twoD, _ := strconv.Atoi(s[i - 2:i])\\n        if oneD >= 1 { dp[i] += dp[i - 1] }\\n        if twoD >= 10 && twoD <= 26 { dp[i] += dp[i - 2] }\\n    }\\n    return dp[len(s)]\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numDecodings(s string) int {\\n    dp := make([]int, len(s) + 1)\\n    dp[0] = 1\\n    if s[0] != \\'0\\' { dp[1] = 1 }\\n    for i := 2; i < len(dp); i++ {\\n        oneD, _ := strconv.Atoi(s[i - 1:i])\\n        twoD, _ := strconv.Atoi(s[i - 2:i])\\n        if oneD >= 1 { dp[i] += dp[i - 1] }\\n        if twoD >= 10 && twoD <= 26 { dp[i] += dp[i - 2] }\\n    }\\n    return dp[len(s)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950115,
                "title": "java-dp-solution-o-n-o-n-2ms",
                "content": "This porblem is a good example for Dynamic Programming, As we can notice we need to map each letter into number so, the first thing we can takle while we are solving the DP is to look for the sample or satrting testcase \\nLet\\'s have some example to explain the DP\\n\\nEx1:\\nrange [1:9]--> number of ways to decod will be 1\\nEx2:\\n0 -->number of ways to decod will be 0\\nEx3:\\n[10:26] -->number of ways to decod will be 3 becasue I can decode \\n\\n\\n            (236) \\n        /            \\\\\\n     \"3\"26           \"32\"6  \\t\\n     /     \\\\           x  \\n    \"2\"6 \"26\" \\n\\t /\\n\\t\"6\"\\n  \\n \\nSo we can notice from this recomputing values so can use DP, also we can notice that we are working with strings of size 1 or size 2 becasue these are the possibles simple values to work with it will be in ranges [0:9] and [10:26]\\n\\n```\\npublic int solution (String s) {\\n   /*first check if our string is valid or the length is bigger than zero*/  \\n   if(s==null || s.length()==0) return 0;\\n   /*Second we will build or DP array with size of s.length()+1*/\\n   int []dp= new int [s.length()+1];\\n   /*We need to put our intial cases when I have string with length 0 I can decode with only value 1*/\\n   dp[0]=1;\\n   /*then we want to check if the  string with length 1 and has value instead of \"0\" I will use ternary coondition here*/\\n   dp[1]= (s.charAt(0)!=\\'0\\')?1:0;\\n   /*Now we need to handel if the string length is bigger than 1 we can use a for loop and then reproduce all possible combination using substring(start,end) function , I will start my loop from i=2 becasue I already handled the first char of the string */\\n   \\n   for(int i=2;i<=s.length();i++)\\n   {\\n       int oneDigit= Integer.valueOf(s.substring(i-1,i)); \\n\\t   int TwoDigit= Integer.valueOf(s.substring(i-2,i));\\n\\t   \\n\\t   //Check if oneDigit doesn\\'t equal 0 \\n\\t    if(oneDigit!=0){\\n\\t   // dp{0,1,?} \\n\\t       dp[i]+=dp[i-1]; }// the value here will be 2 for the provided example because we have in this stage 2 numbers so 23 so to decod them we can have two values if we are working on a sperate digits  \\n\\t\\t if(twoDigit>=10 && twoDigit<=26){\\n\\t\\t    dp[i]+=dp[i-2];\\n\\t\\t }\\n\\t\\t\\n   }\\n   \\n   return dp[s.length()];\\n }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int solution (String s) {\\n   /*first check if our string is valid or the length is bigger than zero*/  \\n   if(s==null || s.length()==0) return 0;\\n   /*Second we will build or DP array with size of s.length()+1*/\\n   int []dp= new int [s.length()+1];\\n   /*We need to put our intial cases when I have string with length 0 I can decode with only value 1*/\\n   dp[0]=1;\\n   /*then we want to check if the  string with length 1 and has value instead of \"0\" I will use ternary coondition here*/\\n   dp[1]= (s.charAt(0)!=\\'0\\')?1:0;\\n   /*Now we need to handel if the string length is bigger than 1 we can use a for loop and then reproduce all possible combination using substring(start,end) function , I will start my loop from i=2 becasue I already handled the first char of the string */\\n   \\n   for(int i=2;i<=s.length();i++)\\n   {\\n       int oneDigit= Integer.valueOf(s.substring(i-1,i)); \\n\\t   int TwoDigit= Integer.valueOf(s.substring(i-2,i));\\n\\t   \\n\\t   //Check if oneDigit doesn\\'t equal 0 \\n\\t    if(oneDigit!=0){\\n\\t   // dp{0,1,?} \\n\\t       dp[i]+=dp[i-1]; }// the value here will be 2 for the provided example because we have in this stage 2 numbers so 23 so to decod them we can have two values if we are working on a sperate digits  \\n\\t\\t if(twoDigit>=10 && twoDigit<=26){\\n\\t\\t    dp[i]+=dp[i-2];\\n\\t\\t }\\n\\t\\t\\n   }\\n   \\n   return dp[s.length()];\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 940620,
                "title": "recursion-memoization-js-solution",
                "content": "```\\nvar numDecodings = function(s) {\\n    // validate input\\n    if (s.replace(/[0-9]/g, \"\") !== \"\") {\\n        return 0;\\n    }\\n    if (s === \"\") {\\n        return 0;\\n    }\\n    let set = new Set(), memo = new Map();\\n    for (let i = 1; i <= 26; i++) {\\n        set.add(i.toString());\\n    }\\n    return decode(s, set, memo);\\n    // T.C: O(N), memoization helps pruning the recursion tree\\n    // S.C: O(N), memo hash table can contain at most N entries\\n};\\n\\nconst decode = (s, set, memo) => {\\n    if (s.length === 0) {\\n        return 1;\\n    }\\n    if (s.length === 1) {\\n        return set.has(s) ? 1 : 0;\\n    }\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    let numOfWays = 0;\\n    if (set.has(s.substring(0,1))) {\\n        numOfWays += decode(s.substring(1), set, memo);\\n    }\\n    if (set.has(s.substring(0,2))) {\\n        numOfWays += decode(s.substring(2), set, memo);\\n    }\\n    memo.set(s, numOfWays);\\n    return numOfWays;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numDecodings = function(s) {\\n    // validate input\\n    if (s.replace(/[0-9]/g, \"\") !== \"\") {\\n        return 0;\\n    }\\n    if (s === \"\") {\\n        return 0;\\n    }\\n    let set = new Set(), memo = new Map();\\n    for (let i = 1; i <= 26; i++) {\\n        set.add(i.toString());\\n    }\\n    return decode(s, set, memo);\\n    // T.C: O(N), memoization helps pruning the recursion tree\\n    // S.C: O(N), memo hash table can contain at most N entries\\n};\\n\\nconst decode = (s, set, memo) => {\\n    if (s.length === 0) {\\n        return 1;\\n    }\\n    if (s.length === 1) {\\n        return set.has(s) ? 1 : 0;\\n    }\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    let numOfWays = 0;\\n    if (set.has(s.substring(0,1))) {\\n        numOfWays += decode(s.substring(1), set, memo);\\n    }\\n    if (set.has(s.substring(0,2))) {\\n        numOfWays += decode(s.substring(2), set, memo);\\n    }\\n    memo.set(s, numOfWays);\\n    return numOfWays;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835174,
                "title": "python-top-down-dp-with-memoization",
                "content": "This problem is about generating slices of a string and counting them. There are only two restrictions. 1) \\'0\\' is not a valid number. 2) Any number > 26 is not valid\\n\\ns = \\'227\\' \\n-> 2 2 7 OK\\n-> 22 7 OK\\n-> 2 27 NOT OK\\nAns = 2\\n\\ns = \\'220\\'\\n-> 2 2 0 NOT OK\\n-> 2 20 OK\\n-> 22 0 NOT OK\\nAns = 1\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        return self.helper(s,{})\\n    def helper(self, s, memo):\\n        if not s: # We reached an answer here\\n            return 1\\n        if s[0] == \"0\":  # Any # with 0 at start of string is invalid, including 0 itself\\n            return 0\\n        if s in memo: # Retrieve from cache\\n            return memo[s]\\n        \\n        res = 0\\n        res += self.helper(s[1:], memo)\\n        \\n        if len(s) >= 2:\\n            if int(s[0:2]) <= 26: # Check if the first 2 numbers are over 26. Then recursively call the function on the rest of the string\\n                res += self.helper(s[2:], memo)\\n        memo[s] = res\\n        return memo[s]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        return self.helper(s,{})\\n    def helper(self, s, memo):\\n        if not s: # We reached an answer here\\n            return 1\\n        if s[0] == \"0\":  # Any # with 0 at start of string is invalid, including 0 itself\\n            return 0\\n        if s in memo: # Retrieve from cache\\n            return memo[s]\\n        \\n        res = 0\\n        res += self.helper(s[1:], memo)\\n        \\n        if len(s) >= 2:\\n            if int(s[0:2]) <= 26: # Check if the first 2 numbers are over 26. Then recursively call the function on the rest of the string\\n                res += self.helper(s[2:], memo)\\n        memo[s] = res\\n        return memo[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322838,
                "title": "c-concise-dp-o-n-time-o-1-space",
                "content": "We start from the end of the string and work backwards.\\n\\n`c`, `n`, and `nn` represent the number of possible encodings starting from the current digit, the next digit, and the next next digit, respectively. They all start at `1` since an empty string can be encoded in exactly one way.\\n\\n- If the current digit is `0`, there are no ways to encode starting from that point.\\n- If the current digit and next digit are between `10` and `26`, we can either encode them individually, or as a pair. Thus, we add together the possible encodings from `n` and `nn`.\\n- Otherwise, we can only encode in the same number of ways as if we started from the next digit, so `c` = `n`.\\n\\n```\\nint numDecodings(string s) {\\n\\tint c = 1, n = 1, nn = 1;\\n\\tfor(int i = s.size() - 1; i >= 0; i--) {\\n\\t\\tif(s[i] == \\'0\\') c = 0;\\n\\t\\telse if(i < s.size() - 1 && (s[i] == \\'2\\' && s[i + 1] <= \\'6\\' || s[i] == \\'1\\')) c = n + nn;\\n\\t\\telse c = n;\\n\\n\\t\\tnn = n;\\n\\t\\tn = c;\\n\\t}\\n\\treturn c;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint numDecodings(string s) {\\n\\tint c = 1, n = 1, nn = 1;\\n\\tfor(int i = s.size() - 1; i >= 0; i--) {\\n\\t\\tif(s[i] == \\'0\\') c = 0;\\n\\t\\telse if(i < s.size() - 1 && (s[i] == \\'2\\' && s[i + 1] <= \\'6\\' || s[i] == \\'1\\')) c = n + nn;\\n\\t\\telse c = n;\\n\\n\\t\\tnn = n;\\n\\t\\tn = c;\\n\\t}\\n\\treturn c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250683,
                "title": "my-dp-solution-in-swift",
                "content": "```swift\\nclass Solution {\\n    func numDecodings(_ s: String) -> Int {\\n        let s = Array(s)\\n        var dp = Array(repeating: 0, count: s.count)\\n        \\n        for i in 0..<dp.count {\\n            // consider 1 digit\\n            if s[i] != \"0\" {\\n                dp[i] += (i >= 1) ? dp[i-1] : 1\\n            }\\n\\n            // consider 2 digits\\n            if i >= 1 {\\n                let combined = Int(String(s[i-1...i]))!\\n                if combined >= 10 && combined <= 26 {\\n                    dp[i] += (i >= 2) ? dp[i-2] : 1\\n                }\\n            }\\n        }\\n        \\n        return dp.last ?? 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func numDecodings(_ s: String) -> Int {\\n        let s = Array(s)\\n        var dp = Array(repeating: 0, count: s.count)\\n        \\n        for i in 0..<dp.count {\\n            // consider 1 digit\\n            if s[i] != \"0\" {\\n                dp[i] += (i >= 1) ? dp[i-1] : 1\\n            }\\n\\n            // consider 2 digits\\n            if i >= 1 {\\n                let combined = Int(String(s[i-1...i]))!\\n                if combined >= 10 && combined <= 26 {\\n                    dp[i] += (i >= 2) ? dp[i-2] : 1\\n                }\\n            }\\n        }\\n        \\n        return dp.last ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30498,
                "title": "easy-solution-to-this-question",
                "content": "    class Solution {\\n    public:\\n        int numDecodings(string s) {\\n            //\\u52a8\\u6001\\u89c4\\u5212\\n           if(s.size()==0 || s[0]=='0') return 0;\\n           int last1 = 1,last2 = 1;\\n           for(int i = 1;i<s.size() && last1!=0;i++)\\n           {\\n               int cur = 0;\\n               if(s[i]!='0') cur+=last1;\\n               if(s[i-1]=='1' || (s[i-1]=='2' && s[i]<='6')) cur+=last2;\\n               last2 = last1;\\n               last1 = cur;//\\u5982\\u679c\\u4e2d\\u95f4\\u9047\\u5230\\u4e860 \\u5219\\u76f4\\u63a5\\u8fd4\\u56de0\\n           }\\n           return last1;\\n         }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int numDecodings(string s) {\\n            //\\u52a8\\u6001\\u89c4\\u5212\\n           if(s.size()==0 || s[0]=='0') return 0;\\n           int last1 = 1,last2 = 1;\\n           for(int i = 1;i<s.size() && last1!=0;i++)\\n           {\\n               int cur = 0;\\n               if(s[i]!='0') cur+=last1;\\n               if(s[i-1]=='1' || (s[i-1]=='2' && s[i]<='6')) cur+=last2;\\n               last2 = last1;\\n               last1 = cur;//\\u5982\\u679c\\u4e2d\\u95f4\\u9047\\u5230\\u4e860 \\u5219\\u76f4\\u63a5\\u8fd4\\u56de0\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 30540,
                "title": "very-very-very-simple-python-solution-using-top-down-dp",
                "content": "    class Solution(object):\\n        def numDecodings(self, s):\\n    \\n            def search(s, memo):\\n                if s in memo:\\n                    return memo[s]\\n                if len(s) <= 1:\\n                    return 1 if s != \"0\" else 0\\n                res, n, i = 0, len(s), 1\\n                while i <= n and 1 <= int(s[:i]) <= 26:\\n                    res += search(s[i:], memo)\\n                    i += 1\\n                memo[s] = res\\n                return res\\n    \\n            if s == \"\":\\n                return 0\\n            return search(s, {})",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n        def numDecodings(self, s):\\n    \\n            def search(s, memo):\\n                if s in memo:\\n                    return memo[s]\\n                if len(s) <= 1:\\n                    return 1 if s != \"0\" else 0\\n                res, n, i = 0, len(s), 1\\n                while i <= n and 1 <= int(s[:i]) <= 26:\\n                    res += search(s[i:], memo)\\n                    i += 1\\n                memo[s] = res\\n                return res\\n    \\n            if s == \"\":\\n                return 0\\n            return search(s, {}",
                "codeTag": "Java"
            },
            {
                "id": 3255779,
                "title": "memoization-tabulation-space-optimization-dp-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int n, string &s, vector<int> &dp) {\\n        if(i == n) return 1;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : dfs(i + 1, n, s, dp);\\n        int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dfs(i + 2, n, s, dp) : 0;\\n\\n        return dp[i] = pick1 + pick2;\\n    }\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, s, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i=n-1; i>=0; i--) {\\n            int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : dp[i + 1];\\n            int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dp[i + 2] : 0;\\n            dp[i] = pick1 + pick2;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size(), a = 1, b = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : a;\\n            int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? b : 0;\\n            int c = pick1 + pick2;\\n            b = a;\\n            a = c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, string &s, vector<int> &dp) {\\n        if(i == n) return 1;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : dfs(i + 1, n, s, dp);\\n        int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dfs(i + 2, n, s, dp) : 0;\\n\\n        return dp[i] = pick1 + pick2;\\n    }\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, s, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i=n-1; i>=0; i--) {\\n            int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : dp[i + 1];\\n            int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? dp[i + 2] : 0;\\n            dp[i] = pick1 + pick2;\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size(), a = 1, b = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            int pick1 = s[i + 1] == \\'0\\' || s[i] == \\'0\\' ? 0 : a;\\n            int pick2 = s[i] != \\'0\\' && i + 1 < n && stoi(s.substr(i, 2)) <= 26 ? b : 0;\\n            int c = pick1 + pick2;\\n            b = a;\\n            a = c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103831,
                "title": "beats-100-c-easy-solution-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,string &s,vector<int>&dp){\\n        int n=s.size();\\n        if(s[i]==\\'0\\') return 0;\\n        if(i==n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int res=f(i+1,s,dp);\\n        if(i<n-1 && (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1]<=\\'6\\'))\\n            res=(res+f(i+2,s,dp));\\n        return dp[i]=res;\\n    }\\n    int numDecodings(string s) {\\n        vector<int>dp(s.size()+1,-1);\\n\\t\\treturn f(0,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,string &s,vector<int>&dp){\\n        int n=s.size();\\n        if(s[i]==\\'0\\') return 0;\\n        if(i==n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int res=f(i+1,s,dp);\\n        if(i<n-1 && (s[i]==\\'1\\' || s[i]==\\'2\\' && s[i+1]<=\\'6\\'))\\n            res=(res+f(i+2,s,dp));\\n        return dp[i]=res;\\n    }\\n    int numDecodings(string s) {\\n        vector<int>dp(s.size()+1,-1);\\n\\t\\treturn f(0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857885,
                "title": "continuing-your-leetcode-journey-here-s-an-easy-to-understand-break-down",
                "content": "# Intuition\\n\"1\" = A. This gives us $$1 way$$\\n\"11\" = AA or K. This gives us $$2 ways$$\\n\\nBasically, get all the possible ways we can interpret the number - which is given to us as a string of numbers. \\n\\nIntuitively, we can examine each ***single-digit number*** or each ***two-digit number*** at every digit/index. At a high level, we know that we just have to iterate through each possibility. ***Bear with me through the edge cases because that\\'s what makes this algorithm different than other easier Dynamic Programming problems.***\\n\\n#### Example: \"12\"\\nWe can look at the number 1 and then the number 2. We can also look at the number 12. Therefore we can see there are 3 ways: 1, 2, and 12. \\n\\n#### Edge Case: \"102\" \\nIn this case, there is a 0 between 1 and 2. We can actually no longer interpret 1 and 2 separately because we would have to examine, \\'1 and 0 and 2\\' OR \\'1 and 02\\'. \\n\\n**Why**? \\n\\nBecause if we remove 1 from 102, we will get 02. And no matter *how* we look at 02, it is not a valid number (at least in this scenario). 02 is not valid and 0 is not valid because it does not fall within our range of 1 to 26 inclusive (the letters A - Z). \\n\\nSo at the point that our number begins with 0, we can return 0 because there isn\\'t a way to interpret the string when 0 is a starting digit. So essentially, we can stop searching this current path because taking the 1 from \"102\" will just give us 02 which is always an invalid pathway. Thus, there is only one way to interpret this number: 10,2 which ends up being \"JB\". *(The translation to letters doesn\\'t matter, but may be helpful to understand the logic here)*\\n\\n#### Another Edge Case: \"127\"\\n\\nIn this case, we get $$2 ways$$: 1,2,7 and 12,7. The only important distinction to be made here is that $$1,27$$ is not a valid way because 27 is out of our range 1 - 26 inclusive. \\n\\n# Approach\\nWe can do a top-down with memoization or a bottom-up dynamic programming approach.\\n\\n# Algorithm\\n\\n#### Top down with Memoization\\n1. Create hashmap for memoization.\\n2. Create our recursive depth-first-search function with $$i$$ representing our current index.\\n3. Handle our base cases: \\nif s[$$i$$] is \\'0\\' return 0; \\nif $$i$$ reaches the end of the string or the string length, we can return 1 (this represents that we found a valid way).\\n4. Set $$nextTwoDigitNum$$ to the $$number$$ you would get by taking the two indices from index $$i$$. Example: \"12\" at index 0 would give us 12 here.\\n5. Set $$nextDigitNum$$ to dfs(i + 1). At this step we\\'re examining the input one digit at a time.\\n6. Finally, if $$nextTwoDigitNum$$ is within our range of 1-26 inclusive, we can add it to the number of ways we get from $$nextDigitNum$$. *Note*: we only really need to check from 10 to 26 because anything less than 10 would be a single digit number. Here I simply add dfs(i + 2) representing that we found a valid 2 digit number.\\n7. Return our recursive function with the first index of the (number) string.\\n\\n#### Bottom Up with Space Optimization\\n\\nWe can optimize space here similar to the `number of ways to traverse stairs` problem and `fibonacci`. (I don\\'t remember the exact variation, please feel free to comment problem names that have this pattern if you come across it)\\n\\n1. Handle our base cases: if the string begins with \\'0\\' or the length of the string is 0, return 0.\\n2. Set our two variables $$back1$$ and $$back2$$ to 1 representing 1 valid way of interpretting our input.\\n3. Loop through the (number) string starting at index 1. If we have a valid single digit number, we can set $$current$$ from 0 to $$back1$$ representing valid ways found at the last index.\\n4. Similar to step 4 of the top-down method we check the two-digit number at index $$i$$ as well. Notice that we slice our number at i - 1 to i + 1. This is because we\\'re starting at index 1 and need to account for the number starting at index 0. We also want to save the \"current\" number of ways to our corresponding index in a DP array. **However, Since we\\'re not using a DP array, we are simply saving the current number of ways to $$back1$$.\\n5. Return $$back1$$ representing the number of ways we have calculated.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the size of the input string\\n\\n- Space complexity:\\nTop down w/ memoization: O(n) where n is the size of the input string\\nBottom up with optimization O(1) \\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n\\n// top down\\nvar numDecodingsTD = function(s) { // remove TD from var name to test\\n  const memo = {}\\n  \\n  function dfs(i) {\\n    if (i in memo) return memo[i]\\n    \\n    if (s[i] === \\'0\\') return 0\\n    if (i === s.length - 1 || i === s.length) return 1\\n    \\n    // we can check either one digit or two digits\\n    let nextDigitNum = dfs(i + 1)\\n    const nextTwoDigitNum = parseInt(s.slice(i, i+2))\\n\\n    if (nextTwoDigitNum >= 10 && nextTwoDigitNum <= 26) {\\n      nextDigitNum += dfs(i + 2)\\n    }\\n    \\n    memo[i] = nextDigitNum\\n    return memo[i]\\n  }\\n  \\n  return dfs(0)\\n};\\n\\n// bottom up\\nvar numDecodings = function(s) {\\n  if (s[0] === \\'0\\') return 0\\n  \\n  let back2 = 1\\n  let back1 = 1\\n  \\n  if (s.length === 0) return 0\\n  \\n  for (let i = 1; i < s.length; i++) {\\n    let current = 0\\n    if (s[i] !== \\'0\\') current = back1\\n    \\n    let twoDigit = parseInt(s.slice(i - 1, i + 1))\\n    if (twoDigit >= 10 && twoDigit <= 26) {\\n        current += back2;\\n    }\\n\\n    back2 = back1;\\n    back1 = current;\\n  }\\n  \\n  return back1\\n};\\n       \\n```\\n\\nThanks for reading. Please comment any improvements that could be made to my post.",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\n\\n// top down\\nvar numDecodingsTD = function(s) { // remove TD from var name to test\\n  const memo = {}\\n  \\n  function dfs(i) {\\n    if (i in memo) return memo[i]\\n    \\n    if (s[i] === \\'0\\') return 0\\n    if (i === s.length - 1 || i === s.length) return 1\\n    \\n    // we can check either one digit or two digits\\n    let nextDigitNum = dfs(i + 1)\\n    const nextTwoDigitNum = parseInt(s.slice(i, i+2))\\n\\n    if (nextTwoDigitNum >= 10 && nextTwoDigitNum <= 26) {\\n      nextDigitNum += dfs(i + 2)\\n    }\\n    \\n    memo[i] = nextDigitNum\\n    return memo[i]\\n  }\\n  \\n  return dfs(0)\\n};\\n\\n// bottom up\\nvar numDecodings = function(s) {\\n  if (s[0] === \\'0\\') return 0\\n  \\n  let back2 = 1\\n  let back1 = 1\\n  \\n  if (s.length === 0) return 0\\n  \\n  for (let i = 1; i < s.length; i++) {\\n    let current = 0\\n    if (s[i] !== \\'0\\') current = back1\\n    \\n    let twoDigit = parseInt(s.slice(i - 1, i + 1))\\n    if (twoDigit >= 10 && twoDigit <= 26) {\\n        current += back2;\\n    }\\n\\n    back2 = back1;\\n    back1 = current;\\n  }\\n  \\n  return back1\\n};\\n       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736248,
                "title": "c-bottom-up-dynamic-programming-detailed-explanation-worked-example",
                "content": "# Approach\\nWe can look at this using a Bottom-Up Dynamic Programming (DP) approach. \\nWe\\'ll be iterating character by character over the input string in reverse, keeping track of how many different ways we can decode the string so far in an array called `dp`.\\nWhen doing this, there are a couple of cases that we need to consider:\\n\\n1. **Number at index is equal to 0**\\n        - Since 0 isn\\'t a valid number to start with, we set `dp[i] = 0` if `s[i] == 0`.\\n        - If this isn\\'t the case, then we know the number at `s[i]` is valid, and we set `dp[i] = dp[i+1]`.\\n2. **Check whether we can create a valid 2 digit number**\\n        - Since the range of valid numbers to decode is `1-26` we need to check whether our current number can be combined into a valid 2 digit number.\\n        - Our two sets of valid 2 digit numbers are `10-19` and `20-26` and we can check this by looking at whether `s[i] == 1`, or whether `s[i] == 2 && 0 <= s[i+1] <= 6`\\n        - If we have a valid two digit number, then we can add `dp[i+1]` to `dp[i]`\\n\\nThese cases, especially the second, may not seem completely intuitive at first, but the explanation below should clear up any confusion.\\n\\n# Explanation\\n\\nThe first case is the simpler of the two, but may not make sense initally. We can think of this case as being `If there is a valid number, then we maintain the previous number of different ways to decode the string`.\\n\\nTthe second case is where it gets more complicated. We can think of this case as being `If we can form a valid 2 digit number, then the number ways to decode the string will increase by the number of ways to decode the substring that begins after the second digit of our 2 digit number`. To give an example:\\n\\n```\\nstring s = \"12235\"\\ni = 4, dp = {0, 0, 0, 0, 0, 1}\\nCurrent permutations: []\\n5 is valid, so set dp[4] = dp[5]\\nNo 2 digit number can be made\\nCurrent permutations: [5]\\n\\ni = 3, dp = {0, 0, 0, 0, 1, 1}\\nCurrent permutations: [5]\\n5 is valid, so set dp[3] = dp[4]\\nA 2 digit number can be made but it isn\\'t valid\\nCurrent permutations: [35]\\n\\ni = 2, dp = {0, 0, 0, 1, 1, 1}\\nCurrent permutations: [35]\\n2 is valid, so set dp[2] = dp[3]\\nA 2 digit number can be made, and it is valid, so increase dp[2] by dp[4]\\nCurrent permutations: [235, [23]5]\\n\\ni = 1, dp = {0, 0, 2, 1, 1, 1}\\nCurrent permutations: [235, [23]5]\\n2 is valid, so set dp[1] = dp[2]\\nA 2 digit number can be made, and it is valid, so increase dp[1] by dp[3]\\nCurrent permutations: [2235, 2[23]5, [22]35]\\n\\ni = 0, dp = {0, 3, 2, 1, 1, 1}\\nCurrent permutations: [2235, 2[23]5, [22]35]\\n1 is valid, so set dp[0] = dp[1]\\nA 2 digit number can be made, and it is valid, so increase dp[0] by dp[2]\\nCurrent permutations: [12235, 12[23]5, 1[22]35, [12]235, [12][23]5]\\n\\nFinal dp = {5, 3, 2, 1, 1, 1}\\nResult = 5\\n\\n```\\nWe can see in the above that by adding a valid number, e.g. `1`, on it\\'s own, we maintain the number of permutations we had before (`dp[i+1]`), but by using a valid two digit number, e.g. `12`, we also add all the ways that the remaining substring, e.g. `[235]` can be made (`dp[i+2]`).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\nThis can be reduced to $$O(1)$$ by only tracking `dp[i]`, `dp[i+1]`, and `dp[i+2]`\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumDecodings(string s) {\\n        var dp = new int[s.Length+1];\\n        dp[s.Length] = 1;\\n\\n        for (int i = s.Length-1; i >= 0; i--)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i] = 0;\\n            }\\n            else\\n            {\\n                dp[i] = dp[i + 1];\\n            }\\n\\n            if (i + 1 < s.Length && (s[i] == \\'1\\' || (s[i] == \\'2\\' && (int)Char.GetNumericValue(s[i+1]) >= 0 && (int)Char.GetNumericValue(s[i+1]) <= 6)))\\n            {\\n                dp[i] += dp[i+2];\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring s = \"12235\"\\ni = 4, dp = {0, 0, 0, 0, 0, 1}\\nCurrent permutations: []\\n5 is valid, so set dp[4] = dp[5]\\nNo 2 digit number can be made\\nCurrent permutations: [5]\\n\\ni = 3, dp = {0, 0, 0, 0, 1, 1}\\nCurrent permutations: [5]\\n5 is valid, so set dp[3] = dp[4]\\nA 2 digit number can be made but it isn\\'t valid\\nCurrent permutations: [35]\\n\\ni = 2, dp = {0, 0, 0, 1, 1, 1}\\nCurrent permutations: [35]\\n2 is valid, so set dp[2] = dp[3]\\nA 2 digit number can be made, and it is valid, so increase dp[2] by dp[4]\\nCurrent permutations: [235, [23]5]\\n\\ni = 1, dp = {0, 0, 2, 1, 1, 1}\\nCurrent permutations: [235, [23]5]\\n2 is valid, so set dp[1] = dp[2]\\nA 2 digit number can be made, and it is valid, so increase dp[1] by dp[3]\\nCurrent permutations: [2235, 2[23]5, [22]35]\\n\\ni = 0, dp = {0, 3, 2, 1, 1, 1}\\nCurrent permutations: [2235, 2[23]5, [22]35]\\n1 is valid, so set dp[0] = dp[1]\\nA 2 digit number can be made, and it is valid, so increase dp[0] by dp[2]\\nCurrent permutations: [12235, 12[23]5, 1[22]35, [12]235, [12][23]5]\\n\\nFinal dp = {5, 3, 2, 1, 1, 1}\\nResult = 5\\n\\n```\n```\\npublic class Solution {\\n    public int NumDecodings(string s) {\\n        var dp = new int[s.Length+1];\\n        dp[s.Length] = 1;\\n\\n        for (int i = s.Length-1; i >= 0; i--)\\n        {\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i] = 0;\\n            }\\n            else\\n            {\\n                dp[i] = dp[i + 1];\\n            }\\n\\n            if (i + 1 < s.Length && (s[i] == \\'1\\' || (s[i] == \\'2\\' && (int)Char.GetNumericValue(s[i+1]) >= 0 && (int)Char.GetNumericValue(s[i+1]) <= 6)))\\n            {\\n                dp[i] += dp[i+2];\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646037,
                "title": "c-100-faster-dp-solution",
                "content": "The basic logic is that we shall move one index forward if current index of string lies between and 1 and 26. We can also, move two indices forward if two indices make a number between 1 and 26.\\nWe can also see that if current index value is 0, we can return since we cannot move forward with one index or two indices(example- 0 and 06), hence I have included it as a base condition.\\nThe dp at an index will store the required answer from that particular index.\\nIn order to have ease memoising the solution, it is first necessary to write the dp[i] in the form of a+b. For achieving this, I have included two bools a and b, so that the return statements can be included in if and else statements. Remember to pass the string and dp through references to save memory and time both.\\n\\n```\\nclass Solution {\\npublic:\\n    int f(string &s,int i, vector<int> &dp){\\n        int ans=0;\\n        bool a,b=false;\\n        if(i>=s.size())\\n            return 1;\\n        if(s[i]==\\'0\\')\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        if(s[i]-\\'0\\'>=1 && s[i]-\\'0\\'<=26){\\n            a=true;\\n        }\\n            \\n        if(i+1<s.size()){\\n            \\n            int temp=10*(s[i]-\\'0\\')+(s[i+1]-\\'0\\');\\n            if(temp>=0 && temp<=26){\\n                b=true;\\n            }\\n                \\n        }\\n        if(a && b)\\n            return dp[i]= f(s,i+1,dp)+f(s,i+2,dp);\\n        else\\n            return dp[i]= f(s,i+1,dp);\\n            \\n    }\\n    \\n    int numDecodings(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return f(s,0,dp);\\n        \\n        \\n    }\\n};\\n```\\nPlease upvote if you find the solution helpful. Thank you.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(string &s,int i, vector<int> &dp){\\n        int ans=0;\\n        bool a,b=false;\\n        if(i>=s.size())\\n            return 1;\\n        if(s[i]==\\'0\\')\\n            return 0;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        if(s[i]-\\'0\\'>=1 && s[i]-\\'0\\'<=26){\\n            a=true;\\n        }\\n            \\n        if(i+1<s.size()){\\n            \\n            int temp=10*(s[i]-\\'0\\')+(s[i+1]-\\'0\\');\\n            if(temp>=0 && temp<=26){\\n                b=true;\\n            }\\n                \\n        }\\n        if(a && b)\\n            return dp[i]= f(s,i+1,dp)+f(s,i+2,dp);\\n        else\\n            return dp[i]= f(s,i+1,dp);\\n            \\n    }\\n    \\n    int numDecodings(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return f(s,0,dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644913,
                "title": "c-simple-dp-single-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> t(n+1);\\n        t[n] = 1;\\n        for(int i = n-1; i >= 0; --i) {\\n            if(s[i] == \\'0\\')\\n                t[i] = 0; \\n            else {\\n                t[i] = t[i+1];\\n                if(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i+1] < \\'7\\')) \\n                    t[i] += t[i+2];\\n            }\\n        }\\n        return t[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<int> t(n+1);\\n        t[n] = 1;\\n        for(int i = n-1; i >= 0; --i) {\\n            if(s[i] == \\'0\\')\\n                t[i] = 0; \\n            else {\\n                t[i] = t[i+1];\\n                if(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i+1] < \\'7\\')) \\n                    t[i] += t[i+2];\\n            }\\n        }\\n        return t[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644816,
                "title": "java-checking-all-possible-situations-dynamic-programming",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.charAt(0)  == \\'0\\') return 0;\\n\\n        int[] dp = new int[s.length()];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i < dp.length; i++) {\\n            if (s.charAt(i - 1) == \\'0\\' && s.charAt(i) == \\'0\\') {\\n                dp[i] = 0;\\n            }\\n            else if (s.charAt(i - 1) == \\'0\\' && s.charAt(i) != \\'0\\') {\\n                dp[i] = dp[i - 1];\\n            }\\n            else if (s.charAt(i - 1) != \\'0\\' && s.charAt(i) == \\'0\\') {\\n                if (s.charAt(i - 1) == \\'1\\' || s.charAt(i - 1) == \\'2\\') {\\n                    dp[i] = (i >= 2 ? dp[i - 2] : 1);\\n                }\\n                else dp[i] = 0;\\n            }\\n            else {\\n                if (Integer.parseInt(s.substring(i - 1, i + 1)) <= 26) {\\n                    dp[i] = dp[i - 1] + (i >= 2 ? dp[i - 2] : 1);\\n                }\\n                else dp[i] = dp[i - 1];\\n            }\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.charAt(0)  == \\'0\\') return 0;\\n\\n        int[] dp = new int[s.length()];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i < dp.length; i++) {\\n            if (s.charAt(i - 1) == \\'0\\' && s.charAt(i) == \\'0\\') {\\n                dp[i] = 0;\\n            }\\n            else if (s.charAt(i - 1) == \\'0\\' && s.charAt(i) != \\'0\\') {\\n                dp[i] = dp[i - 1];\\n            }\\n            else if (s.charAt(i - 1) != \\'0\\' && s.charAt(i) == \\'0\\') {\\n                if (s.charAt(i - 1) == \\'1\\' || s.charAt(i - 1) == \\'2\\') {\\n                    dp[i] = (i >= 2 ? dp[i - 2] : 1);\\n                }\\n                else dp[i] = 0;\\n            }\\n            else {\\n                if (Integer.parseInt(s.substring(i - 1, i + 1)) <= 26) {\\n                    dp[i] = dp[i - 1] + (i >= 2 ? dp[i - 2] : 1);\\n                }\\n                else dp[i] = dp[i - 1];\\n            }\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644749,
                "title": "js-javascript-4-solutions-top-down-dp-bottom-up-dp",
                "content": "**Approach 1: Recursion**\\n\\n```\\n// Time complexity: O(2^n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tif (s.length === 0)\\n\\t\\treturn 0;\\n\\n\\treturn helper(s, 0);\\n};\\n\\nfunction helper(s, i) {\\n\\tif (i === s.length)\\n\\t\\treturn 1;\\n\\n\\tif (s[i] === \\'0\\')\\n\\t\\treturn 0;\\n\\n\\tlet res = helper(s, i + 1);\\n\\n\\tif (i < s.length - 1 && (s[i] === \\'1\\' || s[i] === \\'2\\' && s[i + 1] < \\'7\\'))\\n\\t\\tres += helper(s, i + 2);\\n\\n\\treturn res;\\n};\\n```\\n\\n**Approach 2: Top Down DP - Recursion + Memoization**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tif (s.length === 0)\\n\\t\\treturn 0;\\n\\n\\tconst memo = Array(s.length).fill(-1);\\n\\treturn helper(s, 0, memo);\\n};\\n\\nvar helper = function(s, i, memo) {\\n\\tif (i === s.length)\\n\\t\\treturn 1;\\n\\n\\tif (s[i] == \\'0\\')\\n\\t\\treturn 0;\\n\\n\\tif (memo[i] !== -1)\\n\\t\\treturn memo[i];\\n\\n\\tlet res = helper(s, i + 1, memo);\\n\\n\\tif (i < s.length - 1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\'))\\n\\t\\tres += helper(s, i + 2, memo);\\n\\n\\treturn memo[i] = res;\\n};\\n\\n```\\n\\n**Approach 3: Bottom Up DP**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tlet n = s.length;\\n\\t\\n\\tconst dp = Array(n + 1).fill(0); \\n\\tdp[n] = 1;\\n\\t\\n\\tfor(let i = n - 1; i >= 0; i--) {\\n\\t\\tif(s[i] != \\'0\\') {\\n\\t\\t\\tdp[i] = dp[i + 1];\\n\\t\\t\\t\\n\\t\\t\\tif(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\')) \\n\\t\\t\\t\\tdp[i] += dp[i + 2];\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[0];   \\n};\\n```\\n\\n**Approach 4: Bottom Up DP - Optimized**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar numDecodings = function(s) {\\n\\tlet dp1 = 1, dp2 = 0, n = s.length;\\n\\n\\tfor (let i = n - 1; i >= 0; i--) {\\n\\t\\tlet dp = s[i] == \\'0\\' ? 0 : dp1;\\n\\n\\t\\tif(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\')) \\n\\t\\t\\tdp += dp2;\\n\\n\\t\\tdp2 = dp1;\\n\\t\\tdp1 = dp;\\n\\t}\\n\\n\\treturn dp1;\\n};\\n```\\n\\n**Please upvote if you find this post useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Time complexity: O(2^n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tif (s.length === 0)\\n\\t\\treturn 0;\\n\\n\\treturn helper(s, 0);\\n};\\n\\nfunction helper(s, i) {\\n\\tif (i === s.length)\\n\\t\\treturn 1;\\n\\n\\tif (s[i] === \\'0\\')\\n\\t\\treturn 0;\\n\\n\\tlet res = helper(s, i + 1);\\n\\n\\tif (i < s.length - 1 && (s[i] === \\'1\\' || s[i] === \\'2\\' && s[i + 1] < \\'7\\'))\\n\\t\\tres += helper(s, i + 2);\\n\\n\\treturn res;\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tif (s.length === 0)\\n\\t\\treturn 0;\\n\\n\\tconst memo = Array(s.length).fill(-1);\\n\\treturn helper(s, 0, memo);\\n};\\n\\nvar helper = function(s, i, memo) {\\n\\tif (i === s.length)\\n\\t\\treturn 1;\\n\\n\\tif (s[i] == \\'0\\')\\n\\t\\treturn 0;\\n\\n\\tif (memo[i] !== -1)\\n\\t\\treturn memo[i];\\n\\n\\tlet res = helper(s, i + 1, memo);\\n\\n\\tif (i < s.length - 1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\'))\\n\\t\\tres += helper(s, i + 2, memo);\\n\\n\\treturn memo[i] = res;\\n};\\n\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar numDecodings = function(s) {\\n\\tlet n = s.length;\\n\\t\\n\\tconst dp = Array(n + 1).fill(0); \\n\\tdp[n] = 1;\\n\\t\\n\\tfor(let i = n - 1; i >= 0; i--) {\\n\\t\\tif(s[i] != \\'0\\') {\\n\\t\\t\\tdp[i] = dp[i + 1];\\n\\t\\t\\t\\n\\t\\t\\tif(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\')) \\n\\t\\t\\t\\tdp[i] += dp[i + 2];\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[0];   \\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar numDecodings = function(s) {\\n\\tlet dp1 = 1, dp2 = 0, n = s.length;\\n\\n\\tfor (let i = n - 1; i >= 0; i--) {\\n\\t\\tlet dp = s[i] == \\'0\\' ? 0 : dp1;\\n\\n\\t\\tif(i < n-1 && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i + 1] < \\'7\\')) \\n\\t\\t\\tdp += dp2;\\n\\n\\t\\tdp2 = dp1;\\n\\t\\tdp1 = dp;\\n\\t}\\n\\n\\treturn dp1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644639,
                "title": "every-test-cases-explained-with-ascii-pictures-complete-zero-tle-to-accepted",
                "content": "```\\n/*\\n    Let\\'s do some important observations and questions, in order to come to a solution.\\n    -----------------------------------------------------------------------------------\\n    \\n        Obs#1 Since we\\'ve only mappings within range [1-26], so therefore we can conclude that\\n              either we\\'ve to consider single character or two characters at time.\\n              \\n              Considering more than 1 characters at a time unnecessarily wasting of computation\\n              power.\\n              \\n        Obs#2 If given string s has at least 1 leading zero. Answer would always be 0.\\n              NOTE: We cann\\'t map zero or zero followed by any digit(s) to a character.\\n        \\n        Obs#3 If given string s has at last 1 substring of type \"00\". Answer would always be 0.\\n        \\n              Testcases like: \"23100343\", \"33....00.....\"\\n                        \\n                        Doesn\\'t matter we\\'re able to map single 0 with 1 or 2, but still we\\'re\\n                        left w/ 1 zero. That single zero can\\'t mapped to anyone.\\n                        \\n                        Hence we can say => for such type of testcases our answer is always 0.\\n                        \\n        Obs#4 If there is a single zero in given string s and character just before it is other\\n              than 1 or 2. Answer would always be 0 for such type of test cases as well.\\n              \\n              Why?? because we\\'ve only mappings for [1-26].\\n              \\n              Testcases like: \"40\", \"60\", \"....30...\", \"1233304343\". [We can\\'t map any sequence of digit(s)]\\n              having length >= 2. whoose first digit is [3-9] & second digit is [0].\\n              \\n    ------------------------------------------------------------------------------------------------------------\\n    \\n        Let\\'s analyze one test case\\n        ---------------------------\\n        \\n        s => \"23221\"\\n        \\n        Can be decode as : 2,3,2,2,1 [BCBBA]\\n        Can be decode as : 2,3,2,21  [BCBU]\\n        Can be decode as : 2,3,22,1  [BCVA]\\n        Can be decode as : 23,2,2,1  [WBBA]\\n        Can be decode as : 23,2,21   [WBU]\\n        Can be decode as : 23,22,1   [WVA]\\n        \\n        \\n        If you look at the above test cases carefully : substring \"221\" comes two times among\\n        all possible (6) ways to decode the message.\\n                    \\n        It means this problem has Overlapping subproblems.\\n        -------------------------------------------------\\n        \\n        Q: Does this problem has Optimal Substructure?\\n        A: Yes. It has.\\n        \\n        Let\\'s see\\n        ---------\\n        \\n        Original Problem: \"23221\"\\n        \\n            \"23\"     +    \"221\"\\n              ^             ^\\n              |              |\\n              |              |  \\n              |\\n              |         Total ways to decode it : 3 [BBA,BU,VA]\\n              |          Our subproblem.\\n              |\\n              |\\n              |\\n        If we know => How many ways we can decode \"23\", then for each one of them\\n        \"221\" is repeated subproblem.\\n        \\n        Using the optimal result of subproblem [\"221\"] we can determine the result of our subproblem {\"23\"}.\\n        \\n        \\n        \"23\" can decoded as follows\\n        ---------------------------\\n            \\n        [\"2\",\"3\"] + \"221\"==> subproblem [3 ways]\\n        [\"23\"]    + \"221\"==> subproblem [3 ways]\\n        \\n        \\n        Total we\\'ve 2 ways to decode \"23\" and for each one of them we\\'ve 3 ways to decode the subproblem \"221\".\\n        Hence we can say that total number of ways to decode entire message is : (2 * 3) ways.\\n        \\n        Now we\\'ve got the result of our original problem : Using the optimal results of\\n        its subproblems having similar nature.\\n        \\n    ---------------------------------------------------------------------------------------------------------------\\n    \\n    To see more overlapping subproblems draw recursion tree for medium size test case like : \"2212121221\".\\n    \\n    Worst case occurs for the test cases like : \"11111111\"\\n    \\n    \\n    \\n    Q: So the question is, how do we solve this question?\\n    A: Well, a more intuitive way to solve this question is using Backtracking [Recursion].\\n            => Since based on different observations that we\\'ve made earlier.\\n            \\n            => We\\'ve to take different decisions [At each point[digit]],\\n                who helps us for making decisions?\\n            \\n            => Who : Recursion [We want to explore every possiabilities based \\n                on different decisions] => One of the best way\\n                     to do that using Recursion (If we made the wrong/no-left-decisions decision\\n                     at any point track back and try other possiabilites).\\n                     \\n    Q: What is the time complexity for Backtracking approach?\\n    A: Since at each digit we\\'ve two choices either it\\'s valid encoding or not.\\n            => if so, again we\\'ve two more choices for each subproblem.\\n            => if NOT, try to validate digits having length 2.\\n                        => again those subproblem has similar choices.\\n                                \\n      Since we\\'ve total N number of characters and for each of them we\\'ve 2 choices => so therefore, i can say \\n      in general we\\'ve total (2^N) number of choices.\\n      \\n      TC : O(2^N) exponential.\\n      SC : O(N) maximum depth of implicit stack space for recursive function calls.\\n      \\n    Q: Can we optimize/reduce the time complexity?\\n    A: Yes. Since we\\'ve already seen our problem fits for Dynamic Programming.\\n        So we can use it to improve exponential time complexity to linear/quadratic\\n        [Depends on problem].\\n        \\n*/\\n\\n```\\n\\n```\\nBacktracking Approach TLE for Test-Cases like : \"111111.......1111\"\\n```\\n\\n```\\n\\nclass Solution {\\n    private static final Set<String> map;\\n    private static final int M = 26;\\n    static {\\n        map = new HashSet<>();\\n        for(int digit = 1; digit <= M; digit += 1) {\\n            map.add(String.valueOf(digit));\\n        }\\n    }\\n    \\n    private int decodeWays(String s) {\\n        if(s.equals(\"\")) return 1;\\n        //Consider only those subproblems having either digit(s) with length 1 or 2\\n        int ways = 0;\\n        for(int i = 0; i < Math.min(2, s.length()); i += 1) {\\n            String dgt = s.substring(0, i + 1);\\n            if(map.contains(dgt)) {\\n                ways += decodeWays(s.substring(i + 1));\\n            }\\n        }\\n        return ways;\\n    }\\n    \\n    public int numDecodings(String s) {\\n        int index0 = s.indexOf(\"0\");\\n        //  Obs#2                           Obs#3                                   Obs#4\\n        if(index0 == 0 || (index0 != -1 && s.charAt(index0 - 1) - \\'0\\' > 2) || s.indexOf(\"00\") != -1) return 0;\\n        return decodeWays(s);\\n    }\\n}\\n```\\n\\n```\\nDynamic Programming Approach : Memoization\\n```\\n\\n```\\n\\nclass Solution {\\n    private static final Set<String> map;\\n    private static final int M = 26;\\n    static {\\n        map = new HashSet<>();\\n        for(int digit = 1; digit <= M; digit += 1) {\\n            map.add(String.valueOf(digit));\\n        }\\n    }\\n    \\n    private Map<String, Integer> cache;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    \\n    private int decodeWaysMemo(String s) {\\n        if(s.equals(\"\")) return 1;\\n        if(cache.containsKey(s)) return cache.get(s);\\n        String subproblem = null;\\n        int ways = 0;\\n        for(int i = 0; i < Math.min(2, s.length()); i += 1) {\\n            String dgt = s.substring(0, i + 1);\\n            if(map.contains(dgt)) {\\n                subproblem = s.substring(i + 1);\\n                ways += decodeWaysMemo(subproblem);\\n                cache.put(subproblem, ways);\\n            }\\n        }\\n        cache.put(subproblem, ways);\\n        return ways;\\n    }\\n    \\n    public int numDecodings(String s) {\\n        int index0 = s.indexOf(\"0\");\\n        //  Obs#2                           Obs#3                                   Obs#4\\n        if(index0 == 0 || (index0 != -1 && s.charAt(index0 - 1) - \\'0\\' > 2) || s.indexOf(\"00\") != -1) return 0;\\n        return decodeWaysMemo(s);\\n    }\\n}\\n```\\n\\n*If it\\'s somehow helps you then please upvote my solution for putting this much effort.*",
                "solutionTags": [],
                "code": "```\\n/*\\n    Let\\'s do some important observations and questions, in order to come to a solution.\\n    -----------------------------------------------------------------------------------\\n    \\n        Obs#1 Since we\\'ve only mappings within range [1-26], so therefore we can conclude that\\n              either we\\'ve to consider single character or two characters at time.\\n              \\n              Considering more than 1 characters at a time unnecessarily wasting of computation\\n              power.\\n              \\n        Obs#2 If given string s has at least 1 leading zero. Answer would always be 0.\\n              NOTE: We cann\\'t map zero or zero followed by any digit(s) to a character.\\n        \\n        Obs#3 If given string s has at last 1 substring of type \"00\". Answer would always be 0.\\n        \\n              Testcases like: \"23100343\", \"33....00.....\"\\n                        \\n                        Doesn\\'t matter we\\'re able to map single 0 with 1 or 2, but still we\\'re\\n                        left w/ 1 zero. That single zero can\\'t mapped to anyone.\\n                        \\n                        Hence we can say => for such type of testcases our answer is always 0.\\n                        \\n        Obs#4 If there is a single zero in given string s and character just before it is other\\n              than 1 or 2. Answer would always be 0 for such type of test cases as well.\\n              \\n              Why?? because we\\'ve only mappings for [1-26].\\n              \\n              Testcases like: \"40\", \"60\", \"....30...\", \"1233304343\". [We can\\'t map any sequence of digit(s)]\\n              having length >= 2. whoose first digit is [3-9] & second digit is [0].\\n              \\n    ------------------------------------------------------------------------------------------------------------\\n    \\n        Let\\'s analyze one test case\\n        ---------------------------\\n        \\n        s => \"23221\"\\n        \\n        Can be decode as : 2,3,2,2,1 [BCBBA]\\n        Can be decode as : 2,3,2,21  [BCBU]\\n        Can be decode as : 2,3,22,1  [BCVA]\\n        Can be decode as : 23,2,2,1  [WBBA]\\n        Can be decode as : 23,2,21   [WBU]\\n        Can be decode as : 23,22,1   [WVA]\\n        \\n        \\n        If you look at the above test cases carefully : substring \"221\" comes two times among\\n        all possible (6) ways to decode the message.\\n                    \\n        It means this problem has Overlapping subproblems.\\n        -------------------------------------------------\\n        \\n        Q: Does this problem has Optimal Substructure?\\n        A: Yes. It has.\\n        \\n        Let\\'s see\\n        ---------\\n        \\n        Original Problem: \"23221\"\\n        \\n            \"23\"     +    \"221\"\\n              ^             ^\\n              |              |\\n              |              |  \\n              |\\n              |         Total ways to decode it : 3 [BBA,BU,VA]\\n              |          Our subproblem.\\n              |\\n              |\\n              |\\n        If we know => How many ways we can decode \"23\", then for each one of them\\n        \"221\" is repeated subproblem.\\n        \\n        Using the optimal result of subproblem [\"221\"] we can determine the result of our subproblem {\"23\"}.\\n        \\n        \\n        \"23\" can decoded as follows\\n        ---------------------------\\n            \\n        [\"2\",\"3\"] + \"221\"==> subproblem [3 ways]\\n        [\"23\"]    + \"221\"==> subproblem [3 ways]\\n        \\n        \\n        Total we\\'ve 2 ways to decode \"23\" and for each one of them we\\'ve 3 ways to decode the subproblem \"221\".\\n        Hence we can say that total number of ways to decode entire message is : (2 * 3) ways.\\n        \\n        Now we\\'ve got the result of our original problem : Using the optimal results of\\n        its subproblems having similar nature.\\n        \\n    ---------------------------------------------------------------------------------------------------------------\\n    \\n    To see more overlapping subproblems draw recursion tree for medium size test case like : \"2212121221\".\\n    \\n    Worst case occurs for the test cases like : \"11111111\"\\n    \\n    \\n    \\n    Q: So the question is, how do we solve this question?\\n    A: Well, a more intuitive way to solve this question is using Backtracking [Recursion].\\n            => Since based on different observations that we\\'ve made earlier.\\n            \\n            => We\\'ve to take different decisions [At each point[digit]],\\n                who helps us for making decisions?\\n            \\n            => Who : Recursion [We want to explore every possiabilities based \\n                on different decisions] => One of the best way\\n                     to do that using Recursion (If we made the wrong/no-left-decisions decision\\n                     at any point track back and try other possiabilites).\\n                     \\n    Q: What is the time complexity for Backtracking approach?\\n    A: Since at each digit we\\'ve two choices either it\\'s valid encoding or not.\\n            => if so, again we\\'ve two more choices for each subproblem.\\n            => if NOT, try to validate digits having length 2.\\n                        => again those subproblem has similar choices.\\n                                \\n      Since we\\'ve total N number of characters and for each of them we\\'ve 2 choices => so therefore, i can say \\n      in general we\\'ve total (2^N) number of choices.\\n      \\n      TC : O(2^N) exponential.\\n      SC : O(N) maximum depth of implicit stack space for recursive function calls.\\n      \\n    Q: Can we optimize/reduce the time complexity?\\n    A: Yes. Since we\\'ve already seen our problem fits for Dynamic Programming.\\n        So we can use it to improve exponential time complexity to linear/quadratic\\n        [Depends on problem].\\n        \\n*/\\n\\n```\n```\\nBacktracking Approach TLE for Test-Cases like : \"111111.......1111\"\\n```\n```\\n\\nclass Solution {\\n    private static final Set<String> map;\\n    private static final int M = 26;\\n    static {\\n        map = new HashSet<>();\\n        for(int digit = 1; digit <= M; digit += 1) {\\n            map.add(String.valueOf(digit));\\n        }\\n    }\\n    \\n    private int decodeWays(String s) {\\n        if(s.equals(\"\")) return 1;\\n        //Consider only those subproblems having either digit(s) with length 1 or 2\\n        int ways = 0;\\n        for(int i = 0; i < Math.min(2, s.length()); i += 1) {\\n            String dgt = s.substring(0, i + 1);\\n            if(map.contains(dgt)) {\\n                ways += decodeWays(s.substring(i + 1));\\n            }\\n        }\\n        return ways;\\n    }\\n    \\n    public int numDecodings(String s) {\\n        int index0 = s.indexOf(\"0\");\\n        //  Obs#2                           Obs#3                                   Obs#4\\n        if(index0 == 0 || (index0 != -1 && s.charAt(index0 - 1) - \\'0\\' > 2) || s.indexOf(\"00\") != -1) return 0;\\n        return decodeWays(s);\\n    }\\n}\\n```\n```\\nDynamic Programming Approach : Memoization\\n```\n```\\n\\nclass Solution {\\n    private static final Set<String> map;\\n    private static final int M = 26;\\n    static {\\n        map = new HashSet<>();\\n        for(int digit = 1; digit <= M; digit += 1) {\\n            map.add(String.valueOf(digit));\\n        }\\n    }\\n    \\n    private Map<String, Integer> cache;\\n    public Solution() {\\n        cache = new HashMap<>();\\n    }\\n    \\n    private int decodeWaysMemo(String s) {\\n        if(s.equals(\"\")) return 1;\\n        if(cache.containsKey(s)) return cache.get(s);\\n        String subproblem = null;\\n        int ways = 0;\\n        for(int i = 0; i < Math.min(2, s.length()); i += 1) {\\n            String dgt = s.substring(0, i + 1);\\n            if(map.contains(dgt)) {\\n                subproblem = s.substring(i + 1);\\n                ways += decodeWaysMemo(subproblem);\\n                cache.put(subproblem, ways);\\n            }\\n        }\\n        cache.put(subproblem, ways);\\n        return ways;\\n    }\\n    \\n    public int numDecodings(String s) {\\n        int index0 = s.indexOf(\"0\");\\n        //  Obs#2                           Obs#3                                   Obs#4\\n        if(index0 == 0 || (index0 != -1 && s.charAt(index0 - 1) - \\'0\\' > 2) || s.indexOf(\"00\") != -1) return 0;\\n        return decodeWaysMemo(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644542,
                "title": "c-bottom-up-dp-faster-than-100",
                "content": "Let\\'s construct a dp array where dp[i] is the number of ways of decoding the string for first \\'i\\' characters.\\n\\nIdea\\n1. If the first digit is 0, the answer is always zero. You cannot take it alone or in conjunction with other digits.\\n2. If the current digit not 0, it is a valid code. Hence we can safely add this to the answer. ( dp[i] = dp[i] + dp[i-1] )\\n3. If the current digit is 0, check whether it can form a number less than 27 in conjunction with the last digit. If not, return zero immediately. ( Cases like : \"606\" )\\n4. If the current digit is not zero, we still check whether the conjuction of this digit with the last digit can form a number less than 27. If yes, we can add dp[i-2] to the answer since last two digits can be read as a single code. ( dp[i] = dp[i] + dp[i-2] )\\n5. Return dp[n] as the answer.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if ( s[0] == \\'0\\' ) return 0;\\n        \\n        int n = s.length();\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for ( int i = 1; i<n; i++ )\\n        {\\n            if ( s[i]!=\\'0\\' )     \\n                dp[i+1] = dp[i];\\n            if ( stoi(s.substr(i-1,2)) < 27 && s[i-1]!=\\'0\\' )\\n                dp[i+1]+=dp[i-1];\\n            else if ( s[i]==\\'0\\' )\\n                return 0;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if ( s[0] == \\'0\\' ) return 0;\\n        \\n        int n = s.length();\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for ( int i = 1; i<n; i++ )\\n        {\\n            if ( s[i]!=\\'0\\' )     \\n                dp[i+1] = dp[i];\\n            if ( stoi(s.substr(i-1,2)) < 27 && s[i-1]!=\\'0\\' )\\n                dp[i+1]+=dp[i-1];\\n            else if ( s[i]==\\'0\\' )\\n                return 0;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643977,
                "title": "python-3-dfs-w-explanation-w-example-t-m-99-7-22",
                "content": "```\\nclass Solution:             # Here\\'s the plan:\\n                            #    Use dp such that at each call, we decide whether the first one char\\n                            #    or the first two chars each comprise a legitimate integer n such that\\n                            #    1 <= n <= 26. For each legitimate integer, we slice its chars from the string \\n                            #    and recurse the remaining string. For each illegitimate integer, we stop. We \\n\\t\\t\\t\\t\\t\\t\\t#    count the leaves that each exhaust the string of digits\\n                            #    \\n                            #    For example, let s = 1202421. The tree shows the application of this recursion:\\n\\n                            #                          __________________root_______________________\\n                            #                         /                                              \\\\\\n                            #               _________1_______                               __________12_________\\n                            #              /                 \\\\                             /                     \\\\\\n                            #         ____2___             ___20_____                     0                      02 \\n                            #        /        \\\\           /           \\\\                   X                       X\\n                            #       0          02        2 ____        24              \\n                            #       X           X       /      \\\\       / \\\\           \\n                            #                          4       42    2    21 \\n                            #                         /  \\\\      X   /      *\\n                            #                        2   21        1\\n                            #                       /     *        *\\n                            #                      1\\n                            #                      *\\n                            #  The legitimate and illegitimate strings are labeled * and X respectively.\\n                            #  The legitimate strings: 1,20,2,4,2,1 --> atdbba \\n                            #                          1,20,2,4,21  --> atdbu\\n                            #                          1,20,24,2,1  --> atxba\\n                            #                          1,20,24,21   --> atxu\\n                            #  The answer is 4.\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n\\n        @lru_cache(None)\\n        def dfs(s):\\n            if not s: return 1\\n            if s[0]==\\'0\\': return 0\\n\\n            if len(s) > 1 and int(s[:2]) < 27: \\n                \\n                return dfs(s[1:]) + dfs(s[2:])\\n\\n            return dfs(s[1:])      \\n        \\n        return dfs(s)\\n```\\n\\n[https://leetcode.com/submissions/detail/608230999/](http://)\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:             # Here\\'s the plan:\\n                            #    Use dp such that at each call, we decide whether the first one char\\n                            #    or the first two chars each comprise a legitimate integer n such that\\n                            #    1 <= n <= 26. For each legitimate integer, we slice its chars from the string \\n                            #    and recurse the remaining string. For each illegitimate integer, we stop. We \\n\\t\\t\\t\\t\\t\\t\\t#    count the leaves that each exhaust the string of digits\\n                            #    \\n                            #    For example, let s = 1202421. The tree shows the application of this recursion:\\n\\n                            #                          __________________root_______________________\\n                            #                         /                                              \\\\\\n                            #               _________1_______                               __________12_________\\n                            #              /                 \\\\                             /                     \\\\\\n                            #         ____2___             ___20_____                     0                      02 \\n                            #        /        \\\\           /           \\\\                   X                       X\\n                            #       0          02        2 ____        24              \\n                            #       X           X       /      \\\\       / \\\\           \\n                            #                          4       42    2    21 \\n                            #                         /  \\\\      X   /      *\\n                            #                        2   21        1\\n                            #                       /     *        *\\n                            #                      1\\n                            #                      *\\n                            #  The legitimate and illegitimate strings are labeled * and X respectively.\\n                            #  The legitimate strings: 1,20,2,4,2,1 --> atdbba \\n                            #                          1,20,2,4,21  --> atdbu\\n                            #                          1,20,24,2,1  --> atxba\\n                            #                          1,20,24,21   --> atxu\\n                            #  The answer is 4.\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n\\n        @lru_cache(None)\\n        def dfs(s):\\n            if not s: return 1\\n            if s[0]==\\'0\\': return 0\\n\\n            if len(s) > 1 and int(s[:2]) < 27: \\n                \\n                return dfs(s[1:]) + dfs(s[2:])\\n\\n            return dfs(s[1:])      \\n        \\n        return dfs(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236200,
                "title": "simple-c-optimized-solution-in-o-n-time-complexity-and-o-1-space-complexity",
                "content": "**1.) Naive approach using recursion.\\n2.) Dynamic programing memoization. \\n3.) Dynamic programing tabulation.\\n4.) Optimized solution with O(N) Time Complexity and constant Space Complexity.**\\n\\n# 1.) Naive approach using recursion.\\n\\n      class Solution {\\n      public:\\n      int f(int idx,string s)\\n      {\\n        if(idx==s.size())\\n        {\\n            return 1;\\n        }\\n\\t\\t\\n        int first=0;\\n        int second=0;\\n\\n        if((s[idx]-\\'0\\')>=1 && (s[idx]-\\'0\\')<=26)\\n        {\\n            first=f(idx+1,s);\\n        }\\n        \\n        if((idx+1)<s.size() && (s[idx]-\\'0\\') > 0 && stoi(s.substr(idx,2))>=1 && stoi(s.substr(idx,2))<=26)\\n        {\\n            second=f(idx+2,s);\\n        }\\n        return first+second;\\n    }\\n\\t\\n\\tint numDecodings(string s) {\\n         return f(0,s);\\n\\t}\\n\\t};\\n\\n\\n# 2.) Dynamic programing memoization.\\n\\n    class Solution {\\n    public:\\n    int f(int idx,string s,vector<int>& dp)\\n    {\\n        if(idx==s.size())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        int first=0;\\n        int second=0;\\n\\n        if((s[idx]-\\'0\\')>=1 && (s[idx]-\\'0\\')<=26)\\n        {\\n            first=f(idx+1,s,dp);\\n        }\\n        \\n        if((idx+1)<s.size() && (s[idx]-\\'0\\') > 0 && stoi(s.substr(idx,2))>=1 && stoi(s.substr(idx,2))<=26)\\n        {\\n            second=f(idx+2,s,dp);\\n        }\\n        \\n        return dp[idx]=(first+second);\\n        \\n    }\\n    int numDecodings(string s) {\\n        vector<int> dp(s.size(),-1);\\n\\t\\treturn f(0,s,dp);\\n\\t}\\t\\t\\n\\t};\\n\\n\\n# 3.) Dynamic programing tabulation.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint numDecodings(string s) {\\n        \\n            int n=s.size();\\n           vector<int> dp(n+1,0);\\n        \\n           dp[n]=1;\\n           for(int idx=n-1;idx>=0;idx--)\\n          {\\n                int first=0;\\n               int second=0;\\n\\n               if((s[idx]-\\'0\\')>=1 && (s[idx]-\\'0\\')<=26)\\n               {\\n                   first=dp[idx+1];\\n               }\\n\\n               if((idx+1)<n && (s[idx]-\\'0\\') > 0 && stoi(s.substr(idx,2))>=1 && stoi(s.substr(idx,2))<=26)\\n               {\\n                   second=dp[idx+2];\\n               }\\n\\n               dp[idx]=(first+second);\\n            \\n           }\\n           return dp[0];   \\n    }\\n\\t};\\n\\n\\n# 4.) Optimized solution with O(N) Time Complexity and constant Space Complexity.\\n\\tclass Solution {\\n\\tpublic:\\n\\t int numDecodings(string s) {\\n        \\n            int n=s.size();\\n\\t        int next1=1;\\n\\t\\t\\tint next2=1;\\n\\t\\t\\tfor(int idx=n-1;idx>=0;idx--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint m=0;\\n            \\n\\t\\t\\t\\tif((s[idx]-\\'0\\')>=1 && (s[idx]-\\'0\\')<=26)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm+=next1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif((idx+1)<n && (s[idx]-\\'0\\') > 0 && stoi(s.substr(idx,2))>=1 && stoi(s.substr(idx,2))<=26)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm+=next2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnext2=next1;\\n\\t\\t\\t\\tnext1=m;\\n        }\\n        return next1;\\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n      public:\\n      int f(int idx,string s)\\n      {\\n        if(idx==s.size())\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2158998,
                "title": "python3-dp-top-down-approach",
                "content": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = {}\\n        length = len(s) - 1\\n        \\n        def getResult(index):\\n            if index > length:\\n                return 1\\n            if s[index] == \\'0\\':\\n                return 0\\n            if index in dp:\\n                return dp[index]\\n            singleLetter = getResult(index+1)\\n            word = 0\\n            if index < length and int(s[index] + s[index+1])<=26:\\n                word = getResult(index+2)\\n            dp[index] = singleLetter + word\\n            return dp[index]\\n        \\n        return getResult(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = {}\\n        length = len(s) - 1\\n        \\n        def getResult(index):\\n            if index > length:\\n                return 1\\n            if s[index] == \\'0\\':\\n                return 0\\n            if index in dp:\\n                return dp[index]\\n            singleLetter = getResult(index+1)\\n            word = 0\\n            if index < length and int(s[index] + s[index+1])<=26:\\n                word = getResult(index+2)\\n            dp[index] = singleLetter + word\\n            return dp[index]\\n        \\n        return getResult(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010749,
                "title": "java-space-1-dp-solution-with-explanation",
                "content": "##### Steps\\ngiven `dp[i]` is the number of decode ways for string end with `i` index\\nwe can either decode 1 or 2 digits from the tail of the string\\n\\nTherefore, we can the formula:\\n`dp[i] = (a) + (b)`, where\\n- (a) `dp[i-1]` if string[i,i] is 1~9 (otherwise, 0)\\n- (b) `dp[i-2]` if string[i-1,i] is 10~26 (otherwise, 0)\\n\\nBase case: `dp[i] = 1` when string length is 0\\n##### Solution\\n- time: `O(n)`\\n- space: `O(n)`\\n```java\\npublic int numDecodings(String s) {\\n    int n = s.length();\\n    int[] dp = new int[n+1];\\n    dp[0] = 1;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) != \\'0\\') {\\n            dp[i+1] += dp[i];\\n        }\\n\\n        if (i > 0 && (s.charAt(i - 1) == \\'1\\' || (s.charAt(i - 1) == \\'2\\' && s.charAt(i) <= \\'6\\'))) {\\n            dp[i+1] += dp[i-1];\\n        }\\n    }\\n    return dp[n];\\n}\\n```\\n-----\\nWe find that only the `i-1` and `i-2` are used.\\nTherefore, we can simplify the dp array to constant\\n\\n- time: `O(n)`\\n- space: `O(1)`\\n```java\\npublic int numDecodings(String s) {\\n    int n = s.length();\\n    int prepre = 0, pre = 1;\\n\\n    for (int i = 0; i < n; i++) {\\n        int cur = 0;\\n        if (s.charAt(i) != \\'0\\') {\\n            cur += pre;\\n        }\\n\\n        if (i > 0 && (s.charAt(i - 1) == \\'1\\' || (s.charAt(i - 1) == \\'2\\' && s.charAt(i) <= \\'6\\'))) {\\n            cur += prepre;\\n        }\\n\\n        prepre = pre;\\n        pre = cur;\\n    }\\n    return pre;\\n}\\n```\\n\\nPlease let me know if the explanation is helpful for you, thanks :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic int numDecodings(String s) {\\n    int n = s.length();\\n    int[] dp = new int[n+1];\\n    dp[0] = 1;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) != \\'0\\') {\\n            dp[i+1] += dp[i];\\n        }\\n\\n        if (i > 0 && (s.charAt(i - 1) == \\'1\\' || (s.charAt(i - 1) == \\'2\\' && s.charAt(i) <= \\'6\\'))) {\\n            dp[i+1] += dp[i-1];\\n        }\\n    }\\n    return dp[n];\\n}\\n```\n```java\\npublic int numDecodings(String s) {\\n    int n = s.length();\\n    int prepre = 0, pre = 1;\\n\\n    for (int i = 0; i < n; i++) {\\n        int cur = 0;\\n        if (s.charAt(i) != \\'0\\') {\\n            cur += pre;\\n        }\\n\\n        if (i > 0 && (s.charAt(i - 1) == \\'1\\' || (s.charAt(i - 1) == \\'2\\' && s.charAt(i) <= \\'6\\'))) {\\n            cur += prepre;\\n        }\\n\\n        prepre = pre;\\n        pre = cur;\\n    }\\n    return pre;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004126,
                "title": "easy-c-solution-using-dp-o-n-time-o-n-space",
                "content": "The main idea behind this approach is that whenever we have a value of curr > 26 or curr = 0, a letter is not possible and we return 0.\\nFor a corrrect sequence to perform, we have to get the index till the last index.\\n\\n```\\nclass Solution {\\npublic:\\n    int check(string s, int n, vector<vector<int>>& dp, int idx = 0, int curr = -1){\\n        if(idx == n){\\n            if(curr != 0 && curr<=26) return 1;\\n            return 0;\\n        }\\n        if(curr == 0 || curr>26) return 0;\\n        if(curr != -1 && dp[idx][curr] != -1) return dp[idx][curr];\\n        int x = check(s, n, dp, idx+1, s[idx]-\\'0\\');\\n        int y = curr != -1 ? check(s, n, dp, idx+1, curr*10 + (s[idx]-\\'0\\')) : 0;\\n        if(curr != -1) dp[idx][curr] = x+y;\\n        return x+y;\\n    }\\n    \\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(27, -1));\\n        return check(s, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(string s, int n, vector<vector<int>>& dp, int idx = 0, int curr = -1){\\n        if(idx == n){\\n            if(curr != 0 && curr<=26) return 1;\\n            return 0;\\n        }\\n        if(curr == 0 || curr>26) return 0;\\n        if(curr != -1 && dp[idx][curr] != -1) return dp[idx][curr];\\n        int x = check(s, n, dp, idx+1, s[idx]-\\'0\\');\\n        int y = curr != -1 ? check(s, n, dp, idx+1, curr*10 + (s[idx]-\\'0\\')) : 0;\\n        if(curr != -1) dp[idx][curr] = x+y;\\n        return x+y;\\n    }\\n    \\n    int numDecodings(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(27, -1));\\n        return check(s, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870182,
                "title": "memoization-solution-c",
                "content": "Memoization Solution (Top to Bottom Approach)-->\\n```\\nclass Solution {\\npublic:\\n    int decode(string s,int i,vector<int>& memo){\\n        if(i>s.size()){\\n            return 0;\\n        }\\n        if(i==(s.size())){\\n            return 1;\\n        }\\n        if(s[i]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        if(memo[i]!=-1){\\n            return memo[i];\\n        }\\n        int one=0;\\n        int two=0;\\n        \\n        one=decode(s,i+1,memo);\\n        int num=10*(s[i]-\\'0\\')+(s[i+1]-\\'0\\');\\n        if(num<=26){\\n        two=decode(s,i+2,memo);\\n        }\\n        memo[i]=one+two;\\n        return one+two;\\n        \\n    }\\n    int numDecodings(string s) {\\n        vector<int> memo(s.size(),-1);\\n        int ans=decode(s,0,memo);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int decode(string s,int i,vector<int>& memo){\\n        if(i>s.size()){\\n            return 0;\\n        }\\n        if(i==(s.size())){\\n            return 1;\\n        }\\n        if(s[i]==\\'0\\'){\\n            return 0;\\n        }\\n        \\n        if(memo[i]!=-1){\\n            return memo[i];\\n        }\\n        int one=0;\\n        int two=0;\\n        \\n        one=decode(s,i+1,memo);\\n        int num=10*(s[i]-\\'0\\')+(s[i+1]-\\'0\\');\\n        if(num<=26){\\n        two=decode(s,i+2,memo);\\n        }\\n        memo[i]=one+two;\\n        return one+two;\\n        \\n    }\\n    int numDecodings(string s) {\\n        vector<int> memo(s.size(),-1);\\n        int ans=decode(s,0,memo);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801956,
                "title": "python-dp-solution-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        \\n        #If we don\\'t have a string we return zero\\n        if not s:\\n            return 0\\n        \\n        #We initialize our dp array\\n        #dp Index: length up to this point when checking the s string\\n        #dp Value: Number of different ways we can decode up to this length of string which is determined by the index\\n        dp = [0] * (len(s) + 1)\\n        \\n        #Here, we\\'re saying that a string of length zero can only be decoded 1 way. As an empty string\\n        dp[0] = 1\\n            \\n            \\n        #Now we iterate through dp i.e. the length of string s\\n        \\n        for i in range(1, len(s) + 1):\\n            \\n            #here, we\\'re saying that as long as the previous number wasn\\'t a 0, at the current length, there is atleast\\n            #the number of ways to decode as when length was length - 1\\n            if s[i - 1] != \\'0\\':\\n                dp[i] += dp[i - 1]\\n                \\n            #Condition 1: We\\'re only checking for values when we have an i big enough\\n            #to support checking if a two digit number is within range\\n            #Condition 2:Checking to see if the number can be interpreted as a letter, i.e. 1 to 26\\n            #Condition 3: We are not accepting leading zeros as possible values letters that map to single digit values\\n            if i != 1 and s[i - 2: i] < \\'27\\' and s[i - 2: i] > \\'09\\':\\n                dp[i] += dp[i - 2]\\n        \\n        #Here, let\\'s return dp where the length of the word we\\'re checking is the length of the word\\n        return dp[len(s)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        \\n        #If we don\\'t have a string we return zero\\n        if not s:\\n            return 0\\n        \\n        #We initialize our dp array\\n        #dp Index: length up to this point when checking the s string\\n        #dp Value: Number of different ways we can decode up to this length of string which is determined by the index\\n        dp = [0] * (len(s) + 1)\\n        \\n        #Here, we\\'re saying that a string of length zero can only be decoded 1 way. As an empty string\\n        dp[0] = 1\\n            \\n            \\n        #Now we iterate through dp i.e. the length of string s\\n        \\n        for i in range(1, len(s) + 1):\\n            \\n            #here, we\\'re saying that as long as the previous number wasn\\'t a 0, at the current length, there is atleast\\n            #the number of ways to decode as when length was length - 1\\n            if s[i - 1] != \\'0\\':\\n                dp[i] += dp[i - 1]\\n                \\n            #Condition 1: We\\'re only checking for values when we have an i big enough\\n            #to support checking if a two digit number is within range\\n            #Condition 2:Checking to see if the number can be interpreted as a letter, i.e. 1 to 26\\n            #Condition 3: We are not accepting leading zeros as possible values letters that map to single digit values\\n            if i != 1 and s[i - 2: i] < \\'27\\' and s[i - 2: i] > \\'09\\':\\n                dp[i] += dp[i - 2]\\n        \\n        #Here, let\\'s return dp where the length of the word we\\'re checking is the length of the word\\n        return dp[len(s)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783066,
                "title": "javascript-dynamic-programming-with-explanation",
                "content": "The idea is to move from the end and initialize it to 1 since the number of ways of decoding the string from the last character can be either 0 or 1 [0 if the last digit is zero]\\n\\nIf the value of string[i] === 0, we know that we cannot have any string starting from it, so number of ways of forming values starting with 0 is ZERO. So set dp[i] = 0\\n\\nOtherwise there are 2 ways of forming values starting from i\\n\\na. Single Digit\\nb. Two Digits \\n\\nHence for position i , ways of decoding will be \\ndp[i+1] + dp[i+2] \\n\\nHow?\\n\\nFor example in 1, 2, 1\\nFor first position ways of decoding\\na.If we assume it as Single Digit => **[1]**,2,1 (ways of decoding starting i+1)\\nb.If we assume it as Two Digits => **[1,2]**,1 (ways of decoding starting i+2)\\n\\nWe add them both and we get the result.\\n\\n\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numDecodings = function (s) {\\n    const dp = [];\\n\\n    dp[s.length] = 1;\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n\\n        //When we take ith as a single digit number\\n        if (s[i] === \\'0\\') {\\n            dp[i] = 0;\\n        }\\n        else {\\n            dp[i] = dp[i + 1]\\n        }\\n\\n        //When we take ith plus i+1th character as a two digit number\\n\\t\\t//The right part of the if condition ensures that the two digit number is legal i.e between [10,26]\\n        if (i + 2 <= s.length && (s[i] === \\'1\\' || s[i] === \\'2\\' && \\'0123456\\'.includes(s[i + 1]))) {\\n            dp[i] += dp[i + 2]\\n        }\\n    }\\n\\n    return dp[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numDecodings = function (s) {\\n    const dp = [];\\n\\n    dp[s.length] = 1;\\n\\n    for (let i = s.length - 1; i >= 0; i--) {\\n\\n        //When we take ith as a single digit number\\n        if (s[i] === \\'0\\') {\\n            dp[i] = 0;\\n        }\\n        else {\\n            dp[i] = dp[i + 1]\\n        }\\n\\n        //When we take ith plus i+1th character as a two digit number\\n\\t\\t//The right part of the if condition ensures that the two digit number is legal i.e between [10,26]\\n        if (i + 2 <= s.length && (s[i] === \\'1\\' || s[i] === \\'2\\' && \\'0123456\\'.includes(s[i + 1]))) {\\n            dp[i] += dp[i + 2]\\n        }\\n    }\\n\\n    return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1718072,
                "title": "3-java-solution-from-brute-force-to-top-down-to-bottom-up-dp-with-comments",
                "content": "**Approach 1-> Brute Force**\\n\\n1. Call helper recursively starting from 0 index and when i reaches s.length() return 1 as it means 1 pair is found. \\n2. if during any index i value is \\'0\\' it means no answer possible and hence return 0.\\nWhy? because while considering single character only, Zero can never lead to answer alone. it must be combined with previous character to be able to give valid answer. in all other cases, by considering single character we will give 1 valid decoded string always.\\n\\n3. For case where two characters can be combined -> just check if by combining i and i+1 can result in number under 27. if yes call helper(s,i+2). and add result of this call to the total.\\n\\nwhy? because we have already considered single character and now we want to explore that if combining two charcs can lead to valid combination i.e. it must reaches length. \\n\\nNote -> In such case we have eliminated ith character to be zero also.\\n\\nExample ->\\nfor case like 100 we are sure that considering all char alone will not give answer. as \\'A\\'=1\\nand here if we combine 1 with 0. we still left with 0 which cannot lead to valid decoded string.\\n\\n```\\npublic int bruteForce(String s) {\\n\\t\\treturn bruteForce(s, 0);\\n\\t}\\n\\n\\tprivate int bruteForce(String s, int i) {\\n\\t\\t// if i reaches end add 1 to answer\\n\\t\\tif (i == s.length()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t// if current character is 0 return 0\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t// call for individual element consideration\\n\\t\\tint res = bruteForce(s, i + 1);\\n\\t\\t// check if by combining two elements together can result in number under 26\\n\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\t// if yes, call again by skipping next character.\\n\\t\\t\\tres += bruteForce(s, i + 2);\\n\\t\\t}\\n\\t\\t// return final result\\n\\t\\treturn res;\\n\\t}\\n```\\n\\n**Approach 2-> top down dp**\\n\\nIn above apporach we kept on doing same computation again and again and hence result in TLE. so just pass the output array to hold the answer and before calling reucrsive method just check if answer exists if yes just return directly else call method.\\n```\\npublic int topdownDp(String s) {\\n\\t\\treturn topdown(s, 0, new Integer[s.length()]);\\n\\t}\\n\\n\\tprivate int topdown(String s, int i, Integer[] op) {\\n\\t\\tif (i == s.length()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (op[i] != null) {\\n\\t\\t\\treturn op[i];\\n\\t\\t}\\n\\t\\top[i] = topdown(s, i + 1, op);\\n\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\top[i] += topdown(s, i + 2, op);\\n\\t\\t}\\n\\t\\treturn op[i];\\n\\t}\\n```\\n\\n**Approach 3-> Bottom up DP**\\n\\nConvert recursvie solution to iterative by just reversing the logic. in such case op[0] will be the answer.\\n```\\npublic int bottomUpDp(String s) {\\n\\t\\tint[] op = new int[s.length() + 1];\\n\\t\\top[s.length()] = 1;\\n\\t\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\top[i] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\top[i] = op[i + 1];\\n\\t\\t\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\t\\t\\top[i] += op[i + 2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn op[0];\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int bruteForce(String s) {\\n\\t\\treturn bruteForce(s, 0);\\n\\t}\\n\\n\\tprivate int bruteForce(String s, int i) {\\n\\t\\t// if i reaches end add 1 to answer\\n\\t\\tif (i == s.length()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\t// if current character is 0 return 0\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t// call for individual element consideration\\n\\t\\tint res = bruteForce(s, i + 1);\\n\\t\\t// check if by combining two elements together can result in number under 26\\n\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\t// if yes, call again by skipping next character.\\n\\t\\t\\tres += bruteForce(s, i + 2);\\n\\t\\t}\\n\\t\\t// return final result\\n\\t\\treturn res;\\n\\t}\\n```\n```\\npublic int topdownDp(String s) {\\n\\t\\treturn topdown(s, 0, new Integer[s.length()]);\\n\\t}\\n\\n\\tprivate int topdown(String s, int i, Integer[] op) {\\n\\t\\tif (i == s.length()) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (op[i] != null) {\\n\\t\\t\\treturn op[i];\\n\\t\\t}\\n\\t\\top[i] = topdown(s, i + 1, op);\\n\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\top[i] += topdown(s, i + 2, op);\\n\\t\\t}\\n\\t\\treturn op[i];\\n\\t}\\n```\n```\\npublic int bottomUpDp(String s) {\\n\\t\\tint[] op = new int[s.length() + 1];\\n\\t\\top[s.length()] = 1;\\n\\t\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\t\\tif (s.charAt(i) == \\'0\\') {\\n\\t\\t\\t\\top[i] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\top[i] = op[i + 1];\\n\\t\\t\\t\\tif (i < s.length() - 1 && (s.charAt(i) == \\'1\\' || (s.charAt(i) < \\'3\\' && s.charAt(i + 1) < \\'7\\'))) {\\n\\t\\t\\t\\t\\top[i] += op[i + 2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn op[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713882,
                "title": "c-100-faster-99-better-memory-use-single-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) \\n    {\\n        if(s.length() == 0 || s[0] == \\'0\\') return 0;\\n        if(s.length() == 1) return 1;\\n        int count1 = 1,count2 = 1;//count1-prev to prev,count2-prev\\n        for(int i=1;i<s.length();i++)\\n        {\\n            int n = s[i]-\\'0\\';\\n            int nn = (s[i-1]-\\'0\\')*10 + n;\\n            int count =0;\\n            if(n > 0) count += count2;\\n            if(nn>=10 && nn <= 26) count += count1;\\n            count1 = count2;\\n            count2 = count;\\n        }\\n        return count2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numDecodings(string s) \\n    {\\n        if(s.length() == 0 || s[0] == \\'0\\') return 0;\\n        if(s.length() == 1) return 1;\\n        int count1 = 1,count2 = 1;//count1-prev to prev,count2-prev\\n        for(int i=1;i<s.length();i++)\\n        {\\n            int n = s[i]-\\'0\\';\\n            int nn = (s[i-1]-\\'0\\')*10 + n;\\n            int count =0;\\n            if(n > 0) count += count2;\\n            if(nn>=10 && nn <= 26) count += count1;\\n            count1 = count2;\\n            count2 = count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1672880,
                "title": "c-iterative-dp-0ms-runtime",
                "content": "**Tackling the problem case-by-case:**\\n1. When `s[0]` is `\\'0\\'`, there is no way to pair this, return 0;\\n2. If there are two adjescent `\\'0\\'`s in s, there is no way to pair them, return 0;\\n3. Now, if `s.length()` is just `1` and it cannot be zero (handled above), there is only one way to decode, return 1;\\n4. Next, the idea is that every character will either be paired with another one, or be single/unpaired, there is no other case (Think!)\\nMake a `nx2` dp table (call it `memo`) with\\n**DP State:**\\n*memo[i][0] = no. of ways to decode s[0:i] if s[i] is not paired*\\n*memo[i][1] = no. of ways to decode s[0:i] if s[i] is paired with s[i-1]*\\n**Base Case:** We need to define `memo[0]` and `memo[1]`, as the recurrance relation (below) requires `memo[i-2]`, and we know for a fact len of s >= 2 (Think!).\\n* `memo[0][0]` is `0`, if s[1] is a zero (has to be paired with s[0]); `1` otherwise\\n* `memo[0][1]` is `0`, as it cannot be paired with s[i-1] (does not exist)\\n* `memo[1][0]` is `0`, if s[i] is zero (has to be paired); `1` otherwise\\n* `memo[1][1]` is `1`, if number formed by pairing s[0] and s[1] can be decoded (is <=26); `0` otherwise\\n**Recurrance Relation:**\\n**For memo[i][0]:**\\n*If a `s[i]` OR `s[i+1]` is \\'0\\':* `i` and `i+1` have to be paired, so there is no way to decode w/o pairing\\n*Else:* `no. of ways to decode s[0:i] when i is unpaired` = `no. of ways to decode s[0:i-1]`\\n**For memo[i][1]:**\\n*If a `s[i-1]` is \\'0\\' OR pairing `i` and `i-1` yields a number > 26 (cannot be docoded):* `i` and `i+1` cannot be paired\\n*Else:* `no. of ways to decode s[0:i] when i is unpaired` = `no. of ways to decode s[0:i-1]`\\n```\\nmemo[i][0] = 0;                           // if s[i]==\\'0\\' or s[i+1]==\\'0\\'\\n\\t\\t   = memo[i-1][0] + memo[i-1][1]; // otherwise\\nmemo[i][1] = 0;                           // if s[i-1]==\\'0\\' or stoi(s.substr(i-1,2))>26\\n\\t\\t   = memo[i-2][0] + memo[i-2][1]; // otherwise\\n```\\n\\n**Code:**\\n```\\nint numDecodings(string s) {\\n    int n=s.length();\\n\\t\\n    // 1\\n    if(s[0]==\\'0\\') return 0;\\n\\t\\n\\t// 2\\n    for(int i=0; i<n-1; i++) \\n        if(s[i]==\\'0\\' && s[i+1]==\\'0\\') \\n            return 0;\\n\\t\\n\\t// 3\\n    if(n==1) return 1;\\n\\n\\t// 4\\n    int memo[n][2];\\n\\t\\n\\t// Base Case\\n    memo[0][0] = (s[1]!=\\'0\\');\\n\\tmemo[0][1] = 0;\\n\\tmemo[1][0] = (s[1]!=\\'0\\');\\n\\tmemo[1][1] = (stoi(s.substr(0, 2))<=26);\\n\\n\\t// Recurrance Relation\\n    for(int i=2; i<n; i++) {\\n        memo[i][0] = (s[i]==\\'0\\' || (i+1<n && s[i+1]==\\'0\\')) \\n\\t\\t\\t\\t\\t? 0 \\n\\t\\t\\t\\t\\t: memo[i-1][0]+memo[i-1][1];\\n        memo[i][1] = (s[i-1]==\\'0\\' || stoi(s.substr(i-1,2))>26) \\n\\t\\t\\t\\t\\t? 0 \\n\\t\\t\\t\\t\\t: memo[i-2][0]+memo[i-2][1];\\n    }\\n\\n    return memo[n-1][0]+memo[n-1][1];\\n}\\n```\\n\\nHope this helps. Consider upvoting. :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nmemo[i][0] = 0;                           // if s[i]==\\'0\\' or s[i+1]==\\'0\\'\\n\\t\\t   = memo[i-1][0] + memo[i-1][1]; // otherwise\\nmemo[i][1] = 0;                           // if s[i-1]==\\'0\\' or stoi(s.substr(i-1,2))>26\\n\\t\\t   = memo[i-2][0] + memo[i-2][1]; // otherwise\\n```\n```\\nint numDecodings(string s) {\\n    int n=s.length();\\n\\t\\n    // 1\\n    if(s[0]==\\'0\\') return 0;\\n\\t\\n\\t// 2\\n    for(int i=0; i<n-1; i++) \\n        if(s[i]==\\'0\\' && s[i+1]==\\'0\\') \\n            return 0;\\n\\t\\n\\t// 3\\n    if(n==1) return 1;\\n\\n\\t// 4\\n    int memo[n][2];\\n\\t\\n\\t// Base Case\\n    memo[0][0] = (s[1]!=\\'0\\');\\n\\tmemo[0][1] = 0;\\n\\tmemo[1][0] = (s[1]!=\\'0\\');\\n\\tmemo[1][1] = (stoi(s.substr(0, 2))<=26);\\n\\n\\t// Recurrance Relation\\n    for(int i=2; i<n; i++) {\\n        memo[i][0] = (s[i]==\\'0\\' || (i+1<n && s[i+1]==\\'0\\')) \\n\\t\\t\\t\\t\\t? 0 \\n\\t\\t\\t\\t\\t: memo[i-1][0]+memo[i-1][1];\\n        memo[i][1] = (s[i-1]==\\'0\\' || stoi(s.substr(i-1,2))>26) \\n\\t\\t\\t\\t\\t? 0 \\n\\t\\t\\t\\t\\t: memo[i-2][0]+memo[i-2][1];\\n    }\\n\\n    return memo[n-1][0]+memo[n-1][1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1630451,
                "title": "simple-c-solution-faster-than-100-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        //Taking care of the edge cases\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        \\n        //Creating a dp vector\\n        vector<int> dp(s.size()+1, 0);\\n        dp[s.size()] = 1;\\n        for (int i = s.size() - 1; i >= 0; --i) {\\n            //Check for single digit\\n            if (s[i] != \\'0\\') \\n                dp[i] += dp[i+1];\\n            //Check for multiple digits since the to digit numbers lie between 10 and 26(both inclusive)\\n            if (i+1 < s.size() && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i+1] <= \\'6\\')) \\n                dp[i] += dp[i+2];\\n        }\\n        return dp[0];    \\n    }\\n};\\n```\\n\\n**If you found it helpful, kindly upvote...** \\uD83D\\uDE00",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        //Taking care of the edge cases\\n        if (s[0] == \\'0\\') return 0;\\n        if (s.size() == 1) return 1;\\n        \\n        //Creating a dp vector\\n        vector<int> dp(s.size()+1, 0);\\n        dp[s.size()] = 1;\\n        for (int i = s.size() - 1; i >= 0; --i) {\\n            //Check for single digit\\n            if (s[i] != \\'0\\') \\n                dp[i] += dp[i+1];\\n            //Check for multiple digits since the to digit numbers lie between 10 and 26(both inclusive)\\n            if (i+1 < s.size() && (s[i] == \\'1\\' || s[i] == \\'2\\' && s[i+1] <= \\'6\\')) \\n                dp[i] += dp[i+2];\\n        }\\n        return dp[0];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411444,
                "title": "python-top-down-dp-recursive-clear-explanation",
                "content": "**Explanation:**\\n***When string has 2 or more characters:***\\n* At each step, we have two choices - we can either decode two characters or we can decode one character\\n* When we decode one or two characters, we need to check whether we can decode the rest of the string\\n* So, we will pass ```s[1:]``` (to the recursive function) if we decode 1 character and ```s[2:]``` if we decode 2 characters. Eg. for ```\"226\"``` we can decode as ```\"2\" + decode(\"26\")``` as well as ```\"22\" + decode(\"6\")```\\n* When the integer value of 1st two characters, is less than 26, we can do both ```s[1:]``` and ```s[2:]``` decodings except in case of \"10\" and \"20\" where only ```s[2:]``` should be done\\n* When 1st two characters value is greater than 26, then only ```s[1:]``` decoding can be done\\n* When 1st character itself is a \\'0\\', both 1 char as well as 2 char decodings are invalid - like in case of \"06\", so return 0\\n\\n***When string has 1 or 0 characters:***\\n* When we have an empty string, it means we have decoded all characters successfully thus far, so its a valid decoding and hence return 1\\n* Essentially, we have a valid decoding if we have reached outside of the string (empty character) \\n* If we have one character, its a valid decoding if it\\'s not \"0\" because 0 maps to no character while 1-9 maps to A-I respectively\\n\\nWe use memoization (cache) to prevent repeated calculations for same string\\n\\nHere, left side of tree is 1 char decoding and right side is 2 char decoding and leaves are base cases\\n\\n\\n\\n```\\n\\t\\t226            230          1231\\n\\t\\t/ \\\\            / \\\\          /  \\\\\\n\\t  26   6          30  0       231   31\\n\\t  / \\\\            /            / \\\\   /\\n\\t 6  \\'\\'          0           31   1  1\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t   1\\n```\\n\\n**Python Code - 24 ms**\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if len(s) <= 1:\\t\\t\\t\\t\\t#base cases where recursion ends\\n                return 1 if s != \\'0\\' else 0\\n            if s[0] == \\'0\\':\\t\\t\\t\\t\\t\\n                return 0\\n            if int(s[0:2]) <= 26:\\n                if s[1] == \\'0\\':\\t\\t\\t\\t#for \"10\" and \"20\"\\n                    return helper(s[2:])\\n                else:\\n                    return helper(s[1:]) + helper(s[2:])\\n            else:\\n                return helper(s[1:])\\t    #for strings like \"31xx....\"\\n        return helper(s)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```s[1:]```\n```s[2:]```\n```\"226\"```\n```\"2\" + decode(\"26\")```\n```\"22\" + decode(\"6\")```\n```s[1:]```\n```s[2:]```\n```s[2:]```\n```s[1:]```\n```\\n\\t\\t226            230          1231\\n\\t\\t/ \\\\            / \\\\          /  \\\\\\n\\t  26   6          30  0       231   31\\n\\t  / \\\\            /            / \\\\   /\\n\\t 6  \\'\\'          0           31   1  1\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t   1\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if len(s) <= 1:\\t\\t\\t\\t\\t#base cases where recursion ends\\n                return 1 if s != \\'0\\' else 0\\n            if s[0] == \\'0\\':\\t\\t\\t\\t\\t\\n                return 0\\n            if int(s[0:2]) <= 26:\\n                if s[1] == \\'0\\':\\t\\t\\t\\t#for \"10\" and \"20\"\\n                    return helper(s[2:])\\n                else:\\n                    return helper(s[1:]) + helper(s[2:])\\n            else:\\n                return helper(s[1:])\\t    #for strings like \"31xx....\"\\n        return helper(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285739,
                "title": "c-easy-1-d-dp-soln",
                "content": "```\\n int numDecodings(string s) {\\n        \\n        int n=s.length();\\n        int arr[n+1]; //the current index will have answer tull prevoius index, so n+1\\n        if(s[0]==\\'0\\')\\n        {\\n            return 0;\\n        }\\n        arr[0]=1;\\n        arr[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            arr[i]=0;\\n            if(s[i-1]>\\'0\\')\\n            {\\n                arr[i]=arr[i-1]; // see if the previous number can stand as individual \\n            }\\n            if(s[i-2]==\\'1\\' or (s[i-2]==\\'2\\' and s[i-1]<\\'7\\'))\\n            {\\n                arr[i]+=arr[i-2];  // check if prevoius 2 numbers form a pair\\n            }\\n        }\\n        return arr[n];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int numDecodings(string s) {\\n        \\n        int n=s.length();\\n        int arr[n+1]; //the current index will have answer tull prevoius index, so n+1\\n        if(s[0]==\\'0\\')\\n        {\\n            return 0;\\n        }\\n        arr[0]=1;\\n        arr[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            arr[i]=0;\\n            if(s[i-1]>\\'0\\')\\n            {\\n                arr[i]=arr[i-1]; // see if the previous number can stand as individual \\n            }\\n            if(s[i-2]==\\'1\\' or (s[i-2]==\\'2\\' and s[i-1]<\\'7\\'))\\n            {\\n                arr[i]+=arr[i-2];  // check if prevoius 2 numbers form a pair\\n            }\\n        }\\n        return arr[n];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232395,
                "title": "clean-c-dp-solution",
                "content": "**Top-down Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        //Prefix subarray\\n        int n = s.size(), i;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] ==\\'0\\' ? 0:1;\\n        \\n        for(i=2;i<=n; i++){\\n            //dp[i] = dp[i-1] +dp[i-2];\\n            //only the last character\\n            dp[i] = 0;\\n            if(s[i-1] != \\'0\\')\\n                dp[i] += dp[i-1];\\n            //last 2 characters\\n            if(s[i-2] == \\'1\\')\\n                dp[i] += dp[i-2];\\n            else if(s[i-2] == \\'2\\' && s[i-1] <= \\'6\\')\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        //Prefix subarray\\n        int n = s.size(), i;\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] ==\\'0\\' ? 0:1;\\n        \\n        for(i=2;i<=n; i++){\\n            //dp[i] = dp[i-1] +dp[i-2];\\n            //only the last character\\n            dp[i] = 0;\\n            if(s[i-1] != \\'0\\')\\n                dp[i] += dp[i-1];\\n            //last 2 characters\\n            if(s[i-2] == \\'1\\')\\n                dp[i] += dp[i-2];\\n            else if(s[i-2] == \\'2\\' && s[i-1] <= \\'6\\')\\n                dp[i] += dp[i-2];\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987197,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numDecodings = function(s) {\\n    const helper = (data, k, memo) => {\\n        if (k === 0) return 1\\n        const idx = data.length - k\\n        \\n        if (data[idx] === \\'0\\') return 0\\n        if (memo.has(k)) return memo.get(k)\\n        \\n        let result = helper(data, k - 1, memo)\\n        \\n        const isAlphabetical = Number(data.substring(idx, idx + 2)) <= 26\\n        if (k >= 2 && isAlphabetical) result += helper(data, k - 2, memo)\\n        \\n        memo.set(k, result)\\n        return result\\n    }\\n    \\n    return helper(s, s.length, new Map())\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numDecodings = function(s) {\\n    const helper = (data, k, memo) => {\\n        if (k === 0) return 1\\n        const idx = data.length - k\\n        \\n        if (data[idx] === \\'0\\') return 0\\n        if (memo.has(k)) return memo.get(k)\\n        \\n        let result = helper(data, k - 1, memo)\\n        \\n        const isAlphabetical = Number(data.substring(idx, idx + 2)) <= 26\\n        if (k >= 2 && isAlphabetical) result += helper(data, k - 2, memo)\\n        \\n        memo.set(k, result)\\n        return result\\n    }\\n    \\n    return helper(s, s.length, new Map())\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928803,
                "title": "java-dp-solution-1ms-with-comments",
                "content": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.charAt(0) == \\'0\\') return 0;\\n        if (s.length() == 1) return 1;\\n        // dp[i] stores the number of ways to decode the substring from index 0 to i(inclusive)\\n        int[] dp = new int[s.length()];\\n        dp[0] = 1;\\n        for (int i = 1; i < s.length();i++){\\n            // check if i-th digit can be decoded to a letter\\n            if (s.charAt(i) != \\'0\\') dp[i] += dp[i-1];\\n            // check if (i-1)-th and i-th digit can together be decoded to a letter\\n            if (s.charAt(i-1) != \\'0\\' && (s.charAt(i-1) - \\'0\\') * 10 + s.charAt(i) - \\'0\\' <= 26) \\n                dp[i] += (i >= 2 ? dp[i-2] : 1);\\n            // dp[i] == 0 means the substring can not be decoded, return 0\\n            if (dp[i] == 0) return 0;\\n        }\\n        return dp[s.length()-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if (s.charAt(0) == \\'0\\') return 0;\\n        if (s.length() == 1) return 1;\\n        // dp[i] stores the number of ways to decode the substring from index 0 to i(inclusive)\\n        int[] dp = new int[s.length()];\\n        dp[0] = 1;\\n        for (int i = 1; i < s.length();i++){\\n            // check if i-th digit can be decoded to a letter\\n            if (s.charAt(i) != \\'0\\') dp[i] += dp[i-1];\\n            // check if (i-1)-th and i-th digit can together be decoded to a letter\\n            if (s.charAt(i-1) != \\'0\\' && (s.charAt(i-1) - \\'0\\') * 10 + s.charAt(i) - \\'0\\' <= 26) \\n                dp[i] += (i >= 2 ? dp[i-2] : 1);\\n            // dp[i] == 0 means the substring can not be decoded, return 0\\n            if (dp[i] == 0) return 0;\\n        }\\n        return dp[s.length()-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919163,
                "title": "java-dp-solution-from-n-to-o-1-space-beats-100",
                "content": "Simple O(n) space solution:\\n```\\npublic int numDecodings(String s) {\\n\\tfinal int n = s.length();\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = s.charAt(0) == \\'0\\'? 0: 1;\\n\\tfor (int i = 2; i <= n; i++) {\\n\\t\\t// max 26 characters => max two digits\\n\\t\\tint prevChar = s.charAt(i - 1) - \\'0\\';\\n\\t\\tif (prevChar > 0) {\\n\\t\\t\\tdp[i] += dp[i - 1];\\n\\t\\t}\\n\\t\\tint prev2Chars = (s.charAt(i - 2) - \\'0\\') * 10 + prevChar;\\n\\t\\tif (prev2Chars >= 10 && prev2Chars <= 26) {\\n\\t\\t\\tdp[i] += dp[i - 2];\\n\\t\\t}\\n\\n\\t}\\n\\treturn dp[n];\\n}\\n```\\n\\nWe can observe that only the previous two values are used (similar to fibonacci), so we can get rid of the array:\\n\\n```\\npublic int numDecodings(String s) {\\n\\tfinal int n = s.length();\\n\\tint prev2 = 1;\\n\\tint prev1 = s.charAt(0) == \\'0\\'? 0: 1;\\n\\n\\tfor (int i = 2; i <= n; i++) {\\n\\t\\tint cur = 0; // current result\\n\\t\\t// max 26 characters => max two digits\\n\\t\\tint prevChar = s.charAt(i - 1) - \\'0\\';\\n\\t\\tif (prevChar > 0) {\\n\\t\\t\\tcur = prev1;\\n\\t\\t}\\n\\t\\tint prev2Chars = (s.charAt(i - 2) - \\'0\\') * 10 + prevChar;\\n\\t\\tif (prev2Chars >= 10 && prev2Chars <= 26) {\\n\\t\\t\\tcur += prev2;\\n\\t\\t}\\n\\t\\t// overwrite old values\\n\\t\\tprev2 = prev1;\\n\\t\\tprev1 = cur;\\n\\t}\\n\\treturn prev1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numDecodings(String s) {\\n\\tfinal int n = s.length();\\n\\tint[] dp = new int[n + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = s.charAt(0) == \\'0\\'? 0: 1;\\n\\tfor (int i = 2; i <= n; i++) {\\n\\t\\t// max 26 characters => max two digits\\n\\t\\tint prevChar = s.charAt(i - 1) - \\'0\\';\\n\\t\\tif (prevChar > 0) {\\n\\t\\t\\tdp[i] += dp[i - 1];\\n\\t\\t}\\n\\t\\tint prev2Chars = (s.charAt(i - 2) - \\'0\\') * 10 + prevChar;\\n\\t\\tif (prev2Chars >= 10 && prev2Chars <= 26) {\\n\\t\\t\\tdp[i] += dp[i - 2];\\n\\t\\t}\\n\\n\\t}\\n\\treturn dp[n];\\n}\\n```\n```\\npublic int numDecodings(String s) {\\n\\tfinal int n = s.length();\\n\\tint prev2 = 1;\\n\\tint prev1 = s.charAt(0) == \\'0\\'? 0: 1;\\n\\n\\tfor (int i = 2; i <= n; i++) {\\n\\t\\tint cur = 0; // current result\\n\\t\\t// max 26 characters => max two digits\\n\\t\\tint prevChar = s.charAt(i - 1) - \\'0\\';\\n\\t\\tif (prevChar > 0) {\\n\\t\\t\\tcur = prev1;\\n\\t\\t}\\n\\t\\tint prev2Chars = (s.charAt(i - 2) - \\'0\\') * 10 + prevChar;\\n\\t\\tif (prev2Chars >= 10 && prev2Chars <= 26) {\\n\\t\\t\\tcur += prev2;\\n\\t\\t}\\n\\t\\t// overwrite old values\\n\\t\\tprev2 = prev1;\\n\\t\\tprev1 = cur;\\n\\t}\\n\\treturn prev1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886480,
                "title": "c-0ms-solution",
                "content": "```\\nint numDecodings(string A) \\n    {\\n        vector<int> dp(A.size()+1,0);\\n    dp[0]=1;\\n    if(A[0]==\\'0\\')\\n    dp[1]=0;\\n    else\\n    dp[1]=1;\\n    for(int i=2;i<=A.size();i++)\\n    {\\n        if(A[i-1]>\\'0\\')\\n        dp[i]=dp[i-1];\\n        if((A[i-2]==\\'1\\') || (A[i-2]==\\'2\\' && A[i-1]<\\'7\\'))\\n        dp[i]=(dp[i-2]+dp[i]);\\n    }\\n    return dp[A.size()];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numDecodings(string A) \\n    {\\n        vector<int> dp(A.size()+1,0);\\n    dp[0]=1;\\n    if(A[0]==\\'0\\')\\n    dp[1]=0;\\n    else\\n    dp[1]=1;\\n    for(int i=2;i<=A.size();i++)\\n    {\\n        if(A[i-1]>\\'0\\')\\n        dp[i]=dp[i-1];\\n        if((A[i-2]==\\'1\\') || (A[i-2]==\\'2\\' && A[i-1]<\\'7\\'))\\n        dp[i]=(dp[i-2]+dp[i]);\\n    }\\n    return dp[A.size()];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817162,
                "title": "java-dp-solution",
                "content": "Let\\'s take a look at the example of s = \"226\".\\n\\nFirst initialize the dp array:\\n```\\nint[] dp = new int[s.length() + 1];\\ndp[0] = 1;\\ndp[1] = 1;\\n```\\n\\ndp[i] stands for how many different decode ways at position i so far.\\ndp[1] = 1, since s.charAt(0) = 2, which has only 1 way of decoding\\ndp[2] = ? \\nFirst, there are at least 1 way. Because \"22\" -> \"BB\" as dp[1] = 1 = dp[2-1]\\nSecond, \"22\" is also equivalent to \"V\" as dp[0] = 1 = dp[2-2]\\nTherefore, in total, dp[2] = 1 + 1 = 2. Let\\'s continue...\\n\\nHow about dp[3] = ?\\nFirst, there are at least 2 ways, Because we have already known dp[2] = 2, and \"22\" can be decoded to \"BB\" or \"V\". Alternatively, \"226\" can be decode to \"BBF\" or \"VF\", 2 ways.\\nSecond, \"226\" can also be separate into \"2\" and \"26\", so this is 1 more way. \\n\\nHowever, if we take a closer look at \"2\" and \"26\". \\nThis is 1 way of separation because we have already defined at where \"2\" => dp[1] => dp[3-2] = 1 way \\n\\nTherefore, the induction rule is actually become like this: dp[i] = dp[i-1] + dp[i-2]\\nThe current number of decode ways depends on this previous 2 values.\\n\\nHere is the code:\\n```\\npublic int numDecodings(String s) {\\n\\tif(s.charAt(0) == \\'0\\') return 0;\\n\\t// initialize\\n\\tint[] dp = new int[s.length() + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = 1;\\n\\t// induction rules\\n\\tfor(int i = 2; i < dp.length; i++){\\n\\t\\tdp[i] = (s.charAt(i-1) == \\'0\\') ? 0 : dp[i-1];\\n\\t\\tif(s.charAt(i-2) == \\'1\\' || (s.charAt(i-2) == \\'2\\' && s.charAt(i-1) <= \\'6\\')) {\\n\\t\\t\\tdp[i] += dp[i-2];\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nint[] dp = new int[s.length() + 1];\\ndp[0] = 1;\\ndp[1] = 1;\\n```\n```\\npublic int numDecodings(String s) {\\n\\tif(s.charAt(0) == \\'0\\') return 0;\\n\\t// initialize\\n\\tint[] dp = new int[s.length() + 1];\\n\\tdp[0] = 1;\\n\\tdp[1] = 1;\\n\\t// induction rules\\n\\tfor(int i = 2; i < dp.length; i++){\\n\\t\\tdp[i] = (s.charAt(i-1) == \\'0\\') ? 0 : dp[i-1];\\n\\t\\tif(s.charAt(i-2) == \\'1\\' || (s.charAt(i-2) == \\'2\\' && s.charAt(i-1) <= \\'6\\')) {\\n\\t\\t\\tdp[i] += dp[i-2];\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797526,
                "title": "java-dp-w-constant-space-o-1-solution-with-explanation",
                "content": "A slight optimization from the DP array solution:\\nUse array of size two, since you only need the last two calculations, and toggle between the cells to store them.\\nYou need a new variable, currentWays, to keep track of the current number of ways to decode the string, and it gets stored in dp[1].\\nAt the end of each pass of the loop, store the value of dp[1] in dp[0], so you can override it with currentWays.\\nAt the end, your answer will be stored in dp[1].\\n\\nQuick explanation of the addition logic:\\nEvery time you find a new valid two-digit number, it adds *several* new ways to decode the string, not just one.\\nThat\\'s why you\\'re constantly adding to the previous count, instead of incrementing by 1 each time.\\nAt the most complex case (a case of a string of all 1\\'s or all 2\\'s, where each digit forms a valid pair with both the previous AND next digit), the number of ways to decode the string increments like the fibonacci sequence.\\nEx.:\\n\"111\" has 3 ways to be decoded.\\n\"1111\" has 5 ways to be decoded.\\n\"11111\" has 8 ways to be decoded.\\n\"111111\" has 13 ways to be decoded.\\netc.\\n\\n```java\\nclass Solution {\\n    public int numDecodings(String s) {\\n        // Dynamic Programming, with constant space\\n        int[] dp = new int[2];\\n        \\n        if(s == null || s.length() == 0)\\n            return 0;\\n        \\n        // Ways to decode a string of size 1 is 1, unless the string is \\'0\\', so we initialize the array to 1\\'s.\\n        // This if statement prevents the program from checking the entire string if the first character\\n        // makes it invalid.\\n        if(s.charAt(0) == \\'0\\')\\n            return 0;\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            int currentWays = 0;\\n            \\n            // Check if successful single digit decode is possible, and add to current ways\\n            if(s.charAt(i) != \\'0\\')\\n                currentWays += dp[1];\\n            \\n            // Check if successful double digit decode is possible, and add to current ways\\n            int twoDigit = Integer.valueOf(s.substring(i-1, i+1));\\n            if(twoDigit >= 10 && twoDigit <= 26)\\n                currentWays += dp[0];\\n            \\n            dp[0] = dp[1];\\n            dp[1] = currentWays;\\n        }\\n        \\n        return dp[1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int numDecodings(String s) {\\n        // Dynamic Programming, with constant space\\n        int[] dp = new int[2];\\n        \\n        if(s == null || s.length() == 0)\\n            return 0;\\n        \\n        // Ways to decode a string of size 1 is 1, unless the string is \\'0\\', so we initialize the array to 1\\'s.\\n        // This if statement prevents the program from checking the entire string if the first character\\n        // makes it invalid.\\n        if(s.charAt(0) == \\'0\\')\\n            return 0;\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            int currentWays = 0;\\n            \\n            // Check if successful single digit decode is possible, and add to current ways\\n            if(s.charAt(i) != \\'0\\')\\n                currentWays += dp[1];\\n            \\n            // Check if successful double digit decode is possible, and add to current ways\\n            int twoDigit = Integer.valueOf(s.substring(i-1, i+1));\\n            if(twoDigit >= 10 && twoDigit <= 26)\\n                currentWays += dp[0];\\n            \\n            dp[0] = dp[1];\\n            dp[1] = currentWays;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 727182,
                "title": "c-fastest-two-pointer-no-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int a = 0;\\n        int b = 1;\\n        int ans = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char ch = s[i];\\n            ans = 0;\\n            if (ch != \\'0\\') {\\n                ans = b;\\n                if (i < s.length() - 1) {\\n                    int num = (ch - \\'0\\') * 10 + (s[i + 1] - \\'0\\');\\n                    if (num <= 26) {\\n                        ans += a;\\n                    }\\n                }\\n            }\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int a = 0;\\n        int b = 1;\\n        int ans = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char ch = s[i];\\n            ans = 0;\\n            if (ch != \\'0\\') {\\n                ans = b;\\n                if (i < s.length() - 1) {\\n                    int num = (ch - \\'0\\') * 10 + (s[i + 1] - \\'0\\');\\n                    if (num <= 26) {\\n                        ans += a;\\n                    }\\n                }\\n            }\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487090,
                "title": "detailed-explanation-97-o-n-time-o-1-space-complexity-solution",
                "content": "Lets start from a simple example and make it more and more complicated:\\n\\n1. \"**99999999999999**\" - very simple, no pairs between numbers are possible, so the answer is 1.\\n1. \"**99199**\" - now the answer is 2, because 1 in the middle can be interpreted like 1 (9, 9, 1, 9, 9) or merged with the next number and form 19 (9, 9, 19, 9). Lets call this situation a **pair**.\\n1. What happens if we have a multiple non-adjacent pairs? For instance \"**9922999992299**\" - each pair in this case has two possible states - (.., 9, 2, 2, 9, ..) and (.., 9, 22, 9, ..). So the answer is 2 * 2 = 4. If we would have 3 non-adjacent pairs the answer would be 2 * 2 * 2 = 8, and so on.\\n1. But what happens if we have more complicated situation like this \"**111**\". In this case we cen have 3 possible solutions, because 1 in the middle can be a part of the left pair and form (11, 1) or the right pair, (1, 11). Lets make a couple of observations. First, any digit can\\'t be a part of more than two possible pairs, because maximal length of code we have is 2. Next lets find a solution for the first couple of only-one inputs - \"1\" = 1, \"**11**\" = 2, \"**111**\" = 3, \"**1111**\" = 5, \"**11111**\" = 8, \"**111111**\" = 13... Can you see it? If you are smart you can tell that this is a fibonacci sequence. If you are like me, then you can understand it the same way I did. Lets say we have a \"**1111**\" input (will call it 4-digit-input) and it has 5 solutions. **\\'-\\'** will stand for digit, **\\'()\\'** - for what we called previously a pair: 1) **----** 2) **()--** 3) **-()-** 4) **--()** 5) **()().** Now using this solutions lets try to produce a solutions for 5-digits-input with one more \\'1\\' digit on the end. How we can do this? We can add \\'-\\' to every solution to make it 5 digits long, and after this every solution that has **--** in the end will create one additional solution, where **--** in the end is replaced by **()**. And what is the number of this solutions, that have **--** in the end? It is the number of solutions for the input one digit less then we have. You can see it yourself by drawing it on paper. So for n-digit-length sequence where each digit forms pair with each adjacent digit, the number of possible solutions will be equal to the number of solutions for (n-1)-digit sequence + (n-2)-digit sequence. Lets call this n-digits a region\\n1. Regions can\\'t be adjacent by definition, in that case they would form one big region. How does 2 non-adjacent regions behave? Like \"**9992229999992229999**\". In this case we have 2 regions of length 3. Number of solutions for each one of them is 3, so the total number of possible solutions is 3 * 3 = 9, pretty similar to how non-adjacent pairs behave.\\n1. Now we need to talk about one bad digit that breaks the whole solution - 0. 0 can be a second digit in the code, but cant be a digit on its own. 20 is valid input, but 02 or 0 is not. How we can resolve it? After some tests I found, that if 0 can form a valid pair with previous digit and this digit is a part of region, then this digit will be removed from that region. So **1110** will become a 11 region as 0 takes the last 1.\\n1. 0 as the first digit is not allowed so answer is 0.\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        \\n        int answer = 1;\\n        int fibonacciNumber1 = 1; // previous fibonacci number\\n        int fibonacciNumber2 = 1; // current fibonacci number\\n        \\n        char previous = s.charAt(0);\\n        char current;\\n        \\n        if (s.charAt(0) == \\'0\\') return 0; \\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            \\n            current = s.charAt(i);\\n            boolean createsPair = (previous == \\'1\\') || (previous == \\'2\\' && current >= \\'0\\' && current <= \\'6\\'); //check if previous and current digits can form pair\\n            \\n            if (current == \\'0\\') {\\n                if (!createsPair) return 0; // current has to be a part of a pair, otherwise input is invalid\\n                answer *= fibonacciNumber1; // if 0 is valid then it finishes current region and number of solutions for this region is PREVIOUS fibonacci number\\n                // zeroing fibonacci numbers\\n\\t\\t\\t\\tfibonacciNumber1 = 1;\\n                fibonacciNumber2 = 1;\\n            } else {\\n                if (createsPair) {\\n\\t\\t\\t\\t\\t// any pair starts a region\\n\\t\\t\\t\\t\\t// calculate next fibonacci number which is equal to the number of solutions in the current region\\n                    int newFibonacci = fibonacciNumber1 + fibonacciNumber2;\\n                    fibonacciNumber1 = fibonacciNumber2;\\n                    fibonacciNumber2 = newFibonacci;\\n                } else {\\n\\t\\t\\t\\t\\t// lack of pair finishes current region and number of solutions in it is equla to CURRENT fibonacci number\\n                    answer *= fibonacciNumber2;\\n\\t\\t\\t\\t\\t// zeroing fibonacci numbers\\n                    fibonacciNumber1 = 1;\\n                    fibonacciNumber2 = 1;\\n                }\\n            }\\n            \\n            previous = current;\\n            \\n        }\\n        \\n\\t\\t// if last digit is a part of a region for-loop above will miss it, following line is a fix for this situation\\n        answer *= fibonacciNumber2;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        \\n        int answer = 1;\\n        int fibonacciNumber1 = 1; // previous fibonacci number\\n        int fibonacciNumber2 = 1; // current fibonacci number\\n        \\n        char previous = s.charAt(0);\\n        char current;\\n        \\n        if (s.charAt(0) == \\'0\\') return 0; \\n        \\n        for (int i = 1; i < s.length(); i++) {\\n            \\n            current = s.charAt(i);\\n            boolean createsPair = (previous == \\'1\\') || (previous == \\'2\\' && current >= \\'0\\' && current <= \\'6\\'); //check if previous and current digits can form pair\\n            \\n            if (current == \\'0\\') {\\n                if (!createsPair) return 0; // current has to be a part of a pair, otherwise input is invalid\\n                answer *= fibonacciNumber1; // if 0 is valid then it finishes current region and number of solutions for this region is PREVIOUS fibonacci number\\n                // zeroing fibonacci numbers\\n\\t\\t\\t\\tfibonacciNumber1 = 1;\\n                fibonacciNumber2 = 1;\\n            } else {\\n                if (createsPair) {\\n\\t\\t\\t\\t\\t// any pair starts a region\\n\\t\\t\\t\\t\\t// calculate next fibonacci number which is equal to the number of solutions in the current region\\n                    int newFibonacci = fibonacciNumber1 + fibonacciNumber2;\\n                    fibonacciNumber1 = fibonacciNumber2;\\n                    fibonacciNumber2 = newFibonacci;\\n                } else {\\n\\t\\t\\t\\t\\t// lack of pair finishes current region and number of solutions in it is equla to CURRENT fibonacci number\\n                    answer *= fibonacciNumber2;\\n\\t\\t\\t\\t\\t// zeroing fibonacci numbers\\n                    fibonacciNumber1 = 1;\\n                    fibonacciNumber2 = 1;\\n                }\\n            }\\n            \\n            previous = current;\\n            \\n        }\\n        \\n\\t\\t// if last digit is a part of a region for-loop above will miss it, following line is a fix for this situation\\n        answer *= fibonacciNumber2;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457171,
                "title": "dp-solution-java-to-o-1-space-complexity",
                "content": "1. DP Tabular method\\n\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length();\\n        int[] dp = new int[n + 1]; // with extra space for [0] base case\\n        dp[0] = 1;\\n        dp[1] = s.charAt(0) != \\'0\\' ? 1 : 0;\\n        for(int i = 2; i <= n; i++) {\\n            Character c1 = s.charAt(i - 1);\\n            if(c1 != \\'0\\') {\\n                dp[i] += dp[i - 1];\\n            }\\n            \\n            Character c2 = s.charAt(i - 2);\\n            if(c2 == \\'1\\' || (c2 == \\'2\\' && c1 <= \\'6\\')) {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n2. O(1) space complexity, since only 2 previous answer is needed (i.e. p and pp).\\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length();\\n        int pp = 1;\\n        int p = s.charAt(0) != \\'0\\' ? 1 : 0;\\n        int cur = p;\\n        for(int i = 2; i <= n; i++) {\\n            cur = 0;\\n            Character c1 = s.charAt(i - 1);\\n            if(c1 != \\'0\\') {\\n                cur += p;\\n            }\\n            \\n            Character c2 = s.charAt(i - 2);\\n            if(c2 == \\'1\\' || (c2 == \\'2\\' && c1 <= \\'6\\')) {\\n                cur += pp;\\n            }\\n            \\n            pp = p;\\n            p = cur;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length();\\n        int[] dp = new int[n + 1]; // with extra space for [0] base case\\n        dp[0] = 1;\\n        dp[1] = s.charAt(0) != \\'0\\' ? 1 : 0;\\n        for(int i = 2; i <= n; i++) {\\n            Character c1 = s.charAt(i - 1);\\n            if(c1 != \\'0\\') {\\n                dp[i] += dp[i - 1];\\n            }\\n            \\n            Character c2 = s.charAt(i - 2);\\n            if(c2 == \\'1\\' || (c2 == \\'2\\' && c1 <= \\'6\\')) {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numDecodings(String s) {\\n        if(s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        int n = s.length();\\n        int pp = 1;\\n        int p = s.charAt(0) != \\'0\\' ? 1 : 0;\\n        int cur = p;\\n        for(int i = 2; i <= n; i++) {\\n            cur = 0;\\n            Character c1 = s.charAt(i - 1);\\n            if(c1 != \\'0\\') {\\n                cur += p;\\n            }\\n            \\n            Character c2 = s.charAt(i - 2);\\n            if(c2 == \\'1\\' || (c2 == \\'2\\' && c1 <= \\'6\\')) {\\n                cur += pp;\\n            }\\n            \\n            pp = p;\\n            p = cur;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443919,
                "title": "python-dp-solution-with-detailed-explanation",
                "content": "The question here is to make subsets of the given string and see if those subsets are valid. Since we know for a subset to be valid, it can either be a one-digit number or a two-digit number.\\n\\nBase Cases:\\nIf the string length is 0, return 0\\nIf the string length is 1, then there is only one possible subset, i.e., the string itself and it is valid if the single-digit is not equal to 0 as there is no mapping of 0 to any character\\nIf the string length is 2, then two splittings are possible: For example, 22, we can either make it (2,2) or (22).  For the first set to be valid, neither of the digits should be equal to 0, and for the second case, the two-digit number has to be greater than nine and less than 27. The reason is 09 is not a valid number mapping. \\n\\nSplitting the problem into its subproblems:\\neg, The given number is 22261, considering that we have to make subsets of the given string, we can cut the string at the following locations:\\n2|2261\\n22|261\\n222|61\\n2226|1\\nTo get further splittings, we need to know the possible kinds of subset splitting for 2, 22,222, and 2226 and those become our subproblems.\\n\\nNote: We are not considering 2261,261,61,1 for further splitting, as those cases will be automatically handled by splitting the left side of the splits.\\n\\nImportant Point: Since we know a valid subset is of length 2, we will ignore cases 1 and 2 since we are not making any subsets on the right side, and those substrings are of length greater than 2, so we only care about the cases 3 and 4.\\n\\nTherefore for 22261, the two subproblems are:\\nAdd the possible subsets for 2226 only if 1 is a valid substring\\nAdd the possible subsets for 222 only if 61 is a valid substring\\n\\nSo we make a DP array of the same length as a string which represents the number of ways to decode till that index.\\n\\n\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        n = len(s)\\n        \\n        #Base Case 1\\n        if n == 0:\\n            return n\\n        \\n        #Base Case 2\\n        if n == 1:\\n            if int(s) > 0:\\n                return 1\\n            #since 0 does not have any mapping to any character so if s = 0, answer is 0\\n            return 0\\n        \\n        dp = [0]*n\\n        \\n        #Since our dp is dependent on previous 2 values, we initialize values for 0 and 1 index\\n        #That is numDecodings for substring till 0th and 1st index\\n        dp[0] = 0 if int(s[0]) == 0 else 1\\n        dp[1] += 1 if int(s[:2]) <= 26 and int(s[:2]) >= 10 else 0\\n        dp[1] += 0 if (int(s[0]) == 0 or int(s[1]) == 0) else 1\\n        \\n        for i in range(2,n):\\n            dp[i] += dp[i-2] if int(s[i-1:i+1]) <= 26 and int(s[i-1:i+1]) >= 10 else 0\\n            if not int(s[i]) == 0:\\n                dp[i] += dp[i-1] \\n        return dp[n-1]\\n```\\n        \\n\\nFurther optimizations in memory:\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        n = len(s)\\n        \\n        #Base Case 1\\n        if n == 0:\\n            return n\\n        \\n        #Base Case 2\\n        if n == 1:\\n            if int(s) > 0:\\n                return 1\\n            #since 0 does not have any mapping to any character so if s = 0, answer is 0\\n            return 0\\n        \\n        #Since our dp is dependent on previous 2 values, we initialize values for 0 and 1 index\\n        #That is numDecodings for substring till 0th and 1st index\\n        a = 0 if int(s[0]) == 0 else 1\\n        b = 0\\n        b += 1 if int(s[:2]) <= 26 and int(s[:2]) >= 10 else 0\\n        b += 0 if (int(s[0]) == 0 or int(s[1]) == 0) else 1\\n        \\n        for i in range(2,n):\\n            c = 0\\n            c += a if int(s[i-1:i+1]) <= 26 and int(s[i-1:i+1]) >= 10 else 0\\n            if not int(s[i]) == 0:\\n                c += b \\n            a = b\\n            b = c\\n        return b\\n```\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        n = len(s)\\n        \\n        #Base Case 1\\n        if n == 0:\\n            return n\\n        \\n        #Base Case 2\\n        if n == 1:\\n            if int(s) > 0:\\n                return 1\\n            #since 0 does not have any mapping to any character so if s = 0, answer is 0\\n            return 0\\n        \\n        dp = [0]*n\\n        \\n        #Since our dp is dependent on previous 2 values, we initialize values for 0 and 1 index\\n        #That is numDecodings for substring till 0th and 1st index\\n        dp[0] = 0 if int(s[0]) == 0 else 1\\n        dp[1] += 1 if int(s[:2]) <= 26 and int(s[:2]) >= 10 else 0\\n        dp[1] += 0 if (int(s[0]) == 0 or int(s[1]) == 0) else 1\\n        \\n        for i in range(2,n):\\n            dp[i] += dp[i-2] if int(s[i-1:i+1]) <= 26 and int(s[i-1:i+1]) >= 10 else 0\\n            if not int(s[i]) == 0:\\n                dp[i] += dp[i-1] \\n        return dp[n-1]\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        n = len(s)\\n        \\n        #Base Case 1\\n        if n == 0:\\n            return n\\n        \\n        #Base Case 2\\n        if n == 1:\\n            if int(s) > 0:\\n                return 1\\n            #since 0 does not have any mapping to any character so if s = 0, answer is 0\\n            return 0\\n        \\n        #Since our dp is dependent on previous 2 values, we initialize values for 0 and 1 index\\n        #That is numDecodings for substring till 0th and 1st index\\n        a = 0 if int(s[0]) == 0 else 1\\n        b = 0\\n        b += 1 if int(s[:2]) <= 26 and int(s[:2]) >= 10 else 0\\n        b += 0 if (int(s[0]) == 0 or int(s[1]) == 0) else 1\\n        \\n        for i in range(2,n):\\n            c = 0\\n            c += a if int(s[i-1:i+1]) <= 26 and int(s[i-1:i+1]) >= 10 else 0\\n            if not int(s[i]) == 0:\\n                c += b \\n            a = b\\n            b = c\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419315,
                "title": "python-one-dimension-dp-beat-97-with-explanations",
                "content": "This question reminds me of[ 509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\nWhat type of DP question is this? - Find the total number of possible conbinations (with constraints)\\n1. Define the last step: for example, if we want to know how many ways to decode 426, the previous step could be either decode 42 (+6) or decode 4 (+26)\\n2. State transition: (could be one of the three, depending on the constraint)\\n* F(x) = F(x-1) + F(x-2)\\n* F(x) = F(x-1)\\n* F(x) = F(x-2), where F(x) denotes the number of decoding ways using first x digits from the string.\\n```python\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [1 for _ in range(len(s)+1)]\\n        if s[0] == \\'0\\': # edge cases, if the string starts with \"0\", we return 0\\n            return 0\\n        for i in range(1, len(s)):\\n            if s[i] != \\'0\\' and s[i-1] != \"0\":  # if the string is \"normal\"\\n                if 1 <= int(s[i-1:i+1]) <= 26: # if the two digits are within the covered range\\n                    dp[i+1] = dp[i] + dp[i-1]\\n                else:\\n                    dp[i+1] = dp[i] # the last step can only be 1 step away\\n            else:\\n                if int(s[i-1:i+1]) == 0 or int(s[i-1:i+1]) > 26: # edge cases like \"00\" or \"30\"\\n                    return 0\\n                else:\\n                    dp[i+1] = dp[i-1]  # cases like \"10\", we need to go two steps back, meaning that we can only decode \"10\" as a whole.\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        dp = [1 for _ in range(len(s)+1)]\\n        if s[0] == \\'0\\': # edge cases, if the string starts with \"0\", we return 0\\n            return 0\\n        for i in range(1, len(s)):\\n            if s[i] != \\'0\\' and s[i-1] != \"0\":  # if the string is \"normal\"\\n                if 1 <= int(s[i-1:i+1]) <= 26: # if the two digits are within the covered range\\n                    dp[i+1] = dp[i] + dp[i-1]\\n                else:\\n                    dp[i+1] = dp[i] # the last step can only be 1 step away\\n            else:\\n                if int(s[i-1:i+1]) == 0 or int(s[i-1:i+1]) > 26: # edge cases like \"00\" or \"30\"\\n                    return 0\\n                else:\\n                    dp[i+1] = dp[i-1]  # cases like \"10\", we need to go two steps back, meaning that we can only decode \"10\" as a whole.\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366267,
                "title": "c-o-n-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        unsigned long long n = s.size();\\n        unsigned long long dp[n + 1] = {0};\\n        dp[0] = 1; \\n        dp[1] = s[0] >= \\'1\\' && s[0] <= \\'9\\' ? 1 : 0;\\n        for (unsigned long long i = 2; i <= n; i++) {\\n            if (s[i - 1] >= \\'1\\' && s[i - 1] <= \\'9\\') dp[i] += dp[i - 1]; // current digit can be added to previous ones.\\n            int num = stoi(s.substr(i - 2, 2));\\n            if (num >= 10 && num <= 26) dp[i] += dp[i - 2];  // combination of two previous dgits can be used.\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        unsigned long long n = s.size();\\n        unsigned long long dp[n + 1] = {0};\\n        dp[0] = 1; \\n        dp[1] = s[0] >= \\'1\\' && s[0] <= \\'9\\' ? 1 : 0;\\n        for (unsigned long long i = 2; i <= n; i++) {\\n            if (s[i - 1] >= \\'1\\' && s[i - 1] <= \\'9\\') dp[i] += dp[i - 1]; // current digit can be added to previous ones.\\n            int num = stoi(s.substr(i - 2, 2));\\n            if (num >= 10 && num <= 26) dp[i] += dp[i - 2];  // combination of two previous dgits can be used.\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568505,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1685556,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568249,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1564961,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1565831,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1567386,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1567849,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568240,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1566566,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1566742,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568505,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1685556,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568249,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1564961,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1565831,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1567386,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1567849,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568240,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1566566,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1566742,
                "content": [
                    {
                        "username": "renwopang",
                        "content": "# Dynamic programing\\nA valid decode result belongs to one of the following two categories:\\n* Category 1: ending with a valid one-digit (for example: [........, 9] or [.........., 2])\\n* Category 2: ending with a valid two-digit (for example: [........, 12] or [........, 20] or [........, 16] )\\n\\nFor a certain input string, the total count of valid results = count of Category 1 results + count of Category 2 results.\\n\\nApplying the principle of dynamic programing, when we do a loop on the input string, while we are at a certain character, we try to get new valid decode results by adding this new character onto the valid results ending at the previous character. \\n\\nBecause each valid decode result is in either Category 1 or 2, we have 4 cases:\\n* Category 1 to Category 1 (for example: [........, 9] --add X--> [........, 9, X])\\n* Category 1 to Category 2 (for example: [........, 2] --add X--> [........, 2X])\\n* Category 2 to Category 1 (for example: [........, 20] --add X-->  [........, 20, X])\\n* Category 2 to Category 2 is **Impossible**. (for example: [........, 21] --cannot change into-- > [........, 2, 1X])\\n\\nWe keep track of the counts of Category 1 and Category 2 results ending at each character, using count1 as the count of Category 1 and count2 as count of Categoty 2.\\n\\nSince both Category 1 and 2 can be changed into Category 1, therefore, \\n* count1 = previous count1 + previous count2\\n\\nIf the character is \\'0\\', then the equation above is not valid. In that case, because neither [\\u2026\\u2026\\u2026., X, 0] or [\\u2026\\u2026., XX, 0] is valid, there is no valid solution ending with one-digit \\'0\\'. As a result, we set count1 to 0.\\n\\nOnly Category 1 can be changed into Category 2, therefore, \\n\\n* count2  = previous count1\\n\\nThis equation is not valid if the new character cannot form a valid two-digit with the previous character. For example, [........, 9] --cannot be --> [........, 9X]. Another example, [........, 2] \\u2013cannot be --> [........, 29]. If that is the case, we set count2 to 0.\\n\\n# Example 1\\n![image](https://assets.leetcode.com/users/images/36d317a9-d6cd-409a-b3c6-6a9f5cb1daf9_1610524791.017491.png)\\nIf input is \\'226\\', initial count1 is 1 for [2], while initial count2 is 0 since we only have one character yet. In our loop, we move to next character \\'2\\'. \\'2\\' is not \\'0\\', so count1 = 1+ 0 =1, which corrosponds to [2, 2]. Two-digit composed of previous character and current character is \\'22\\', which is valid. Therefore, count2 = 1, which corrosponds to [22]. Simialiarly, we move to \\'6\\' and we get count1 = 2 and count2 = 1. As a result, the total count is 3.\\n\\n# Example 2\\n![image](https://assets.leetcode.com/users/images/72643f9a-e25b-40cc-8a4a-84314fb2d4c9_1610525081.638054.png)\\n\\nIf input is \\'12121\\', we use the same principle. At last, we get count1 = 5 and count2 =3. Therefore, the result is 8. The actual decode results at each step are listed in the figure above for references.\\n\\n# Example 3\\n![image](https://assets.leetcode.com/users/images/e16bbb20-d573-4c5c-bd6a-470d72f218d0_1610525249.3580933.png)\\n\\nIf input is \\'20419\\', when we are at the character \\'0\\', we set count1 to 0. When we are at the character \\'1\\', since \\'41\\' is not a valid two-digit, we set count2 to 0.\\n\\n# Example 4\\n![image](https://assets.leetcode.com/users/images/9711fdd4-88f2-4a59-a941-744ed4c5b88f_1610525354.404256.png)\\n\\nIf the two potential invalid cases occur at the same step, for example, \\'9012\\'. When we are at \\'0\\', count1 = 0. The previous character is \\'9\\', and \\'90\\' is not valid. Therefore, count2 = 0. In this case, all the following count1 and count2 are 0.\\n\\n\\nThis is my first post on leetcode. I would like to focus on the illustrated explanation of my thoughts instead of detailed codes. If this helps you or if you have any suggestion, feel free to leave a comment.\\n\\nThank you.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "I finished counting stairs, house robber, house robber ii, longest palindromic substring, palindromic substrings and came to this problem feeling a bit confident about my dp skills but boy oh boy was I wrong. Anyone else felt that this was a quite hard problem?"
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "at 58 you shouldn\\'t \" feeling a bit confident about my dp skills\""
                    },
                    {
                        "username": "stridemann",
                        "content": "Me stupid, me so stupid, was 99% sure it can be solved linearly... ofc after fast looking at example cases. Many other problems is a trap like this and should also be solved using DP.\nDunno how to not trap into same situation on interview. Maybe check more cases before coding...\nWorth to read: https://leetcode.com/problems/house-robber/solutions/156523/from-good-to-great-how-to-approach-most-of-dp-problems/ \n\nPS. Probably memoization optimization will fit perfectly here.\nUPD. Yes, memoization fixed timeout. And also there is a linear solution with simple code -_-, because we don't need to track all branches like in dp, because there is only two parallel branches in this algo."
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@Ibloly0127](/Ibloly0127) yeah blind 75 but how effective is it to crack interviews? "
                    },
                    {
                        "username": "Ibloly0127",
                        "content": "Feel the same, do you come from Blind 75 too?"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "yeah I got the correct decision tree quickly but there\\'s so many intricacies the code. Took me a while to fully understand even after looking up a solution"
                    },
                    {
                        "username": "kianyanglee",
                        "content": "Yes no idea how to proceed\\n"
                    },
                    {
                        "username": "mission_2023",
                        "content": "ya this is a small but tricky one"
                    },
                    {
                        "username": "hz9423",
                        "content": "I got fucked by zeros really hard"
                    },
                    {
                        "username": "leolind",
                        "content": "you should read that twice"
                    },
                    {
                        "username": "aniquaTabassum",
                        "content": "same"
                    },
                    {
                        "username": "yumeyao",
                        "content": "There is 1 way to decoding \"\", the decoding result is \"\"."
                    },
                    {
                        "username": "tmp96",
                        "content": "There is a sentence in question:\\n> Given an encoded message containing digits, determine the total number of ways to decode it.\\n\\nBut what message can be encoded to \"0\" ?"
                    },
                    {
                        "username": "rohit1221",
                        "content": "there is also given that we have to decode only 1-9 digits"
                    },
                    {
                        "username": "swo0sh",
                        "content": "None. there are 0 ways to decode it"
                    },
                    {
                        "username": "andhddn",
                        "content": "So which message has been encoded with \"0\" or with \"100\"? I suppose for something like \"909\" the answer is 0 too. No warnings or return values for invalid input were mentioned. Dislike."
                    },
                    {
                        "username": "madhur3",
                        "content": "There are 3 ways to decode \"11\" but the gold file has only 2.\\nI am getting WA on this test case but my answer is correct i.e. 3"
                    },
                    {
                        "username": "idebie",
                        "content": "the question isn\\'t how many characters you can get, it is how many valid combinations, \"AA\" & \"K\" is two combinations"
                    },
                    {
                        "username": "Garuda5209",
                        "content": "aa and k only 2 ways"
                    },
                    {
                        "username": "lixuemin2019",
                        "content": "This question is a little vague about how it should handle zeroes in the middle of a string.\\n\\ni.e. test case:\\n\\n\"123700532\" -> should this return 0?\\n\\nClearly, it has some decodings before the 0, but you couldn\\'t decode a full message past 0, but most dp solutions I see don\\'t handle this case (they just ignore the zero and continue, but still continue dp adding if there were decodings generated before).\\n\\nIn the test cases, it looks like we are decoding the full message, otherwise we would have a degenerate amount of partial solutions."
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "[@mr_kamran](/mr_kamran) It depends on where the character '2' appeared viz., if '2' appears at index 0, then dp[1] = 1 as '20' can be decoded only in single way. Coming to other indices through out the array, if '2' appears at index i-1 and '0' appears after that i.e., at index i, then dp[i] depends upon 2 factors. That is if s[i-1:i]<='26' then, dp[i] = dp[i-2] else dp[i-1]. The code snippet for above example is as shown:\n```\nif s[i]=='0' : \n                if s[i-1]>'2' or s[i-1]=='0' : return 0\n                if s[i-2:i]<='26' : dp[i]=dp[i-2]\n                else : dp[i] = dp[i-1]\n```"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "[@thrinadhsai78](/thrinadhsai78) if the character before \\'0\\' is >2 then also??"
                    },
                    {
                        "username": "thrinadhsai78",
                        "content": "Whenever you encounter a '0', you might want to consider checking the value of before character. If it is '0' too, then the program will return 0 directly. "
                    },
                    {
                        "username": "2014bduck",
                        "content": "10\\u300101\\u3001101\\u30011000001\\n\\ninput 01\\nexpect 0\\n?????"
                    },
                    {
                        "username": "Yuvraj102",
                        "content": "Basically there shouldnt be any leading zeros, leading zeros are not allowed\\n"
                    },
                    {
                        "username": "mr_kamran",
                        "content": "for 10 and 101 u will not get zero\\n"
                    },
                    {
                        "username": "acwboy",
                        "content": "Input: \"01\"  \\nOutput: 1  \\nExpected: 0\\n\\nI think \\n\\n  \"01\" -> '0'=>not, '1' => A, \\n\\n\\nit has one character right??\\n\\nwhy expected result is 'Zero' ??\\n\\nplease tell me questions condition... \\nor \\nwhat means \"01\" ?\\n\\nit's too confused"
                    },
                    {
                        "username": "idebie",
                        "content": "expected is zero, because 01 == nothing, and if you split it then sure 1 == A, but you still have a hanging 0 leftover that is invalid so that is not feasible to split the two and not possible to keep together, expected == 0"
                    }
                ]
            },
            {
                "id": 1568116,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1568916,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1566958,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1569786,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1567850,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1567851,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1567852,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1573085,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1568914,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1568915,
                "content": [
                    {
                        "username": "ivalue",
                        "content": "zero is so terrible, and this test case is annoying. i will say, this problem is so bad."
                    },
                    {
                        "username": "zero_he",
                        "content": "When I test my program, it is wrong annwer for input \"110\"\\n\\nSubmission Result: Wrong Answer\\nInput:\\t\"110\"\\nOutput:\\t2\\nExpected:\\t1\\n\\nbut I'm confused about the \"110\", Why the output is 1? Should it be 2?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I think [1,10] is the only valid solution as [11,0] leads to you having a 0, which cannot be mapped to a letter"
                    },
                    {
                        "username": "vikasyadav87500",
                        "content": "After a long search found a really good explanation of this question.\\nLink is given below check it out.\\nhttps://youtu.be/Km4iqih6WjI"
                    },
                    {
                        "username": "placeboR",
                        "content": "The description doesn\\'t provide detail explanation about \\'0\\' digit. I don\\'t quite understand why testcase \"2206\" has only 1 way to decode it.\\n\\nWhich is not valid? \"BBF\" (2 2 06) or \"VF\" (22 06)?"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "none of  \"BBF\" (2 2 06) or \"VF\" (22 06) are valid. The only valid possibility is \"BTF\" (2 20 6). There is no mapping from \"0x\" where x is any digit. "
                    },
                    {
                        "username": "oleksandr8",
                        "content": "Why for empty input string expected answer is 0 ?\\nI think that it should be 1, because there is one way to decode it with empty string"
                    },
                    {
                        "username": "goodcjw2",
                        "content": "numDecodings('') = 0 makes sense if you think it is invalid input. But one can also argue that there is ONE AND ONLY ONE decoding in case that decoded string is '' as well."
                    },
                    {
                        "username": "cusion",
                        "content": "For example, if the input is \"001\", what should be returned? or what should be returned with \"123000004\"?"
                    },
                    {
                        "username": "zy0016",
                        "content": "why the \"27\" should output the \"1\"?"
                    },
                    {
                        "username": "tacoman",
                        "content": "The questions asks number of ways to decode a string. In my opinion, it should just give a valid string which could at least be decoded. I might be wrong int assuming that, but then could somebody explain that why is 'pqr' not a valid input to the question as we are supposed to give invalid/non-decodeable strings to the program anyways. \\nThe OJ provides 1 as answer when 'pqr' is provided as input."
                    },
                    {
                        "username": "ninacc",
                        "content": "Why we should initialize dp[0]=1 instead of  0?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "dp[0]=1 is initialized only when s[0]!=\\'0\\', else dp[0]=0 when s[0]=\\'0\\'"
                    }
                ]
            },
            {
                "id": 1568917,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1939191,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1750814,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1575159,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1573250,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572936,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572501,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572327,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572286,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572218,
                "content": [
                    {
                        "username": "Samuri",
                        "content": "Runtime Error Message:\\tLine 11: ValueError: invalid literal for int() with base 10: ''\\nLast executed input:\\t\"10\"\\n\\nAny idea?"
                    },
                    {
                        "username": "spookie886",
                        "content": "gist of the problem: CLIMBING STAIRS, but at every step, you need to choose to add the two previous step values based conditions. \n\nclimbing stairs template: `dp[i] = dp[i - 1] + dp[i - 2]`\n\nBut for this problem, you need to reevaluate whether or not to add `dp[i - 1]` and `dp[i - 2]` based on the validity of last digit, and last two digits. Add `dp[i - 1]` and `dp[i - 2]` ONLY when meeting conditions.\n\nif last digit is valid(aka not a 0), you can add `dp[i - 1]`, otherwise, you add 0. \nif last two digits is valid(aka between 10 and 26), add `dp[i - 2]`, otherwise, add 0\n"
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "This is an awesome problem. Do not view solutions before attempting it.\\n\\nHint: Try to figure it out with pen and paper.\\n\\nWhat happens with \"1\", \"1 - 1\", \"1 - 1 - 1\",  \"1 - 1 - 1 - 1\" and  \"1 - 1 - 1 - 1 - 1\"? How does it build up? What\\'s the pattern?\\nThen, add the 0 case (how does zero affect that pattern?)\\nThen explore the > 2 case (how does that affect that pattern?)"
                    },
                    {
                        "username": "sridharchaildn",
                        "content": "1. Single digit being 0\\n2. One digit will have only one way\\n3. Two digit will have two ways if >= 10 and <= 26 \\nThat\\'s it, all the approaches in the solutions make sure they satisfy above rules."
                    },
                    {
                        "username": "ggggggggg",
                        "content": "I understand DP solution is O(n) time complexity.\\nHowever, if using the recursive solution, what will be the time complexity?"
                    },
                    {
                        "username": "BerkeleySquirrel",
                        "content": "Could\\'ve avoided myself a failed submission"
                    },
                    {
                        "username": "krk91",
                        "content": "![image](https://assets.leetcode.com/users/krk91/image_1551758678.png)\\n\\nWhy is the expected value 0?"
                    },
                    {
                        "username": "keejuan05",
                        "content": "I am currently failing this test case but I believe the expected output is incorrect. Since \"27\" have 2 possible decoding ways.\\n\\nIt could be 2 -> \"B\" and 7 -> \"G\". \\n\\nInput\\n\"27\"\\n\\nOutput\\n2\\n\\nExpected\\n1\\n\\nI may have understood the question wrong, but can someone please shed some light on this test case?"
                    },
                    {
                        "username": "never-give-up",
                        "content": "I believe smth is wrong with the test cases.\\n - if I put \"10\" -> 1 is expected\\n- if I put \"01\" -> 0 is expected\\n\\nProbably the task needs to outline \"0\" symbol case."
                    },
                    {
                        "username": "akshayjain114",
                        "content": "![image](https://assets.leetcode.com/users/akshayjain114/image_1539667896.png)\\nAlgorithm: https://leetcode.com/problems/decode-ways/discuss/30358/Java-clean-DP-solution-with-explanation\\n\\nThe underlined portions in the image represent valid \\'ways to decode\\' obtained from former number"
                    }
                ]
            },
            {
                "id": 1572199,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1572093,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1571201,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1571202,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1571203,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1571204,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1574736,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 1572301,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 2072823,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 2054624,
                "content": [
                    {
                        "username": "_l33t",
                        "content": "I think getting the number of ways is easy.\\nbut what if we were supposed to have all the strings too.\\nEg: \\nInput: 12345\\nAnswers:\\nABCDE\\nLCDE\\nAWDE\\n\\nAny help will be greatly appreciated\\n"
                    },
                    {
                        "username": "kiya956",
                        "content": "Why 01 is 0? I thought it can represent A"
                    },
                    {
                        "username": "navieh",
                        "content": "an empty string `''` should be decoded as empty string `''` thus there is `1` way to decode it, but test case returns `0`"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "Question is \"Given an encoded message containing digits, determine the total number of ways to decode it.\"\\n\\nBut \"0\" is not a valid encoded message. Why use it as a test case?"
                    },
                    {
                        "username": "janejingya",
                        "content": "so OJ is OK for starting with extra 0 but not ending with extra 0?"
                    },
                    {
                        "username": "zhaobey",
                        "content": "If there is no '0' in the string, it is not hard.\\nBut i think the hard point is how to handle '0' ?\\nI test three case:\\n\"001\" expected answer 0;\\n**\"12345600\" Expected answer 0\\n\"10\" Expected:1**\\n\\nplease see the case 2> and 3>\\nfor 12345600 and 10, why the Expected answer is different?\\n\\nDoes someone tell me ?"
                    },
                    {
                        "username": "vivekgup",
                        "content": "Dynamic Programming Solution in C++\\nFeedback is appreciated. I might be encouraged to post video solutions regularly if it is helpful for the community.\\n\\n[Video link](https://drive.google.com/file/d/1lsfOXT9sroH_era0urde_ed_37t7jTU_/view?usp=sharing)"
                    },
                    {
                        "username": "paolovalladolid",
                        "content": "The test input \"10\" should have two decodings, not one.\\n\\n\"1\"  is decoded as \\'A\\'\\n\"10\" is decoded as \\'J\\'\\n\\'0\" has no decoding, which is fair"
                    },
                    {
                        "username": "chandleryeh",
                        "content": "very similar to 1-2 step ploblem"
                    },
                    {
                        "username": "benjelplan",
                        "content": "i don\\'t really understand why inputs like \"06\" are provided here. If the point is to learn to sanitise inputs, why not also include strings like \"lol\" as inputs. In general I\\'m not a big fan of having to put code to deal with weird edge cases when surely the point is to learn the algorithm"
                    },
                    {
                        "username": "benjelplan",
                        "content": "[@anagarwal](/anagarwal) I wan\\'t talking about valid inputs like \"106\". I was meaning inputs like \"06\" (or \"1006\", etc.)."
                    },
                    {
                        "username": "anagarwal",
                        "content": "\"06\" may be an edge case but think about \"106\". If you use recursion in your solution, then \"06\" will become an input sometime. For \"106\" the decode will never start with \\'A\\' because then the \"0\" cannot be mapped to anything. So valid decodes will start with \\'J\\'. "
                    }
                ]
            },
            {
                "id": 2049716,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 2016238,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 2008324,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 2001650,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1997965,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1986461,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1981270,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1975478,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1972153,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1969364,
                "content": [
                    {
                        "username": "alice0217",
                        "content": "if character i can form a valid single-digit, dp[i] += dp[i-1]. if the character i and its previous i-1 can form a valid two-digit, dp[i] += dp[i-2]. It\\'s very like climbing stairs, but just some conditions to check. "
                    },
                    {
                        "username": "kartikey101",
                        "content": "was asked to me in oracle intern interview"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This pattern is similar to generating the Fibonacci series."
                    },
                    {
                        "username": "coolblade",
                        "content": "I wonder why my bottom up (2ms) is slower than my top down recursive (1ms)"
                    },
                    {
                        "username": "rmolinamir",
                        "content": "jesus christ"
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "Am I crazy or this is a wrong test case?\nS = \"10\"\nExpected output =1;\nActual output =2;"
                    },
                    {
                        "username": "anagarwal",
                        "content": "The only possible decoding is \"J\". So 1. "
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I think it is easy problem once you see it 2-3 times. recursion + memoization approach is intuitive.  "
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "Finally did this after so many tries  \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Wogrim",
                        "content": "javascript recursive solution fails on time, don\\'t bother"
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "I was feeling good by solving diff types of dp questions and general 1D category just made me lose my confidence to absolute 0"
                    }
                ]
            },
            {
                "id": 1966022,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1939165,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1933438,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1922549,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1912283,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1861730,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1849557,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1844344,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1811262,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1803165,
                "content": [
                    {
                        "username": "anagarwal",
                        "content": "In the problem as given, we are only returning the number of decode the input string and we are able to use memoization to speeden up the process (and avoid the \"Time Limit Exceeded\" on the test case \"1111....111\"). But if we were required to generate all the possible decoded strings, can we still use memoization? "
                    },
                    {
                        "username": "spookie886",
                        "content": "this is question is hard i tried to comprehend it so many times before. to this day still cannot do it. i really just dread this question what can i say. I REALLY DREAD THIS QUESTION."
                    },
                    {
                        "username": "spookie886",
                        "content": "i need mental health support to even look at this question"
                    },
                    {
                        "username": "spookie886",
                        "content": "i have solved word search 2 on my own using trie and dfs, but this question i just keep procrastinating doing it. it really intimidates me and it is actually upsetting, but i have to do it, no way around it so... sigh..........."
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Explain me please how is 4 here - (\"2611055971756562\")?\\nI found only 3\\n1. Every single\\n2. (\"**26**11055971756562\")\\n3. (\"261105597**17**56562\")"
                    },
                    {
                        "username": "Wogrim",
                        "content": "2, 6, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 1, 7, 5, 6, 5, 6, 2\\n2, 6, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n26, 1, 10, 5, 5, 9, 7, 17, 5, 6, 5, 6, 2\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "This makes me feel dumb lol... I thought doing house robber i and ii, LPS and count palindromes would make me better at grasping the thought process but oh well..."
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Here the key thinking point is no number can be formed where \\'0\\' is preceded by number greater than \\'2\\'. This will help immensely in building the recurrence solution.  "
                    },
                    {
                        "username": "yogesh873",
                        "content": "how come 1123 have 5 ways of decoding my answer gives 4 and i can only think 4 (1,12,3);(1,1,2,3);(11,23);(1,12,3). What am I missing here any help is appreciated"
                    },
                    {
                        "username": "ankush920",
                        "content": "100 % FAST OPTIMIZED DP SOLUTION FOR C++\\nankush920\\n0\\na few seconds ago\\nIntuition\\nto solve for small come for large\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        \\n        if( s[0]==\\'0\\')\\n        {\\n          return 0;\\n        }\\n\\n       if(s.size()==1)\\n       {\\n            return 1;\\n       }\\n        int n =s.size();\\n\\n    vector<int>dp(n+1 ,0);\\n     dp[0]=1;\\n      dp[1] =1;\\n\\n      for( int i = 2 ;i<=n ;i++)\\n      {\\n           if(s[i-1]==\\'0\\')\\n           {\\n\\n                 if(s[i-2]<\\'3\\')\\n            {\\n                   dp[i] = dp[i-2]; \\n           }\\n\\n                  if(s[i-2]==\\'0\\')\\n                  {\\n                        dp[i]=0;\\n                  }\\n                 \\n              continue;                \\n           }\\n           \\n\\n           if( s[i-1]<\\'7\\')\\n           {\\n               if(s[i-2]==\\'1\\'|| s[i-2] ==\\'2\\')\\n               {\\n                    dp[i]=dp[i-1]+dp[i-2];\\n                 \\n               }\\n\\n               else\\n               {\\n                     dp[i] = dp[i-1] ;\\n               }\\n\\n          continue;\\n           }\\n           \\n           if( s[i-1]>=\\'7\\')\\n           {\\n                 if(s[i-2]==\\'1\\')\\n                 {\\n                       dp[i]=dp[i-1]+dp[i-2];\\n                       \\n                 }\\n                 else\\n                 {\\n                       dp[i] =dp[i-1];\\n                 }\\n           }\\n           \\n           \\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};"
                    },
                    {
                        "username": "kirti_9",
                        "content": "Have a doubt that how \"10\" will give 1 output ?\\nThis can be decodes as 2 way:\\n1 or 10 ---> \"AJ\""
                    },
                    {
                        "username": "piyushsk1999",
                        "content": "wow that zero thing is very irritating. it gives a lot of edge cases hence the dislike otherwise it a straightforward dp  "
                    },
                    {
                        "username": "wladoseid",
                        "content": "Why should the number 226 be decomposed into 3 options and not 2?\\n226 => (2 2 6), (22, 6) | (2 26) - error"
                    }
                ]
            },
            {
                "id": 1784871,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1767231,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1757953,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1753618,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1745368,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1710771,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1707773,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1706222,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1703913,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1697331,
                "content": [
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\nvector<int>dp;\\n \\n    int numDecodings(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,0);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            if(s[i-1]!=\\'0\\'){\\n                dp[i]+=dp[i-1];\\n            }\\n            if(i>=2&&s[i-2]==\\'1\\'){\\n                dp[i]+=dp[i-2];\\n            }\\n            else if(i>=2&&s[i-2]==\\'2\\'&&s[i-1]-\\'0\\'<=6){\\n                dp[i]+=dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n"
                    },
                    {
                        "username": "user5562Dy",
                        "content": "the solution behind the problem is quite intuitive just think of the ways of decoding 1. we can decode the string single digit wise(A->1,C->3...... till I->9).\\n2. we can also decode the string using double digits(J->10.....Z->26)\\nthink about the corner cases \\n1. in the first we cannot decode 0 as a single digit \\n2. in the second case we cannot decode numbers greater than 26.\\nNow try to solve"
                    },
                    {
                        "username": "daBozz",
                        "content": "\"2101\" is 2, but I get 1. Only way I can think to decode is (2-10-1). What the h am I missing????\\nI\\'m currently passing `227 / 269` test cases, and my solution looks ALMOST the same as the official solution. Since the strategy seems to be the same, I don\\'t know what I\\'m missing."
                    },
                    {
                        "username": "charonme",
                        "content": "I\\'m now getting 1 for \"2101\" from the judge. If you were getting 2 maybe they had a bug and since fixed it?"
                    },
                    {
                        "username": "R140",
                        "content": "Why are we returning 1 for empty string?\\n\\n if(index == s.length()) { //empty string \\n            return 1;\\n        }"
                    },
                    {
                        "username": "charonme",
                        "content": "the constraints now say the length must be >0 and the judge says \"expected \\'s\\' to have 1 <= size <= 100 but got 0\" for empty string input"
                    },
                    {
                        "username": "abhisheksinghaz",
                        "content": "Watch it [youtube_tutorial](https://www.youtube.com/watch?v=W4rYz-kd-cY) till 5:30 and then start writing code."
                    },
                    {
                        "username": "rreocode",
                        "content": "This is way too mind boggling to debug on my own"
                    },
                    {
                        "username": "user9067q",
                        "content": "\"10\" has two options (1 0) and (10) but is expected only one?"
                    },
                    {
                        "username": "rohitsinghkatochj",
                        "content": "Is this question related to matrix chain Multiplication or to Boolean Parathesization because with a couple to tweaks to those codes this can be solved I guess. Am I on the right track?"
                    },
                    {
                        "username": "danish12",
                        "content": "Java based Sol.. pls make it correct for all test cases\\n\\nclass Solution {\\n    public int numDecodings(String str) {\\n        \\n         int count  =  0;\\n         if(str.length()  == 0)\\n         {\\n        // System.out.println(ans);\\n         return 1;\\n         }\\n         \\n         if (str.charAt(0) == \\'0\\')\\n            return 0;\\n             \\n         else if(str.length() == 1) {\\n         \\tString ch0 =  str.substring(0, 1);\\n\\n         \\tString subStr =  str.substring(1);\\n\\n         \\tString code0 = (char)(\\'a\\' +\\n         \\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n\\n         \\tcount  += numDecodings(subStr);\\n         }\\n             \\n         \\telse\\n         \\t{\\n         \\t\\tString ch0 =  str.substring(0, 1);\\n\\n         \\t\\tString subStr1 =  str.substring(1);\\n         \\t\\t\\n         \\t\\tString code1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch0) - 1)) + \"\";\\n         \\t\\tcount += numDecodings(subStr1);            \\t\\n\\n         \\t\\tString ch01 =  str.substring(0, 2);              \\n\\n\\n         \\t\\tsubStr1 =  str.substring(2);\\n\\n         \\t\\tif(Integer.parseInt(ch01) <= 26)\\n         \\t\\t{\\n         \\t\\t\\tcode1 = (char)(\\'a\\' +\\n         \\t\\t\\t\\t\\t(Integer.parseInt(ch01) - 1)) + \"\";\\n         \\t\\t\\tcount += numDecodings(subStr1);\\n         \\t\\t}\\n         \\t}\\n\\n             return count;            \\n         \\n    }\\n}"
                    },
                    {
                        "username": "mission_2023",
                        "content": "this is a tricky one I feel. Considering 2 letter and then doing conditional checks would be tough to crack if not practiced before"
                    }
                ]
            },
            {
                "id": 1647713,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1627667,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1626707,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1626498,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1626295,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1626148,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1625847,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1625762,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1625585,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            },
            {
                "id": 1625551,
                "content": [
                    {
                        "username": "kaparouita",
                        "content": "Input :      \"2101\"\\nOutput :    2\\nExpected : 1\\nBut 21 can be 21=U and 2=B,1=A\\nAm i getting something wrong?"
                    },
                    {
                        "username": "subham1399",
                        "content": "Can anyone help me in knowing why this code is not passing the test cases ?\\n\\n`class Solution {\\npublic:\\n    int numDecodings(string s) {\\n        int n = s.size() ;\\n        int dp[n+1] ;\\n       memset(dp, 0, sizeof(dp)) ;\\n        dp[0] = 1 ;\\n        dp[1] = (s[0] == \\'0\\')? 0 : 1 ;\\n\\n        for(int i=2;i<=n;i++) {\\n            int oneDigit = stoi(s.substr(i-1,i)) ;\\n            int twoDigits = stoi(s.substr(i-2,i));\\n\\n            if(oneDigit >= 1) {\\n                dp[i] += dp[i-1] ;\\n            } \\n\\n            if(twoDigits >=10 && twoDigits <=26){\\n                dp[i] += dp[i-2];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};"
                    },
                    {
                        "username": "kavansoni",
                        "content": " `\\n\\n  `def numDecodings(self, s: str) -> int:`\\n\\n        def isValid(p,n):\\n            return 1 if p<len(s)-n+1 and str(int(s[p:p+n]))== s[p:p+n] and 1<=int(s[p:p+n])<=26 else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def decoding(p):\\n            if p == len(s) : return 1\\n            if p>len(s) or s[p] == \"0\": return 0\\n            return isValid(p,1)*decoding(p+1) + isValid(p,2)*decoding(p+2)\\n\\n        return decoding(0)\\n`"
                    },
                    {
                        "username": "shailesh123-_",
                        "content": "class Solution {\\npublic:\\n    \\n    int helper(int i,string& s,vector<int>& dp){\\n         \\n        if(i>=s.size()) return 1;\\n        \\n          \\n        if(s[i]==\\'0\\')     return 0;\\n        if(i==s.size()-1) return 1;\\n        \\n        if(dp[i]!=-1) return dp[i];\\n        \\n        \\n        int val= stoi(s.substr(i,2));\\n        \\n        if(val>=1 && val<=26) return dp[i]=(helper(i+1,s,dp) + helper(i+2,s,dp));\\n        else                  return dp[i]=helper(i+1,s,dp);\\n        \\n    }\\n\\n    int numDecodings(string s) {\\n       \\n        int n=s.size();\\n        vector<int> dp(n,-1); \\n        return helper(0,s,dp);\\n\\n    }\\n};"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "\\n#Why the hell this giving me runtime error :\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\uD83E\\uDD2F\\n```c++\\nclass Solution {\\npublic:\\n    int numDecodings(string s) {\\n        vector<int> dp(s.length(), 0);\\n        dp[0] = 1;\\n        dp[1] = s[0] == \\'0\\' ? 0 : 1;\\n        for (int i = 2; i <= s.length(); i++)\\n        {\\n            int oneDigit = stoi(s.substr(i - 1, i));\\n            int towDigit = stoi(s.substr(i - 2, i));\\n            if (oneDigit >= 1)\\n            {\\n                dp[i] += dp[i - 1];\\n            }\\n            if (towDigit >= 10 && towDigit <= 26)\\n            {\\n                dp[i] += dp[i - 2];\\n            }\\n        }\\n        return dp[s.length()];\\n        \\n    }\\n};\\n```\\n\\n#error\\n```bash\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000018 at pc 0x000000344934 bp 0x7fff1a5d3a30 sp 0x7fff1a5d3a28\\nREAD of size 4 at 0x602000000018 thread T0\\n    #3 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000000018 is located 0 bytes to the right of 8-byte region [0x602000000010,0x602000000018)\\nallocated by thread T0 here:\\n    #6 0x7f2b5da510b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa 00[fa]fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\nConsole\\n```"
                    },
                    {
                        "username": "Terry_Lah",
                        "content": "# Python solution via backtracking\\n\\n```\\nclass Solution:\\n    from functools import cache\\n    \\n    @cache\\n    def numDecodings(self, s: str) -> int:\\n\\n        if not s:\\n            return 1\\n        elif s[0] == \\'0\\':\\n            return 0\\n        elif len(s) >= 2 and s[:2] <= \\'26\\':\\n            return self.numDecodings(s[1:]) + self.numDecodings(s[2:])\\n        else:\\n            return self.numDecodings(s[1:])\\n```"
                    },
                    {
                        "username": "Sudha_S",
                        "content": "Guys, Fibonacci numbers is the answer. You just need to know the number of places where you actually can combine the values with the next values. If you can\\'t, then the sequence breaks. You multiply the values. "
                    },
                    {
                        "username": "2100030779",
                        "content": "public class Solution {\\n    public int numDecodings(String s) {\\n        int n = s.length();\\n        if (n == 0 || s.startsWith(\"0\")) {\\n            return 0;\\n        }\\n        int[] ways = new int[n+1];\\n        ways[0] = 1;\\n        ways[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int first = Integer.parseInt(s.substring(i-2, i));\\n            int prev = (first <= 26 && first > 9) ? ways[i-2]:0;\\n            int plus = (Integer.parseInt(s.substring(i-1, i)) == 0) ? 0:ways[i-1];\\n            ways[i] = prev + plus;\\n        }\\n        return ways[n];\\n    }\\n}"
                    },
                    {
                        "username": "vishwajeethogale307",
                        "content": " `def check(s,mp):\\n    return int(s in mp.keys())\\ng_d = dict()\\ndef helper(s,mp):\\n    if(s in g_d):\\n        return g_d[s]\\n    if(s[0] == \\'0\\'):\\n        return 0\\n    if(len(s) == 2):\\n        return  check(s[0:2],mp) + helper(s[1:],mp)\\n    if(len(s) == 1 ):\\n        return int(s in mp.keys())\\n    if not check(s[0:2],mp) and check(s[0:1],mp):\\n        g_d[s] = helper(s[1:],mp)\\n        return g_d[s]\\n    if not check(s[0:1],mp) and check(s[0:2],mp):\\n        g_d[s] = helper(s[2:],mp)\\n        return g_d[s]\\n    g_d[s] = helper(s[1:],mp) + helper(s[2:],mp)\\n\\n    return g_d[s]\\nclass Solution(object):\\n    \\n    def numDecodings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        mp = dict()\\n        for i in range(1,27):\\n            mp[str(i)] = chr(64+i)\\n        # print(mp)\\n        return helper(s,mp) `"
                    },
                    {
                        "username": "purohit447",
                        "content": " int fun(string s,int i,vector<int>&dp,int n)\\n    {\\n        int x = 0, y = 0;\\n        if(i==s.length())\\n        {\\n            return 1;\\n        } \\n        if(dp[i]!=-1) return dp[i]; \\n        if(s[i]==\\'0\\') return 0; \\n       \\n        x = fun(s,i+1,dp,n);\\n        if((i+1) < s.length() and ((s[i]==\\'2\\' and s[i+1] <= \\'6\\') or s[i]==\\'1\\' )) y = fun(s,i+2,dp,n);\\n        return dp[i] = x+y;\\n    }\\n    \\n    \\n    int numDecodings(string s) \\n    {\\n        int n = s.length();\\n        vector<int> dp(n+1,-1);\\n        return fun(s,0,dp,n);\\n    }"
                    }
                ]
            }
        ]
    }
]