[
    {
        "title": "Permutations",
        "question_content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n&nbsp;\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 6\n\t-10 <= nums[i] <= 10\n\tAll the integers of nums are unique.",
        "solutions": [
            {
                "id": 18239,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 18247,
                "title": "my-elegant-recursive-c-solution-with-inline-explanation",
                "content": "This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations [here][1]. All comments are welcome.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n    \\t    vector<vector<int> > result;\\n    \\t    \\n    \\t    permuteRecursive(num, 0, result);\\n    \\t    return result;\\n        }\\n        \\n        // permute num[begin..end]\\n        // invariant: num[0..begin-1] have been fixed/permuted\\n    \\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n    \\t\\tif (begin >= num.size()) {\\n    \\t\\t    // one permutation instance\\n    \\t\\t    result.push_back(num);\\n    \\t\\t    return;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = begin; i < num.size(); i++) {\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t    permuteRecursive(num, begin + 1, result);\\n    \\t\\t    // reset\\n    \\t\\t    swap(num[begin], num[i]);\\n    \\t\\t}\\n        }\\n    };\\n\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/permutations.html",
                "solutionTags": [
                    "Recursion",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n    \\t    vector<vector<int> > result;\\n    \\t    \\n    \\t    permuteRecursive(num, 0, result);\\n    \\t    return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18296,
                "title": "simple-python-solution-dfs",
                "content": "        \\n    # DFS\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n        \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            # return # backtracking\\n        for i in xrange(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    # DFS\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n        \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            # return # backtracking\\n        for i in xrange(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "codeTag": "Python3"
            },
            {
                "id": 993970,
                "title": "python-4-approaches-visuals-time-complexity-analysis",
                "content": "--------------------------\\n**Approach 1: Recursive with backtracking (implicit stack)**\\n--------------------------\\n--------------------------\\n\\n**Big-O:**\\n- **Time:** `O(N*N!)` \\n\\t- **Why O(N*N!) and not just O(N!) ?**\\n\\tMany people are debating in the solution tab whether time-complexity should be `O(N!)` or `O(N * N!)`. Below are two intuitive arguments as to why it should be `O(N*N!)`. Let\\'s forget for a while about the recursive nature of the algorithm and examine  the **N-ary, recursive, space-tree** that is generated by the recursive algorithm. \\n\\t\\t\\n\\t\\t![image](https://assets.leetcode.com/users/images/ac9c35dc-89b8-4860-b08c-d2f60859e43e_1609289801.6830964.png)\\n\\t\\t\\n\\t1) In order to reaverse the tree, will visit each node once, we know very well that would cost us `O(N)` in a binary tree and `O(E+V)` in an N-ary tree where V = vertices and E = edges (or number of children). Now for the [1,2,3] example shown in the sketch, we can see there is a total of 16 nodes/verticies and that |E| varies from level to level with an upper limit of N and a lower limit of 1.\\n\\t\\t* So, we can say roughly O(E+V) = a little more than 16\\t\\n\\t\\t* O(N!) on the other hand = 6\\n\\t\\t* whereas, O(N*N!) = 3*6 = 18\\n\\n\\t2) Another way of looking at is we know from set theory that there are N! permutations of a list of size N. We also know that the permutations are going to be the leaves of the tree, which means we will have N! leaves. In order to get to each one of those leaves, we had to go through N calls. That\\'s O(N*N!). Again a little more than the total number of nodes because some nodes are shared among more than one path.\\n\\n\\n- **Space:** `O(N!)` \\n\\t- Because you still need to store the permutations and there are N! of them even if the depth of the stack is maxed out at N+1 (depth of the recursion space-tree is also N+1). See figure below.\\n\\n\\n**Code:**\\n```\\ndef permute(self, nums):\\n\\t# helper\\n\\tdef recursive(nums, perm=[], res=[]):\\n\\t\\tif not nums: # -- NOTE [1] \\n\\t\\t\\tres.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\\n\\n\\t\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tperm.append(nums[i])\\n\\t\\t\\trecursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\\n\\t\\t\\tperm.pop() # -- NOTE [3] \\n\\t\\treturn res\\n\\nreturn recursive(nums)\\n\\n# NOTE [1]:\\n# --------\\n# nums is empty at the leaf of the recursive tree\\n\\n# NOTE [2]:\\n# --------\\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\\n\\n# NOTE [3]:\\n# ---------\\n# See below\\n```\\n\\n**NOTE [3] Explained further : Why do we need to backtrack?** \\n\\n* Notice how in the code above, there is only one variable path (or perm) throughout the problem. This variable is passed to one recursive call after another recursive call as we move from the input (the root of the tree) to the leaf (the permutation) and obvioulsy it gets modified multiple times along the way. As we keep building the path (or perm). It goes from `[ ] -> [1,2] -> [1,2,3]` as you can see in the left-most branch. However, what actually happens is that everytime we append a number to the path, **we are actively changing the path from previous recursive states as well**, since all of these point to the same path list and are not independent states/copies. Since effectively all these aliases are pointing to the same memory location, any change to the variable are echoed to all of its aliases. This can be problematic because it alters the the previous states. See below for visual illustration of the problem.\\n\\t\\n![image](https://assets.leetcode.com/users/images/2dad4626-ba5b-4d8f-adcb-90249a1eddb4_1609299083.319523.png)\\n\\n\\n\\n* To overcome this problem, we need to backtrack. It\\'s tempting to think backtracking is needed only in situations where we encounter an obstacle while building/searching for the solution (such as hitting a wall while traversing a maze), however, backtracking as a technique has broader scope than just that. Any situation where we might need to access a previous state of a variable that keeps changing during the execution of the program requires backtracking. As mentioned earlier an coming across an obstacle in a maze (or anything that renders the path being explored invalid) is NOT the only incident backtracking is called upon. Backtracking would still be required even if the current path being explored is valid, in order to explore the next path. Think of a parent node from which two child nodes diverge. After exploring the first child, we need to backtrack to parent to investigate the sibling node (other child). This situation takes place in our space-tree. See sketch below.\\n\\n![image](https://assets.leetcode.com/users/images/ea5e3934-308b-486b-bd9d-ba5d84972c93_1609311308.955607.png)\\n\\n\\n- As you can see in the sketch above, by the time we reach node B, the path = [1,2,3]. These changes are echoed up to the parent node and even all the way up to the root if we don\\'t backtrack which will ruin subsequent paths (ex: ParentNode -> node C) is missed up. This can be alleviated by popping the path after each recursive call as we did in our code.\\n\\n\\t```\\n\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\tperm.append(nums[i])\\n\\t\\trecursive(newNums, perm, res) \\n\\t\\tperm.pop() # -- BACKTRACK\\n\\t```\\n\\n- It\\'s also worth-mentioning that backtracking was needed here because of the branching nature of the space-tree. Backtracking won\\'t be required if the recursive algorithm produces a linked-list rather than a space-tree. An example of such algorithm is recursively summing up numbers from 0 -> N\\n\\n\\t```\\n\\tdef sumPosNumLessThanN(N, res=0):\\n\\t\\tif N == 0:\\n\\t\\t\\treturn res\\n\\t\\telse:\\n\\t\\t\\tres = 1 + sumPosNumLessThanN(N-1)\\n\\t\\treturn res\\n\\t```\\n\\t\\n\\tThe recursive algorithm above produces a chain of nodes (no branching):\\n![image](https://assets.leetcode.com/users/images/65a431a3-c09d-4926-b431-8df5eb2a4cf3_1609312872.9623408.png)\\n\\n**NOTE [2] Explained further : Why do we need to copy?** \\n- You probably have guessed it by now. As shown above, due to the constantly changing state of our data/variables, we need to append a copy of the path `res.append(path[::])` at the leaf, instead of appending the path itself. The reason being that lists are mutable and are passed by reference, so even after appending a path to our result list, that path will still be affected by any changes to its aliases (will be afftected by all the poppping and backtracking taking place) and by the time our recursion calls make their way to the top/root, the path will be empty `path = [ ]`\\n\\n**Backtracking seems like a pain in the a$$. Is there a way around it?**\\n* Glad you asked, yes, there is! We can avoid backtracking all together with a little bit of book-keeping. Instead of having to backtrack to revert to a previous state of the data/variables, we could save snapshots of the data/variables at each step along the way so that we never have to manually backtrack. This can be done either recursively or iteratively by passing a copy of our data. See Approach 2 for recursive without backtracking, and Approach 3 for an itertaive solution without backtracking below.\\n.\\n.\\n--------------------------\\n**Appraoch 2: Recursive without backtracking (implicit stack)**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef recursive(nums, perm=[], res=[]):\\n        \\n            if not nums: \\n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we\\'re passing a new variable each time \\n\\n            for i in range(len(nums)): \\n                newNums = nums[:i] + nums[i+1:]\\n                # perm.append(nums[i]) # --- instead of appending to the same variable\\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\\n                recursive(newNums, newPerm, res) \\n                # perm.pop()  # --- no need to backtrack\\n            return res\\n        \\n        return recursive(nums)\\n```\\n\\n**How backtracking was avoided?  Approach 2 vs. Approach 3**\\n* Below is a comparison between the two approaches. Notice how on the left side, only one `perm/path` variable is maintained throughout as opposed to multiple `perm/path` snapshots at each step on the right hand side.\\n\\n![image](https://assets.leetcode.com/users/images/0a74e098-5a23-4859-8518-2ffe513ea965_1609340194.1382449.png)\\n\\n\\n* Illustartions above are generated using this [Python Tutor tool](http://www.pythontutor.com/visualize.html#mode=edit)\\n\\t* Approach 2 : Recursive w backtracking : [here](        http://www.pythontutor.com/visualize.html#code=def%20recursivePermute%28nums,%20perm%3D%5B%5D,%20res%3D%5B%5D%29%3A%0A%20%20%20%20if%20not%20nums%3A%20%0A%20%20%20%20%20%20%20%20res.append%28perm%29%20%0A%20%20%20%20%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20for%20i%20in%20range%28len%28nums%29%29%3A%20%23%20%5B1,2,3%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newNums%20%3D%20nums%5B%3Ai%5D%20%2B%20nums%5Bi%2B1%3A%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20perm.append%28nums%5Bi%5D%29%0A%20%20%20%20%20%20%20%20%20%20%20%20recursivePermute%28newNums,%20perm,%20res%29%20%23%20-%20recursive%20call%20will%20make%20sure%20I%20reach%20the%20leaf%0A%20%20%20%20%20%20%20%20%20%20%20%20perm.pop%28%29%20%0A%0A%20%20%20%20return%20res%0A%0Aprint%28recursivePermute%28%5B1,2,3%5D%29%29&cumulative=false&curInstr=25&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false\\n)\\n\\t* Approach 3: Recursive w/o backtracking : [here](http://www.pythontutor.com/visualize.html#code=def%20recursivePermute%28nums,%20perm%3D%5B%5D,%20res%3D%5B%5D%29%3A%0A%20%20%20%20if%20not%20nums%3A%20%0A%20%20%20%20%20%20%20%20res.append%28perm%5B%3A%3A%5D%29%20%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20for%20i%20in%20range%28len%28nums%29%29%3A%20%23%20%5B1,2,3%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newNums%20%3D%20nums%5B%3Ai%5D%20%2B%20nums%5Bi%2B1%3A%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20newPerm%20%3D%20perm%20%2B%20%5Bnums%5Bi%5D%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20recursivePermute%28newNums,%20newPerm,%20res%29%20%23%20-%20recursive%20call%20will%20make%20sure%20I%20reach%20the%20leaf%0A%0A%20%20%20%20return%20res%0A%0Aprint%28recursivePermute%28%5B1,2,3%5D%29%29&cumulative=false&curInstr=23&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n.\\n.\\n--------------------------\\n**Approach 3 : DFS Iterative with Explicit Stack**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(E+V)` which is the same as => `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```       \\ndef recursive(nums):\\n\\t stack = [(nums, [])]   # -- nums, path (or perms)\\n\\t res = []\\n\\t while stack:\\n\\t\\t nums, path = stack.pop()\\n\\t\\t if not nums:\\n\\t\\t\\t res.append(path)\\n\\t\\t for i in range(len(nums)):   # -- NOTE [4]\\n\\t\\t\\t newNums = nums[:i] + nums[i+1:]\\n\\t\\t\\t stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\\n\\t return res\\n\\n# NOTE [4]\\n# The difference between itertaive tree/graph traversal we did before and this one is that\\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)\\n```\\n\\n.\\n.\\n--------------------------\\n**Approach 4 : BFS Iterative with a queue**\\n--------------------------\\n--------------------------\\n**Big-O:**\\n- Time: `O(E+V)` which is the same as => `O(N*N!)`\\n- Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef recursive(nums):\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((nums, []))  # -- nums, path (or perms)\\n\\tres = []\\n\\twhile q:\\n\\t\\tnums, path = q.popleft()\\n\\t\\tif not nums:\\n\\t\\t\\tres.append(path)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tq.append((newNums, path+[nums[i]]))\\n\\treturn res\\n        \\n```\\n\\n- **For JAVA implementation of all 4 approaches : checkout this post** => https://leetcode.com/problems/permutations/discuss/996115/Java-4-Approaches-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef permute(self, nums):\\n\\t# helper\\n\\tdef recursive(nums, perm=[], res=[]):\\n\\t\\tif not nums: # -- NOTE [1] \\n\\t\\t\\tres.append(perm[::]) #  -- NOTE [2] - append a copy of the perm at the leaf before we start popping/backtracking\\n\\n\\t\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tperm.append(nums[i])\\n\\t\\t\\trecursive(newNums, perm, res) # - recursive call will make sure I reach the leaf\\n\\t\\t\\tperm.pop() # -- NOTE [3] \\n\\t\\treturn res\\n\\nreturn recursive(nums)\\n\\n# NOTE [1]:\\n# --------\\n# nums is empty at the leaf of the recursive tree\\n\\n# NOTE [2]:\\n# --------\\n# at the leaf -> we know we have exaushted one path/permutation (each path is a permutation in a recursive tree)\\n# reason why we are copying here is because at lists are passed by reference and since we are maintaining only one path/perm variable throughput, we are gonna be modifiying that path variable (popping it to be precise) in order to revert the path to a previous state (aka parent node) in preperation to make a lateral/horizontal move to a sibling node. See explanation below for further understanding.\\n\\n# NOTE [3]:\\n# ---------\\n# See below\\n```\n```\\n\\tfor i in range(len(nums)): # [1,2,3]\\n\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\tperm.append(nums[i])\\n\\t\\trecursive(newNums, perm, res) \\n\\t\\tperm.pop() # -- BACKTRACK\\n\\t```\n```\\n\\tdef sumPosNumLessThanN(N, res=0):\\n\\t\\tif N == 0:\\n\\t\\t\\treturn res\\n\\t\\telse:\\n\\t\\t\\tres = 1 + sumPosNumLessThanN(N-1)\\n\\t\\treturn res\\n\\t```\n```\\ndef recursive(nums, perm=[], res=[]):\\n        \\n            if not nums: \\n                res.append(perm) # --- no need to copy as we are not popping/backtracking. Instead we\\'re passing a new variable each time \\n\\n            for i in range(len(nums)): \\n                newNums = nums[:i] + nums[i+1:]\\n                # perm.append(nums[i]) # --- instead of appending to the same variable\\n                newPerm = perm + [nums[i]] # --- new copy of the data/variable\\n                recursive(newNums, newPerm, res) \\n                # perm.pop()  # --- no need to backtrack\\n            return res\\n        \\n        return recursive(nums)\\n```\n```       \\ndef recursive(nums):\\n\\t stack = [(nums, [])]   # -- nums, path (or perms)\\n\\t res = []\\n\\t while stack:\\n\\t\\t nums, path = stack.pop()\\n\\t\\t if not nums:\\n\\t\\t\\t res.append(path)\\n\\t\\t for i in range(len(nums)):   # -- NOTE [4]\\n\\t\\t\\t newNums = nums[:i] + nums[i+1:]\\n\\t\\t\\t stack.append((newNums, path+[nums[i]]))  # --  just like we used to do (path + [node.val]) in tree traversal\\n\\t return res\\n\\n# NOTE [4]\\n# The difference between itertaive tree/graph traversal we did before and this one is that\\n# in most tree/graph traversals we are given the DS (tree/graph/edges) whereas here we have to build the nodes before we # traverse them\\n# Generating the nodes is very simple, we Each node will be (nums, pathSofar)\\n```\n```\\ndef recursive(nums):\\n\\tfrom collections import deque\\n\\tq = deque()\\n\\tq.append((nums, []))  # -- nums, path (or perms)\\n\\tres = []\\n\\twhile q:\\n\\t\\tnums, path = q.popleft()\\n\\t\\tif not nums:\\n\\t\\t\\tres.append(path)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tnewNums = nums[:i] + nums[i+1:]\\n\\t\\t\\tq.append((newNums, path+[nums[i]]))\\n\\treturn res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18284,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18237,
                "title": "my-ac-simple-iterative-java-python-solution",
                "content": "the basic idea is, to permute n numbers, we can add the nth number into the resulting `List<List<Integer>>` from the n-1 numbers, in every possible position. \\n\\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial `List<List<Integer>>` (let's call it \"answer\"). \\n\\nThen, 2 can be added in front or after 1. So we have to copy the List<Integer> in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\\n\\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\\n\\n    public List<List<Integer>> permute(int[] num) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (num.length ==0) return ans;\\n        List<Integer> l0 = new ArrayList<Integer>();\\n        l0.add(num[0]);\\n        ans.add(l0);\\n        for (int i = 1; i< num.length; ++i){\\n            List<List<Integer>> new_ans = new ArrayList<List<Integer>>(); \\n            for (int j = 0; j<=i; ++j){            \\n               for (List<Integer> l : ans){\\n            \\t   List<Integer> new_l = new ArrayList<Integer>(l);\\n            \\t   new_l.add(j,num[i]);\\n            \\t   new_ans.add(new_l);\\n               }\\n            }\\n            ans = new_ans;\\n        }\\n        return ans;\\n    }\\n\\n-------------------------------------------------------------------------\\npython version is more concise:\\n\\n    def permute(self, nums):\\n        perms = [[]]   \\n        for n in nums:\\n            new_perms = []\\n            for perm in perms:\\n                for i in xrange(len(perm)+1):   \\n                    new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\\n            perms = new_perms\\n        return perms",
                "solutionTags": [],
                "code": "the basic idea is, to permute n numbers, we can add the nth number into the resulting `List<List<Integer>>` from the n-1 numbers, in every possible position. \\n\\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial `List<List<Integer>>` (let's call it \"answer\"). \\n\\nThen, 2 can be added in front or after 1. So we have to copy the List<Integer> in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\\n\\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\\n\\n    public List<List<Integer>> permute(int[] num) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if (num.length ==0) return ans;\\n        List<Integer> l0 = new ArrayList<Integer>();\\n        l0.add(num[0]);\\n        ans.add(l0);\\n        for (int i = 1; i< num.length; ++i){\\n            List<List<Integer>> new_ans = new ArrayList<List<Integer>>(); \\n            for (int j = 0; j<=i; ++j){            \\n               for (List<Integer> l : ans){\\n            \\t   List<Integer> new_l = new ArrayList<Integer>(l);\\n            \\t   new_l.add(j,num[i]);\\n            \\t   new_ans.add(new_l);\\n               }\\n            }\\n            ans = new_ans;\\n        }\\n        return ans;\\n    }\\n\\n-------------------------------------------------------------------------\\npython version is more concise:\\n\\n    def permute(self, nums):\\n        perms = [[]]   \\n        for n in nums:\\n            new_perms = []\\n            for perm in perms:\\n                for i in xrange(len(perm)+1):   \\n                    new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\\n            perms = new_perms\\n        return perms",
                "codeTag": "Python3"
            },
            {
                "id": 18241,
                "title": "one-liners-in-python",
                "content": "**Solution 1: *Recursive, take any number as first***\\n\\nTake any number as the first number and append any permutation of the other numbers.\\n\\n    def permute(self, nums):\\n        return [[n] + p\\n                for i, n in enumerate(nums)\\n                for p in self.permute(nums[:i] + nums[i+1:])] or [[]]\\n\\n---\\n\\n**Solution 2: *Recursive, insert first number anywhere***\\n\\nInsert the first number anywhere in any permutation of the remaining numbers.\\n\\n    def permute(self, nums):\\n        return nums and [p[:i] + [nums[0]] + p[i:]\\n                         for p in self.permute(nums[1:])\\n                         for i in range(len(nums))] or [[]]\\n\\n---\\n\\n**Solution 3: *Reduce, insert next number anywhere***\\n\\nUse `reduce` to insert the next number anywhere in the already built permutations.\\n\\n    def permute(self, nums):\\n        return reduce(lambda P, n: [p[:i] + [n] + p[i:]\\n                                    for p in P for i in range(len(p)+1)],\\n                      nums, [[]])\\n\\n---\\n\\n**Solution 4: *Using the library***\\n\\n    def permute(self, nums):\\n        return list(itertools.permutations(nums))\\n\\nThat returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists:\\n\\n    def permute(self, nums):\\n        return map(list, itertools.permutations(nums))",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1: *Recursive, take any number as first***\\n\\nTake any number as the first number and append any permutation of the other numbers.\\n\\n    def permute(self, nums):\\n        return [[n] + p\\n                for i, n in enumerate(nums)\\n                for p in self.permute(nums[:i] + nums[i+1:])] or [[]]\\n\\n---\\n\\n**Solution 2: *Recursive, insert first number anywhere***\\n\\nInsert the first number anywhere in any permutation of the remaining numbers.\\n\\n    def permute(self, nums):\\n        return nums and [p[:i] + [nums[0]] + p[i:]\\n                         for p in self.permute(nums[1:])\\n                         for i in range(len(nums))] or [[]]\\n\\n---\\n\\n**Solution 3: *Reduce, insert next number anywhere***\\n\\nUse `reduce` to insert the next number anywhere in the already built permutations.\\n\\n    def permute(self, nums):\\n        return reduce(lambda P, n: [p[:i] + [n] + p[i:]\\n                                    for p in P for i in range(len(p)+1)],\\n                      nums, [[]])\\n\\n---\\n\\n**Solution 4: *Using the library***\\n\\n    def permute(self, nums):\\n        return list(itertools.permutations(nums))\\n\\nThat returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists:\\n\\n    def permute(self, nums):\\n        return map(list, itertools.permutations(nums))",
                "codeTag": "Python3"
            },
            {
                "id": 179932,
                "title": "beats-100-java-with-explanations",
                "content": "**Thought**\\nWe think about a searching tree when we apply Backtracking.\\n```\\ne.g.[1, 2, 3]\\n    1 -2 -3\\n      -3 -2\\n\\n    2 -1 -3\\n      -3 -1\\n\\n    3 -1 -2\\n      -2 -1\\n```\\nIf we exhausted the current branch, `currResult.size() == nums.length`, we will backtrack.\\nTo make sure each element is used once, we establish `boolean[] used`.\\n**Code**\\n```\\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i])\\n                continue;\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\ne.g.[1, 2, 3]\\n    1 -2 -3\\n      -3 -2\\n\\n    2 -1 -3\\n      -3 -1\\n\\n    3 -1 -2\\n      -2 -1\\n```\n```\\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i])\\n                continue;\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685868,
                "title": "dfs-backtracking-python-java-javascript-picture",
                "content": "Classic combinatorial search problem, we can solve it using 3-step system \\n\\n1. Identify states\\nWhat state do we need to know whether we have reached a solution (and using it to construct a solution if the problem asks for it).\\nWe need a state to keep track of the list of letters we have chosen for the current permutation\\n\\nWhat state do we need to decide which child nodes should be visited next and which ones should be pruned?\\nWe have to know what are the letters left that we can still use (since each letter can only be used once).\\n\\n2. Draw the State-space Tree\\n![](https://algomonster.s3.us-east-2.amazonaws.com/dfs_intro/arrangement.png)\\n\\n3. DFS on the State-space tree\\nUsing the [backtracking template](https://algo.monster/problems/backtracking) as basis, we add the two states we identified in step 1:\\n\\nA list to represent permutation constructed so far, path\\nA list to record which letters are already used, used, used[i] == true means ith letter in the origin list has been used.\\n\\nImplementation in 3 languages:\\n\\nPython\\n```\\nclass Solution:\\n    def permute(self, l: List[int]) -> List[List[int]]:\\n        def dfs(path, used, res):\\n            if len(path) == len(l):\\n                res.append(path[:]) # note [:] make a deep copy since otherwise we\\'d be append the same list over and over\\n                return\\n\\n            for i, letter in enumerate(l):\\n                # skip used letters\\n                if used[i]:\\n                    continue\\n                # add letter to permutation, mark letter as used\\n                path.append(letter)\\n                used[i] = True\\n                dfs(path, used, res)\\n                # remove letter from permutation, mark letter as unused\\n                path.pop()\\n                used[i] = False\\n            \\n        res = []\\n        dfs([], [False] * len(l), res)\\n        return res\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] letters) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        dfs(new ArrayList<>(), new boolean[letters.length], res, letters);\\n        return res;\\n    }\\n\\n    private static void dfs(List<Integer> path, boolean[] used, List<List<Integer>> res, int[] letters) {\\n        if (path.size() == used.length) {\\n            // make a deep copy since otherwise we\\'d be append the same list over and over\\n            res.add(new ArrayList<Integer>(path));\\n            return;\\n        }\\n\\n        for (int i = 0; i < used.length; i++) {\\n            // skip used letters\\n            if (used[i]) continue;\\n            // add letter to permutation, mark letter as used\\n            path.add(letters[i]);\\n            used[i] = true;\\n            dfs(path, used, res, letters);\\n            // remove letter from permutation, mark letter as unused\\n            path.remove(path.size() - 1);\\n            used[i] = false;\\n        }\\n    }    \\n}\\n```\\n\\nJavascript\\n```\\nvar permute = function(letters) {\\n    let res = [];\\n    dfs(letters, [], Array(letters.length).fill(false), res);\\n    return res;\\n}\\n\\nfunction dfs(letters, path, used, res) {\\n    if (path.length == letters.length) {\\n        // make a deep copy since otherwise we\\'d be append the same list over and over\\n        res.push(Array.from(path));\\n        return;\\n    }\\n    for (let i = 0; i < letters.length; i++) {\\n        // skip used letters\\n        if (used[i]) continue;\\n        // add letter to permutation, mark letter as used\\n        path.push(letters[i]);\\n        used[i] = true;\\n        dfs(letters, path, used, res);\\n        // remove letter from permutation, mark letter as unused\\n        path.pop();\\n        used[i] = false;\\n    }\\n}\\n```\\n\\nPlease upvote if you find it useful. And learn more about backtracking/dfs here https://algo.monster/problems/backtracking",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, l: List[int]) -> List[List[int]]:\\n        def dfs(path, used, res):\\n            if len(path) == len(l):\\n                res.append(path[:]) # note [:] make a deep copy since otherwise we\\'d be append the same list over and over\\n                return\\n\\n            for i, letter in enumerate(l):\\n                # skip used letters\\n                if used[i]:\\n                    continue\\n                # add letter to permutation, mark letter as used\\n                path.append(letter)\\n                used[i] = True\\n                dfs(path, used, res)\\n                # remove letter from permutation, mark letter as unused\\n                path.pop()\\n                used[i] = False\\n            \\n        res = []\\n        dfs([], [False] * len(l), res)\\n        return res\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] letters) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        dfs(new ArrayList<>(), new boolean[letters.length], res, letters);\\n        return res;\\n    }\\n\\n    private static void dfs(List<Integer> path, boolean[] used, List<List<Integer>> res, int[] letters) {\\n        if (path.size() == used.length) {\\n            // make a deep copy since otherwise we\\'d be append the same list over and over\\n            res.add(new ArrayList<Integer>(path));\\n            return;\\n        }\\n\\n        for (int i = 0; i < used.length; i++) {\\n            // skip used letters\\n            if (used[i]) continue;\\n            // add letter to permutation, mark letter as used\\n            path.add(letters[i]);\\n            used[i] = true;\\n            dfs(path, used, res, letters);\\n            // remove letter from permutation, mark letter as unused\\n            path.remove(path.size() - 1);\\n            used[i] = false;\\n        }\\n    }    \\n}\\n```\n```\\nvar permute = function(letters) {\\n    let res = [];\\n    dfs(letters, [], Array(letters.length).fill(false), res);\\n    return res;\\n}\\n\\nfunction dfs(letters, path, used, res) {\\n    if (path.length == letters.length) {\\n        // make a deep copy since otherwise we\\'d be append the same list over and over\\n        res.push(Array.from(path));\\n        return;\\n    }\\n    for (let i = 0; i < letters.length; i++) {\\n        // skip used letters\\n        if (used[i]) continue;\\n        // add letter to permutation, mark letter as used\\n        path.push(letters[i]);\\n        used[i] = true;\\n        dfs(letters, path, used, res);\\n        // remove letter from permutation, mark letter as unused\\n        path.pop();\\n        used[i] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360280,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Level0: []\\n    level1: [1]                  [2]              [3]\\n    level2: [1,2]    [1,3]       [2,1] [2,3]      [3,1] [3,2]\\n    level3: [1,2,3]  [1,3,2]     [2,1,3][2,3,1]   [3,1,2][3,2,1]          \\n    \\n    \"\"\"\\n    \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        visited = set()\\n        res = []\\n        self.backtracking(res,visited,[],nums)\\n        return res\\n    def backtracking(self,res,visited,subset,nums):\\n        if len(subset) == len(nums):\\n            res.append(subset)\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                visited.add(i)\\n                self.backtracking(res,visited,subset+[nums[i]],nums)\\n                visited.remove(i)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Level0: []\\n    level1: [1]                  [2]              [3]\\n    level2: [1,2]    [1,3]       [2,1] [2,3]      [3,1] [3,2]\\n    level3: [1,2,3]  [1,3,2]     [2,1,3][2,3,1]   [3,1,2][3,2,1]          \\n    \\n    \"\"\"\\n    \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        visited = set()\\n        res = []\\n        self.backtracking(res,visited,[],nums)\\n        return res\\n    def backtracking(self,res,visited,subset,nums):\\n        if len(subset) == len(nums):\\n            res.append(subset)\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                visited.add(i)\\n                self.backtracking(res,visited,subset+[nums[i]],nums)\\n                visited.remove(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18436,
                "title": "java-clean-code-two-recursive-solutions",
                "content": "**Bottom up? approach - 280ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.length == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\n    \\t\\tcollectPermutations(nums, 0, new ArrayList<>(), permutations);\\n    \\t\\treturn permutations;\\n        }\\n    \\n    \\tprivate void collectPermutations(int[] nums, int start, List<Integer> permutation,\\n     \\t\\t\\tList<List<Integer>>  permutations) {\\n    \\t\\t\\n    \\t\\tif (permutation.size() == nums.length) {\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\n    \\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\tnewPermutation.add(i, nums[start]);\\n    \\t\\t\\tcollectPermutations(nums, start + 1, newPermutation, permutations);\\n    \\t\\t}\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n\\n    start = 0, permutation = []\\n    i = 0, newPermutation = [1]\\n    \\tstart = 1, permutation = [1]\\n    \\ti = 0, newPermutation = [2, 1]\\n    \\t\\tstart = 2, permutation = [2, 1]\\n    \\t\\ti = 0, newPermutation = [3, 2, 1]\\n    \\t\\ti = 1, newPermutation = [2, 3, 1]\\n    \\t\\ti = 2, newPermutation = [2, 1, 3]\\n    \\ti = 1, newPermutation = [1, 2]\\n    \\t\\tstart = 2, permutation = [1, 2]\\n    \\t\\ti = 0, newPermutation = [3, 1, 2]\\n    \\t\\ti = 1, newPermutation = [1, 3, 2]\\n    \\t\\ti = 2, newPermutation = [1, 2, 3]\\n\\n**Base case and build approach - 524ms**\\n\\n    public class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\treturn permute(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n       }\\n    \\n    \\tprivate List<List<Integer>> permute(List<Integer> nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.size() == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\tif (nums.size() == 1) {\\n    \\t\\t\\tList<Integer> permutation = new ArrayList<>();\\n    \\t\\t\\tpermutation.add(nums.get(0));\\n    \\t\\t\\tpermutations.add(permutation);\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tList<List<Integer>> smallPermutations = permute(nums.subList(1, nums.size()));\\n    \\t\\tint first = nums.get(0);\\n    \\t\\tfor(List<Integer> permutation : smallPermutations) {\\n    \\t\\t\\tfor (int i = 0; i <= permutation.size(); i++) {\\n    \\t\\t\\t\\tList<Integer> newPermutation = new ArrayList<>(permutation);\\n    \\t\\t\\t\\tnewPermutation.add(i, first);\\n    \\t\\t\\t\\tpermutations.add(newPermutation);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn permutations;\\n    \\t}\\n    }\\n\\n***Code flow***\\n\\n    nums = 1,2,3\\n    \\n    smallPermutations(2, 3)\\n    \\tsmallPermutations(3)\\n    \\t\\treturn [[3]]\\n    \\tfirst = 2\\n     \\t\\tpermutation = [3]\\n    \\t\\t\\ti = 0, newPermutation = [2, 3]\\n    \\t\\t\\ti = 1, newPermutation = [3, 2]\\n    \\treturn [[2, 3], [3, 2]]\\n    first = 1\\n     \\tpermutation = [2, 3]\\n    \\t\\ti = 0, newPermutation = [1, 2, 3]\\n    \\t\\ti = 1, newPermutation = [2, 1, 3]\\n    \\t\\ti = 2, newPermutation = [2, 3, 1]\\n     \\tpermutation = [3, 2]\\n    \\t\\ti = 0, newPermutation = [1, 3, 2]\\n    \\t\\ti = 1, newPermutation = [3, 1, 2]\\n    \\t\\ti = 2, newPermutation = [3, 2, 1]",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public List<List<Integer>> permute(int[] nums) {\\n    \\t\\tList<List<Integer>> permutations = new ArrayList<>();\\n    \\t\\tif (nums.length == 0) {\\n    \\t\\t\\treturn permutations;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1257633,
                "title": "backtracking-solution-c-easy-to-understand-with-explanation",
                "content": "\\nSuppose if give string is ABC then recursive tree like this\\n![image](https://assets.leetcode.com/users/images/0865f0cf-1f8a-4164-9543-4bf13aebcb59_1623088635.478572.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    // Backtracking\\n    void permutation(vector<int> &nums,int i,int n){\\n        if(i==n){\\n            result.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j=i;j<=n;j++){\\n            swap( nums[i],nums[j]);\\n            permutation(nums,i+1,n);\\n            swap( nums[i],nums[j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        permutation(nums,0,nums.size()-1);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    // Backtracking\\n    void permutation(vector<int> &nums,int i,int n){\\n        if(i==n){\\n            result.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j=i;j<=n;j++){\\n            swap( nums[i],nums[j]);\\n            permutation(nums,i+1,n);\\n            swap( nums[i],nums[j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        permutation(nums,0,nums.size()-1);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18360,
                "title": "c-backtracking-and-nextpermutation",
                "content": "**Backtracking**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                swap(nums[i], nums[j]);\\n                permute(nums, i + 1, perms);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Next Permutation**\\n\\nBesides backtracking, you may also solve this problem using [Next Permutation](https://leetcode.com/problems/next-permutation/): computing the next permutation and add it to the result until the permutation becomes the original array (`n!` times since all digits are distinct).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        for (int i = 0, n = factorial(nums.size()); i < n; i++) {\\n            perms.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        return perms;\\n    }\\nprivate:\\n    int factorial(int n) {\\n        int f = 1;\\n        while (n > 1) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n    \\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\nThe above code can also be applied to [Permutations II](https://leetcode.com/problems/permutations-ii/) since the `nextPermutation` is able to handle duplicates.",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                swap(nums[i], nums[j]);\\n                permute(nums, i + 1, perms);\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> perms;\\n        for (int i = 0, n = factorial(nums.size()); i < n; i++) {\\n            perms.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        return perms;\\n    }\\nprivate:\\n    int factorial(int n) {\\n        int f = 1;\\n        while (n > 1) {\\n            f *= n--;\\n        }\\n        return f;\\n    }\\n    \\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18255,
                "title": "share-my-short-iterative-java-solution",
                "content": "    public List<List<Integer>> permute(int[] num) {\\n        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        for (int n : num) {\\n            int size = res.size();\\n            for (; size > 0; size--) {\\n                List<Integer> r = res.pollFirst();\\n                for (int i = 0; i <= r.size(); i++) {\\n                    List<Integer> t = new ArrayList<Integer>(r);\\n                    t.add(i, n);\\n                    res.add(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> permute(int[] num) {\\n        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        for (int n : num) {\\n            int size = res.size();\\n            for (; size > 0; size--) {\\n                List<Integer> r = res.pollFirst();\\n                for (int i = 0; i <= r.size(); i++) {\\n                    List<Integer> t = new ArrayList<Integer>(r);\\n                    t.add(i, n);\\n                    res.add(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 551252,
                "title": "short-recursive-python-solution",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        if len(nums) == 1:\\n            return [nums]\\n        result = []\\n        for i in range(len(nums)):\\n            others = nums[:i] + nums[i+1:]\\n            other_permutations = self.permute(others)\\n            for permutation in other_permutations:\\n                result.append([nums[i]] + permutation)\\n        return result\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        if len(nums) == 1:\\n            return [nums]\\n        result = []\\n        for i in range(len(nums)):\\n            others = nums[:i] + nums[i+1:]\\n            other_permutations = self.permute(others)\\n            for permutation in other_permutations:\\n                result.append([nums[i]] + permutation)\\n        return result\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3378574,
                "title": "beats-100-simple-swapping-and-backtracking",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n# Approach\\n**Not need of an extra array, just use swap on every element.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N!)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    void solve(vector<int>&a,int idx)\\n    {\\n        if(idx >= a.size())\\n        {\\n            v.push_back(a);\\n            return;\\n        }\\n        for(int i = idx; i < a.size(); i++)\\n        {\\n            swap(a[i],a[idx]);\\n            solve(a,idx+1);\\n            swap(a[i],a[idx]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& a) {\\n        vector<int>p;\\n        solve(a,0);\\n        return v;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/169ef9be-319d-4bd7-8cc2-52bb58c7ef9f_1680602007.8632011.png)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    void solve(vector<int>&a,int idx)\\n    {\\n        if(idx >= a.size())\\n        {\\n            v.push_back(a);\\n            return;\\n        }\\n        for(int i = idx; i < a.size(); i++)\\n        {\\n            swap(a[i],a[idx]);\\n            solve(a,idx+1);\\n            swap(a[i],a[idx]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& a) {\\n        vector<int>p;\\n        solve(a,0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293217,
                "title": "javascript-backtracking-with-explanation-beats-99",
                "content": "Here is my simple recursive solution. I\\'ve provided many details to why certain things are done which may be more obvious to others. Credits to user [isaac3](https://leetcode.com/issac3/), as this is inspired by this [post](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)) outlining a general approach to backtracking.\\n\\n## Thought Process\\nFirst, it helps to recognize that this is problem can be solved with recursion. The key buzzwords that should set off *recursion* in your head as viable approaches include: combinations, permutations, subsets, and all possible X\\'s.\\nBecause I think visually, it helps me to draw a diagram of a tree and walk through the different recursive calls to get an intuition for what tools I will need. With our intitial input, we break down the different way we split (each branch) at each recursive level (rows). The array to our left represents what we have *taken* as `temp` , and the right array represents what is *left* to be taken as `nums`\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinitial input\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n## Visualize\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[],[1,2,3]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/         |             \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t[1],[2,3]        [2],[1,3]       [3],[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\t/    \\\\                /    \\\\               /  \\\\\\n\\t\\t\\t\\t\\t[1,2],[3]   [1,3],[2]   [2,1],[3]  [2,3],[1]  [3,1],[2]   [3,2],[1]\\n\\t\\t\\t\\t/                  /           /             \\\\         \\\\           \\\\\\n\\t\\t\\t[1,2,3],[]    [1,3,2],[]        [2,1,3],[]    [2,3,1],[]    [3,1,2],[]  [3,2,1],[]\\nSee in the chart above, the bottom row actually depicts the result that we want:\\n```\\n[ [ 1, 2, 3 ],\\n  [ 1, 3, 2 ],\\n  [ 2, 1, 3 ],\\n  [ 2, 3, 1 ],\\n  [ 3, 1, 2 ],\\n  [ 3, 2, 1 ] ]\\n  ```\\n\\t\\t\\t\\nAs you see at each recursive level, we need to *iterate* over the nums to select different nums to pick out. It\\'s also important that we leave in the rest of the nums so we can pick them later. This **iteration** is a key component we will use to build our algorithm.\\n```\\nfor (var i = 0; i < nums.length; i++) {\\n// pick a different number\\n// do some recursive call\\n}\\n```\\n\\nCan you find the **base case** here? Notice that all the `nums` (right arrays) are all empty. We\\'ll use that as an indicator that we are done.\\n```\\nif (!nums.length) {\\n// we found a solution!\\n// return\\n}\\n```\\n\\n## Putting the Algorithm Together\\n\\n```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = function(nums) {\\n  const result = [];\\n  const temp = [];\\n  // we are using a common strategy to initialize an \\'answer\\' object, and pass it into\\n  // a recursion helper to modify the values. Sometimes it helps to separate this because\\n  // there are times you will want to have conditionals or a for loop in the top level code\\n  // before you call a recursive function.\\n  findPermutations(temp, nums, result);\\n  return result;\\n};\\n\\nconst findPermutations = (temp, nums, result) => {\\n  if (!nums.length) {\\n   // Here it is important to call concat(), just a fancy way of copying the original array.\\n   // See what happens when you remove concat, things will go crazy because you are \\n   // modifying an object that is referenced elsewhere!\\n    result.push(temp.concat());\\n    return;\\n  }\\n\\n  for (var i = 0; i < nums.length; i++) {\\n\\tconst newNum = nums[i];\\n\\t// we\\'ve picked our new number to add, so add it to our \"picked\" array called temp\\n    temp.push(newNum);\\n\\t// remember, in the first iteration, after picking 1, we need to pass in [2, 3] as the numbers left.\\n    nums.splice(i, 1);\\n    findPermutations(temp, nums, result);\\n\\t// Remember to \"reset\" our temp and nums array before our next iteration, where we pick the 2, and leave [1,3] \\n    temp.pop();\\n    nums.splice(i, 0, newNum);\\n  }\\n};\\n```\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\n[ [ 1, 2, 3 ],\\n  [ 1, 3, 2 ],\\n  [ 2, 1, 3 ],\\n  [ 2, 3, 1 ],\\n  [ 3, 1, 2 ],\\n  [ 3, 2, 1 ] ]\\n  ```\n```\\nfor (var i = 0; i < nums.length; i++) {\\n// pick a different number\\n// do some recursive call\\n}\\n```\n```\\nif (!nums.length) {\\n// we found a solution!\\n// return\\n}\\n```\n```\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = function(nums) {\\n  const result = [];\\n  const temp = [];\\n  // we are using a common strategy to initialize an \\'answer\\' object, and pass it into\\n  // a recursion helper to modify the values. Sometimes it helps to separate this because\\n  // there are times you will want to have conditionals or a for loop in the top level code\\n  // before you call a recursive function.\\n  findPermutations(temp, nums, result);\\n  return result;\\n};\\n\\nconst findPermutations = (temp, nums, result) => {\\n  if (!nums.length) {\\n   // Here it is important to call concat(), just a fancy way of copying the original array.\\n   // See what happens when you remove concat, things will go crazy because you are \\n   // modifying an object that is referenced elsewhere!\\n    result.push(temp.concat());\\n    return;\\n  }\\n\\n  for (var i = 0; i < nums.length; i++) {\\n\\tconst newNum = nums[i];\\n\\t// we\\'ve picked our new number to add, so add it to our \"picked\" array called temp\\n    temp.push(newNum);\\n\\t// remember, in the first iteration, after picking 1, we need to pass in [2, 3] as the numbers left.\\n    nums.splice(i, 1);\\n    findPermutations(temp, nums, result);\\n\\t// Remember to \"reset\" our temp and nums array before our next iteration, where we pick the 2, and leave [1,3] \\n    temp.pop();\\n    nums.splice(i, 0, newNum);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18282,
                "title": "backtracking-clean-c-recursion-with-detailed-explanation",
                "content": "The idea is much like the insertion sort. We start with only the first number, and pick next number from the rest of array, insert it to the front or back position of the first number, and pick the third number, insert it to front or mid or back position of the `[first, second]` array, and so on, until no element left.\\nFor example, given array `[1,2,3]`.\\nFirst, we have `[1]` as array to be inserted, and `[2,3]` remain;\\nnext number is `2`, we insert it to the front or back of `[1]`, which become `[1,2]` and `[2,1]`, with `[3]` remain.\\nThen we pick number `3`, insert it to `[1,2]` and `[2,1]`,\\nInsert to front position, we get\\n  `[3,1,2]`,\\n  `[3,2,1]`\\nInsert to mid position, we get\\n  `[1,3,2]`,\\n  `[2,3,1]`,\\nInsert to back, we get\\n  `[1,2,3]`,\\n  `[2,1,3]`,\\nand no element left in remain array, finish.\\nHere is my code,\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>vec;\\n        DFS(nums, 0, vec, res);\\n        return res;\\n    }\\n    \\n    void DFS(vector<int>& nums, int pos, vector<int>& vec, vector<vector<int>>& res){\\n        if(pos == nums.size()){\\n            res.push_back(vec);\\n            return;\\n        }\\n        for(int i = 0; i <= vec.size(); i++){\\n            vec.insert(vec.begin() + i, nums[pos]);\\n            DFS(nums, pos + 1, vec, res);\\n            vec.erase(vec.begin() + i);\\n        }\\n        return;\\n    }\\n};\\n```\\n***\\n*Update(9/2/2017):* No more `insert` and `erase`, my updated solution with `swap`.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        DFS(res, nums, 0);\\n        return res;        \\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(pos == nums.size() - 1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            swap(nums[pos], nums[i]);\\n            DFS(res, nums, pos + 1);\\n            swap(nums[pos], nums[i]);\\n        }\\n    }\\n};\\n```\\n***\\nSimilar swap [solution](https://discuss.leetcode.com/topic/101970/13-lines-c-backtracking) for [Permutations II](https://leetcode.com/problems/permutations-ii/description/).",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>vec;\\n        DFS(nums, 0, vec, res);\\n        return res;\\n    }\\n    \\n    void DFS(vector<int>& nums, int pos, vector<int>& vec, vector<vector<int>>& res){\\n        if(pos == nums.size()){\\n            res.push_back(vec);\\n            return;\\n        }\\n        for(int i = 0; i <= vec.size(); i++){\\n            vec.insert(vec.begin() + i, nums[pos]);\\n            DFS(nums, pos + 1, vec, res);\\n            vec.erase(vec.begin() + i);\\n        }\\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        DFS(res, nums, 0);\\n        return res;        \\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(pos == nums.size() - 1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            swap(nums[pos], nums[i]);\\n            DFS(res, nums, pos + 1);\\n            swap(nums[pos], nums[i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18462,
                "title": "share-my-three-different-solutions",
                "content": "    // method 1: standard backtracing solution\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        permutation(num, 0, ans);\\n        return ans;\\n    }\\n    \\n    void permutation(vector<int> &num, int begin, vector<vector<int> > &ans) {\\n        if (begin >= num.size()) {\\n            ans.push_back(num);\\n            return;\\n        }\\n        \\n        // every number chosen to be the begin once\\n        for (int i = begin; i < num.size(); ++i) {\\n            swap(num[begin], num[i]);\\n            permutation(num, begin+1, ans);\\n            swap(num[begin], num[i]);\\n        }\\n    }\\n    \\n    // method 2: using next_permutation to iterate all the permutaions\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        sort(num.begin(), num.end());\\n        ans.push_back(num);\\n        \\n        while(next_permutation(num.begin(), num.end()))\\n            ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    // method 3: recursive dfs\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        dfs(num, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<int> &num, vector<vector<int>> &ans) {\\n        if (num.size() == 1) {\\n            vector<int> tmp(num.begin(), num.end());\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        vector<vector<int> > ans1;\\n        vector<int> num1(num.begin()+1, num.end());\\n        dfs(num1, ans);\\n        \\n        for(int i = 0; i < ans.size(); ++i) {\\n            for(int j = 0; j <= ans[i].size(); ++j) {\\n                vector<int> tmp = ans[i];\\n                tmp.insert(tmp.begin()+j, num[0]);\\n                ans1.push_back(tmp);\\n            }\\n        }\\n        \\n        ans = ans1;\\n    }",
                "solutionTags": [],
                "code": "    // method 1: standard backtracing solution\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        permutation(num, 0, ans);\\n        return ans;\\n    }\\n    \\n    void permutation(vector<int> &num, int begin, vector<vector<int> > &ans) {\\n        if (begin >= num.size()) {\\n            ans.push_back(num);\\n            return;\\n        }\\n        \\n        // every number chosen to be the begin once\\n        for (int i = begin; i < num.size(); ++i) {\\n            swap(num[begin], num[i]);\\n            permutation(num, begin+1, ans);\\n            swap(num[begin], num[i]);\\n        }\\n    }\\n    \\n    // method 2: using next_permutation to iterate all the permutaions\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        sort(num.begin(), num.end());\\n        ans.push_back(num);\\n        \\n        while(next_permutation(num.begin(), num.end()))\\n            ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    // method 3: recursive dfs\\n    vector<vector<int> > permute(vector<int> &num) {\\n        vector<vector<int> > ans;\\n        dfs(num, ans);\\n        return ans;\\n    }\\n    \\n    void dfs(vector<int> &num, vector<vector<int>> &ans) {\\n        if (num.size() == 1) {\\n            vector<int> tmp(num.begin(), num.end());\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        \\n        vector<vector<int> > ans1;\\n        vector<int> num1(num.begin()+1, num.end());\\n        dfs(num1, ans);\\n        \\n        for(int i = 0; i < ans.size(); ++i) {\\n            for(int j = 0; j <= ans[i].size(); ++j) {\\n                vector<int> tmp = ans[i];\\n                tmp.insert(tmp.begin()+j, num[0]);\\n                ans1.push_back(tmp);\\n            }\\n        }\\n        \\n        ans = ans1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 301437,
                "title": "a-more-general-approach-to-backtracking-questions-in-python",
                "content": "Inspired by @issac3 , I write a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum,Generate Parentheses, Partition Equal Subset Sum,Letter Tile Possibilities)\\n  Thansks for [A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)\\n](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))\\n\\nI use hashmap(collections.Counter)  to make  code more easy and general.\\n\\nPermutations : https://leetcode.com/problems/permutations/\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\nsame code to pass two problems:\\n  ```python\\n    def DFS(self,end_len,path,recoder):\\n        if len(path) == end_len:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0:\\n                    recoder[key] -= 1\\n                    self.DFS(end_len,path+[key],recoder)\\n                    recoder[key] += 1\\n\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n    # def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        recoder = collections.Counter(nums)\\n        self.res = []\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\\n\\nSubsets : https://leetcode.com/problems/subsets/\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\nsame code to pass two problems:\\n\\n ```python\\n    def DFS(self,end_len,path,recoder):\\n        self.res.append(path)\\n        for key in recoder: \\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                self.DFS(end_len,path+[key],recoder_copy)\\n    \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t#def subsets(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        import copy\\n        recoder = collections.Counter(nums)\\n        self.res =[]\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\\n\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target-key >= 0 :\\n                    recoder_copy = copy.copy(recoder)\\n                    self.DFS(target-key,path+[key],recoder_copy)\\n                    recoder[key] =0\\n            \\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\\n\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target - key >= 0:   \\n                    recoder_copy = copy.copy(recoder)\\n                    recoder[key] = 0\\n                    recoder_copy[key] -= 1\\n                    self.DFS(target - key,path+[key],recoder_copy)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\\nGenerate Parentheses : https://leetcode.com/problems/generate-parentheses/\\n```python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        import copy\\n        cnt = {\\'l\\':n,\\'r\\':n}\\n        res = []\\n        def DFS(record,open,path):\\n            if len(path) == 2*n:\\n                res.append(path)\\n                return\\n            if record[\\'l\\']>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'l\\'] -= 1\\n                DFS(new_record,open+1,path+\\'(\\')\\n                \\n            if record[\\'r\\']>0 and open>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'r\\'] -= 1\\n                DFS(new_record,open-1,path+\\')\\')\\n        DFS(cnt,0,\\'\\')\\n        return res\\n```\\nPartition Equal Subset Sum:https://leetcode.com/problems/partition-equal-subset-sum/\\n```python\\n   def DFS(self,target,recoder):\\n        if target == 0:\\n            return True\\n        if target < 0:\\n            return False\\n        \\n        for key in recoder:\\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                if self.DFS(target-key,recoder_copy):\\n                    return True\\n        return False\\n    \\n    def canPartition(self, nums: List[int]) -> bool:\\n        import collections\\n        import copy\\n        if not nums:\\n            return True\\n        sumNum = sum(nums)\\n        if sumNum&1:\\n            return False\\n\\n        halfSum = sumNum//2\\n        recoder = collections.Counter(nums)\\n        return self.DFS(halfSum,recoder)\\n```\\n\\nLetter Tile Possibilities:\\n```python\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 1\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)-1\\n    \\n    # same idea\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 0\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    total+=1\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)\\n```\\n\\nI think this post deserves some upvotes!  : ) hope you enjoy it!",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\n    def DFS(self,end_len,path,recoder):\\n        if len(path) == end_len:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0:\\n                    recoder[key] -= 1\\n                    self.DFS(end_len,path+[key],recoder)\\n                    recoder[key] += 1\\n\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n    # def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        recoder = collections.Counter(nums)\\n        self.res = []\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,end_len,path,recoder):\\n        self.res.append(path)\\n        for key in recoder: \\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                self.DFS(end_len,path+[key],recoder_copy)\\n    \\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n\\t#def subsets(self, nums: List[int]) -> List[List[int]]:\\n        import collections\\n        import copy\\n        recoder = collections.Counter(nums)\\n        self.res =[]\\n        self.DFS(len(nums),[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target-key >= 0 :\\n                    recoder_copy = copy.copy(recoder)\\n                    self.DFS(target-key,path+[key],recoder_copy)\\n                    recoder[key] =0\\n            \\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\n```python\\n    def DFS(self,target,path,recoder):\\n        if target == 0:\\n            self.res.append(path)\\n        else:\\n            for key in recoder:\\n                if recoder[key] > 0 and target - key >= 0:   \\n                    recoder_copy = copy.copy(recoder)\\n                    recoder[key] = 0\\n                    recoder_copy[key] -= 1\\n                    self.DFS(target - key,path+[key],recoder_copy)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        import collections \\n        import copy\\n        recoder = collections.Counter(candidates)\\n        self.res = []\\n        self.DFS(target,[],recoder)\\n        return self.res\\n```\n```python\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        import copy\\n        cnt = {\\'l\\':n,\\'r\\':n}\\n        res = []\\n        def DFS(record,open,path):\\n            if len(path) == 2*n:\\n                res.append(path)\\n                return\\n            if record[\\'l\\']>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'l\\'] -= 1\\n                DFS(new_record,open+1,path+\\'(\\')\\n                \\n            if record[\\'r\\']>0 and open>0:\\n                new_record = copy.copy(record) \\n                new_record[\\'r\\'] -= 1\\n                DFS(new_record,open-1,path+\\')\\')\\n        DFS(cnt,0,\\'\\')\\n        return res\\n```\n```python\\n   def DFS(self,target,recoder):\\n        if target == 0:\\n            return True\\n        if target < 0:\\n            return False\\n        \\n        for key in recoder:\\n            if recoder[key] > 0:\\n                recoder_copy = copy.copy(recoder)\\n                recoder[key] = 0\\n                recoder_copy[key] -= 1\\n                if self.DFS(target-key,recoder_copy):\\n                    return True\\n        return False\\n    \\n    def canPartition(self, nums: List[int]) -> bool:\\n        import collections\\n        import copy\\n        if not nums:\\n            return True\\n        sumNum = sum(nums)\\n        if sumNum&1:\\n            return False\\n\\n        halfSum = sumNum//2\\n        recoder = collections.Counter(nums)\\n        return self.DFS(halfSum,recoder)\\n```\n```python\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 1\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)-1\\n    \\n    # same idea\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        import collections\\n        cnt = collections.Counter(tiles) \\n        \\n        def DFS(cnt):\\n            total = 0\\n            for key in cnt:\\n                if cnt[key] > 0:\\n                    total+=1\\n                    cnt[key] -= 1\\n                    total += DFS(cnt)\\n                    cnt[key] += 1\\n            return total\\n\\n        return DFS(cnt)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3850714,
                "title": "100-fast-image-video-explanation-backtracking-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every number all the positions are available if it is not filled so we can put anywhere and recursively call and generate.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/XUQ0iZ94CGg\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. Define a recursive function `solve` that generates permutations using backtracking. This function takes three parameters: `nums` (the original array of integers), `per` (the current permutation being constructed), and `c` (the current index indicating which element of `nums` is being considered).\\n\\n2. In the `solve` function, if the current index `c` reaches the length of `nums`, it means we have completed constructing one permutation. Therefore, we add the current permutation `per` to the `ans` vector.\\n\\n3. If the current index `c` is not equal to the length of `nums`, we continue generating permutations. For each position `i` in the current permutation `per`, if `per[i]` is equal to 11 (a marker used to indicate that the position is available), we set `per[i]` to the element at index `c` in the `nums` array, call the `solve` function recursively with `c+1` to consider the next element in `nums`, and then reset `per[i]` back to 11 after the recursive call (backtracking step).\\n\\n4. In the `permute` function, initialize a vector `per` with 11 as a placeholder value of the same length as `nums`. This vector will be used to construct the permutations.\\n\\n5. Call the `solve` function with the original `nums` array, the initial permutation `per`, and the starting index `0` to generate all possible permutations.\\n\\n6. Return the resulting `ans` vector, which contains all unique permutations of the input array `nums`.\\n\\n# Complexity\\n- Time complexity:$$O(n*n!)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n!)$$ for ans vector otherwise without taking that space only $$(n)$$ per array size. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void solve(vector<int>& nums,vector<int>&per,int c){\\n        if(c==nums.size()){\\n            ans.push_back(per);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(per[i]==11){\\n                per[i]=nums[c];\\n                solve(nums,per,c+1);\\n                per[i]=11;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>per(n,11);\\n       solve(nums,per,0);\\n       return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    void solve(int[] nums, int[] per, int c) {\\n        if (c == nums.length) {\\n            List<Integer> permutation = new ArrayList<>();\\n            for (int num : per) {\\n                permutation.add(num);\\n            }\\n            ans.add(permutation);\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (per[i] == 11) {\\n                per[i] = nums[c];\\n                solve(nums, per, c + 1);\\n                per[i] = 11;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        int n = nums.length;\\n        int[] per = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            per[i] = 11;\\n        }\\n        solve(nums, per, 0);\\n        return ans;\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def permute(self, nums):\\n        def solve(nums, per, c):\\n            if c == len(nums):\\n                ans.append(list(per))\\n                return\\n            for i in range(len(nums)):\\n                if per[i] == 11:\\n                    per[i] = nums[c]\\n                    solve(nums, per, c + 1)\\n                    per[i] = 11\\n\\n        ans = []\\n        per = [11] * len(nums)\\n        solve(nums, per, 0)\\n        return ans\\n\\n```\\n# Recursive tree for same\\n![Screenshot (306).png](https://assets.leetcode.com/users/images/fc2ba42b-7291-4c76-92de-753b423bbd03_1690949987.7946765.png)\\n\\n# upvote if you understood the solution .",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void solve(vector<int>& nums,vector<int>&per,int c){\\n        if(c==nums.size()){\\n            ans.push_back(per);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(per[i]==11){\\n                per[i]=nums[c];\\n                solve(nums,per,c+1);\\n                per[i]=11;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>per(n,11);\\n       solve(nums,per,0);\\n       return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    void solve(int[] nums, int[] per, int c) {\\n        if (c == nums.length) {\\n            List<Integer> permutation = new ArrayList<>();\\n            for (int num : per) {\\n                permutation.add(num);\\n            }\\n            ans.add(permutation);\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (per[i] == 11) {\\n                per[i] = nums[c];\\n                solve(nums, per, c + 1);\\n                per[i] = 11;\\n            }\\n        }\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        int n = nums.length;\\n        int[] per = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            per[i] = 11;\\n        }\\n        solve(nums, per, 0);\\n        return ans;\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def permute(self, nums):\\n        def solve(nums, per, c):\\n            if c == len(nums):\\n                ans.append(list(per))\\n                return\\n            for i in range(len(nums)):\\n                if per[i] == 11:\\n                    per[i] = nums[c]\\n                    solve(nums, per, c + 1)\\n                    per[i] = 11\\n\\n        ans = []\\n        per = [11] * len(nums)\\n        solve(nums, per, 0)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850526,
                "title": "video-100-unlocking-recursive-backtracking-for-permutations",
                "content": "# Intuition\\nWhen I first looked at this problem, I realized it was a classic case of generating all possible permutations of a given list of numbers. My initial thought was to use a recursive approach to solve it. Recursive algorithms, especially backtracking, often provide a clean and efficient solution for generating permutations. I implemented two different versions of the solution in Python, both capitalizing on recursion and backtracking.\\n\\nBoth versions achieve the same result, but v2 provides more granular control over the recursive process. Version 1 has also been implemented in other programming languages including C++, JavaScript, C#, Java, Rust, Swift, and Go, demonstrating the versatility and applicability of the recursive backtracking approach across different coding environments.\\n\\nhttps://youtu.be/Jlw0sIGdS_4\\n\\n# Approach\\nThe main approach here is to use recursion (a form of backtracking) to generate all permutations of the input list. Here\\'s a detailed step-by-step guide:\\n\\n1. **Initialize Result**: Create an empty list, `result`, to store the final permutations.\\n\\n2. **Define Backtracking Function**: Define a recursive helper function `backtrack`, which takes the remaining numbers to be permuted (`nums`) and the current permutation (`path`) as parameters.\\n   \\n   a. **Base Case**: If there are no numbers left to permute (`nums` is empty), we have a complete permutation, and we add the current `path` to the `result`.\\n   \\n   b. **Recursive Case**: For each number in `nums`, we perform the following steps:\\n      i. Add the current number to `path`.\\n      ii. Remove the current number from `nums`.\\n      iii. Recursively call `backtrack` with the updated `nums` and `path`.\\n      iv. Since we are using slicing to create new lists, there is no need to revert the changes to `nums` and `path` after the recursive call.\\n\\n3. **Start Recursion**: Call the `backtrack` function with the original `nums` and an empty `path` to start the process.\\n\\n4. **Return Result**: Return the `result` list, which will contain all the permutations.\\n\\nBy iteratively choosing one element and recursively calling the function on the remaining elements, this approach ensures that all permutations are explored.\\n\\n# Complexity\\n- Time complexity: O(n*n!) \\n  This is because for generating permutations, we perform n! operations (since there are n! permutations for n numbers) and for each operation, we spend O(n) time for slicing the list in our recursive call.\\n\\n- Space complexity: O(n*n!) \\n  This is due to the number of solutions. In the worst case, if we have \\'n\\' distinct numbers, there would be n! permutations. Since each permutation is a list of \\'n\\' numbers, the space complexity is O(n*n!).\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\\n\\n# Video for Python v2\\nhttps://youtu.be/jTCdBWNaLe8\\n\\n# Code v2\\n``` Python \\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(path, used): \\n            if len(path) == len(nums): \\n                result.append(path[:]) \\n                return \\n            for i in range(len(nums)): \\n                if not used[i]: \\n                    path.append(nums[i]) \\n                    used[i] = True \\n                    dfs(path, used) \\n                    path.pop() \\n                    used[i] = False \\n        result = [] \\n        dfs([], [False] * len(nums)) \\n        return result \\n```\\n\\n## Performance \\n| Language   | Runtime | Beats   | Memory  |\\n|------------|---------|---------|---------|\\n| C++        | 0 ms    | 100%    | 7.5 MB  |\\n| Java       | 1 ms    | 98.58%  | 44.1 MB |\\n| Rust       | 1 ms    | 87.70%  | 2.3 MB  |\\n| Go         | 2 ms    | 61.28%  | 3.1 MB  |\\n| Swift      | 8 ms    | 91.96%  | 14.4 MB |\\n| Python3 v2 | 36 ms   | 99.39%  | 16.5 MB |\\n| Python3    | 39 ms   | 98.74%  | 16.7 MB |\\n| JavaScript | 72 ms   | 55%     | 44.1 MB |\\n| C#         | 131 ms  | 94.50%  | 43.4 MB |\\n\\nThis sorted table provides a quick comparison of the runtime performance across different programming languages for the given problem.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\n``` Python \\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(path, used): \\n            if len(path) == len(nums): \\n                result.append(path[:]) \\n                return \\n            for i in range(len(nums)): \\n                if not used[i]: \\n                    path.append(nums[i]) \\n                    used[i] = True \\n                    dfs(path, used) \\n                    path.pop() \\n                    used[i] = False \\n        result = [] \\n        dfs([], [False] * len(nums)) \\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938018,
                "title": "simple-java-sol",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean [] visited = new boolean[nums.length];\\n        FindAllPermutation(res,nums, new ArrayList(),visited);\\n        return res;\\n    }\\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\\n        if(curr.size()==nums.length){\\n            res.add(new ArrayList(curr));\\n            return;\\n        }\\n\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[i]==true)\\n            continue;\\n            curr.add(nums[i]);\\n            visited[i]= true;\\n            FindAllPermutation(res,nums,curr,visited);\\n            curr.remove(curr.size()-1);\\n            visited[i]=false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        boolean [] visited = new boolean[nums.length];\\n        FindAllPermutation(res,nums, new ArrayList(),visited);\\n        return res;\\n    }\\n    void FindAllPermutation(List<List<Integer>> res, int[] nums, List<Integer> curr, boolean [] visited){\\n        if(curr.size()==nums.length){\\n            res.add(new ArrayList(curr));\\n            return;\\n        }\\n\\n        for(int i =0;i<nums.length;i++){\\n            if(visited[i]==true)\\n            continue;\\n            curr.add(nums[i]);\\n            visited[i]= true;\\n            FindAllPermutation(res,nums,curr,visited);\\n            curr.remove(curr.size()-1);\\n            visited[i]=false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992590,
                "title": "easiest-faang-method-ever",
                "content": "---\\n# ***PLEASE UPVOTE IF IT HELPS \\u2764\\uFE0F***\\n---\\n\\n# 1) Most Optimal Iterative Approach \\uD83D\\uDD25\\n\\n- Time complexity: O(n!+nlogn) ~ O(n!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            ans.emplace_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```\\n# 2) Recursive Approach but uses more space \\u26A0\\uFE0F\\n![image.png](https://assets.leetcode.com/users/images/e83c9988-b6e5-4112-a6ea-99ee252e0b71_1672753262.4502509.png)\\nhttps://www.youtube.com/watch?v=YK78FU5Ffjw&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=13\\n\\n- Time complexity: O(n!*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\\n        if(ds.size() == nums.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(!freq[i]){\\n                ds.emplace_back(nums[i]);\\n                freq[i]++;\\n                Permutations(nums, ans, ds, freq);\\n                freq[i]--;\\n                ds.pop_back();\\n            }\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        int freq[nums.size()];\\n        for(int i=0 ; i<nums.size() ; i++) \\n            freq[i]=0;\\n        Permutations(nums, ans, ds, freq);\\n        return ans;\\n    }\\n};\\n```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 3) Most Optimal Recursive Approach \\uD83D\\uDD25\\nhttps://www.youtube.com/watch?v=f2ic2Rsc9pU&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=13\\n- Time complexity: O(n!*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\\n        if(ind == nums.size()){\\n            ans.emplace_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        Permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# ***PLEASE UPVOTE IF IT HELPS \\u2764\\uFE0F***\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            ans.emplace_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void Permutations(vector<int> &nums, vector<vector<int>> &ans, vector<int> &ds, int freq[]){\\n        if(ds.size() == nums.size()){\\n            ans.emplace_back(ds);\\n            return;\\n        }\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(!freq[i]){\\n                ds.emplace_back(nums[i]);\\n                freq[i]++;\\n                Permutations(nums, ans, ds, freq);\\n                freq[i]--;\\n                ds.pop_back();\\n            }\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        int freq[nums.size()];\\n        for(int i=0 ; i<nums.size() ; i++) \\n            freq[i]=0;\\n        Permutations(nums, ans, ds, freq);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void Permutations(int ind, vector<int> &nums, vector<vector<int>> &ans){\\n        if(ind == nums.size()){\\n            ans.emplace_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        Permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816693,
                "title": "python-solution-93-utilized-the-same-logic-for-problem-39-and-40-with-illustration",
                "content": "It uses the same backtracking algorithm to solve problem 39 and 40. It will be very helpful if you look these 3 question all together. My post on those two questions also linked below. The chart to illustrate the process is in the bottom.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process)\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration)\\n\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\'\\'\\'\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        self.helper(nums, [], ans)\\n        return ans\\n    \\n    def helper(self, nums, temp, ans):\\n        if len(nums)==0:\\n            ans.append(temp)\\n            return\\n\\n        for i in range(len(nums)):\\n            self.helper(nums[:i]+nums[i+1:],temp+[nums[i]],ans )\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/f0af1aef-249f-4e08-8504-91f18c18a56e_1598625210.4955542.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "It uses the same backtracking algorithm to solve problem 39 and 40. It will be very helpful if you look these 3 question all together. My post on those two questions also linked below. The chart to illustrate the process is in the bottom.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process)\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration)\\n\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\'\\'\\'\\n\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        self.helper(nums, [], ans)\\n        return ans\\n    \\n    def helper(self, nums, temp, ans):\\n        if len(nums)==0:\\n            ans.append(temp)\\n            return\\n\\n        for i in range(len(nums)):\\n            self.helper(nums[:i]+nums[i+1:],temp+[nums[i]],ans )\\n\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/f0af1aef-249f-4e08-8504-91f18c18a56e_1598625210.4955542.png)\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3214018,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {   \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n            swap(temp[index] , temp[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {    \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {   \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> &temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n            swap(temp[index] , temp[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), Because there are N! permutations and N! function calls. Where N is the size of the\\n    array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), since we have to store all the possible solutions which are N! in size where N is\\n    the size of the array and ! stands for factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {    \\nprivate :\\n    void permute(vector<int> &nums, vector<vector<int>> &ans, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index] , temp[i]);\\n            permute(nums, ans, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp = nums;\\n        permute(nums, ans, temp, 0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429530,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610172,
                "title": "intuitive-javascript-solution-with-dfs",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n  const output = [];\\n  /**\\n   * The goal is break down the problem by finding permutations in subarrays.\\n   * So we will maintain a subarray of fixed elements and a subarray for \\n   * exploring permutations.\\n   *\\n   *                  [1], [2, 3]    [1, 2], [3]    [1, 2, 3]\\n   * [], [1, 2, 3] -> [2], [1, 3] -> [1, 3], [2] -> [1, 3, 2]\\n   *                  [3], [1, 2]    [2, 1], [1]    [2, 1, 3]\\n   *                                 [2, 3], [1]    [2, 3, 1]\\n   *                                 [3, 1], [2]    [3, 1, 2]\\n   *                                 [3, 2], [1]    [3, 2, 1]                                 \\n   */\\n  const dfs = (curr, rest) => {\\n    // base case. Found a permutation because there\\'s nothing else to explore.\\n    if (rest.length === 0) {\\n      output.push(curr);\\n      return;\\n    }\\n    for (let i = 0; i < rest.length; i++) {\\n      dfs([...curr, rest[i]], [...rest.slice(0, i), ...rest.slice(i + 1)]);\\n    }\\n  }\\n  dfs([], nums);\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n  const output = [];\\n  /**\\n   * The goal is break down the problem by finding permutations in subarrays.\\n   * So we will maintain a subarray of fixed elements and a subarray for \\n   * exploring permutations.\\n   *\\n   *                  [1], [2, 3]    [1, 2], [3]    [1, 2, 3]\\n   * [], [1, 2, 3] -> [2], [1, 3] -> [1, 3], [2] -> [1, 3, 2]\\n   *                  [3], [1, 2]    [2, 1], [1]    [2, 1, 3]\\n   *                                 [2, 3], [1]    [2, 3, 1]\\n   *                                 [3, 1], [2]    [3, 1, 2]\\n   *                                 [3, 2], [1]    [3, 2, 1]                                 \\n   */\\n  const dfs = (curr, rest) => {\\n    // base case. Found a permutation because there\\'s nothing else to explore.\\n    if (rest.length === 0) {\\n      output.push(curr);\\n      return;\\n    }\\n    for (let i = 0; i < rest.length; i++) {\\n      dfs([...curr, rest[i]], [...rest.slice(0, i), ...rest.slice(i + 1)]);\\n    }\\n  }\\n  dfs([], nums);\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252489,
                "title": "python-backtracking-clean-concise",
                "content": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        self.ans = []\\n        \\n        def bt(i):\\n            if i == n:\\n                self.ans.append(deepcopy(nums))\\n                return\\n            \\n            for j in range(i, n):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                bt(i+1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n                \\n        bt(0)\\n        return self.ans\\n```\\n**Complexity**\\n- Time: `O(N!)`\\n- Space: `O(N!)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        self.ans = []\\n        \\n        def bt(i):\\n            if i == n:\\n                self.ans.append(deepcopy(nums))\\n                return\\n            \\n            for j in range(i, n):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                bt(i+1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n                \\n        bt(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474624,
                "title": "c-beginner-explained-backtracking-clean",
                "content": "# ***Approach***\\n```\\nThis problem is very similar to finding combinations of a range but here we have to find permutations , and as we know in permutations we ordering matters\\n\\nmeans [1,2,3] != [2,1,3] != [3,2,1]\\n\\nwe will use visited vector to keep track of already present values in path\\nBenifit of using visited vector : it helps us to find whether a given value is present or not in a path in O(1) time!!!\\n\\nPath : holds single permutation at a time\\nvisited : stores true for all those indexes which are present in path\\nres : stores all permutations!!!!\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<vector<int>> permute(vector<int> &nums) {\\n        \\n        vector<int> path;\\n        vector<bool> visited(nums.size() , false);\\n        dfs(nums , path , visited);\\n        \\n        return res;\\n    }\\n    void dfs(vector<int> &nums , vector<int> &path , vector<bool> &visited)\\n    {\\n        if(path.size() == nums.size())\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i)\\n        {\\n            if(visited[i] == false)\\n            {\\n                visited[i] = true;\\n                path.push_back(nums[i]);\\n                \\n                dfs(nums , path , visited);\\n                \\n                path.pop_back();   // backtrack\\n                visited[i] = false;// backtrack\\n            }\\n        }\\n    }\\n};\\n```\\n# ***If you liked the solution , Please Upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nThis problem is very similar to finding combinations of a range but here we have to find permutations , and as we know in permutations we ordering matters\\n\\nmeans [1,2,3] != [2,1,3] != [3,2,1]\\n\\nwe will use visited vector to keep track of already present values in path\\nBenifit of using visited vector : it helps us to find whether a given value is present or not in a path in O(1) time!!!\\n\\nPath : holds single permutation at a time\\nvisited : stores true for all those indexes which are present in path\\nres : stores all permutations!!!!\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<vector<int>> permute(vector<int> &nums) {\\n        \\n        vector<int> path;\\n        vector<bool> visited(nums.size() , false);\\n        dfs(nums , path , visited);\\n        \\n        return res;\\n    }\\n    void dfs(vector<int> &nums , vector<int> &path , vector<bool> &visited)\\n    {\\n        if(path.size() == nums.size())\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i)\\n        {\\n            if(visited[i] == false)\\n            {\\n                visited[i] = true;\\n                path.push_back(nums[i]);\\n                \\n                dfs(nums , path , visited);\\n                \\n                path.pop_back();   // backtrack\\n                visited[i] = false;// backtrack\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18308,
                "title": "javascript-using-dp",
                "content": "Here's the common backtracking solution for comparison:\\n```\\nvar permute = function(nums) {\\n    const res = [];\\n    backtrack(nums, res);\\n    return res;\\n};\\n\\nfunction backtrack(nums, res, n = 0) {\\n    if (n === nums.length - 1) {\\n        res.push(nums.slice(0));\\n        return;\\n    }\\n    for (let i = n; i < nums.length; i++) {\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n        backtrack(nums, res, n + 1);\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n    }\\n}\\n```\\nThe DP solution came more naturally to my brain and OJ seems to like it for speed:\\n```\\nvar permute = function(nums, n = 0) {\\n    if (n >= nums.length) return [[]];\\n    const res = [];\\n    const prevs = permute(nums, n + 1);  // permutations of elements after n\\n    for (let prev of prevs) {\\n        for (let i = 0; i <= prev.length; i++) {\\n            let p = prev.slice(0);\\n            p.splice(i, 0, nums[n]);  // successively insert element n\\n            res.push(p);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permute = function(nums) {\\n    const res = [];\\n    backtrack(nums, res);\\n    return res;\\n};\\n\\nfunction backtrack(nums, res, n = 0) {\\n    if (n === nums.length - 1) {\\n        res.push(nums.slice(0));\\n        return;\\n    }\\n    for (let i = n; i < nums.length; i++) {\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n        backtrack(nums, res, n + 1);\\n        [nums[i], nums[n]] = [nums[n], nums[i]];\\n    }\\n}\\n```\n```\\nvar permute = function(nums, n = 0) {\\n    if (n >= nums.length) return [[]];\\n    const res = [];\\n    const prevs = permute(nums, n + 1);  // permutations of elements after n\\n    for (let prev of prevs) {\\n        for (let i = 0; i <= prev.length; i++) {\\n            let p = prev.slice(0);\\n            p.splice(i, 0, nums[n]);  // successively insert element n\\n            res.push(p);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527929,
                "title": "java-tc-o-n-n-sc-o-n-recursive-backtracking-iterative-solutions",
                "content": "**Recursive Backtracking**\\n\\n```java\\n/**\\n * Recursive Backtracking. In this solution passing the index of the nums that\\n * needs to be set in the current recursion.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n-1)\\n * ...\\n * T(2) = (2)*T(1) + O(2)\\n * T(1) = O(N) -> To convert the nums array to ArrayList.\\n *\\n * Above equations can be added together to get:\\n * T(n) = n + n*(n-1) + n*(n-1)*(n-2) + ... + (n....2) + (n....1) * n\\n *      = P(n,1) + P(n,2) + P(n,3) + ... + P(n,n-1) + n*P(n,n)\\n *      = (P(n,1) + ... + P(n,n)) + (n-1)*P(n,n)\\n *      = Floor(e*n! - 1) + (n-1)*n!\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        permutationsHelper(result, nums, 0);\\n        return result;\\n    }\\n\\n    private void permutationsHelper(List<List<Integer>> result, int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int n : nums) {\\n                list.add(n);\\n            }\\n            result.add(list);\\n            return;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            permutationsHelper(result, nums, start + 1);\\n            swap(nums, start, i);\\n        }\\n    }\\n\\n    private void swap(int[] nums, int x, int y) {\\n        int t = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = t;\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each\\n * permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Recursive Backtracking using visited array**\\n\\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        helper(result, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void helper(List<List<Integer>> result, List<Integer> temp, int[] nums, boolean[] visited) {\\n        if (temp.size() == nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            temp.add(nums[i]);\\n            visited[i] = true;\\n            helper(result, temp, nums, visited);\\n            visited[i] = false;\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Permutations questions on LeetCode:\\n- [47. Permutations II](https://leetcode.com/problems/permutations-ii/discuss/1527937/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Recursive-Backtracking-and-Iterative-Solutions)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Recursive Backtracking. In this solution passing the index of the nums that\\n * needs to be set in the current recursion.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n-1)\\n * ...\\n * T(2) = (2)*T(1) + O(2)\\n * T(1) = O(N) -> To convert the nums array to ArrayList.\\n *\\n * Above equations can be added together to get:\\n * T(n) = n + n*(n-1) + n*(n-1)*(n-2) + ... + (n....2) + (n....1) * n\\n *      = P(n,1) + P(n,2) + P(n,3) + ... + P(n,n-1) + n*P(n,n)\\n *      = (P(n,1) + ... + P(n,n)) + (n-1)*P(n,n)\\n *      = Floor(e*n! - 1) + (n-1)*n!\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        permutationsHelper(result, nums, 0);\\n        return result;\\n    }\\n\\n    private void permutationsHelper(List<List<Integer>> result, int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int n : nums) {\\n                list.add(n);\\n            }\\n            result.add(list);\\n            return;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            permutationsHelper(result, nums, start + 1);\\n            swap(nums, start, i);\\n        }\\n    }\\n\\n    private void swap(int[] nums, int x, int y) {\\n        int t = nums[x];\\n        nums[x] = nums[y];\\n        nums[y] = t;\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each\\n * permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        helper(result, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void helper(List<List<Integer>> result, List<Integer> temp, int[] nums, boolean[] visited) {\\n        if (temp.size() == nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            temp.add(nums[i]);\\n            visited[i] = true;\\n            helper(result, temp, nums, visited);\\n            visited[i] = false;\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18470,
                "title": "my-java-accepted-solution-without-additional-space",
                "content": "    public class Solution {\\n        public List<List<Integer>> permute(int[] num) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            permute(result, num, 0);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, int[] array, int start) {\\n    \\t\\tif (start >= array.length) {\\n    \\t\\t\\tList<Integer> current = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int a : array) {\\n    \\t\\t\\t    current.add(a);\\n    \\t\\t\\t}\\n    \\t\\t\\tresult.add(current);\\n    \\t\\t} else {\\n    \\t\\t\\tfor (int i=start; i<array.length; i++) {\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t\\tpermute(result, array, start+1);\\n    \\t\\t\\t\\tswap(array, start, i);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tprivate void swap(int[] array, int i, int j) {\\n    \\t\\tint temp = array[i];\\n    \\t\\tarray[i] = array[j];\\n    \\t\\tarray[j] = temp;\\n    \\t}\\n    }\\n\\nI enumerate all the permutations in a generative way, the idea is that, at each position, I specify the element by swapping with values with a larger index. The value at the first position can swap with position 1,2,...,n-1, after each swap, I will do a recursion for the rest of the array. \\n\\nThe problem is that with this approach, the permutations may be out of order.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permute(int[] num) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            permute(result, num, 0);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18377,
                "title": "my-simple-javascript-recursive-solution",
                "content": "    var permute = function(nums) {\\n      let results = [];\\n    \\n      let permutations = (current, remaining) => {\\n        if(remaining.length <= 0) results.push(current.slice());\\n        else {\\n          for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements\\n            current.push(remaining[i]); // Insert the iTH element onto the end of current\\n            permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); // Recurse with inserted element removed\\n            current.pop(); // Remove last inserted element for next iteration\\n          }\\n        }\\n      };\\n    \\n      permutations([], nums);\\n      return results;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var permute = function(nums) {\\n      let results = [];\\n    \\n      let permutations = (current, remaining) => {\\n        if(remaining.length <= 0) results.push(current.slice());\\n        else {\\n          for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements\\n            current.push(remaining[i]); // Insert the iTH element onto the end of current\\n            permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); // Recurse with inserted element removed\\n            current.pop(); // Remove last inserted element for next iteration\\n          }\\n        }\\n      };\\n    \\n      permutations([], nums);\\n      return results;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 780823,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> result;\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        helper(nums, 0, (int)nums.size() - 1);\\n        \\n        return result;\\n    }\\n    \\n    void helper(vector<int> num_arr, int l, int r) {\\n        if (l == r){\\n            result.push_back(num_arr);\\n        } \\n        else {  \\n            for (int i = l; i <= r; i++) {\\n                swap(num_arr[l], num_arr[i]);\\n\\n                helper(num_arr, l + 1, r); \\n\\n                swap(num_arr[l], num_arr[i]);  \\n            }  \\n        }\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> result;\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        helper(nums, 0, (int)nums.size() - 1);\\n        \\n        return result;\\n    }\\n    \\n    void helper(vector<int> num_arr, int l, int r) {\\n        if (l == r){\\n            result.push_back(num_arr);\\n        } \\n        else {  \\n            for (int i = l; i <= r; i++) {\\n                swap(num_arr[l], num_arr[i]);\\n\\n                helper(num_arr, l + 1, r); \\n\\n                swap(num_arr[l], num_arr[i]);  \\n            }  \\n        }\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139642,
                "title": "clean-javascript-backtracking-solution",
                "content": "```js\\nconst permute = (nums) => {\\n  const res = [];\\n\\n  const go = (cur, rest) => {\\n    if (rest.length === 0) {\\n      res.push(cur);\\n      return;\\n    }\\n\\n    for (let i = 0; i < rest.length; i++) {\\n      // note if using array push and splice here, it will cause mutation\\n      go(\\n        [...cur, rest[i]],\\n        [...rest.slice(0, i), ...rest.slice(i + 1)],\\n      );\\n    }\\n  };\\n\\n  go([], nums);\\n  return res;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nconst permute = (nums) => {\\n  const res = [];\\n\\n  const go = (cur, rest) => {\\n    if (rest.length === 0) {\\n      res.push(cur);\\n      return;\\n    }\\n\\n    for (let i = 0; i < rest.length; i++) {\\n      // note if using array push and splice here, it will cause mutation\\n      go(\\n        [...cur, rest[i]],\\n        [...rest.slice(0, i), ...rest.slice(i + 1)],\\n      );\\n    }\\n  };\\n\\n  go([], nums);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851480,
                "title": "c-python-c-0ms-backtrack-with-graph-explained-beginner-friendly",
                "content": "# Approach\\nUse a recursive function `backtrack`, in the function, we pass in a index.\\nIn the function, we use a for loop swap `nums[index]` with different numbers in `nums`.\\nAfter each swap, call `backtrack` again with `index+1`.\\nThen swap back the values, so that we can get every permutations as the graph shown below.\\n\\nIf `index` reach `n-1`, we kwon that we get one of the premutations.\\nSo just add `nums` into `arr`.\\nAfter all the recursion, we get our answer.\\n \\n![image.png](https://assets.leetcode.com/users/images/bde05504-fcb3-4ab0-98a5-98e24a83daed_1690955270.7047431.png)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    void backtrack(vector<int>& nums, int n, int index){\\n        if(index == n - 1){\\n            arr.push_back(nums);\\n            return;\\n        }\\n        for(int i=index; i<n; i++){\\n            swap(nums[index], nums[i]);\\n            backtrack(nums, n, index+1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n = nums.size();\\n        backtrack(nums, n, 0);\\n        return arr;\\n    }\\n};\\n```\\n```c []\\n void swap(int* a, int* b){\\n     int temp = *a;\\n     *a = *b;\\n     *b = temp;\\n }\\n\\n void backtrack(int* nums, int numsSize, int*** arr, int* returnSize, int** returnColumnSizes, int index){\\n     if(index == numsSize - 1){\\n         (*returnSize)++;\\n         *arr = (int**)realloc(*arr, sizeof(int*) * (*returnSize));\\n         (*returnColumnSizes)[*returnSize - 1] = numsSize;\\n         (*arr)[*returnSize - 1] = (int*)malloc(sizeof(int) * numsSize);\\n         for(int i=0; i<numsSize; i++){\\n             (*arr)[*returnSize - 1][i] = nums[i];\\n         }\\n         return;\\n     }\\n     for(int i=index; i<numsSize; i++){\\n         swap(nums+index, nums+i);\\n         backtrack(nums, numsSize, arr, returnSize, returnColumnSizes, index + 1);\\n         swap(nums+index, nums+i);\\n     }\\n }\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        arr = []\\n\\n        def backtrack(index):\\n            if(index == n):\\n                arr.append(nums[:])\\n                return\\n            for i in range(index, n):\\n                nums[index], nums[i] = nums[i], nums[index] # swap\\n                backtrack(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index] # swap back\\n        \\n        backtrack(0)\\n        return arr\\n```\\n# Please UPVOTE if this helps\\n![image.png](https://assets.leetcode.com/users/images/0edc260d-5815-41d8-af72-7a42927e99c8_1690956153.464619.png)\\n![image.png](https://assets.leetcode.com/users/images/85e39eaf-a380-450f-b311-0b2f67778c8c_1690953992.3802822.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> arr;\\n    void backtrack(vector<int>& nums, int n, int index){\\n        if(index == n - 1){\\n            arr.push_back(nums);\\n            return;\\n        }\\n        for(int i=index; i<n; i++){\\n            swap(nums[index], nums[i]);\\n            backtrack(nums, n, index+1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        int n = nums.size();\\n        backtrack(nums, n, 0);\\n        return arr;\\n    }\\n};\\n```\n```c []\\n void swap(int* a, int* b){\\n     int temp = *a;\\n     *a = *b;\\n     *b = temp;\\n }\\n\\n void backtrack(int* nums, int numsSize, int*** arr, int* returnSize, int** returnColumnSizes, int index){\\n     if(index == numsSize - 1){\\n         (*returnSize)++;\\n         *arr = (int**)realloc(*arr, sizeof(int*) * (*returnSize));\\n         (*returnColumnSizes)[*returnSize - 1] = numsSize;\\n         (*arr)[*returnSize - 1] = (int*)malloc(sizeof(int) * numsSize);\\n         for(int i=0; i<numsSize; i++){\\n             (*arr)[*returnSize - 1][i] = nums[i];\\n         }\\n         return;\\n     }\\n     for(int i=index; i<numsSize; i++){\\n         swap(nums+index, nums+i);\\n         backtrack(nums, numsSize, arr, returnSize, returnColumnSizes, index + 1);\\n         swap(nums+index, nums+i);\\n     }\\n }\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize = 1;\\n    for(int i=1; i<=numsSize; i++) (*returnSize) *= i;\\n    *returnColumnSizes = (int*)malloc(*returnSize * sizeof(int)); \\n    *returnSize = 0;\\n    int **arr = (int**)malloc(sizeof(int*));\\n    backtrack(nums, numsSize, &arr, returnSize, returnColumnSizes, 0);\\n    return arr;\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        arr = []\\n\\n        def backtrack(index):\\n            if(index == n):\\n                arr.append(nums[:])\\n                return\\n            for i in range(index, n):\\n                nums[index], nums[i] = nums[i], nums[index] # swap\\n                backtrack(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index] # swap back\\n        \\n        backtrack(0)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310924,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n        {\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n        {\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790702,
                "title": "easy-to-understand-recursion-beats-97-38",
                "content": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# Base conditions\\n\\t\\t# If length is 0 or 1, there is only 1 permutation\\n        if n in [0, 1]:\\n            return [nums]\\n\\t\\t\\n\\t\\t# If length is 2, then there are only two permutations\\n\\t\\t# Example: [1,2] and [2,1]\\n        if n == 2:\\n            return [nums, nums[::-1]]\\n\\t\\t\\t\\n        res = []\\n\\t\\t# For every number in array, choose 1 number and permute the remaining\\n\\t\\t# by calling permute recursively\\n        for i in range(n):\\n            permutations = self.permute(nums[:i] + nums[i+1:])\\n            for p in permutations:\\n                res.append([nums[i]] + p)\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n\\t\\t\\n\\t\\t# Base conditions\\n\\t\\t# If length is 0 or 1, there is only 1 permutation\\n        if n in [0, 1]:\\n            return [nums]\\n\\t\\t\\n\\t\\t# If length is 2, then there are only two permutations\\n\\t\\t# Example: [1,2] and [2,1]\\n        if n == 2:\\n            return [nums, nums[::-1]]\\n\\t\\t\\t\\n        res = []\\n\\t\\t# For every number in array, choose 1 number and permute the remaining\\n\\t\\t# by calling permute recursively\\n        for i in range(n):\\n            permutations = self.permute(nums[:i] + nums[i+1:])\\n            for p in permutations:\\n                res.append([nums[i]] + p)\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18444,
                "title": "new-approach-directly-find-the-kth-permutation-k-1-n-with-a-simple-loop",
                "content": "# Explanation\\n\\nThe general idea is the following (same as other solutions):\\n\\n 1. We know there are `n!` possible permutations for `n` elements.\\n 2. Enumerate them one by one\\n\\nMost solutions use the previous permutation to generate the next permutation or build it recursively.\\nI had the idea to calculate the `k`<sup>th</sup> permutation directly from the input. Steps are as follows:\\n\\n 1. Build a list of all elements in ascending order.  \\nThe length of this list is `n` (i.e. not the original input size).\\n 2. Given `k` we know what the first element will be in the `k`<sup>th</sup> permutation of the current list.  \\nThere are `n` groups in the lexicographical order of all permutations of the list. Inside a group each permutation's first element is the same. Each group has `(n-1)!` elements, so an easy `k / (n-1)!` will give us the index.\\n 3. Append the selected element to the result, i.e. the next element in the `k`<sup>th</sup> permutation.\\n 4. Remove the selected element from the list.  \\n 5. Now the list has one less elements and we can **repeat from Step 2** with `k' = k % n!`,  \\nthat is the `k'`<sup>th</sup> permutation of the reduced list.\\n\\nNotice that it doesn't matter what the elements are because the indices are calculated.\\n\\n# Examples for `n = 1...4`\\n\\n    elements  k    indices\\n    []        -    -       =----- trivial\\n\\n    [1]       0    0       =----- reduces to [] after selecting 1\\n\\n    [1,2]     0    0 0     =----- reduces to [2] after selecting 1\\n    [2,1]     1    1 0     =----- reduces to [1] after selecting 2\\n    \\n    [1,2,3]   0    0 0 0   =\\\\____ reduces to [2,3] after selecting 1\\n    [1,3,2]   1    0 1 0   =/\\n    [2,1,3]   2    1 0 0   =\\\\____ reduces to [1,3] after selecting 2\\n    [2,3,1]   3    1 1 0   =/\\n    [3,1,2]   4    2 0 0   =\\\\____ reduces to [1,2] after selecting 3\\n    [3,2,1]   5    2 1 0   =/\\n    \\n    [1,2,3,4] 0    0 0 0 0 =\\\\\\n    [1,2,4,3] 1    0 0 1 0   \\\\\\n    [1,3,2,4] 2    0 1 0 0    \\\\__ reduces to [2,3,4] after selecting 1\\n    [1,3,4,2] 3    0 1 1 0    /\\n    [1,4,2,3] 4    0 2 0 0   /\\n    [1,4,3,2] 5    0 2 1 0 =/\\n    [2,1,3,4] 6    1 0 0 0 =\\\\\\n    [2,1,4,3] 7    1 0 1 0   \\\\\\n    [2,3,1,4] 8    1 1 0 0    \\\\__ reduces to [1,3,4] after selecting 2\\n    [2,3,4,1] 9    1 1 1 0    /\\n    [2,4,1,3] 10   1 2 0 0   /\\n    [2,4,3,1] 11   1 1 1 0 =/\\n    [3,1,2,4] 12   2 0 0 0 =\\\\\\n    [3,1,4,2] 13   2 0 1 0   \\\\\\n    [3,2,1,4] 14   2 1 0 0    \\\\__ reduces to [1,2,4] after selecting 3\\n    [3,2,4,1] 15   2 1 1 0    /\\n    [3,4,1,2] 16   2 2 0 0   /\\n    [3,4,2,1] 17   2 2 1 0 =/\\n    [4,1,2,3] 18   3 0 0 0 =\\\\\\n    [4,1,3,2] 19   3 0 1 0   \\\\\\n    [4,2,1,3] 20   3 1 0 0    \\\\__ reduces to [1,2,3] after selecting 4\\n    [4,2,3,1] 21   3 1 1 0    /\\n    [4,3,1,2] 22   3 2 0 0   /\\n    [4,3,2,1] 23   3 2 1 0 =/\\n\\n# Code\\n\\n**The fact of `FACT`**: since the problem asks for **all** permutations we can be sure it won't ask for more than `12` elements, because `13!` is out of range for `int` and all lists are indexed by `int`s. Also `12!` permutations of `12` elements in `List<List>` is good `7GiB` worth of memory.\\n\\n    public class Solution {\\n        private static final int[] FACT = { // 479001600 < 2147483647 < 6227020800\\n            1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600\\n        };\\n        public List<List<Integer>> permute(int[] nums) {\\n            Arrays.sort(nums);\\n            List<List<Integer>> result = new ArrayList<>(nums.length);\\n            for (int k = 0; k < FACT[nums.length]; ++k) {\\n                result.add(permutation(nums, k));\\n            }\\n            return result;\\n        }\\n        List<Integer> permutation(int[] nums, int k) {\\n            // k %= FACT[nums.length]; // in case you want to use it elsewhere\\n            List<Integer> source = toList(nums);\\n            List<Integer> result = new ArrayList(nums.length);\\n            while (!source.isEmpty()) {\\n                int f = FACT[source.size() - 1];\\n                result.add(source.remove(k / f));\\n                k %= f;\\n            }\\n            return result;\\n        }\\n        List<Integer> toList(int[] nums) {\\n            List<Integer> result = new LinkedList<>();\\n            for (int num : nums) {\\n                result.add(num);\\n            }\\n            return result;\\n        }\\n    }\\n\\n# Analysis\\n\\nIt's clear that we need to iterate `n!` times, because we're generating `n!` elements.\\nThe `permutation` method looks like `O(n)`, but sadly it's `O(n^2)` because `remove` takes `O(n)`:\\n\\n * `LinkedList`  \\n`i` steps to find the `i`<sup>th</sup> element and `O(1)` to remove it\\n * `ArrayList`  \\n`O(1)` to find the `i`<sup>th</sup> element and `n-i` steps to remove the `i`<sup>th</sup> element\\n * keep `int[] nums` and `boolean[] removed`  \\nwe have to iterate over each removed item, so `O(n)`\\n * `Map<Integer, Integer>`  \\nmay be better, but we have to re-index all remaining elements\\n * **Is there a better data structure for this?**\\n\\n# Code variations\\n\\nIn case you don't like the hardcoded `FACT`:\\n\\n    /* 12! = 479001600 < Integer.MAX_VALUE = 2147483647 < 13! = 6227020800 */\\n    private static final int[] FACT = factorials(12);\\n    static int[] factorials(int n) {\\n        int[] f = new int[n+1];\\n        f[0] = f[1] = 1;\\n        for (int i = 2; i <= n; ++i) {\\n            f[i] = f[i-1] * i;\\n        }\\n        return f;\\n    }\\n\\nor it's even possible to calculate `n!` only once and keep reducing it, but then we have to pass an extra unrelated argument.\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>(nums.length);\\n        int fact = factorial(nums.length);\\n        for (int k = 0; k < fact; ++k) {\\n            result.add(permutation(nums, fact, k));\\n        }\\n        return result;\\n    }\\n    List<Integer> permutation(int[] nums, int f, int k) {\\n        if (nums.length == 0) return Collections.emptyList();\\n        List<Integer> source = toList(nums);\\n        List<Integer> result = new ArrayList(nums.length);\\n        do {\\n            k %= f;\\n            f /= source.size();\\n            result.add(source.remove(k / f));\\n        } while (!source.isEmpty());\\n        return result;\\n    }\\n    static int factorial(int n) {\\n        if (n <= 1) return 1;\\n        int result = n;\\n        while (--n > 1) {\\n            result *= n;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        private static final int[] FACT = { // 479001600 < 2147483647 < 6227020800\\n            1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3851346,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing backtracking to create all possible combinations\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/J7m7W7P6e3s\\n\\n# Subscribe to my channel from here. I have 238 videos as of August 2nd\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python solution. Other might be different a bit.\\n\\n1. The function `permute` takes a list of integers `nums` as input and aims to generate all possible permutations of the elements in the input list.\\n\\n2. The base case is checked: if the length of the `nums` list is 1, then it means there\\'s only one element left to permute, and at this point, a list containing that single element is returned as a permutation.\\n\\n3. If the `nums` list has more than one element, the algorithm proceeds with permutation generation.\\n\\n4. Initialize an empty list `res` to store the permutations.\\n\\n5. Iterate over each element in the `nums` list (using `_` as a placeholder for the loop variable). In each iteration, pop the first element `n` from the `nums` list.\\n\\n6. Recursively call the `permute` function on the remaining elements in `nums` after removing the first element. This generates all possible permutations of the remaining elements.\\n\\n7. For each permutation `p` generated in the recursive call, append the previously removed element `n` to it.\\n\\n8. Extend the `res` list with the permutations generated in the recursive calls, each with the element `n` appended.\\n\\n9. After the loop completes, add the removed element `n` back to the end of the `nums` list, restoring the original state for the next iteration.\\n\\n10. Finally, return the list `res` containing all the generated permutations.\\n\\nIn summary, this code uses a recursive approach to generate all possible permutations of the input list `nums`. It removes one element at a time, generates permutations for the remaining elements, appends the removed element to those permutations, and collects all permutations in the `res` list. The recursion continues until only one element is left in the list, at which point a permutation containing that single element is returned. \\n\\n# Complexity\\n- Time complexity: O(n * n!)\\n\\n    - Recursive Calls: The permute function is called recursively, and each time it generates permutations for a smaller list by removing one element. In the worst case, the recursion depth is equal to the length of the input list nums, which is n.\\n\\n    - Permutation Generation: For each index, we are generating permutations for the remaining elements and appending the removed element at the end. This involves recursive calls and list manipulations. In general time complexity of permutation should be O(n!)\\n\\n- Space complexity: O(n)\\n    - Recursion Depth: The depth of recursion goes up to the number of elements in the input list. So, the maximum recursion depth is O(n).\\n    - Additional Memory: The additional memory usage includes the res list, the n variable, and the space used in each recursive call.\\n\\n        Considering these factors, the space complexity is O(n)\\n\\n\\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums[:]]\\n        \\n        res = []\\n\\n        for _ in range(len(nums)):\\n            n = nums.pop(0)\\n            perms = self.permute(nums)\\n\\n            for p in perms:\\n                p.append(n)\\n            \\n            res.extend(perms)\\n            nums.append(n)\\n        \\n        return res\\n            \\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    if (nums.length === 1) {\\n        return [nums.slice()];\\n    }\\n    \\n    var res = [];\\n\\n    for (var i = 0; i < nums.length; i++) {\\n        var n = nums.shift();\\n        var perms = permute(nums.slice());\\n\\n        for (var p of perms) {\\n            p.push(n);\\n        }\\n        \\n        res.push(...perms);\\n        nums.push(n);\\n    }\\n    \\n    return res;  \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 1) {\\n            List<Integer> singleList = new ArrayList<>();\\n            singleList.add(nums[0]);\\n            res.add(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int[] remainingNums = new int[nums.length - 1];\\n            int index = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (j != i) {\\n                    remainingNums[index] = nums[j];\\n                    index++;\\n                }\\n            }\\n            \\n            List<List<Integer>> perms = permute(remainingNums);\\n            for (List<Integer> p : perms) {\\n                p.add(n);\\n            }\\n            \\n            res.addAll(perms);\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        if (nums.size() == 1) {\\n            vector<int> singleList;\\n            singleList.push_back(nums[0]);\\n            res.push_back(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            vector<int> remainingNums;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (j != i) {\\n                    remainingNums.push_back(nums[j]);\\n                }\\n            }\\n            \\n            vector<vector<int>> perms = permute(remainingNums);\\n            for (vector<int> p : perms) {\\n                p.insert(p.begin(), n);  // Insert n at the beginning of the permutation\\n                res.push_back(p);  // Append the modified permutation to the result\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```\\n\\n- This is bonus codes I don\\'t explain in the article.\\n\\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n\\n        def backtrack(start):\\n            if start == len(nums):\\n                res.append(nums[:])\\n                return\\n            \\n            for i in range(start, len(nums)):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start + 1)\\n                nums[start], nums[i] = nums[i], nums[start]\\n\\n        res = []\\n        backtrack(0)\\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const backtrack = (start) => {\\n        if (start === nums.length) {\\n            res.push([...nums]);\\n            return;\\n        }\\n        \\n        for (let i = start; i < nums.length; i++) {\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n            backtrack(start + 1);\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n        }\\n    };\\n\\n    const res = [];\\n    backtrack(0);\\n    return res;  \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, res);\\n        return res;    \\n    }\\n\\n    private void backtrack(int[] nums, int start, List<List<Integer>> res) {\\n        if (start == nums.length) {\\n            res.add(arrayToList(nums));\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            backtrack(nums, start + 1, res);\\n            swap(nums, start, i);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : arr) {\\n            list.add(num);\\n        }\\n        return list;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }    \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(nums, 0, res);\\n        return res;\\n    }\\n\\n    void backtrack(vector<int>& nums, int start, vector<vector<int>>& res) {\\n        if (start == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            swap(nums[start], nums[i]);\\n            backtrack(nums, start + 1, res);\\n            swap(nums[start], nums[i]);\\n        }\\n    }\\n    \\n    void swap(int& a, int& b) {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n    }    \\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums[:]]\\n        \\n        res = []\\n\\n        for _ in range(len(nums)):\\n            n = nums.pop(0)\\n            perms = self.permute(nums)\\n\\n            for p in perms:\\n                p.append(n)\\n            \\n            res.extend(perms)\\n            nums.append(n)\\n        \\n        return res\\n            \\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    if (nums.length === 1) {\\n        return [nums.slice()];\\n    }\\n    \\n    var res = [];\\n\\n    for (var i = 0; i < nums.length; i++) {\\n        var n = nums.shift();\\n        var perms = permute(nums.slice());\\n\\n        for (var p of perms) {\\n            p.push(n);\\n        }\\n        \\n        res.push(...perms);\\n        nums.push(n);\\n    }\\n    \\n    return res;  \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums.length == 1) {\\n            List<Integer> singleList = new ArrayList<>();\\n            singleList.add(nums[0]);\\n            res.add(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int[] remainingNums = new int[nums.length - 1];\\n            int index = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (j != i) {\\n                    remainingNums[index] = nums[j];\\n                    index++;\\n                }\\n            }\\n            \\n            List<List<Integer>> perms = permute(remainingNums);\\n            for (List<Integer> p : perms) {\\n                p.add(n);\\n            }\\n            \\n            res.addAll(perms);\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        if (nums.size() == 1) {\\n            vector<int> singleList;\\n            singleList.push_back(nums[0]);\\n            res.push_back(singleList);\\n            return res;\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            int n = nums[i];\\n            vector<int> remainingNums;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (j != i) {\\n                    remainingNums.push_back(nums[j]);\\n                }\\n            }\\n            \\n            vector<vector<int>> perms = permute(remainingNums);\\n            for (vector<int> p : perms) {\\n                p.insert(p.begin(), n);  // Insert n at the beginning of the permutation\\n                res.push_back(p);  // Append the modified permutation to the result\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n\\n        def backtrack(start):\\n            if start == len(nums):\\n                res.append(nums[:])\\n                return\\n            \\n            for i in range(start, len(nums)):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start + 1)\\n                nums[start], nums[i] = nums[i], nums[start]\\n\\n        res = []\\n        backtrack(0)\\n        return res\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const backtrack = (start) => {\\n        if (start === nums.length) {\\n            res.push([...nums]);\\n            return;\\n        }\\n        \\n        for (let i = start; i < nums.length; i++) {\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n            backtrack(start + 1);\\n            [nums[start], nums[i]] = [nums[i], nums[start]];\\n        }\\n    };\\n\\n    const res = [];\\n    backtrack(0);\\n    return res;  \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backtrack(nums, 0, res);\\n        return res;    \\n    }\\n\\n    private void backtrack(int[] nums, int start, List<List<Integer>> res) {\\n        if (start == nums.length) {\\n            res.add(arrayToList(nums));\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.length; i++) {\\n            swap(nums, start, i);\\n            backtrack(nums, start + 1, res);\\n            swap(nums, start, i);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : arr) {\\n            list.add(num);\\n        }\\n        return list;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }    \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(nums, 0, res);\\n        return res;\\n    }\\n\\n    void backtrack(vector<int>& nums, int start, vector<vector<int>>& res) {\\n        if (start == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            swap(nums[start], nums[i]);\\n            backtrack(nums, start + 1, res);\\n            swap(nums[start], nums[i]);\\n        }\\n    }\\n    \\n    void swap(int& a, int& b) {\\n        int temp = a;\\n        a = b;\\n        b = temp;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681162,
                "title": "100-faster-c-solution-simple-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums, vector<vector<int>>& ans, int index){\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j=index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            solve(nums, ans, index+1); //recursive call\\n            swap(nums[index], nums[j]); //backtracking\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums,ans,index);\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote If You Find the Solution Helpful..\\nHappy Coding !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums, vector<vector<int>>& ans, int index){\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j=index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            solve(nums, ans, index+1); //recursive call\\n            swap(nums[index], nums[j]); //backtracking\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums,ans,index);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898253,
                "title": "easyway-explanation-every-step",
                "content": "```\\n\\ndfs(nums = [1, 2, 3] , path = [] , result = [] )\\n|____ dfs(nums = [2, 3] , path = [1] , result = [] )\\n|      |___dfs(nums = [3] , path = [1, 2] , result = [] )\\n|      |    |___dfs(nums = [] , path = [1, 2, 3] , result = [[1, 2, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [2] , path = [1, 3] , result = [[1, 2, 3]] )\\n|           |___dfs(nums = [] , path = [1, 3, 2] , result = [[1, 2, 3], [1, 3, 2]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 3] , path = [2] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |___dfs(nums = [3] , path = [2, 1] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |    |___dfs(nums = [] , path = [2, 1, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [1] , path = [2, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] )\\n|           |___dfs(nums = [] , path = [2, 3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 2] , path = [3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |___dfs(nums = [2] , path = [3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |    |___dfs(nums = [] , path = [3, 1, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) # added a new permutation to the result\\n       |___dfs(nums = [1] , path = [3, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] )\\n            |___dfs(nums = [] , path = [3, 2, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ) # added a new permutation to the results\\n\\n\\n```\\n\\n```\\ndef permute(self, nums):\\n    res = []\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n        # return # backtracking\\n    for i in range(len(nums)):\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n\\ndfs(nums = [1, 2, 3] , path = [] , result = [] )\\n|____ dfs(nums = [2, 3] , path = [1] , result = [] )\\n|      |___dfs(nums = [3] , path = [1, 2] , result = [] )\\n|      |    |___dfs(nums = [] , path = [1, 2, 3] , result = [[1, 2, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [2] , path = [1, 3] , result = [[1, 2, 3]] )\\n|           |___dfs(nums = [] , path = [1, 3, 2] , result = [[1, 2, 3], [1, 3, 2]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 3] , path = [2] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |___dfs(nums = [3] , path = [2, 1] , result = [[1, 2, 3], [1, 3, 2]] )\\n|      |    |___dfs(nums = [] , path = [2, 1, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) # added a new permutation to the result\\n|      |___dfs(nums = [1] , path = [2, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] )\\n|           |___dfs(nums = [] , path = [2, 3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) # added a new permutation to the result\\n|____ dfs(nums = [1, 2] , path = [3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |___dfs(nums = [2] , path = [3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] )\\n       |    |___dfs(nums = [] , path = [3, 1, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) # added a new permutation to the result\\n       |___dfs(nums = [1] , path = [3, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] )\\n            |___dfs(nums = [] , path = [3, 2, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ) # added a new permutation to the results\\n\\n\\n```\n```\\ndef permute(self, nums):\\n    res = []\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n        # return # backtracking\\n    for i in range(len(nums)):\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1861293,
                "title": "simple-java-solution-with-full-explanation-simple-recursion-1-ms-faster-than-93-44",
                "content": "![image](https://assets.leetcode.com/users/images/2c97ed56-e3b7-47bf-8a01-7e9bcc9d7e47_1647625201.5840182.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        return permutation(new ArrayList<>(),nums);\\n    }\\n    public List<List<Integer>> permutation(List<Integer> p,int[] up){\\n        \\n        if(up.length==0){\\n            List<List<Integer>> sublist=new ArrayList<>();\\n            sublist.add(p);\\n            return sublist;\\n        }\\n        int num=up[0];\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<=p.size();i++){\\n            List<Integer> new1=new ArrayList<>();\\n            new1.addAll(p.subList(0,i));\\n            new1.add(num);\\n            new1.addAll(p.subList(i,p.size()));\\n            ans.addAll(permutation(new1,Arrays.copyOfRange(up, 1, up.length)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n// If it seems to easy to understand, give a upvote(reputation)\\uD83D\\uDC4Dto motivate me\\uD83D\\uDE09\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        return permutation(new ArrayList<>(),nums);\\n    }\\n    public List<List<Integer>> permutation(List<Integer> p,int[] up){\\n        \\n        if(up.length==0){\\n            List<List<Integer>> sublist=new ArrayList<>();\\n            sublist.add(p);\\n            return sublist;\\n        }\\n        int num=up[0];\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<=p.size();i++){\\n            List<Integer> new1=new ArrayList<>();\\n            new1.addAll(p.subList(0,i));\\n            new1.add(num);\\n            new1.addAll(p.subList(i,p.size()));\\n            ans.addAll(permutation(new1,Arrays.copyOfRange(up, 1, up.length)));\\n        }\\n        return ans;\\n    }\\n}\\n\\n// If it seems to easy to understand, give a upvote(reputation)\\uD83D\\uDC4Dto motivate me\\uD83D\\uDE09\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090060,
                "title": "simple-c-using-backtracking-and-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply do swaping recusrively for every index and bactrack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo approaches \\n- Using Backtracking\\n- Using STL function\\n# Complexity\\n- Time complexity:$$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n!)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Backtracking**\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void permutation(vector<int>&arr,int start){\\n        if(start==arr.size())\\n        ans.push_back(arr);\\n\\n        for(int i=start;i<arr.size();i++){\\n              swap(arr[i],arr[start]);\\n              permutation(arr,start+1);\\n              swap(arr[i],arr[start]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        \\n        vector<int>temp;\\n        permutation(arr,0);\\n        return ans;\\n    }\\n};\\n```\\n**USING STL Function**\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> permute(vector<int>& arr) {\\n       vector<vector<int>>ans;\\n         sort(arr.begin(),arr.end());\\n         do{\\n            ans.push_back(arr);\\n         }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```\\n# UpVote If HELPFULL \\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\n    void permutation(vector<int>&arr,int start){\\n        if(start==arr.size())\\n        ans.push_back(arr);\\n\\n        for(int i=start;i<arr.size();i++){\\n              swap(arr[i],arr[start]);\\n              permutation(arr,start+1);\\n              swap(arr[i],arr[start]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& arr) {\\n        \\n        vector<int>temp;\\n        permutation(arr,0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> permute(vector<int>& arr) {\\n       vector<vector<int>>ans;\\n         sort(arr.begin(),arr.end());\\n         do{\\n            ans.push_back(arr);\\n         }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036237,
                "title": "clean-short-approach-in-python-with-intution-explained",
                "content": "In recursion you want to think of an obvious solution, a solution which you\\'re sure of, which is obvious. For ex: what will be the list of permutations of [1]? obviously it\\'ll be [1] only. This makes our base case.\\n\\nNext you need to think about how a normal typical person would go about solving it. Taking another example:\\nfor [1, 2, 3] I would go about it like this:\\n1) fix 1 at 1st position and get all permutation for [2, 3], which would give me [1, 2, 3], and [1, 3, 2].\\n2) fix 2 at 1st position and get all permutation for [1, 3], which would give me [2, 1, 3], and [2, 3, 1].\\n3) fix 3 at 1st position and get all permutation for [2, 3], which would give me [3, 2, 1], and [3, 1, 2].\\n\\nBelow is my code based on just the above approach\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef permute(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn [nums]\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\t\\t\\t\\tsub_prob = self.permute(nums[1:])\\n\\t\\t\\t\\tfor sub_ans in sub_prob:\\n\\t\\t\\t\\t\\tans.append([nums[0]] + sub_ans)\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\n\\t\\t\\treturn ans\\n\\n\\'\\'\\'\\n\\nHope it helps. Thanks.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "In recursion you want to think of an obvious solution, a solution which you\\'re sure of, which is obvious. For ex: what will be the list of permutations of [1]? obviously it\\'ll be [1] only. This makes our base case.\\n\\nNext you need to think about how a normal typical person would go about solving it. Taking another example:\\nfor [1, 2, 3] I would go about it like this:\\n1) fix 1 at 1st position and get all permutation for [2, 3], which would give me [1, 2, 3], and [1, 3, 2].\\n2) fix 2 at 1st position and get all permutation for [1, 3], which would give me [2, 1, 3], and [2, 3, 1].\\n3) fix 3 at 1st position and get all permutation for [2, 3], which would give me [3, 2, 1], and [3, 1, 2].\\n\\nBelow is my code based on just the above approach\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef permute(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tif len(nums)==1:\\n\\t\\t\\t\\treturn [nums]\\n\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\t\\t\\t\\tsub_prob = self.permute(nums[1:])\\n\\t\\t\\t\\tfor sub_ans in sub_prob:\\n\\t\\t\\t\\t\\tans.append([nums[0]] + sub_ans)\\n\\t\\t\\t\\tnums[0], nums[i] = nums[i], nums[0]\\n\\n\\t\\t\\treturn ans\\n\\n\\'\\'\\'\\n\\nHope it helps. Thanks.",
                "codeTag": "Java"
            },
            {
                "id": 586822,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/newbiecoder1/image_1587275499.png)\\n\\n**Solution 1**\\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Backtracking(nums, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(list.Contains(nums[i]))\\n                    continue;\\n                list.Add(nums[i]);\\n                Backtracking(nums, list, res);\\n                list.RemoveAt(list.Count -1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2**\\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Backtracking(nums, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(list.Contains(nums[i]))\\n                    continue;\\n                list.Add(nums[i]);\\n                Backtracking(nums, list, res);\\n                list.RemoveAt(list.Count -1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168050,
                "title": "python-iterative-solution-beat-99",
                "content": "The idea is to insert new num in the existing permutation to form new permutations.\\n\\nFor example, suppose we need to get all permutation of `[1, 2, 3]`. Assume that we have got the permutation of `[1, 2]`, so `result = [[1, 2], [2, 1]]`. Then we could add 3 to each position of each element of result to get all permutations with number 3. The idea is kind of like BFS. \\n\\nAs a time optimization, we do not actually insert 3 in existing permutation because it takes O(N) for each insertation. We could simply append 3 to the end of [1, 2] and then swap each element with 3 to get new permutation. \\n\\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            new_res = []\\n            for i in range(len(res)):\\n                prev = res[i]\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    new_res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n            res = new_res\\n        return res\\n```\\n\\nThe space could be further optimized by using one array. \\n\\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            size = len(res)\\n            for i in range(size):\\n                prev = res.pop(0)\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n        return res\\n```\\n\\nA little bit slower, since pop(0) also takes O(N), can be avoid by using `deque`  though. \\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            new_res = []\\n            for i in range(len(res)):\\n                prev = res[i]\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    new_res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n            res = new_res\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        res = [[]]\\n        for num in nums:\\n            size = len(res)\\n            for i in range(size):\\n                prev = res.pop(0)\\n                prev.append(num)\\n                for j in range(len(prev)):\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n                    res.append(prev[:])\\n                    prev[j], prev[-1] = prev[-1], prev[j]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850847,
                "title": "easy-explanation-short-code-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to generate all possible permutations of a given set of numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive backtracking approach to generate all the permutations. It starts by fixing the first element of the permutation and then recursively generates the permutations for the remaining elements by swapping the first element with each of the subsequent elements. This process continues until all elements have been considered as the first element.\\n\\n> Inside the \\'solve\\' function:\\n-  It checks if \\'ind\\' is equal to the size of \\'nums\\'. If it is, that means we have formed one permutation, so it adds \\'nums\\' to the \\'res\\' vector and returns from the function.\\n-  Otherwise, it enters a loop starting from the current \\'ind\\' up to the end of the \\'nums\\' vector\\n- Inside the loop, it swaps the elements at \\'ind\\' and \\'i\\' indices to try different possibilities for the first element.\\n-  After swapping, it makes a recursive call to \\'solve\\' with \\'ind+1\\' (moving to the next index) to generate permutations for the remaining elements.\\n\\n`Let\\'s analyze the time complexity of the code. For each element at index \\'ind\\', there are \\'n - ind\\' choices to be made for swapping (where \\'n\\' is the total number of elements). Then, for each choice, we make a recursive call to generate permutations for the remaining elements. Therefore, the time complexity of this algorithm can be expressed as O(n * n!), where \\'n\\' is the number of elements in the input vector \\'nums\\'.`\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*n!)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(int ind ,vector<int>&nums,vector<vector<int>>&res){\\n        if(ind == nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,res);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(0,nums,res);\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void solve(int ind ,vector<int>&nums,vector<vector<int>>&res){\\n        if(ind == nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i=ind ; i<nums.size() ; i++){\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,res);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(0,nums,res);\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909417,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n\\tfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\t\\tvar res: [[Int]] = []\\n        \\n\\n\\t\\tfunc recursion(_ list: [Int], _ rest: [Int]) -> Void {\\n            for (i, item) in rest.enumerated() {\\n\\t\\t\\t\\tvar list = list\\n\\t\\t\\t\\tvar rest = rest\\n\\n\\t\\t\\t\\tlist.append(item)\\n\\t\\t\\t\\trest.remove(at: i)\\n\\t\\t\\t\\tif (list.count == nums.count) { res.append(list) }\\n                recursion(list, rest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trecursion([], nums)\\n\\t\\treturn res\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\t\\tvar res: [[Int]] = []\\n        \\n\\n\\t\\tfunc recursion(_ list: [Int], _ rest: [Int]) -> Void {\\n            for (i, item) in rest.enumerated() {\\n\\t\\t\\t\\tvar list = list\\n\\t\\t\\t\\tvar rest = rest\\n\\n\\t\\t\\t\\tlist.append(item)\\n\\t\\t\\t\\trest.remove(at: i)\\n\\t\\t\\t\\tif (list.count == nums.count) { res.append(list) }\\n                recursion(list, rest)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trecursion([], nums)\\n\\t\\treturn res\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700569,
                "title": "solution-swift-permutations",
                "content": "```swift\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 1 && len <= 6 else { return [] }\\n        \\n        var permutes = [[Int]](repeating: [], count: 1)\\n        \\n        for n in nums where n >= -10 && n <= 10 {\\n            var values: [[Int]] = []\\n            for var arr in permutes {\\n                for i in 0..<arr.count {\\n                    var temp = arr\\n                    temp.insert(n, at: i)\\n                    values.append(temp)\\n                }\\n                arr.append(n)\\n                values.append(arr)\\n            }\\n            permutes = values\\n        }\\n        \\n        return permutes\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 1 && len <= 6 else { return [] }\\n        \\n        var permutes = [[Int]](repeating: [], count: 1)\\n        \\n        for n in nums where n >= -10 && n <= 10 {\\n            var values: [[Int]] = []\\n            for var arr in permutes {\\n                for i in 0..<arr.count {\\n                    var temp = arr\\n                    temp.insert(n, at: i)\\n                    values.append(temp)\\n                }\\n                arr.append(n)\\n                values.append(arr)\\n            }\\n            permutes = values\\n        }\\n        \\n        return permutes\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541908,
                "title": "python-bfs-solution",
                "content": "Python BFS solution\\n\\n```python\\nfrom collections import deque\\ndef permute(self, nums: List[int]) -> List[List[int]]:        \\n\\tif len(nums) <= 1:\\n\\t\\treturn [nums]\\n\\n\\tans = []\\n\\tqueue = deque([([], nums)])\\n\\n\\twhile queue:\\n\\t\\tarr, options = queue.popleft()\\n\\n\\t\\tfor i in range(len(options)):\\n\\t\\t\\tnext_options = options[:i] + options[i+1:]\\n\\t\\t\\tnew_arr = arr + [options[i]]\\n\\n\\t\\t\\tif next_options:\\n\\t\\t\\t\\tqueue.append((new_arr, next_options))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(new_arr)\\n\\n\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Python BFS solution\\n\\n```python\\nfrom collections import deque\\ndef permute(self, nums: List[int]) -> List[List[int]]:        \\n\\tif len(nums) <= 1:\\n\\t\\treturn [nums]\\n\\n\\tans = []\\n\\tqueue = deque([([], nums)])\\n\\n\\twhile queue:\\n\\t\\tarr, options = queue.popleft()\\n\\n\\t\\tfor i in range(len(options)):\\n\\t\\t\\tnext_options = options[:i] + options[i+1:]\\n\\t\\t\\tnew_arr = arr + [options[i]]\\n\\n\\t\\t\\tif next_options:\\n\\t\\t\\t\\tqueue.append((new_arr, next_options))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(new_arr)\\n\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 18486,
                "title": "simple-python-solution-68ms",
                "content": "    def permute(self, nums):\\n        ans = [nums]\\n        for i in xrange(1, len(nums)):\\n            m = len(ans)\\n            for k in xrange(m):\\n                for j in xrange(i):\\n                    ans.append(ans[k][:])\\n                    ans[-1][j], ans[-1][i] = ans[-1][i], ans[-1][j]\\n        return ans\\n\\n\\n    # 25 / 25 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 68 ms\\n    # 99.02%\\n\\nswap unique pairs of numbers for all the answers in pocket to generate new answers.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def permute(self, nums):\\n        ans = [nums]\\n        for i in xrange(1, len(nums)):\\n            m = len(ans)\\n            for k in xrange(m):\\n                for j in xrange(i):\\n                    ans.append(ans[k][:])\\n                    ans[-1][j], ans[-1][i] = ans[-1][i], ans[-1][j]\\n        return ans\\n\\n\\n    # 25 / 25 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 68 ms\\n    # 99.02%\\n\\nswap unique pairs of numbers for all the answers in pocket to generate new answers.",
                "codeTag": "Python3"
            },
            {
                "id": 18459,
                "title": "java-solution-easy-to-understand-backtracking",
                "content": "public class Solution {\\n    \\n    List<List<Integer>> list;\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        list = new ArrayList<>();\\n        ArrayList<Integer> perm = new ArrayList<Integer>();\\n        backTrack(perm,0,nums);\\n        return list;\\n    }\\n    \\n    void backTrack (ArrayList<Integer> perm,int i,int[] nums){\\n        \\n        //Permutation completes\\n        if(i==nums.length){\\n            list.add(new ArrayList(perm));\\n            return;\\n        }\\n        \\n        ArrayList<Integer> newPerm = new ArrayList<Integer>(perm);\\n        \\n       //Insert elements in the array by increasing index\\n        for(int j=0;j<=i;j++){\\n            newPerm.add(j,nums[i]);\\n            backTrack(newPerm,i+1,nums);\\n            newPerm.remove(j);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    List<List<Integer>> list;\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        list = new ArrayList<>();\\n        ArrayList<Integer> perm = new ArrayList<Integer>();\\n        backTrack(perm,0,nums);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3850900,
                "title": "c-python3-java-easy-explanation-with-image-backtracking-solution",
                "content": "# Intuition\\nSince the n is very small we could try all the permutations. \\n\\n# Approach\\nTo solve this problem, we will use a recursive backtracking algorithm. The main idea behind backtracking is to explore all possible combinations by trying out different choices and then undoing those choices if they lead to invalid solutions. We will start with the main array `nums` and swap and permutate it untill we reach our base case.\\n\\n1. Base Case:\\nWe need to identify the base case of the recursion, i.e., when to stop generating permutations. In our case, the base case will be when the i which is the index of the array reaches the end of the array which is `nums.size()`.\\n\\n2. Recursive Function:\\nWe will define a recursive function, let\\'s call it `recur`, which will be responsible for generating the permutations. This function will take the following parameters:\\n   - `nums`: The original array which we will use to generate all the permutations.\\n   - `i`: index of the element at which it is currently present.\\n\\n3. Initialization:\\nWe will start by calling the recursive `recur` function with `nums` and `i` the 0th index at which we are starting.\\n\\n4. Backtracking Algorithm:\\nInside the `recur` function, we will do the following steps:\\n   a. Check the base case: If the length of `i` equals the length of `nums`, add it to the array of valid permutations.\\n   b. Iterate through the `nums` array:\\n      i. Swap the i<sup>th</sup> element with the j<sup>th</sup> element.\\n      ii. Call for the function recursively for the next index which is i + 1.\\n      iii. Backtrack by undoing what we did with swaping back that i<sup>th</sup> element with the j<sup>th</sup> \\n\\nConclusion:\\nBy implementing the above approach, we can efficiently generate all possible permutations of the given array `nums`. The backtracking algorithm ensures that we explore all possible combinations while efficiently avoiding invalid solutions.\\n\\n![Screenshot (462).png](https://assets.leetcode.com/users/images/c6653b56-827d-441a-b4e8-14d5610db238_1690945456.6858256.png)\\n\\n# Complexity\\n- Time complexity: O(n*n!) Note that there are n! permutations and it requires O(n) time to print a permutation.\\n\\n- Space complexity: O(n * n!) in worst case.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void recur(vector<int> nums , int i){\\n        if(i == nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int j = i ; j < nums.size() ; j++){\\n            swap(nums[i] , nums[j]);\\n            recur(nums , i + 1);\\n            swap(nums[i] , nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        recur(nums , 0);\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        \\n        def recur(nums, i):\\n            if i == len(nums):\\n                ans.append(nums[:])\\n                return\\n            \\n            for j in range(i, len(nums)):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                recur(nums, i + 1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n        \\n        recur(nums, 0)\\n        return ans\\n```\\n```Java []\\nclass Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    private void recur(int[] nums, int i) {\\n        if (i == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            ans.add(temp);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++) {\\n            swap(nums, i, j);\\n            recur(nums, i + 1);\\n            swap(nums, i, j);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        recur(nums, 0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void recur(vector<int> nums , int i){\\n        if(i == nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int j = i ; j < nums.size() ; j++){\\n            swap(nums[i] , nums[j]);\\n            recur(nums , i + 1);\\n            swap(nums[i] , nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        recur(nums , 0);\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        \\n        def recur(nums, i):\\n            if i == len(nums):\\n                ans.append(nums[:])\\n                return\\n            \\n            for j in range(i, len(nums)):\\n                nums[i], nums[j] = nums[j], nums[i]\\n                recur(nums, i + 1)\\n                nums[i], nums[j] = nums[j], nums[i]\\n        \\n        recur(nums, 0)\\n        return ans\\n```\n```Java []\\nclass Solution {\\n    private List<List<Integer>> ans = new ArrayList<>();\\n\\n    private void recur(int[] nums, int i) {\\n        if (i == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            ans.add(temp);\\n            return;\\n        }\\n        for (int j = i; j < nums.length; j++) {\\n            swap(nums, i, j);\\n            recur(nums, i + 1);\\n            swap(nums, i, j);\\n        }\\n    }\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n        recur(nums, 0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773139,
                "title": "permutations-java-solution-2-approaches",
                "content": "```\\n1. First Approach :- Generating all permutations\\n\\nTwo Extra Data Structure Required To generate permutation\\n1. ArrayList<> subset //to store subset\\n2. boolean map[]   //this map will tell us which element is pick or not picked at that time\\n\\n//Let\\'s Understand\\nExample :- [1,2,3]\\n\\nfor make permutation we can pick one element from given three element\\n1. if we pick 1 mark in map true ,map[T,F,F] & subset[1]\\n2. if we pick 2 mark in map true , map[F,T,F] & subset[2]\\n3. if we pick 3 mark in map true , map[F,F,T] & subset[3]\\n\\nnow suppose we picked 1 so that our map is map[T,F,F] & subset[1], again for make permutation we can pick one element from \\ngiven three element but this time we already picked 1 so we have only 2 elements remaining\\n1.if we pick 2 mark in map true, map[T,T,F] & subset[1,2]\\n2.if we pick 3 mark in map true, map[T,F,T] & subset[1,3]\\n\\nnow suppose we picked 2 so that our map is map[T,T,F] & subset[1,2], again for make permutation we can pick one element from \\ngiven three element but this time we already picked1 & 2 so we have only 3 remaining\\n1.we picked 3 mark in map true, map[T,T,T] & subset[1,2,3]\\n\\nWhen subset size equal to arra size store the subset into our final ans \\nand same for remaining cases\\n```\\n![image](https://assets.leetcode.com/users/images/9a46ac0c-e3c8-4c42-9567-2c5d1ec73157_1667463248.6818707.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList();\\n        List<Integer> subset = new ArrayList();\\n        boolean map[] = new boolean[nums.length];\\n        helper(nums,subset,ans,map);\\n        return ans;\\n    }\\n    public static void helper(int nums[],List<Integer> subset,List<List<Integer>> ans,boolean map[]){\\n        if(subset.size()==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(!map[i]){\\n                subset.add(nums[i]);\\n                map[i]=true;\\n                helper(nums,subset,ans,map);\\n                subset.remove(subset.size()-1);\\n                map[i]=false;\\n            }\\n        }\\n    }\\n}\\nT.C :- n!(for generating all permutation) * n(for running loop i=0 to nums.length)\\nS.C :- EXTRA SPACE :- n(for subset data structure) + n(for map data structure)\\n      :- Auxillary Space :- recursion stack i.e. O(n)\\n```\\n```\\n2. Second Approach :- Backtracking & Swapping \\n```\\n![image](https://assets.leetcode.com/users/images/e8bfec02-f92d-42ef-a686-1b67ffe210d5_1667464348.8291073.jpeg)\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n          List<List<Integer>> ans = new ArrayList<>();\\n\\t        helper(nums,0,ans);\\n\\t        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans)\\n\\t    {\\n\\t\\t//BASE CASE\\n\\t    \\tif(index==nums.length){\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t        for(int i = index; i<nums.length; i++){\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\nT.C :- n! * n\\nS.C :- Auxillary Space - O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. First Approach :- Generating all permutations\\n\\nTwo Extra Data Structure Required To generate permutation\\n1. ArrayList<> subset //to store subset\\n2. boolean map[]   //this map will tell us which element is pick or not picked at that time\\n\\n//Let\\'s Understand\\nExample :- [1,2,3]\\n\\nfor make permutation we can pick one element from given three element\\n1. if we pick 1 mark in map true ,map[T,F,F] & subset[1]\\n2. if we pick 2 mark in map true , map[F,T,F] & subset[2]\\n3. if we pick 3 mark in map true , map[F,F,T] & subset[3]\\n\\nnow suppose we picked 1 so that our map is map[T,F,F] & subset[1], again for make permutation we can pick one element from \\ngiven three element but this time we already picked 1 so we have only 2 elements remaining\\n1.if we pick 2 mark in map true, map[T,T,F] & subset[1,2]\\n2.if we pick 3 mark in map true, map[T,F,T] & subset[1,3]\\n\\nnow suppose we picked 2 so that our map is map[T,T,F] & subset[1,2], again for make permutation we can pick one element from \\ngiven three element but this time we already picked1 & 2 so we have only 3 remaining\\n1.we picked 3 mark in map true, map[T,T,T] & subset[1,2,3]\\n\\nWhen subset size equal to arra size store the subset into our final ans \\nand same for remaining cases\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList();\\n        List<Integer> subset = new ArrayList();\\n        boolean map[] = new boolean[nums.length];\\n        helper(nums,subset,ans,map);\\n        return ans;\\n    }\\n    public static void helper(int nums[],List<Integer> subset,List<List<Integer>> ans,boolean map[]){\\n        if(subset.size()==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        for(int i=0; i<nums.length; i++){\\n            if(!map[i]){\\n                subset.add(nums[i]);\\n                map[i]=true;\\n                helper(nums,subset,ans,map);\\n                subset.remove(subset.size()-1);\\n                map[i]=false;\\n            }\\n        }\\n    }\\n}\\nT.C :- n!(for generating all permutation) * n(for running loop i=0 to nums.length)\\nS.C :- EXTRA SPACE :- n(for subset data structure) + n(for map data structure)\\n      :- Auxillary Space :- recursion stack i.e. O(n)\\n```\n```\\n2. Second Approach :- Backtracking & Swapping \\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n          List<List<Integer>> ans = new ArrayList<>();\\n\\t        helper(nums,0,ans);\\n\\t        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans)\\n\\t    {\\n\\t\\t//BASE CASE\\n\\t    \\tif(index==nums.length){\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t        for(int i = index; i<nums.length; i++){\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\nT.C :- n! * n\\nS.C :- Auxillary Space - O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961596,
                "title": "c-easy-to-understand-with-diagram-0-ms-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/6d15c5f2-ac03-4b37-821e-9e8a04111124_1650304031.4591222.png)\\n**//image source gfg**\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n\\t\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\t\\tres.push_back(nums);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\tfor(int j=i;j<nums.size();j++){\\n\\t\\t\\t   swap(nums[i],nums[j]);\\n\\t\\t\\t   helper(res,nums,i+1);\\n\\t\\t\\t   swap(nums[i],nums[j]);\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t\\t\\tvector<vector<int>> res;\\n\\t\\t\\t\\thelper(res,nums,0);\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n\\t\\t\\t\\tif(i==nums.size()){\\n\\t\\t\\t\\t\\tres.push_back(nums);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18404,
                "title": "2ms-java-solution-beats-93-i-think-it-could-be-optimized",
                "content": "    public class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tperm(result,nums,0,nums.length-1);\\n\\t\\treturn result;\\n    }\\n    public static void perm(List<List<Integer>> result, int[] nums, int start, int end){\\n\\t\\tif(start==end){\\n\\t\\t\\tInteger[] ele = new Integer[nums.length];\\n\\t\\t\\tfor(int i=0; i<nums.length; i++){\\n\\t\\t\\t\\tele[i] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tresult.add(Arrays.asList(ele));\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tfor(int i=start; i<=end; i++){\\n\\t\\t\\t\\tint temp = nums[start];\\n\\t\\t\\t\\tnums[start] = nums[i];\\n\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tperm(result, nums,start+1,end);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttemp = nums[start];\\n\\t\\t\\t\\tnums[start] = nums[i];\\n\\t\\t\\t\\tnums[i] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n\\t\\tperm(result,nums,0,nums.length-1);\\n\\t\\treturn result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 18540,
                "title": "my-c-solution-share",
                "content": "It is obvious that **N numbers has N! permutations** .\\n\\nHere I assume an empty vector also has one permutation. It seems OJ didn't check the empty input case. Well, it doesn't matter.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n            // Add an empty vector as the base case (empty input)\\n        \\tvector<vector<int> > permutations(1, vector<int>());\\n        \\t// Algrithm description:\\n        \\t//\\tInsert the current number in different spaces of previous permutations\\n        \\tfor (vector<int>::size_type index = 0; index != num.size(); ++index)\\n        \\t{\\n        \\t\\tvector<vector<int> > subPermutations(permutations);\\n        \\t\\tpermutations.clear();\\n        \\t\\tfor (vector<vector<int> >::size_type i = 0; i != subPermutations.size(); ++i)\\n        \\t\\t{\\n        \\t\\t\\tfor (int offset = 0; offset != subPermutations[i].size()+1; ++offset)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\tvector<int> temp(subPermutations[i]);\\n        \\t\\t\\t\\ttemp.insert(temp.begin() + offset, num[index]);\\n        \\t\\t\\t\\tpermutations.push_back(temp);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn permutations;\\n        }\\n    };\\n\\nAll comments are welcome !",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n            // Add an empty vector as the base case (empty input)\\n        \\tvector<vector<int> > permutations(1, vector<int>());\\n        \\t// Algrithm description:\\n        \\t//\\tInsert the current number in different spaces of previous permutations\\n        \\tfor (vector<int>::size_type index = 0; index != num.size(); ++index)\\n        \\t{\\n        \\t\\tvector<vector<int> > subPermutations(permutations);\\n        \\t\\tpermutations.clear();\\n        \\t\\tfor (vector<vector<int> >::size_type i = 0; i != subPermutations.size(); ++i)\\n        \\t\\t{\\n        \\t\\t\\tfor (int offset = 0; offset != subPermutations[i].size()+1; ++offset)\\n        \\t\\t\\t{\\n        \\t\\t\\t\\tvector<int> temp(subPermutations[i]);\\n        \\t\\t\\t\\ttemp.insert(temp.begin() + offset, num[index]);\\n        \\t\\t\\t\\tpermutations.push_back(temp);\\n        \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2844437,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-only-4-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        do {\\n            ans.push_back(nums);\\n        } while (next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        do {\\n            ans.push_back(nums);\\n        } while (next_permutation(nums.begin(),nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542099,
                "title": "javascript-dfs-backtracking-with-heavy-comments",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = (nums) => {\\n    // Backtracking\\n    const used = new Set(); // Keep track of what we have used\\n    const path = []; // Current potiential answer array\\n    const res = []; // Result array to be returned\\n    \\n    const dfs = () => {\\n        // If path is same length as nums, we know we have an answer. Push it to res array\\n        if(path.length === nums.length) {\\n            res.push([...path]); // We use spread operator to clone since arrays are pass by reference\\n        }\\n        \\n        // Every DFS we loop all numbers\\n        for(let i = 0; i < nums.length; i++) {\\n            // We can skip these numbers if they have been used\\n            if(used.has(nums[i])) continue;\\n            \\n            // Add to our potienial answer array and make it used by adding to used set\\n            path.push(nums[i]);\\n            used.add(nums[i]);\\n            \\n            // After adding, we call DFS again. DFS will continue till we hit the base case above\\n\\t\\t\\t// Think of this as just continuing down a path till we have an answer\\n            dfs();\\n            \\n            // Once we pop out of DFS, we need to remove from path array and remove from used Set\\n            // This will let it be used later in further paths\\n            path.pop();\\n            used.delete(nums[i])\\n        }\\n        \\n    }\\n    \\n    // Start DFS\\n    // All variables are global, no need to pass in anything\\n    dfs();\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nconst permute = (nums) => {\\n    // Backtracking\\n    const used = new Set(); // Keep track of what we have used\\n    const path = []; // Current potiential answer array\\n    const res = []; // Result array to be returned\\n    \\n    const dfs = () => {\\n        // If path is same length as nums, we know we have an answer. Push it to res array\\n        if(path.length === nums.length) {\\n            res.push([...path]); // We use spread operator to clone since arrays are pass by reference\\n        }\\n        \\n        // Every DFS we loop all numbers\\n        for(let i = 0; i < nums.length; i++) {\\n            // We can skip these numbers if they have been used\\n            if(used.has(nums[i])) continue;\\n            \\n            // Add to our potienial answer array and make it used by adding to used set\\n            path.push(nums[i]);\\n            used.add(nums[i]);\\n            \\n            // After adding, we call DFS again. DFS will continue till we hit the base case above\\n\\t\\t\\t// Think of this as just continuing down a path till we have an answer\\n            dfs();\\n            \\n            // Once we pop out of DFS, we need to remove from path array and remove from used Set\\n            // This will let it be used later in further paths\\n            path.pop();\\n            used.delete(nums[i])\\n        }\\n        \\n    }\\n    \\n    // Start DFS\\n    // All variables are global, no need to pass in anything\\n    dfs();\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074177,
                "title": "mathematical-proof-that-time-complexity-is-o-e-n-not-o-n-n",
                "content": "I have seen a lot of answers here that simply state the time complexity is `O(n*n!)` but the justification isn\\'t too well explained. Here I show a better approximation for the time complexity is actually `O(e*n!)`.\\n\\nFirst we must visualise the recursion tree (see other answers for recursive solution), the tree below shows the recursion for `n=4`. On the first layer of the tree we have `n` possible options to choose from, so we make `n` function calls and have `n` nodes in our tree. Now we have n partial permutations built up so far and have `n-1` numbers to choose from, so the next layer in our tree will have `n*(n-1)` nodes. The layer after this will have `n*(n-1)*(n-2)` nodes and so on and so forth. Until we have `n!` leaf nodes at the bottom of our tree. At this point it is obvious to see `O(n*n!)` is an over estimate for the time complexity of this algorithm, as it implies each layer (there are `n` in total) has `n!` nodes.\\n\\nWe know the time complexity of a recursive algorithm is the number of nodes in its recursion tree multiplied by the cost of computation at each node. At each node in our tree we either call the dfs function recursively (non-leaf nodes) or add to the results array, both of these operations are `O(1)`, hence the time complexity is equal to the number of nodes in the recursion tree.\\n\\nNow for the magic, if we sum up the nodes in each layer of the recursion tree we get to the expression:\\n\\n`O(n) = 1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n!`\\n\\nIf we reverse the order of terms in this series and factor out `n!` we get:\\n\\n`O(n) = n!(1/1! + 1/2! + 1/3! + ... + 1/n!)`\\n\\nNotice the second term is the series representation of `e`, so we have:\\n\\n`O(n) = e * n!`\\n\\n![image](https://assets.leetcode.com/users/images/824a0380-cf67-4058-89c1-fb98ba79da68_1653524447.4704807.png)\\n\\nHere are some calculations for n = 1-10, of actual nodes in recursion tree (calculating the first summation expression in a while loop) vs `e*n!` vs `n*n!`:\\n\\n```\\nn    actual    e*n!      n*n!\\n1    1         2         1\\n2    4         5         4\\n3    15        16        18\\n4    64        65        96\\n5    325       326       600\\n6    1956      1957      4320\\n7    13699     13700     35280\\n8    109600    109601    322560\\n9    986409    986410    3265920\\n10   9864100   9864101   36288000\\n```\\n",
                "solutionTags": [],
                "code": "```\\nn    actual    e*n!      n*n!\\n1    1         2         1\\n2    4         5         4\\n3    15        16        18\\n4    64        65        96\\n5    325       326       600\\n6    1956      1957      4320\\n7    13699     13700     35280\\n8    109600    109601    322560\\n9    986409    986410    3265920\\n10   9864100   9864101   36288000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690075,
                "title": "golang-beats-100-recursion-explanation",
                "content": "```\\n// To solve this problem we can use recursion.\\n// If we think about it, a combination is valid when it has the same length of the input.\\n// So, all we need to do is, have a concept of current combination (left) and left items (right)\\n// that we need to analyse every time. We start with empty current combination and left will be equal to the input.\\n//\\n// E.G. current: []; left: [1, 2, 3]\\n// Then we would have current: [1]; left: [2, 3], current: [2]; left: [1, 3], current: [3]; left: [1, 2]\\n// \\n// The recursion tree looks like:\\n//\\n// - ([],[1, 2, 3])\\n// - ([1],[2,3]); ([2],[1, 3]); ([3],[2, 1])\\n// - ([1,2],[3]); ([1,3],[2]); ([2,1],[3]); ([2,3],[1]); ([3,2],[1]); ([3,1],[2])\\n// - ([1,2,3]); ([1,3,2]); ([2,1,3]); ([2,3,1]); ([3,2,1]); ([3,1,2])\\n//\\n// T: O(n!)\\n// S: O(n!)\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\tpermuteRec([]int{}, nums, &res)\\n\\treturn res\\n}\\n\\n// We use a pointer for the result so we don\\'t need to worry returning it.\\nfunc permuteRec(currComb, left []int, res *[][]int) {\\n\\t// We know that we found a new combination when we have no elements left.\\n\\tif 0 == len(left) {\\n\\t\\t*res = append(*res, currComb)\\n\\t\\treturn\\n\\t}\\n\\t// For the next iteration we consider all the left elements but the current one (idx).\\n\\tfor idx, l := range left {\\n\\t\\tpermuteRec(\\n\\t\\t\\tappend(currComb, l),\\n\\t\\t\\tappend(append([]int{}, left[:idx]...), left[idx+1:]...), // Make sure to allocate a new slice.\\n\\t\\t\\tres,\\n\\t\\t)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n// To solve this problem we can use recursion.\\n// If we think about it, a combination is valid when it has the same length of the input.\\n// So, all we need to do is, have a concept of current combination (left) and left items (right)\\n// that we need to analyse every time. We start with empty current combination and left will be equal to the input.\\n//\\n// E.G. current: []; left: [1, 2, 3]\\n// Then we would have current: [1]; left: [2, 3], current: [2]; left: [1, 3], current: [3]; left: [1, 2]\\n// \\n// The recursion tree looks like:\\n//\\n// - ([],[1, 2, 3])\\n// - ([1],[2,3]); ([2],[1, 3]); ([3],[2, 1])\\n// - ([1,2],[3]); ([1,3],[2]); ([2,1],[3]); ([2,3],[1]); ([3,2],[1]); ([3,1],[2])\\n// - ([1,2,3]); ([1,3,2]); ([2,1,3]); ([2,3,1]); ([3,2,1]); ([3,1,2])\\n//\\n// T: O(n!)\\n// S: O(n!)\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\tpermuteRec([]int{}, nums, &res)\\n\\treturn res\\n}\\n\\n// We use a pointer for the result so we don\\'t need to worry returning it.\\nfunc permuteRec(currComb, left []int, res *[][]int) {\\n\\t// We know that we found a new combination when we have no elements left.\\n\\tif 0 == len(left) {\\n\\t\\t*res = append(*res, currComb)\\n\\t\\treturn\\n\\t}\\n\\t// For the next iteration we consider all the left elements but the current one (idx).\\n\\tfor idx, l := range left {\\n\\t\\tpermuteRec(\\n\\t\\t\\tappend(currComb, l),\\n\\t\\t\\tappend(append([]int{}, left[:idx]...), left[idx+1:]...), // Make sure to allocate a new slice.\\n\\t\\t\\tres,\\n\\t\\t)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18378,
                "title": "simple-python-code-without-recursion",
                "content": "    class Solution(object):\\n        def permute(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            def swap(i, j, nums):\\n                new_nums = list(nums)\\n                new_nums[i], new_nums[j] = new_nums[j], new_nums[i]\\n                return new_nums\\n    \\n            result = [nums,]\\n    \\n            for i in range(len(nums)-1):\\n                for one in result[:]:\\n                    for j in range(i+1, len(nums)):\\n                        result.append(swap(i, j, one))\\n    \\n            return result",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def permute(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[List[int]]\\n            \"\"\"\\n            def swap(i, j, nums):\\n                new_nums = list(nums)\\n                new_nums[i], new_nums[j] = new_nums[j], new_nums[i]\\n                return new_nums\\n    \\n            result = [nums,]\\n    \\n            for i in range(len(nums)-1):\\n                for one in result[:]:\\n                    for j in range(i+1, len(nums)):\\n                        result.append(swap(i, j, one))\\n    \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3851730,
                "title": "c-bits-approach-recursion-day-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int mask,vector<int>&v,vector<int>&temp){\\n        if(mask==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(mask & (1<<i)){\\n                temp.push_back(v[i]);\\n                help(mask ^ (1<<i), v,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& v) {\\n        vector<int>temp;\\n        help((1<<v.size())-1,v,temp);\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/531dcc09-5c89-4f76-855e-433d650af579_1690959144.8366618.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(int mask,vector<int>&v,vector<int>&temp){\\n        if(mask==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(mask & (1<<i)){\\n                temp.push_back(v[i]);\\n                help(mask ^ (1<<i), v,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& v) {\\n        vector<int>temp;\\n        help((1<<v.size())-1,v,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851090,
                "title": "very-simple-c-c-java-python3-codes-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to generate all possible permutations of a given array of distinct integers. A permutation is an arrangement of elements in a specific order. For example, given the array [1, 2, 3], the permutations are [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]].\\n\\nTo solve this problem, we can use a recursive approach known as backtracking. The intuition behind the backtracking approach is to try out all possible combinations by swapping elements to find the different arrangements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a helper function that takes the current index as a parameter and generates permutations for the remaining elements.\\n- The base case for recursion is when the current index reaches the end of the array. At this point, we have a valid permutation, so we add it to the result list.\\n- For each index from the current position, swap the element at the current index with the element at the current position, and then recursively generate permutations for the rest of the array.\\n- After the recursive call, swap the elements back to their original positions to restore the original array for further exploration.\\n\\n# Complexity\\n- Time complexity: **O(n!)** We have to generate all possible permutations, and there are n! permutations for an array of size n.\\n\\n- Space complexity:**O(n)** The space required for recursion depth and the result list\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generatePermutations(vector<int>& nums, int index, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            swap(nums[index], nums[i]);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums[index], nums[i]); // Backtrack\\n        }\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\n    private void generatePermutations(int[] nums, int index, List<List<Integer>> result) {\\n        if (index == nums.length) {\\n            List<Integer> currentPerm = new ArrayList<>();\\n            for (int num : nums) {\\n                currentPerm.add(num);\\n            }\\n            result.add(currentPerm);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.length; i++) {\\n            swap(nums, index, i);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums, index, i); // Backtrack\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\\n## Python3\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def generate_permutations(index):\\n            if index == len(nums):\\n                result.append(nums.copy())\\n                return\\n            \\n            for i in range(index, len(nums)):\\n                nums[index], nums[i] = nums[i], nums[index]\\n                generate_permutations(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index]  # Backtrack\\n        \\n        result = []\\n        generate_permutations(0)\\n        return result\\n```\\n## C\\n```\\nvoid swap(int* nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\nvoid generatePermutations(int* nums, int numsSize, int index, int** result, int* returnSize, int** returnColumnSizes) {\\n    if (index == numsSize) {\\n        result[*returnSize] = malloc(numsSize * sizeof(int));\\n        memcpy(result[*returnSize], nums, numsSize * sizeof(int));\\n        (*returnColumnSizes)[*returnSize] = numsSize;\\n        (*returnSize)++;\\n        return;\\n    }\\n\\n    for (int i = index; i < numsSize; i++) {\\n        swap(nums, index, i);\\n        generatePermutations(nums, numsSize, index + 1, result, returnSize, returnColumnSizes);\\n        swap(nums, index, i); // Backtrack\\n    }\\n}\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }\\n\\n    int** result = (int**)malloc(totalPermutations * sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(totalPermutations * sizeof(int));\\n    *returnSize = 0;\\n\\n    generatePermutations(nums, numsSize, 0, result, returnSize, returnColumnSizes);\\n    return result;\\n}\\n```\\n\\n![upvote img.jpg](https://assets.leetcode.com/users/images/98fa308e-0a58-4b30-a602-c745ada9c64c_1690950320.6229887.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void generatePermutations(vector<int>& nums, int index, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); ++i) {\\n            swap(nums[index], nums[i]);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums[index], nums[i]); // Backtrack\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        generatePermutations(nums, 0, result);\\n        return result;\\n    }\\n\\n    private void generatePermutations(int[] nums, int index, List<List<Integer>> result) {\\n        if (index == nums.length) {\\n            List<Integer> currentPerm = new ArrayList<>();\\n            for (int num : nums) {\\n                currentPerm.add(num);\\n            }\\n            result.add(currentPerm);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.length; i++) {\\n            swap(nums, index, i);\\n            generatePermutations(nums, index + 1, result);\\n            swap(nums, index, i); // Backtrack\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def generate_permutations(index):\\n            if index == len(nums):\\n                result.append(nums.copy())\\n                return\\n            \\n            for i in range(index, len(nums)):\\n                nums[index], nums[i] = nums[i], nums[index]\\n                generate_permutations(index + 1)\\n                nums[index], nums[i] = nums[i], nums[index]  # Backtrack\\n        \\n        result = []\\n        generate_permutations(0)\\n        return result\\n```\n```\\nvoid swap(int* nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\nvoid generatePermutations(int* nums, int numsSize, int index, int** result, int* returnSize, int** returnColumnSizes) {\\n    if (index == numsSize) {\\n        result[*returnSize] = malloc(numsSize * sizeof(int));\\n        memcpy(result[*returnSize], nums, numsSize * sizeof(int));\\n        (*returnColumnSizes)[*returnSize] = numsSize;\\n        (*returnSize)++;\\n        return;\\n    }\\n\\n    for (int i = index; i < numsSize; i++) {\\n        swap(nums, index, i);\\n        generatePermutations(nums, numsSize, index + 1, result, returnSize, returnColumnSizes);\\n        swap(nums, index, i); // Backtrack\\n    }\\n}\\n\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\\n    int totalPermutations = 1;\\n    for (int i = 1; i <= numsSize; i++) {\\n        totalPermutations *= i;\\n    }\\n\\n    int** result = (int**)malloc(totalPermutations * sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(totalPermutations * sizeof(int));\\n    *returnSize = 0;\\n\\n    generatePermutations(nums, numsSize, 0, result, returnSize, returnColumnSizes);\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850454,
                "title": "100-backtracking-recursive-approach-unlocking-permutations",
                "content": "# Intuition\\nThe problem requires generating all possible permutations of a given array of distinct integers. A clear and intuitive understanding of the recursive approach can be achieved by watching vanAmsen\\'s video explanation, where the permutations are constructed by choosing one element at a time and recursively calling the function on the remaining elements. The video thoroughly explains the underlying logic and how to implement it in code. Special thanks to vanAmsen for the insightful explanation! [Watch the video here](https://youtu.be/Jlw0sIGdS_4).\\n\\n\\n# Approach\\n1. We define a recursive function `backtrack` that takes the current numbers and the path of the permutation being constructed.\\n2. In the base case, if there are no numbers left, we append the current path to the result list.\\n3. We iterate through the numbers, and for each number, we add it to the current path and recursively call `backtrack` with the remaining numbers (excluding the current number).\\n4. We initialize an empty result list and call the `backtrack` function with the original numbers and an empty path to start the process.\\n5. The result list will contain all the permutations, and we return it.\\n\\n# Complexity\\n- Time complexity: \\\\(O(n!)\\\\)\\n  - We generate \\\\(n!\\\\) permutations, where \\\\(n\\\\) is the length of the input list.\\n\\n- Space complexity: \\\\(O(n)\\\\)\\n  - The maximum depth of the recursion is \\\\(n\\\\), and we use additional space for the current path and slicing operations.\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\nvar permute = function(nums) {\\n    let result = []; \\n    permuteRec(nums, 0, result); \\n    return result; \\n             \\n};\\n\\nfunction permuteRec(nums, begin, result) {  \\n    if (begin === nums.length) { \\n            result.push(nums.slice()); \\n        return; \\n    } \\n    for (let i = begin; i < nums.length; i++) { \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n        permuteRec(nums, begin + 1, result); \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n    } \\n} \\n```\\n``` C# []\\npublic class Solution {\\n    public void PermuteRec(int[] nums, int begin, IList<IList<int>> result) {\\n        if (begin == nums.Length) {\\n            var temp = new List<int>(nums);\\n            result.Add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.Length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            PermuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        PermuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\nvar permute = function(nums) {\\n    let result = []; \\n    permuteRec(nums, 0, result); \\n    return result; \\n             \\n};\\n\\nfunction permuteRec(nums, begin, result) {  \\n    if (begin === nums.length) { \\n            result.push(nums.slice()); \\n        return; \\n    } \\n    for (let i = begin; i < nums.length; i++) { \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n        permuteRec(nums, begin + 1, result); \\n        [nums[begin], nums[i]] = [nums[i], nums[begin]];  \\n    } \\n} \\n```\n``` C# []\\npublic class Solution {\\n    public void PermuteRec(int[] nums, int begin, IList<IList<int>> result) {\\n        if (begin == nums.Length) {\\n            var temp = new List<int>(nums);\\n            result.Add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.Length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            PermuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        PermuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297287,
                "title": "simple-python-solution-beats-99-with-comments",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \\n        res = []\\n        def dfs(path, num): # record the path and remaining numbers\\n            if not num:\\n                res.append(path)    # When finished iterating, append path to result\\n                return\\n            for i in range(len(num)):\\n                dfs(path + [num[i]], num[:i] + num[i + 1:]) \\n                # append the current number to path and iterate with the unused numbers\\n        \\n        dfs([], nums)\\n        return res  # return results\\n    \\n    #If you find this solution helpful, please upvote :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \\n        res = []\\n        def dfs(path, num): # record the path and remaining numbers\\n            if not num:\\n                res.append(path)    # When finished iterating, append path to result\\n                return\\n            for i in range(len(num)):\\n                dfs(path + [num[i]], num[:i] + num[i + 1:]) \\n                # append the current number to path and iterate with the unused numbers\\n        \\n        dfs([], nums)\\n        return res  # return results\\n    \\n    #If you find this solution helpful, please upvote :)",
                "codeTag": "Java"
            },
            {
                "id": 1564505,
                "title": "java-easy-solution-recursion-and-backtracking",
                "content": "**Code**\\n\\n```java\\npublic List<List<Integer>> permute(int[] nums) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tpermuteUtil(list, new ArrayList<>(), nums);\\n\\treturn list;\\n}\\n\\npublic void permuteUtil(List<List<Integer>> list, List<Integer> temp, int[] nums) {\\n\\t//base case\\n\\tif(temp.size() == nums.length) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t//recursive case\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif(temp.contains(nums[i])) continue;\\n\\t\\ttemp.add(nums[i]);\\n\\t\\tpermuteUtil(list, temp, nums);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\\n\\n**Explanation**\\nThis is a standard problem and this approach is used in a variety of problems, I\\'ve explained the approach there, do check them out, the problems are as follows:-\\n- [Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1560722/java-easy-solution-100-faster-recursion-and-backtracking)\\n- [Combination Sum 2](https://leetcode.com/problems/combination-sum-ii/discuss/1560743/java-easy-solution-with-explanation-recursion-and-backtracking)\\n- [Subsets](https://leetcode.com/problems/subsets/)\\n- [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/discuss/1561260/java-easy-solution-recursion-and-backtracking)\\n\\nThanks",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\npublic List<List<Integer>> permute(int[] nums) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tpermuteUtil(list, new ArrayList<>(), nums);\\n\\treturn list;\\n}\\n\\npublic void permuteUtil(List<List<Integer>> list, List<Integer> temp, int[] nums) {\\n\\t//base case\\n\\tif(temp.size() == nums.length) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t//recursive case\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tif(temp.contains(nums[i])) continue;\\n\\t\\ttemp.add(nums[i]);\\n\\t\\tpermuteUtil(list, temp, nums);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463162,
                "title": "c-clean-code-two-approaches-with-proper-comments",
                "content": "Approach 1\\n\\nusing a freq array to store the number visited because it should not be included again in the answer\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,vector<int>&v,vector<vector<int>>&ans,int freq[])\\n    {\\n        if(v.size()==nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }  \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!freq[i])\\n            {\\n               freq[i]=1;  //marking that number as visited\\n                v.push_back(nums[i]); //pushing the number in vector\\n                solve(nums,v,ans,freq); \\n                freq[i]=0; //after recursive call is finished mark it as unvisited so that it can be considered for other permutation\\n                v.pop_back(); // pop it otherwise it will remain a part of other permutations too\\n            }   \\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n     vector<int>v;\\n        vector<vector<int>>ans;\\n        int n=nums.size();\\n        int freq[n];\\n        for(int i=0;i<n;i++)freq[i]=0; //initialisation of freq array\\n        solve(nums,v,ans,freq);\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2\\n\\nWithout freq array, by swapping two numbers \\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>& nums,vector<vector<int>>&ans)\\n    {\\n        if(ind==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n       for(int i=ind;i<nums.size();i++)\\n       {\\n           swap(nums[i],nums[ind]);  \\n           solve(ind+1,nums,ans); //ind is increased by one so that swapping is done with next index element in further calls\\n            swap(nums[i],nums[ind]); // swapping it back to original order after recursion call is over\\n       }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>ans;\\n\\t   solve(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like my solution",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& nums,vector<int>&v,vector<vector<int>>&ans,int freq[])\\n    {\\n        if(v.size()==nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }  \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!freq[i])\\n            {\\n               freq[i]=1;  //marking that number as visited\\n                v.push_back(nums[i]); //pushing the number in vector\\n                solve(nums,v,ans,freq); \\n                freq[i]=0; //after recursive call is finished mark it as unvisited so that it can be considered for other permutation\\n                v.pop_back(); // pop it otherwise it will remain a part of other permutations too\\n            }   \\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n     vector<int>v;\\n        vector<vector<int>>ans;\\n        int n=nums.size();\\n        int freq[n];\\n        for(int i=0;i<n;i++)freq[i]=0; //initialisation of freq array\\n        solve(nums,v,ans,freq);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>& nums,vector<vector<int>>&ans)\\n    {\\n        if(ind==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n       for(int i=ind;i<nums.size();i++)\\n       {\\n           swap(nums[i],nums[ind]);  \\n           solve(ind+1,nums,ans); //ind is increased by one so that swapping is done with next index element in further calls\\n            swap(nums[i],nums[ind]); // swapping it back to original order after recursion call is over\\n       }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>ans;\\n\\t   solve(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172632,
                "title": "python-dfs-bfs",
                "content": "### 46. Permutations\n[此题收录在Github](https://github.com/yuzhoujr/leetcode/issues/33)\n#### DFS\n\n```python\nclass Solution:\n    def permute(self, nums):\n        self.res = []\n        self.dfs(nums, [])\n        return self.res\n    \n    def dfs(self, nums, temp):\n        if len(nums) == len(temp):\n            self.res.append(temp[:])\n            return\n        \n        for i in range(len(nums)):\n            if nums[i] in temp: continue\n            temp.append(nums[i])\n            self.dfs(nums, temp)\n            temp.pop()\n```\n\n#### BFS (Using Deque)\n\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/permu.jpg)\n\n先把起始状态的`queue`存好: `[[1],[2],[3]]`\n\n`while`这一层检查我们`queue`里面是否有比input `nums`长度小的单位，如果有的话，咱还有针对这个`queue`里面的元素进行增值。\n\n`for`这一层把pop()出来的数组`temp`，进行去重比对，如果发现`nums`里面的元素没有出现在`temp`，代表着这是unique的，我们这个数组的的copy `temp[:]`加上当前的值，放回`queue`中。\n\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = deque()\n        for num in nums:\n            q.append([num])\n\n        while len(min(q,key=len)) < len(nums):\n            temp = q.popleft()\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return list(q)\n```\n\n#### BFS (Acting like using Deque)\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = [[num] for num in nums]\n        while len(min(q,key=len)) < len(nums):\n            temp = q.pop(0)\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return q\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def permute(self, nums):\n        self.res = []\n        self.dfs(nums, [])\n        return self.res\n    \n    def dfs(self, nums, temp):\n        if len(nums) == len(temp):\n            self.res.append(temp[:])\n            return\n        \n        for i in range(len(nums)):\n            if nums[i] in temp: continue\n            temp.append(nums[i])\n            self.dfs(nums, temp)\n            temp.pop()\n```\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = deque()\n        for num in nums:\n            q.append([num])\n\n        while len(min(q,key=len)) < len(nums):\n            temp = q.popleft()\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return list(q)\n```\n```python\nfrom collections import deque\nclass Solution:\n    def permute(self, nums):\n        q = [[num] for num in nums]\n        while len(min(q,key=len)) < len(nums):\n            temp = q.pop(0)\n            for num in nums:\n                if num in temp: continue\n                q.append(temp[:] + [num])\n        return q\n```",
                "codeTag": "Java"
            },
            {
                "id": 18414,
                "title": "accepted-as-best-in-c",
                "content": "    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void search(int* nums, int size, int*** arr, int* returnSize, int begin, int end)\\n    {\\n        if(begin == end)\\n        {\\n            (*returnSize)++;\\n            *arr = (int**)realloc(*arr, sizeof(int*)*(*returnSize));\\n            (*arr)[*returnSize-1] = (int*)malloc(sizeof(int)*size);\\n            for(int i = 0; i < size; i++)\\n                (*arr)[*returnSize-1][i] = nums[i];\\n            return;\\n        }\\n        for(int i = begin; i <= end; i++)\\n        {\\n            swap(nums+begin, nums+i); //try to use each element as the head;\\n            search(nums, size, arr, returnSize, begin+1, end);\\n            swap(nums+begin, nums+i);\\n        }\\n    }\\n    \\n    //AC - 4ms;\\n    int** permute(int* nums, int size, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        int** arr = (int**)malloc(sizeof(int*));\\n        search(nums, size, &arr, returnSize, 0, size-1);\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void search(int* nums, int size, int*** arr, int* returnSize, int begin, int end)\\n    {\\n        if(begin == end)\\n        {\\n            (*returnSize)++;\\n            *arr = (int**)realloc(*arr, sizeof(int*)*(*returnSize));\\n            (*arr)[*returnSize-1] = (int*)malloc(sizeof(int)*size);\\n            for(int i = 0; i < size; i++)\\n                (*arr)[*returnSize-1][i] = nums[i];\\n            return;\\n        }\\n        for(int i = begin; i <= end; i++)\\n        {\\n            swap(nums+begin, nums+i); //try to use each element as the head;\\n            search(nums, size, arr, returnSize, begin+1, end);\\n            swap(nums+begin, nums+i);\\n        }\\n    }\\n    \\n    //AC - 4ms;\\n    int** permute(int* nums, int size, int* returnSize)\\n    {\\n        *returnSize = 0;\\n        int** arr = (int**)malloc(sizeof(int*));\\n        search(nums, size, &arr, returnSize, 0, size-1);\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18546,
                "title": "accepted-recursive-solution-in-java",
                "content": "    int len;\\n    boolean[] used;\\n    List<List<Integer>> result;\\n    List<Integer> temp;\\n    public List<List<Integer>> permute(int[] num) {\\n        len = num.length;\\n        used = new boolean[len];\\n        result = new ArrayList<List<Integer>>();\\n        temp = new ArrayList<>();\\n        doPermute(num, 0);\\n\\n        return result;\\n    }\\n\\n    public void doPermute(int[] in, int level) {\\n        if (level == len) {\\n            result.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (used[i]) {\\n                continue;\\n            }\\n\\n            temp.add(in[i]);\\n            used[i] = true;\\n            doPermute(in, level + 1);\\n            used[i] = false;\\n            temp.remove(level);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "    int len;\\n    boolean[] used;\\n    List<List<Integer>> result;\\n    List<Integer> temp;\\n    public List<List<Integer>> permute(int[] num) {\\n        len = num.length;\\n        used = new boolean[len];\\n        result = new ArrayList<List<Integer>>();\\n        temp = new ArrayList<>();\\n        doPermute(num, 0);\\n\\n        return result;\\n    }\\n\\n    public void doPermute(int[] in, int level) {\\n        if (level == len) {\\n            result.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (used[i]) {\\n                continue;\\n            }\\n\\n            temp.add(in[i]);\\n            used[i] = true;\\n            doPermute(in, level + 1);\\n            used[i] = false;\\n            temp.remove(level);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 996115,
                "title": "java-4-approaches-visuals-time-complexity-analysis",
                "content": "- **For Python implementation (AND/OR) a more detailed explanation and visuals -> checkout this post:**\\nhttps://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis\\n\\n- **For JAVA implementation => scroll down**\\n------------------------\\n\\n**Recursive with backtracking**\\n--------------\\n-------------\\n\\n```\\n/*\\n    Recursive with backtracking\\n*/\\n\\nclass Solution {\\n\\n    // helper\\n    public List<List<Integer>> recursive(List<Integer> numsLst, List<List<Integer>> res, List<Integer> path) {\\n        \\n        if (numsLst.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        }\\n        else {\\n            for (int i=0; i<numsLst.size(); i++) {\\n                List<Integer> newNumsLst = new ArrayList(numsLst);\\n                newNumsLst.remove(i);\\n                path.add(numsLst.get(i));\\n                recursive(newNumsLst, res, path);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        // a turn around is to instantiate vars here - equivalent to Pythonic optional vars \\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> path = new ArrayList();\\n        \\n        // convert array to list\\n        List<Integer> numsLst = new ArrayList<Integer>();\\n        for (int num: nums) {\\n            numsLst.add(num);\\n        }\\n        \\n        // call helper\\n        return recursive(numsLst, res, path);\\n        \\n    }\\n}\\n```\\n------------------------\\n\\n**Recursive without backtracking**\\n--------------\\n----------\\n\\n```\\n/*\\n    Recursive without backtracking\\n*/\\nclass Solution {\\n    \\n    // helper to convert array to arrayList\\n    public List<Integer> toArrayList(int[] arr) {\\n        List<Integer> l = new ArrayList();\\n        for (int num : arr) {\\n            l.add(num);\\n        }\\n        return l;\\n    }\\n    \\n    public List<List<Integer>> recursive(List<Integer> nums, List<List<Integer>> res, List<Integer> path) {\\n        if (nums.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        } else {\\n            for (int i=0; i<nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(nums); // copy\\n                newNums.remove(i); // remove takes an index\\n                \\n                List<Integer> newPath = new ArrayList(path);\\n                path.add(nums.get(i)); \\n                recursive(newNums, res, newPath);\\n                // no backtracking needed\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n        return recursive(numsLst, res, path);\\n    }\\n}\\n```\\n------------------------\\n\\n**Iterative DFS**\\n--------------\\n----------\\n\\n```\\n/*\\n    Iterative DFS\\n*/\\n\\nclass Node {\\n    List<Integer> nums;\\n    List<Integer> path;\\n    \\n    // Constructor\\n    Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // helper\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        List<List<Integer>> res = new ArrayList();\\n        Stack<Node> stack = new Stack();\\n        List<Integer> path = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        Node node = new Node(numsLst, path);\\n        stack.push(node);\\n        \\n        while (!stack.isEmpty()) {\\n            node = stack.pop();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            \\n            for (int i=0; i<node.nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                stack.push(newNode);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\n------------------------\\n\\n**Iterative DFS**\\n--------------\\n----------\\n\\n```\\n/*\\n    Iterative BFS\\n*/\\n\\nclass Node {\\n    List<Integer> path;\\n    List<Integer> nums;\\n    \\n    // Constructor\\n    public Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        Deque<Node> q = new ArrayDeque<>();\\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        Node node = new Node(numsLst, path);\\n        q.add(node);\\n        while (!q.isEmpty()) {\\n            node = q.pollFirst();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            for (int i=0; i< node.nums.size(); i++) {\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                q.add(newNode);\\n            }\\n        }\\n        return res;\\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    Recursive with backtracking\\n*/\\n\\nclass Solution {\\n\\n    // helper\\n    public List<List<Integer>> recursive(List<Integer> numsLst, List<List<Integer>> res, List<Integer> path) {\\n        \\n        if (numsLst.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        }\\n        else {\\n            for (int i=0; i<numsLst.size(); i++) {\\n                List<Integer> newNumsLst = new ArrayList(numsLst);\\n                newNumsLst.remove(i);\\n                path.add(numsLst.get(i));\\n                recursive(newNumsLst, res, path);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        // a turn around is to instantiate vars here - equivalent to Pythonic optional vars \\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> path = new ArrayList();\\n        \\n        // convert array to list\\n        List<Integer> numsLst = new ArrayList<Integer>();\\n        for (int num: nums) {\\n            numsLst.add(num);\\n        }\\n        \\n        // call helper\\n        return recursive(numsLst, res, path);\\n        \\n    }\\n}\\n```\n```\\n/*\\n    Recursive without backtracking\\n*/\\nclass Solution {\\n    \\n    // helper to convert array to arrayList\\n    public List<Integer> toArrayList(int[] arr) {\\n        List<Integer> l = new ArrayList();\\n        for (int num : arr) {\\n            l.add(num);\\n        }\\n        return l;\\n    }\\n    \\n    public List<List<Integer>> recursive(List<Integer> nums, List<List<Integer>> res, List<Integer> path) {\\n        if (nums.isEmpty()) {\\n            res.add(new ArrayList(path));\\n        } else {\\n            for (int i=0; i<nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(nums); // copy\\n                newNums.remove(i); // remove takes an index\\n                \\n                List<Integer> newPath = new ArrayList(path);\\n                path.add(nums.get(i)); \\n                recursive(newNums, res, newPath);\\n                // no backtracking needed\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n        return recursive(numsLst, res, path);\\n    }\\n}\\n```\n```\\n/*\\n    Iterative DFS\\n*/\\n\\nclass Node {\\n    List<Integer> nums;\\n    List<Integer> path;\\n    \\n    // Constructor\\n    Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n\\n    // helper\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n\\n        List<List<Integer>> res = new ArrayList();\\n        Stack<Node> stack = new Stack();\\n        List<Integer> path = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        Node node = new Node(numsLst, path);\\n        stack.push(node);\\n        \\n        while (!stack.isEmpty()) {\\n            node = stack.pop();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            \\n            for (int i=0; i<node.nums.size(); i++) {\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                stack.push(newNode);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\n/*\\n    Iterative BFS\\n*/\\n\\nclass Node {\\n    List<Integer> path;\\n    List<Integer> nums;\\n    \\n    // Constructor\\n    public Node(List<Integer> nums, List<Integer> path) {\\n        this.nums = nums;\\n        this.path = path;\\n    }\\n}\\n\\nclass Solution {\\n    public List<Integer> toArrayList(int[] nums) {\\n        List<Integer> numsLst = new ArrayList();\\n        for (int num : nums) {\\n            numsLst.add(num);\\n        }\\n        return numsLst;\\n    }\\n    \\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        Deque<Node> q = new ArrayDeque<>();\\n        List<List<Integer>> res = new ArrayList();\\n        List<Integer> numsLst = toArrayList(nums);\\n        List<Integer> path = new ArrayList();\\n        Node node = new Node(numsLst, path);\\n        q.add(node);\\n        while (!q.isEmpty()) {\\n            node = q.pollFirst();\\n            if (node.nums.isEmpty()) {\\n                res.add(new ArrayList(node.path));\\n            }\\n            for (int i=0; i< node.nums.size(); i++) {\\n                List<Integer> newPath = new ArrayList(node.path);\\n                newPath.add(node.nums.get(i));\\n                List<Integer> newNums = new ArrayList(node.nums);\\n                newNums.remove(i);\\n                Node newNode = new Node(newNums, newPath);\\n                q.add(newNode);\\n            }\\n        }\\n        return res;\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854583,
                "title": "python-simple-solution-explained-video-code-beginner",
                "content": "[](https://www.youtube.com/watch?v=DBLUa6ErLKw)\\nhttps://www.youtube.com/watch?v=DBLUa6ErLKw\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.backtrack(nums, [])\\n        return self.res\\n    \\n    def backtrack(self, nums, path):\\n        if not nums:\\n            self.res.append(path)\\n        for x in range(len(nums)):\\n            self.backtrack(nums[:x]+nums[x+1:], path+[nums[x]])\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.backtrack(nums, [])\\n        return self.res\\n    \\n    def backtrack(self, nums, path):\\n        if not nums:\\n            self.res.append(path)\\n        for x in range(len(nums)):\\n            self.backtrack(nums[:x]+nums[x+1:], path+[nums[x]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276363,
                "title": "javascript-solution",
                "content": "```\\nvar permute = function(nums) {\\n    let sol = [];\\n    if(nums.length < 1) {\\n        return [[]];\\n    } else if(nums.length == 1) {\\n        return [[nums[0]]];\\n    } \\n    for(let i = 0; i < nums.length; i++) {\\n        let numsCopy = [...nums]; \\n        numsCopy.splice(i, 1); \\n        let rtnVal = permute(numsCopy);\\n        for(let j = 0; j < rtnVal.length; j++) {\\n            sol.push([nums[i], ...rtnVal[j]])\\n        }  \\n    }\\n    return sol;\\n};\\n```\\n\\n# Approach:\\nThe approach to this problem is quite similar to that of the [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/). Since we\\'re dealing with combinations in arrays, my intuition told me that this likely had a recursive solution. \\n\\nLet\\'s deal with the base case first:\\nIf the given array is empty (array = `[]`), then the function should return `[[]]`.\\nIf the given array only had one element, then it should return `[[array[0]]`.\\n\\nNow, that we have our base cases, let\\'s go into our recursion. We know that when the array has more than one element, each element has a number of permutations in which that element is the first element.\\n\\nSo that\\'s why we have the outer for loop:\\n```\\nfor(let i = 0; i < nums.length; i++) {\\n.\\n.\\n.\\n\\tsol.push(nums[i], ....);\\n}\\n```\\n\\nTo visualize:\\n```\\npermute([1, 2, 3]):\\ni = 0: nums[0] == 1 --> [[1, ...[2,3]], [1, ...[3,2]]] --> [[1,2,3], [1,3,2]]\\ni = 1: nums[1] == 2 --> [[2, ...[1,3]], [2, ...[3,1]]] --> [[2,1,3], [2,3,1]]\\ni = 1: nums[2] == 3 --> [[3, ...[1,2]], [3, ...[2,1]]] --> [[3,1,2], [3,2,1]]\\n```\\n\\nNow, in order to get the other combinations such as `[1,3], [2,3]`, I used the `splice()`. **However**, `splice()` changes the array reference and object, so you must make a copy. Which is why I did `let numsCopy = [...nums]`. \\n\\nNow, we simply recurse on `numsCopy` after we remove the `i-th` element and it will return an array with the permutations of `numsCopy`. Then we just add `[nums[i], ...rtnVal[j]]` to the `sol` and return the value.\\n\\nRuntime: `O(n!)`\\nSpace Complexity: `O(n)`",
                "solutionTags": [],
                "code": "```\\nvar permute = function(nums) {\\n    let sol = [];\\n    if(nums.length < 1) {\\n        return [[]];\\n    } else if(nums.length == 1) {\\n        return [[nums[0]]];\\n    } \\n    for(let i = 0; i < nums.length; i++) {\\n        let numsCopy = [...nums]; \\n        numsCopy.splice(i, 1); \\n        let rtnVal = permute(numsCopy);\\n        for(let j = 0; j < rtnVal.length; j++) {\\n            sol.push([nums[i], ...rtnVal[j]])\\n        }  \\n    }\\n    return sol;\\n};\\n```\n```\\nfor(let i = 0; i < nums.length; i++) {\\n.\\n.\\n.\\n\\tsol.push(nums[i], ....);\\n}\\n```\n```\\npermute([1, 2, 3]):\\ni = 0: nums[0] == 1 --> [[1, ...[2,3]], [1, ...[3,2]]] --> [[1,2,3], [1,3,2]]\\ni = 1: nums[1] == 2 --> [[2, ...[1,3]], [2, ...[3,1]]] --> [[2,1,3], [2,3,1]]\\ni = 1: nums[2] == 3 --> [[3, ...[1,2]], [3, ...[2,1]]] --> [[3,1,2], [3,2,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18442,
                "title": "java-backtracking-solution",
                "content": "    public class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return lists;\\n        }\\n\\n        dfs(nums, lists, new ArrayList<Integer>());\\n        return lists;\\n    }\\n\\n    private void dfs(int[] nums, List<List<Integer>> lists, List<Integer> cur) {\\n        if (cur.size() == nums.length) {\\n            List<Integer> list = new ArrayList<>(cur);\\n            lists.add(list);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (cur.contains(nums[i])) {\\n                continue;\\n            }\\n            cur.add(nums[i]);\\n            dfs(nums, lists, cur);\\n            cur.remove(cur.size() - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> lists = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return lists;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3797989,
                "title": "video-backtracking-100-unlocking-permutations",
                "content": "# Intuition\\nUpon encountering this problem, I was immediately struck by its resemblance to a well-known puzzle: generating all possible permutations of a given sequence. It\\'s like holding a Rubik\\'s Cube of numbers and twisting it to discover every conceivable arrangement. With the challenge laid out, my mind gravitated towards the elegant world of recursion, an approach that often weaves simplicity with efficiency. In particular, the concept of backtracking emerged as a promising path. Imagine walking through a maze of numbers, exploring every turn and alley, but with the magical ability to step back and try a different route whenever needed. That\\'s the beauty of backtracking in recursion. It\\'s not just about finding a solution; it\\'s about crafting an adventure through the mathematical landscape, one permutation at a time.\\n\\nhttps://youtu.be/Jlw0sIGdS_4\\n\\n# Approach\\nThe solution to this problem is elegantly found through recursion, a form of backtracking. The approach begins by initializing an empty list, `result`, to store the final permutations. Then, a recursive helper function `backtrack` is defined, which takes the remaining numbers (`nums`) and the current permutation (`path`) as parameters. The base case is reached when there are no numbers left to permute; at this point, the current `path` is added to the `result`. In the recursive case, for each number in `nums`, the following steps are performed: (i) add the current number to `path`, (ii) remove the current number from `nums`, (iii) recursively call `backtrack` with the updated `nums` and `path`, and (iv) proceed without needing to revert the changes to `nums` and `path` due to the use of list slicing. Finally, the `backtrack` function is called with the original `nums` and an empty `path` to start the process, and the `result` list containing all the permutations is returned. This method ensures that all permutations are explored by iteratively choosing one element and recursively calling the function on the remaining elements.\\n\\n# Complexity\\n- Time complexity: O(n*n!) \\n  This is because for generating permutations, we perform n! operations (since there are n! permutations for n numbers) and for each operation, we spend O(n) time for slicing the list in our recursive call.\\n\\n- Space complexity: O(n*n!) \\n  This is due to the number of solutions. In the worst case, if we have \\'n\\' distinct numbers, there would be n! permutations. Since each permutation is a list of \\'n\\' numbers, the space complexity is O(n*n!).\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```\\n## Performance \\n| Language   | Runtime | Beats   | Memory  |\\n|------------|---------|---------|---------|\\n| C++        | 0 ms    | 100%    | 7.5 MB  |\\n| Java       | 1 ms    | 98.58%  | 44.1 MB |\\n| Rust       | 1 ms    | 87.70%  | 2.3 MB  |\\n| Go         | 2 ms    | 61.28%  | 3.1 MB  |\\n| Swift      | 8 ms    | 91.96%  | 14.4 MB |\\n| Python3    | 39 ms   | 98.74%  | 16.7 MB |\\n| JavaScript | 72 ms   | 55%     | 44.1 MB |\\n| C#         | 131 ms  | 94.50%  | 43.4 MB |\\n\\n\\nThis sorted table provides a quick comparison of the runtime performance across different programming languages for the given problem.",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Swift",
                    "Go",
                    "Rust"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(nums, path): \\n            if not nums: \\n                result.append(path) \\n                return \\n            for i in range(len(nums)): \\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) \\n        result = [] \\n        backtrack(nums, []) \\n        return result \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    const result = [];\\n    const backtrack = (nums, path) => {\\n        if (nums.length === 0) {\\n            result.push(path);\\n            return;\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            backtrack([...nums.slice(0, i), ...nums.slice(i + 1)], [...path, nums[i]]);\\n        }\\n    };\\n    backtrack(nums, []);\\n    return result;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> Permute(int[] nums) {\\n        IList<IList<int>> result = new List<IList<int>>();\\n        Backtrack(nums, new List<int>(), result);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] nums, List<int> path, IList<IList<int>> result) {\\n        if (path.Count == nums.Length) {\\n            result.Add(new List<int>(path));\\n            return;\\n        }\\n        foreach (int num in nums) {\\n            if (path.Contains(num)) continue;\\n            path.Add(num);\\n            Backtrack(nums, path, result);\\n            path.RemoveAt(path.Count - 1);\\n        }\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public void permuteRec(int[] nums, int begin, List<List<Integer>> result) {\\n        if (begin == nums.length) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for (int num : nums) temp.add(num);\\n            result.add(temp);\\n            return;\\n        }\\n        for (int i = begin; i < nums.length; i++) {\\n            // Swap\\n            int temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n            \\n            permuteRec(nums, begin + 1, result);\\n            \\n            // Swap back\\n            temp = nums[begin];\\n            nums[begin] = nums[i];\\n            nums[i] = temp;\\n        }\\n    }\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        permuteRec(nums, 0, result);\\n        return result;\\n    }\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut result = Vec::new();\\n        Self::backtrack(nums, vec![], &mut result);\\n        result\\n    }\\n\\n    fn backtrack(nums: Vec<i32>, path: Vec<i32>, result: &mut Vec<Vec<i32>>) {\\n        if nums.is_empty() {\\n            result.push(path);\\n            return;\\n        }\\n        for i in 0..nums.len() {\\n            let mut new_nums = nums.clone();\\n            new_nums.remove(i);\\n            let mut new_path = path.clone();\\n            new_path.push(nums[i]);\\n            Self::backtrack(new_nums, new_path, result);\\n        }\\n    }\\n}\\n```\n``` Swift []\\nclass Solution {\\n    func permute(_ nums: [Int]) -> [[Int]] {\\n        var result: [[Int]] = []\\n        \\n        func backtrack(_ nums: [Int], _ path: [Int]) {\\n            if nums.isEmpty {\\n                result.append(path)\\n                return\\n            }\\n            for i in 0..<nums.count {\\n                var newNums = nums\\n                newNums.remove(at: i)\\n                backtrack(newNums, path + [nums[i]])\\n            }\\n        }\\n        \\n        backtrack(nums, [])\\n        return result\\n    }\\n}\\n```\n``` Go []\\nfunc permute(nums []int) [][]int {\\n    var result [][]int\\n    \\n    var backtrack func([]int, []int)\\n    backtrack = func(nums []int, path []int) {\\n        if len(nums) == 0 {\\n            result = append(result, append([]int(nil), path...))\\n            return\\n        }\\n        for i := 0; i < len(nums); i++ {\\n            newNums := append([]int(nil), nums[:i]...)\\n            newNums = append(newNums, nums[i+1:]...)\\n            newPath := append([]int(nil), path...)\\n            newPath = append(newPath, nums[i])\\n            backtrack(newNums, newPath)\\n        }\\n    }\\n    \\n    backtrack(nums, []int{})\\n    return result\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475963,
                "title": "backtracking-o-n-time-and-o-n-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n![image.png](https://assets.leetcode.com/users/images/14fe9f74-0ba3-42db-ab6c-74e0554f21d2_1683001886.1161199.png)\\n\\n*The problem of generating all permutations of a given array can be solved using a recursive backtracking algorithm. The basic idea is to swap each element of the array with every other element in the array, and then recursively generate all permutations of the remaining elements. Once we have generated all permutations of the remaining elements, we swap the original elements back to restore the original order of the array.*\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    // Recursive helper function to generate permutations\\n    void helper(int l, int r, vector<int>& nums, vector<vector<int>>& ans) {\\n        // Base case: when left and right pointers are equal,\\n        // we have generated a permutation and add it to the answer.\\n        if (l == r) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        // Recursive case: for each index i in the range [l, r],\\n        // swap nums[l] with nums[i], generate permutations of the rest\\n        // of the array, and then swap back to restore original order.\\n        else {\\n            for (int i = l; i <= r; i++) {\\n                swap(nums[l], nums[i]); // Swap nums[l] with nums[i]\\n                helper(l+1, r, nums, ans); // Recursively generate permutations for remaining indices\\n                swap(nums[l], nums[i]); // Swap back to restore original order\\n            }\\n        }\\n    }\\n    // Main function to generate permutations\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, nums.size()-1, nums, ans); // Generate permutations starting from index 0 to n-1\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n * n!)**, where n! is the number of permutations of an n-element array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(n * n!)**, In the recursive helper function, we are using the call stack to store the state of each recursive call. The maximum depth of the call stack is n, which corresponds to the length of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    // Recursive helper function to generate permutations\\n    void helper(int l, int r, vector<int>& nums, vector<vector<int>>& ans) {\\n        // Base case: when left and right pointers are equal,\\n        // we have generated a permutation and add it to the answer.\\n        if (l == r) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        // Recursive case: for each index i in the range [l, r],\\n        // swap nums[l] with nums[i], generate permutations of the rest\\n        // of the array, and then swap back to restore original order.\\n        else {\\n            for (int i = l; i <= r; i++) {\\n                swap(nums[l], nums[i]); // Swap nums[l] with nums[i]\\n                helper(l+1, r, nums, ans); // Recursively generate permutations for remaining indices\\n                swap(nums[l], nums[i]); // Swap back to restore original order\\n            }\\n        }\\n    }\\n    // Main function to generate permutations\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, nums.size()-1, nums, ans); // Generate permutations starting from index 0 to n-1\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990689,
                "title": "java-explained-multiple-approaches",
                "content": "**1. Using extra space**\\n\\nCreate two containers \\n\\t- First is for candidates for next permutations\\n\\t- Second is for storing current permutation\\n\\nNow let\\'s consider we\\'ve to generate all the permutations for [1,2,3]\\n\\nInitially we\\'ll have - \\nCandidates     = [1,2,3] \\nPermutation   = []\\n\\nNow we\\'ll call a recursive method for each number in the candidates, remove it from candidates, put it into the permutation and recurse for remaining candidates.\\n\\n// Method call 1\\nLoop for **i=0 to 2**, remove first candidate and put into permutation\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\n// Method call 2\\nNow 1 is fixed and we need to find possible permutations for [2,3] so we recurse for i=1 from here\\nAgain loop from **i=0 to 1** as there are only two elements left, remove first candidate and put into permutation\\nCandidates     = [3] \\nPermutation   = [1,2]\\n\\n// Method call 3\\nNow 1,2 is fixed and we need to find possible permutations for [3] so we recurse for i=2 from here\\nLoop from **i=0 to 0** as there is only one element left, remove first candidate and put into permutation\\nCandidates     = [] \\nPermutation   = [1,2,3]\\n\\n// Method call 4\\nSince first permutation is generated, put into the result and **back track to Method call 3.**\\n\\n// Method call 3\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 2.**\\nCandidates     = [3] \\nPermutation   = [1,2]\\n\\n// Method call 2\\nRemove the last element from permutation and put it back into candidates and **continue the loop for index 1**\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\nremove second candidate and put into permutation\\nCandidates     = [2] \\nPermutation   = [1,3]\\n\\n// Method call 3\\nNow 1,3 is fixed and we need to find possible permutations for [2] so we recurse for i=2 from here.\\nLoop from **i=0 to 0** as there is only one element left, remove first candidate and put into permutation\\nCandidates     = [] \\nPermutation   = [1,3,2]\\n\\n// Method call 4\\nSecond permutation is generated, put into the result and **back track to Method call 3.**\\n\\n// Method call 3\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 2.**\\nCandidates     = [2] \\nPermutation   = [1,3]\\n\\n// Method call 2\\nRemove the last element from permutation and put it back into candidates and **back track to Method call 1 and loop finished.**\\nCandidates     = [2,3] \\nPermutation   = [1]\\n\\nNow method 1 will again repeat the same steps for index 1 and 2 as well. and will generate all the possible permutations.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        List<Integer> candidates = new ArrayList<>();\\n        \\n        for(int num : nums) {\\n            candidates.add( num );\\n        }\\n        \\n        permute(candidates, new ArrayList<>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(List<Integer> candidates, List<Integer> permutation, List<List<Integer>> result) {\\n        \\n        // Since no number is left for permutation, a permutation is generated\\n        if( candidates.isEmpty() ) {\\n            result.add( new ArrayList<>( permutation ) );\\n            return;\\n        }\\n        \\n        int n = candidates.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = candidates.get(i);\\n            \\n            // Fix the current number\\n            permutation.add( num );\\n            \\n            // Remove the current number from candidates\\n            candidates.remove( i );\\n            \\n            // And permute for remaining numbers\\n            permute(candidates, permutation, result);\\n            \\n            // Add the number back to it\\'s original index\\n            candidates.add(i, num );\\n            \\n            // Remove the number from the permutation\\n            permutation.remove( permutation.size() - 1 );\\n        }\\n    }\\n}\\n```\\n\\n**2. Using Swapping**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        permute(nums, 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(int[] nums, int start, List<List<Integer>> result) {\\n        int n = nums.length;\\n        \\n        // All the permutations in the current path has been generated.\\n        if( start == n ) {\\n            result.add( new ArrayList<>( arrayToList( nums ) ));\\n            return;\\n        }\\n        \\n        for(int i=start; i<n; i++) {\\n            \\n            /* Swap the current number with the number at start to \\n            generate next permutation */\\n            swap(nums, i, start);\\n            \\n            /* Fix the start, permute the number after start */\\n            permute(nums, start+1, result);\\n            \\n            /* Re-swap the current number with the number at start */\\n            swap(nums, i, start);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> lst = new ArrayList<>();\\n        for(int item : arr) {\\n            lst.add( item );\\n        }\\n        return lst;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        if( i == j ) return;\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        List<Integer> candidates = new ArrayList<>();\\n        \\n        for(int num : nums) {\\n            candidates.add( num );\\n        }\\n        \\n        permute(candidates, new ArrayList<>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(List<Integer> candidates, List<Integer> permutation, List<List<Integer>> result) {\\n        \\n        // Since no number is left for permutation, a permutation is generated\\n        if( candidates.isEmpty() ) {\\n            result.add( new ArrayList<>( permutation ) );\\n            return;\\n        }\\n        \\n        int n = candidates.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = candidates.get(i);\\n            \\n            // Fix the current number\\n            permutation.add( num );\\n            \\n            // Remove the current number from candidates\\n            candidates.remove( i );\\n            \\n            // And permute for remaining numbers\\n            permute(candidates, permutation, result);\\n            \\n            // Add the number back to it\\'s original index\\n            candidates.add(i, num );\\n            \\n            // Remove the number from the permutation\\n            permutation.remove( permutation.size() - 1 );\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        permute(nums, 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void permute(int[] nums, int start, List<List<Integer>> result) {\\n        int n = nums.length;\\n        \\n        // All the permutations in the current path has been generated.\\n        if( start == n ) {\\n            result.add( new ArrayList<>( arrayToList( nums ) ));\\n            return;\\n        }\\n        \\n        for(int i=start; i<n; i++) {\\n            \\n            /* Swap the current number with the number at start to \\n            generate next permutation */\\n            swap(nums, i, start);\\n            \\n            /* Fix the start, permute the number after start */\\n            permute(nums, start+1, result);\\n            \\n            /* Re-swap the current number with the number at start */\\n            swap(nums, i, start);\\n        }\\n    }\\n    \\n    private List<Integer> arrayToList(int[] arr) {\\n        List<Integer> lst = new ArrayList<>();\\n        for(int item : arr) {\\n            lst.add( item );\\n        }\\n        return lst;\\n    }\\n    \\n    private void swap(int[] arr, int i, int j) {\\n        if( i == j ) return;\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492456,
                "title": "javascript-bfs",
                "content": "Javascript Breath First Search. \\n\\nEach queue element will have two array: \\n* The first array is the current sequence we have constructed so far. \\n* The second array is the remaning numbers from nums. \\n\\nFor every element of the queue we add a new element for every remaning number. For example: \\nif our nums = [1,2,3] and we dequed the following element: [ [1], [2, 3] ], then: \\n\\tWe iterate through the second array and add  [ [1 ,2] , [3] ] and [ [1, 3] , [2] ] to the queue. \\n\\n\\n```\\nvar permute = function(nums) {\\n    \\n    const result = [];\\n    const queue = [];\\n    \\n    queue.push([[], nums]);\\n    \\n    while(queue.length){\\n        const [currentSequence, availableNumbers] = queue.shift();\\n        \\n        if(availableNumbers.length === 0)\\n        {\\n            result.push(currentSequence);\\n            continue;\\n        }\\n            \\n        \\n        for(let i =0; i < availableNumbers.length; i++)\\n        {\\n            const number = availableNumbers[i];\\n            queue.push([\\n                [...currentSequence, number], \\n                [...availableNumbers.slice(0, i), ...availableNumbers.slice(i + 1)]\\n            ]);    \\n        }   \\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar permute = function(nums) {\\n    \\n    const result = [];\\n    const queue = [];\\n    \\n    queue.push([[], nums]);\\n    \\n    while(queue.length){\\n        const [currentSequence, availableNumbers] = queue.shift();\\n        \\n        if(availableNumbers.length === 0)\\n        {\\n            result.push(currentSequence);\\n            continue;\\n        }\\n            \\n        \\n        for(let i =0; i < availableNumbers.length; i++)\\n        {\\n            const number = availableNumbers[i];\\n            queue.push([\\n                [...currentSequence, number], \\n                [...availableNumbers.slice(0, i), ...availableNumbers.slice(i + 1)]\\n            ]);    \\n        }   \\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525691,
                "title": "simple-and-easy-to-understand-c-using-recursion-98-faster-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> results;\\n        generatePermutations(0, &nums, &results);\\n        return results;\\n    }\\nprivate:\\n    void generatePermutations(int i, vector<int>* nums_ptr, vector<vector<int>>* results) {\\n        auto& nums = *nums_ptr;\\n        if (i == nums.size() - 1) {\\n            results->emplace_back(nums);\\n            return;\\n        }\\n        \\n        for (int j = i; j < nums.size(); ++j) {\\n            std::swap(nums[i], nums[j]);\\n            generatePermutations(i + 1, nums_ptr, results);\\n            std::swap(nums[i], nums[j]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> results;\\n        generatePermutations(0, &nums, &results);\\n        return results;\\n    }\\nprivate:\\n    void generatePermutations(int i, vector<int>* nums_ptr, vector<vector<int>>* results) {\\n        auto& nums = *nums_ptr;\\n        if (i == nums.size() - 1) {\\n            results->emplace_back(nums);\\n            return;\\n        }\\n        \\n        for (int j = i; j < nums.size(); ++j) {\\n            std::swap(nums[i], nums[j]);\\n            generatePermutations(i + 1, nums_ptr, results);\\n            std::swap(nums[i], nums[j]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389065,
                "title": "javascript-solution-98",
                "content": "```\\nvar permute = function(nums) {\\n\\n    let permutations = []\\n    \\n    let findPermutations = function(visited = new Set(), currPerm = []) {\\n        if (currPerm.length === nums.length) {\\n            permutations.push(currPerm)\\n            return\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            if(!visited.has(i)) {\\n                findPermutations(new Set([...visited, i]), [...currPerm, nums[i]])\\n            }\\n        }\\n    }\\n    \\n    findPermutations()\\n    \\n    return permutations;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permute = function(nums) {\\n\\n    let permutations = []\\n    \\n    let findPermutations = function(visited = new Set(), currPerm = []) {\\n        if (currPerm.length === nums.length) {\\n            permutations.push(currPerm)\\n            return\\n        }\\n        for (let i = 0; i < nums.length; i++) {\\n            if(!visited.has(i)) {\\n                findPermutations(new Set([...visited, i]), [...currPerm, nums[i]])\\n            }\\n        }\\n    }\\n    \\n    findPermutations()\\n    \\n    return permutations;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247779,
                "title": "easy-solution-for-kotlin",
                "content": "```\\nclass Solution {\\n    private val result: MutableList<List<Int>> = mutableListOf()\\n\\n    fun permute(nums: IntArray): List<List<Int>> {\\n        permuteAux(mutableListOf(), nums.toList())\\n        return result\\n    }\\n\\n    private fun permuteAux(added: List<Int>, left: List<Int>) {\\n        if (left.isEmpty()) {\\n            result.add(added)\\n        } else {\\n            left.forEach { candidate ->\\n                permuteAux(added + candidate, left - candidate)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private val result: MutableList<List<Int>> = mutableListOf()\\n\\n    fun permute(nums: IntArray): List<List<Int>> {\\n        permuteAux(mutableListOf(), nums.toList())\\n        return result\\n    }\\n\\n    private fun permuteAux(added: List<Int>, left: List<Int>) {\\n        if (left.isEmpty()) {\\n            result.add(added)\\n        } else {\\n            left.forEach { candidate ->\\n                permuteAux(added + candidate, left - candidate)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18563,
                "title": "share-my-c-backtracksolution",
                "content": "\\n    class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n        \\tvector<vector<int> > res;   // result\\n        \\tvector<bool> flags( num.size(), false);    // bool, whether num[i] is choosed\\n        \\tvector<int> path;     // num have been choosed\\n        \\tbacktrack(num, res, path, flags);   //backtrack\\n        \\treturn res;\\t\\n        }\\n    \\n        void backtrack(vector<int> &num, vector<vector<int> > &res, \\n    \\tvector<int> path,vector<bool> flags)\\n    {\\n    \\tif( num.size() == path.size() )\\n    \\t{\\n    \\t\\tres.push_back(path);\\n    \\t}\\n    \\telse\\n    \\t{\\n    \\t\\tfor( int i = 0; i < num.size(); i++ )\\n    \\t\\t{\\n    \\t\\t\\tif( flags[i] == true )\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tpath.push_back(num[i]);\\n    \\t\\t\\t\\tflags[i] = true;\\n    \\t\\t\\t\\tbacktrack( num, res, path, flags );\\n    \\t\\t\\t\\tflags[i] = false;\\n    \\t\\t\\t\\tpath.pop_back();\\n    \\t\\t\\t}\\n    \\t\\t\\t\\n    \\t\\t}\\n    \\t}\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permute(vector<int> &num) {\\n        \\tvector<vector<int> > res;   // result\\n        \\tvector<bool> flags( num.size(), false);    // bool, whether num[i] is choosed\\n        \\tvector<int> path;     // num have been choosed\\n        \\tbacktrack(num, res, path, flags);   //backtrack\\n        \\treturn res;\\t\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3851219,
                "title": "c-easy-recursive-and-backtracking-solution-heavy-commented",
                "content": "## **\\u2705\\u2705C++ Easy Recursive and Backtracking Solution**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    void rec(int idx,vector<int>&nums,vector<vector<int>>&ans){\\n        //if our index reached nums.size() then we will and the nums in ans and return\\n        if(idx==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        //we are traversing from idx to nums.size() and swapping the nums[i] and nums[idx]\\n        for(int i=idx;i<nums.size();i++){\\n            swap(nums[idx],nums[i]);\\n            rec(idx+1,nums,ans);\\n            //backtracking \\n            swap(nums[idx],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //we have created the ans vector for storing all the permutation in it\\n        vector<vector<int>>ans;\\n        //we are calling recursive function for the 0th index\\n        rec(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/a7291557-8a27-49e5-88f9-9565acd4c438_1690952446.59402.png)\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(int idx,vector<int>&nums,vector<vector<int>>&ans){\\n        //if our index reached nums.size() then we will and the nums in ans and return\\n        if(idx==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        //we are traversing from idx to nums.size() and swapping the nums[i] and nums[idx]\\n        for(int i=idx;i<nums.size();i++){\\n            swap(nums[idx],nums[i]);\\n            rec(idx+1,nums,ans);\\n            //backtracking \\n            swap(nums[idx],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //we have created the ans vector for storing all the permutation in it\\n        vector<vector<int>>ans;\\n        //we are calling recursive function for the 0th index\\n        rec(0,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538037,
                "title": "python-seriously-1-liner",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(itertools.permutations(nums,len(nums)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(itertools.permutations(nums,len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480880,
                "title": "c-recurive-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findpermutation(vector<int>& nums, vector<vector<int>>&ans, vector<int>&ds,int freq[]){\\n        if(ds.size()==nums.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=0;i<nums.size(); i++){\\n            if(!freq[i]){\\n                ds.push_back(nums[i]);\\n                freq[i]=1;\\n                findpermutation(nums,ans,ds,freq);\\n                freq[i]=0;\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        int freq[nums.size()];\\n        for(int i=0;i<nums.size();i++){\\n            freq[i]=0;\\n        }\\n\\n        findpermutation(nums,ans,ds,freq);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findpermutation(vector<int>& nums, vector<vector<int>>&ans, vector<int>&ds,int freq[]){\\n        if(ds.size()==nums.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=0;i<nums.size(); i++){\\n            if(!freq[i]){\\n                ds.push_back(nums[i]);\\n                freq[i]=1;\\n                findpermutation(nums,ans,ds,freq);\\n                freq[i]=0;\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        int freq[nums.size()];\\n        for(int i=0;i<nums.size();i++){\\n            freq[i]=0;\\n        }\\n\\n        findpermutation(nums,ans,ds,freq);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099923,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/nXQUC0gpvck\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 0){\\n            res.push(temp)\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function(nums) {\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 0){\\n            res.push(temp)\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557947,
                "title": "easiest-cpp-solution-without-swapping-array-elements-using-recursion-and-backtracking",
                "content": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   o\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t / | \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   /   |   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /     |     \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /       |       \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /         |         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t   /           |           \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t /             |             \\\\ \\n\\t\\t\\t\\t\\t\\t\\t\\t1              2              3\\n\\t\\t\\t\\t\\t\\t\\t   / \\\\            / \\\\            / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2   3          3   1          2   1\\n\\t\\t\\t\\t\\t\\t\\t /     \\\\        /     \\\\        /     \\\\\\n\\t\\t\\t\\t\\t\\t\\t3       2      1       3      1       2\\n\\t\\t\\t\\t\\t\\t\\t|       |      |       |      |       |\\n\\t\\t\\t\\t\\t\\t   123     132    231     213    321     312\\n*/\\nclass Solution {\\npublic:\\n    void permutation(vector<int> &vec, int k, vector<int> &a, vector<int> &res, vector<vector<int>> &ans){\\n        if(k==vec.size()){\\n            ans.push_back(res);//pushing res vector to ans vector\\n        }\\n        else{\\n            for(int i=0;i<vec.size();i++){\\n\\t\\t\\t//checking if that element is already taken or not, if it is 0 then we will add it\\n\\t\\t\\t//in resultant vector else we will move forward\\n                if(a[i]==0){\\n                    res[k] = vec[i];  //adding element to resultant vector\\n                    a[i] = 1;  //Assign 1 such that next time it will not get counted\\n                    permutation(vec, k+1, a, res, ans);  //calling function by increasing k\\n                    a[i] = 0;  //backtracking(moving back to previous position)\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans; \\n        vector<int> a(nums.size(), 0);  //for storing 0 & 1(vector for checking)\\n        vector<int> res(nums.size());  //for storing vector elemets\\n        permutation(nums, 0, a, res, ans);  //calling recursive function\\n        return ans;  //returning answer\\n    }\\n};\\n```\\n**I hope you find this solution helpful. If so, then please upvote it...\\u270C\\uD83C\\uDFFB\\uD83E\\uDD17**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   o\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t / | \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   /   |   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /     |     \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /       |       \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /         |         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t   /           |           \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t /             |             \\\\ \\n\\t\\t\\t\\t\\t\\t\\t\\t1              2              3\\n\\t\\t\\t\\t\\t\\t\\t   / \\\\            / \\\\            / \\\\\\n\\t\\t\\t\\t\\t\\t\\t  2   3          3   1          2   1\\n\\t\\t\\t\\t\\t\\t\\t /     \\\\        /     \\\\        /     \\\\\\n\\t\\t\\t\\t\\t\\t\\t3       2      1       3      1       2\\n\\t\\t\\t\\t\\t\\t\\t|       |      |       |      |       |\\n\\t\\t\\t\\t\\t\\t   123     132    231     213    321     312\\n*/\\nclass Solution {\\npublic:\\n    void permutation(vector<int> &vec, int k, vector<int> &a, vector<int> &res, vector<vector<int>> &ans){\\n        if(k==vec.size()){\\n            ans.push_back(res);//pushing res vector to ans vector\\n        }\\n        else{\\n            for(int i=0;i<vec.size();i++){\\n\\t\\t\\t//checking if that element is already taken or not, if it is 0 then we will add it\\n\\t\\t\\t//in resultant vector else we will move forward\\n                if(a[i]==0){\\n                    res[k] = vec[i];  //adding element to resultant vector\\n                    a[i] = 1;  //Assign 1 such that next time it will not get counted\\n                    permutation(vec, k+1, a, res, ans);  //calling function by increasing k\\n                    a[i] = 0;  //backtracking(moving back to previous position)\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans; \\n        vector<int> a(nums.size(), 0);  //for storing 0 & 1(vector for checking)\\n        vector<int> res(nums.size());  //for storing vector elemets\\n        permutation(nums, 0, a, res, ans);  //calling recursive function\\n        return ans;  //returning answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308076,
                "title": "detailed-explanation-about-why-the-time-complexity-of-two-methods-are-o-n-n-and-o-n",
                "content": "I will demonstrate two methods here. \\n* The complexity of the basic DFS is `O(n*n!)`\\n* The complexity of the DFS with swap is `O(n!)`\\n\\n### **Method 1**\\nThe first method is the basic DFS (not using swap). Its time complexity is `O(n*n!)`. I paste the code first.\\n\\n```java\\n/*\\n * Method1: DFS - use an extra boolean array for visited-checking\\n * 1ms, 92.55%\\n * For each position pos in nums, i.e., pos is [0, len-1], we try each number that has not been\\n * used yet.\\n * For example, nums=[1,2,3,4], at index 0, we can try 1, 2, 3, 4, say this time we try\\n * 2, then at index 1, we can try 1, 3, 4, and so on.\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> cur = new ArrayList<>();\\n    // The last parameter, a boolean array, is to record which elements has been used\\n    dfs(nums, 0, ans, cur, new boolean[nums.length]);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans, List<Integer> cur, boolean[] visited) {\\n    if (pos == nums.length) {\\n      ans.add(new ArrayList<>(cur));\\n      return;\\n    }\\n    // Try all the elements that are not used yet in this position\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (!visited[i]) {\\n        visited[i] = true;\\n        cur.add(nums[i]);\\n        dfs(nums, pos + 1, ans, cur, visited);\\n        cur.remove(cur.size() - 1);\\n        visited[i] = false;\\n      }\\n    }\\n  }\\n}\\n```\\n\\nThe time complexity is determined by the total number of nodes in the recursion tree. Take nums=[1, 2, 3] as an example. \\n\\n![image](https://assets.leetcode.com/users/images/51a9e886-04b0-453f-966e-9f36a52751a8_1625103952.2332764.jpeg)\\n\\nThe number of nodes is `1 + 3 + 3*2 + 3*2*1`. Now let\\'s extend this to a general case. Let nums has n numbers. The total number of nodes the recursion tree has will be:\\n```plain\\n1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n*(n-1)*(n-2)*...*2 + n*(n-1)*(n-2)*...*2*1\\n```\\n\\nNow we reverse the order of the terms:\\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n```\\n\\nNext, let\\'s simplify it\\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n= n! + n!/1! + n!/2! + ... + n!/(n-1)! + n!/n!\\n= n! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!)           ---------------------------------- formula (1)\\n```\\n\\nBased on Taylor Formula, \\n```plain\\ne^x = 1 + x + x^2/2! + x^3/3! + x^4/4! + ... +x^n/n!\\n```\\n\\nLet `x = 1`, we got\\n```plain\\ne = 1 + 1 + 1/2! + 1/3! + 1/4! + ... + 1/n!\\n```\\n\\nNext, combine this with formula (1) above, we get\\n```plain\\nn! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!) \\n= n! * e\\n```\\n\\nNow, we know that the total number of nodes in the recursion tree is `n! * e`. \\n\\nIn each non-leaf node, we have a for-loop which iterate over all the n numbers. Its time is `O(n)`. In each leaf node, we add the current result to the final answer by `ans.add(new ArrayList<>(cur));` whose time is `O(n)` as well. So in each node, it take `O(n)`. \\n\\nSo the time complexity is `O(n * n! * e)`, i.e., `O(n * n!)`. \\n\\n### **Method 2**\\nThe second method is DFS with swap. The time complexity is `O(n!)`. \\n\\n```java\\n * Method2: DFS - use swap to avoid visited-checking\\n * 0ms, 100%\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    dfs(nums, 0, ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans) {\\n    if (pos == nums.length) {\\n      ans.add(arrayToList(nums));\\n      return;\\n    }\\n    // For each position pos in nums, i.e., pos is [0, len-1], we swap nums[pos] with each\\n    // number after it.\\n    for (int i = pos; i < nums.length; ++i) {\\n      swap(nums, pos, i);\\n      dfs(nums, pos + 1, ans);\\n      swap(nums, i, pos);\\n    }\\n  }\\n\\n  private List<Integer> arrayToList(int[] array) {\\n    List<Integer> l = new ArrayList<>();\\n    for (int i : array) {\\n      l.add(i);\\n    }\\n    return l;\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    if (i == j) {\\n      return;\\n    }\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```\\n\\nTake a look at the for-loop, on each node, it is not from 0 to n, and instead it is from pos to n. So the number of execution is not constant n for each node, but decreasing level by level. For example, in the root node, for-loop has n executions (pos is from 0 to n); in a node of the second level, for-loop has n-1 executions (pos is from 1 to n); and so on so forth. \\n\\nIn the figure below, I use `[1, 2, 3]` as an example, and I list \\n1. the number of nodes each level has\\n2. the number of executions in the for-loop for each node in a level\\n3. the number of executions for all nodes in a level (equals to the multiplication of the two numbers above)\\n\\n![image](https://assets.leetcode.com/users/images/44ad5d75-bb8c-4e1a-a42f-9c660006e1d6_1626470559.319824.jpeg)\\n\\nNow let\\'s generalize it to an array with n numbers. The total number of executions for all nodes in the recursion tree is:\\n```plain\\n1*n + n*(n-1) + n*(n-2)*(n-3) + ... + n(n-1)(n-2)...1\\n= n!/(n-1)! + n!/(n-2)! + ... + n!\\n= n! * (1/(n-1)! + 1/(n-2)! + ... + 1)\\n= n! * (e - 1/n!)\\n= n! * e - 1\\n= O(n!)\\n```\\n\\nSo the time complexity of this method is `O(n!)`.\\n\\n\\nHope this is helpful. Thank you very much. \\n\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\n/*\\n * Method1: DFS - use an extra boolean array for visited-checking\\n * 1ms, 92.55%\\n * For each position pos in nums, i.e., pos is [0, len-1], we try each number that has not been\\n * used yet.\\n * For example, nums=[1,2,3,4], at index 0, we can try 1, 2, 3, 4, say this time we try\\n * 2, then at index 1, we can try 1, 3, 4, and so on.\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> cur = new ArrayList<>();\\n    // The last parameter, a boolean array, is to record which elements has been used\\n    dfs(nums, 0, ans, cur, new boolean[nums.length]);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans, List<Integer> cur, boolean[] visited) {\\n    if (pos == nums.length) {\\n      ans.add(new ArrayList<>(cur));\\n      return;\\n    }\\n    // Try all the elements that are not used yet in this position\\n    for (int i = 0; i < nums.length; ++i) {\\n      if (!visited[i]) {\\n        visited[i] = true;\\n        cur.add(nums[i]);\\n        dfs(nums, pos + 1, ans, cur, visited);\\n        cur.remove(cur.size() - 1);\\n        visited[i] = false;\\n      }\\n    }\\n  }\\n}\\n```\n```plain\\n1 + n + n*(n-1) + n*(n-1)*(n-2) + ... + n*(n-1)*(n-2)*...*2 + n*(n-1)*(n-2)*...*2*1\\n```\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n```\n```plain\\nn*(n-1)*(n-2)*...*2*1 + n*(n-1)*(n-2)*...*2 + ... +  n*(n-1)*(n-2) + n*(n-1) + n + 1\\n= n! + n!/1! + n!/2! + ... + n!/(n-1)! + n!/n!\\n= n! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!)           ---------------------------------- formula (1)\\n```\n```plain\\ne^x = 1 + x + x^2/2! + x^3/3! + x^4/4! + ... +x^n/n!\\n```\n```plain\\ne = 1 + 1 + 1/2! + 1/3! + 1/4! + ... + 1/n!\\n```\n```plain\\nn! * (1 + 1/1! + 1/2! + ... + 1/(n-1)! + 1/n!) \\n= n! * e\\n```\n```java\\n * Method2: DFS - use swap to avoid visited-checking\\n * 0ms, 100%\\n */\\nclass Solution {\\n  public List<List<Integer>> permute(int[] nums) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    dfs(nums, 0, ans);\\n    return ans;\\n  }\\n\\n  private void dfs(int[] nums, int pos, List<List<Integer>> ans) {\\n    if (pos == nums.length) {\\n      ans.add(arrayToList(nums));\\n      return;\\n    }\\n    // For each position pos in nums, i.e., pos is [0, len-1], we swap nums[pos] with each\\n    // number after it.\\n    for (int i = pos; i < nums.length; ++i) {\\n      swap(nums, pos, i);\\n      dfs(nums, pos + 1, ans);\\n      swap(nums, i, pos);\\n    }\\n  }\\n\\n  private List<Integer> arrayToList(int[] array) {\\n    List<Integer> l = new ArrayList<>();\\n    for (int i : array) {\\n      l.add(i);\\n    }\\n    return l;\\n  }\\n\\n  private void swap(int[] nums, int i, int j) {\\n    if (i == j) {\\n      return;\\n    }\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n}\\n```\n```plain\\n1*n + n*(n-1) + n*(n-2)*(n-3) + ... + n(n-1)(n-2)...1\\n= n!/(n-1)! + n!/(n-2)! + ... + n!\\n= n! * (1/(n-1)! + 1/(n-2)! + ... + 1)\\n= n! * (e - 1/n!)\\n= n! * e - 1\\n= O(n!)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822916,
                "title": "simple-java-solution-recursive-0ms-100-faster",
                "content": "It is similar to subset question.\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        permutations(nums,0,list);\\n        return list;\\n    }\\n    \\n    public void permutations(int[] nums,int i,List<List<Integer>> list) {\\n        if(i==nums.length) {\\n            List<Integer> sublist = new ArrayList<>();\\n            for(int j=0;j<nums.length;j++){\\n                sublist.add(nums[j]);\\n            }\\n            list.add(sublist);\\n            return;\\n        }\\n        for(int start=i;start<nums.length;start++) {\\n            swap(nums,i,start);\\n            permutations(nums,i+1,list);  \\n            swap(nums,i,start);            \\n        }\\n\\n    }\\n    \\n    private void swap(int[] nums,int i,int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        permutations(nums,0,list);\\n        return list;\\n    }\\n    \\n    public void permutations(int[] nums,int i,List<List<Integer>> list) {\\n        if(i==nums.length) {\\n            List<Integer> sublist = new ArrayList<>();\\n            for(int j=0;j<nums.length;j++){\\n                sublist.add(nums[j]);\\n            }\\n            list.add(sublist);\\n            return;\\n        }\\n        for(int start=i;start<nums.length;start++) {\\n            swap(nums,i,start);\\n            permutations(nums,i+1,list);  \\n            swap(nums,i,start);            \\n        }\\n\\n    }\\n    \\n    private void swap(int[] nums,int i,int j) {\\n        int temp = nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790275,
                "title": "java-solution-backtrack-remove-the-last-element",
                "content": "* **Please upvote if helpFul!!**\\n```\\nclass Solution {\\n    //[1,2,3]\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> resultList, ArrayList<Integer> tempSet, int[] nums) {\\n\\n        if (tempSet.size() == nums.length) {\\n            resultList.add(new ArrayList<>(tempSet));\\n            return;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (tempSet.contains(nums[i])) continue;\\n            tempSet.add(nums[i]);\\n            backtrack(resultList, tempSet, nums);\\n            tempSet.remove(tempSet.size() - 1);  // v v v IMP step....this is where backtrack magic happens...\\n\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    //[1,2,3]\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> resultList, ArrayList<Integer> tempSet, int[] nums) {\\n\\n        if (tempSet.size() == nums.length) {\\n            resultList.add(new ArrayList<>(tempSet));\\n            return;\\n        }\\n\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (tempSet.contains(nums[i])) continue;\\n            tempSet.add(nums[i]);\\n            backtrack(resultList, tempSet, nums);\\n            tempSet.remove(tempSet.size() - 1);  // v v v IMP step....this is where backtrack magic happens...\\n\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359476,
                "title": "c-clear-general-backtracking-beats-98-38-in-time-100-00-in-memory",
                "content": "```\\n\\tvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        backtrack(res, nums, current);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count(current.begin(), current.end(), nums[i]) == 0){\\n                current.push_back(nums[i]);\\n                backtrack(res, nums, current);\\n                current.pop_back();\\n            }\\n        }\\n    }\\n```\\n\\nRuntime: 8 ms, faster than 98.38% of C++ online submissions.\\n\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions.\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n\\tvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        backtrack(res, nums, current);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count(current.begin(), current.end(), nums[i]) == 0){\\n                current.push_back(nums[i]);\\n                backtrack(res, nums, current);\\n                current.pop_back();\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18539,
                "title": "my-ac-solution-in-c-i-think-this-is-not-dfs-is-it",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int> > permute(vector<int> &num) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tif (num.size() == 0)\\n    \\t\\t\\treturn result;\\n    \\t\\tsort(num.begin(), num.end());\\n    \\t\\tpermute(num, 0, result);\\n    \\t\\treturn result;\\n    \\t}\\n    private:\\n    \\tvoid permute(vector<int> &num, size_t start, vector<vector<int>> &result){\\n    \\t\\tif (start == num.size()-1){\\n    \\t\\t\\tresult.push_back(num);\\n    \\t\\t}\\n    \\t\\telse{\\n    \\t\\t\\tfor (size_t i = start; i < num.size(); i++){\\n    \\t\\t\\t\\tswap(num[start], num[i]);\\n    \\t\\t\\t\\tpermute(num, start + 1, result);\\n    \\t\\t\\t\\tswap(num[start], num[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > permute(vector<int> &num) {\\n    \\t\\tvector<vector<int>> result;\\n    \\t\\tif (num.size() == 0)\\n    \\t\\t\\treturn result;\\n    \\t\\tsort(num.begin(), num.end());\\n    \\t\\tpermute(num, 0, result);\\n    \\t\\treturn result;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3854776,
                "title": "beats-100-simple-recursion-with-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n;\\n    void solve(vector<int> &nums, int mask, vector<int> &temp)\\n    {\\n        if(mask==((1<<n)-1))\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!(mask&(1<<i)))\\n            {\\n                temp.push_back(nums[i]);\\n                solve(nums, mask|(1<<i), temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        int mask=0;\\n        vector<int> temp;\\n        solve(nums, mask, temp);      \\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n    int n;\\n    void solve(vector<int> &nums, int mask, vector<int> &temp)\\n    {\\n        if(mask==((1<<n)-1))\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!(mask&(1<<i)))\\n            {\\n                temp.push_back(nums[i]);\\n                solve(nums, mask|(1<<i), temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        int mask=0;\\n        vector<int> temp;\\n        solve(nums, mask, temp);      \\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850769,
                "title": "beats-100-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/c1bh0cRLrIU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }\\n    \\n    public void helper(List<Integer> curr, int[] nums) {\\n        if (curr.size() == nums.length) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        for (int num: nums) {\\n            if (!curr.contains(num)) {\\n                curr.add(num);\\n                helper(curr, nums);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> curr;\\n        helper(curr, nums);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& curr, vector<int>& nums) {\\n        if (curr.size() == nums.size()) {\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for (int num : nums) {\\n            if (find(curr.begin(), curr.end(), num) == curr.end()) {\\n                curr.push_back(num);\\n                helper(curr, nums);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.helper([], nums, result)\\n        return result\\n    \\n    def helper(self, curr, nums, result):\\n        if len(curr) == len(nums):\\n            result.append(curr.copy())\\n            return\\n        \\n        for num in nums:\\n            if num not in curr:\\n                curr.append(num)\\n                self.helper(curr, nums, result)\\n                curr.pop()\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> permute(int[] nums) {\\n        result = new ArrayList<>();\\n        helper(new ArrayList<>(), nums);\\n        return result;\\n    }\\n    \\n    public void helper(List<Integer> curr, int[] nums) {\\n        if (curr.size() == nums.length) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        for (int num: nums) {\\n            if (!curr.contains(num)) {\\n                curr.add(num);\\n                helper(curr, nums);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> curr;\\n        helper(curr, nums);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& curr, vector<int>& nums) {\\n        if (curr.size() == nums.size()) {\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for (int num : nums) {\\n            if (find(curr.begin(), curr.end(), num) == curr.end()) {\\n                curr.push_back(num);\\n                helper(curr, nums);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.helper([], nums, result)\\n        return result\\n    \\n    def helper(self, curr, nums, result):\\n        if len(curr) == len(nums):\\n            result.append(curr.copy())\\n            return\\n        \\n        for num in nums:\\n            if num not in curr:\\n                curr.append(num)\\n                self.helper(curr, nums, result)\\n                curr.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792941,
                "title": "python3-easy-to-understand-simple-recursive-approach-beats-85",
                "content": "# Approach\\nRecursive call tries to add a number that was not used earlier (not in the list). If the list gains the right length it goes to the result. The process repeats with each num as a first element.\\n# Code\\n```re\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def solve(s=[], nums=[]):\\n            if len(s) == len(nums):\\n                res.append(s)\\n                return\\n            for i in range(len(nums)):\\n                if nums[i] not in s:\\n                    solve(s + [nums[i]], nums)\\n        solve([], nums)\\n        return res\\n\\n```\\n\\n\\n## UPVOTE makes me happy --> (o\\u02D8\\u25E1\\u02D8o)",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```re\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def solve(s=[], nums=[]):\\n            if len(s) == len(nums):\\n                res.append(s)\\n                return\\n            for i in range(len(nums)):\\n                if nums[i] not in s:\\n                    solve(s + [nums[i]], nums)\\n        solve([], nums)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776165,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<vector<int>> &ans, vector<int> v){\\n        if(idx == v.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = idx;i < v.size();i++){\\n            swap(v[i], v[idx]);\\n            helper(idx+1, ans, v);\\n            swap(v[i], v[idx]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, ans, nums);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<vector<int>> &ans, vector<int> v){\\n        if(idx == v.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = idx;i < v.size();i++){\\n            swap(v[i], v[idx]);\\n            helper(idx+1, ans, v);\\n            swap(v[i], v[idx]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        helper(0, ans, nums);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630991,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<vector<int>> &ans){\\n        if(i>=n-1){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int j = i; j < n; j++){\\n            swap(v[i],v[j]);\\n            solve(i+1,n,v,ans);\\n            swap(v[i],v[j]);\\n        }\\n\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        solve(0,n,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,vector<int> &v,vector<vector<int>> &ans){\\n        if(i>=n-1){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int j = i; j < n; j++){\\n            swap(v[i],v[j]);\\n            solve(i+1,n,v,ans);\\n            swap(v[i],v[j]);\\n        }\\n\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        solve(0,n,nums,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561075,
                "title": "easy-to-understand-with-hand-written-example-well-commented",
                "content": "# Code\\n![Adobe Scan May 25, 2023_1.jpg](https://assets.leetcode.com/users/images/6e4c7c07-d522-4649-9503-0f4e6c69296d_1684998844.7881637.jpeg)\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,vector<vector<int>> &res){\\n        //If index reaches to the last push the nums to result\\n        if(i==nums.size()-1){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n            //Swap the values and then recursively call the function again.\\n            swap(nums[i],nums[j]);\\n            solve(nums,i+1,res);\\n            //Backtracking\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(nums,0,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> &nums,int i,vector<vector<int>> &res){\\n        //If index reaches to the last push the nums to result\\n        if(i==nums.size()-1){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n            //Swap the values and then recursively call the function again.\\n            swap(nums[i],nums[j]);\\n            solve(nums,i+1,res);\\n            //Backtracking\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        solve(nums,0,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454676,
                "title": "beates-everyone-java-recursive-solution-2-approaches-explained",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Without Using Extra Space\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // call the helper function to generate all permutations\\n        helper(0,nums,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int index, int nums[], List<List<Integer>> ans){\\n        // if we have processed all elements up to the last one in the array,\\n        // add the current permutation to the list of permutations and return\\n        if(index == nums.length){\\n            // create a list to store the current permutation\\n            List<Integer> ds = new ArrayList<>();\\n\\n            // copy the current array into the list\\n            for(int i = 0; i < nums.length;i++){\\n                ds.add(nums[i]);\\n            }\\n\\n            // add the current permutation to the list of permutations\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through the remaining elements in the array starting from the current index\\n        for(int i = index; i < nums.length;i++){\\n            // swap the current element with the element at the current index\\n            swap(i,index,nums);\\n\\n            // call the helper function recursively to generate all permutations using the remaining elements\\n            helper(index+1, nums, ans);\\n\\n            // swap the current element back to its original position\\n            swap(i,index,nums);\\n        }\\n    }\\n\\n    // helper method to swap two elements in the array\\n    private void swap(int i, int j, int nums[]){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/e1511521-29cf-4935-9a96-12802ce94e9d_1682443584.171484.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N * N!)\\n\\n\\n# Using Extra Boolean Array\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // create a list to store the current permutation being built\\n        ArrayList<Integer> ds = new ArrayList<>();\\n\\n        // create an array to keep track of whether each element has been used in the current permutation\\n        boolean freq[] = new boolean[nums.length];\\n\\n        // call the helper function to generate all permutations\\n        helper(nums,freq,ds,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int nums[], boolean freq[], ArrayList<Integer> ds, List<List<Integer>> ans){\\n        // if the current permutation is the same length as the original array,\\n        // add it to the list of permutations and return\\n        if(ds.size() == nums.length){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through each element in the original array\\n        for(int i = 0; i < nums.length;i++){\\n            // if the current element has not already been used in the current permutation\\n            if(!freq[i]){\\n                // mark the current element as used\\n                freq[i] = true;\\n                // add the current element to the current permutation\\n                ds.add(nums[i]);\\n\\n                // call the helper function recursively to generate all permutations using the current element\\n                helper(nums,freq,ds,ans);\\n\\n                // remove the current element from the current permutation and mark it as unused\\n                ds.remove(ds.size() - 1);\\n                freq[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        \\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // call the helper function to generate all permutations\\n        helper(0,nums,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int index, int nums[], List<List<Integer>> ans){\\n        // if we have processed all elements up to the last one in the array,\\n        // add the current permutation to the list of permutations and return\\n        if(index == nums.length){\\n            // create a list to store the current permutation\\n            List<Integer> ds = new ArrayList<>();\\n\\n            // copy the current array into the list\\n            for(int i = 0; i < nums.length;i++){\\n                ds.add(nums[i]);\\n            }\\n\\n            // add the current permutation to the list of permutations\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through the remaining elements in the array starting from the current index\\n        for(int i = index; i < nums.length;i++){\\n            // swap the current element with the element at the current index\\n            swap(i,index,nums);\\n\\n            // call the helper function recursively to generate all permutations using the remaining elements\\n            helper(index+1, nums, ans);\\n\\n            // swap the current element back to its original position\\n            swap(i,index,nums);\\n        }\\n    }\\n\\n    // helper method to swap two elements in the array\\n    private void swap(int i, int j, int nums[]){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        // create a list to store all permutations\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // create a list to store the current permutation being built\\n        ArrayList<Integer> ds = new ArrayList<>();\\n\\n        // create an array to keep track of whether each element has been used in the current permutation\\n        boolean freq[] = new boolean[nums.length];\\n\\n        // call the helper function to generate all permutations\\n        helper(nums,freq,ds,ans);\\n\\n        // return the list of permutations\\n        return ans;\\n    }\\n\\n    public void helper(int nums[], boolean freq[], ArrayList<Integer> ds, List<List<Integer>> ans){\\n        // if the current permutation is the same length as the original array,\\n        // add it to the list of permutations and return\\n        if(ds.size() == nums.length){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        // iterate through each element in the original array\\n        for(int i = 0; i < nums.length;i++){\\n            // if the current element has not already been used in the current permutation\\n            if(!freq[i]){\\n                // mark the current element as used\\n                freq[i] = true;\\n                // add the current element to the current permutation\\n                ds.add(nums[i]);\\n\\n                // call the helper function recursively to generate all permutations using the current element\\n                helper(nums,freq,ds,ans);\\n\\n                // remove the current element from the current permutation and mark it as unused\\n                ds.remove(ds.size() - 1);\\n                freq[i] = false;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458885,
                "title": "c-solution-100-fast-0-ms-space-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(vector<int>&nums,int ind,vector<vector<int>>&ans,int max)\\n{\\n\\tif(ind >= max)\\n\\t{\\n\\t\\tans.push_back(nums);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=ind;i<max;i++)\\n\\t{\\n\\t\\tswap(nums[ind],nums[i]);\\n\\t\\tsolve(nums,ind+1,ans,max);\\n\\t\\tswap(nums[i],nums[ind]);\\n\\t}\\n\\t\\n}\\n\\n vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\n\\tvector<vector<int>> ans;        \\n\\t\\n\\tint max = nums.size();\\n\\t\\n\\tsolve(nums,0,ans,max);\\n\\t\\n\\treturn ans;\\n\\n}\\n\\n};\\n```\\n\\nupvote if it helps you :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid solve(vector<int>&nums,int ind,vector<vector<int>>&ans,int max)\\n{\\n\\tif(ind >= max)\\n\\t{\\n\\t\\tans.push_back(nums);\\n\\t\\treturn ;\\n\\t}\\n\\tfor(int i=ind;i<max;i++)\\n\\t{\\n\\t\\tswap(nums[ind],nums[i]);\\n\\t\\tsolve(nums,ind+1,ans,max);\\n\\t\\tswap(nums[i],nums[ind]);\\n\\t}\\n\\t\\n}\\n\\n vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\n\\tvector<vector<int>> ans;        \\n\\t\\n\\tint max = nums.size();\\n\\t\\n\\tsolve(nums,0,ans,max);\\n\\t\\n\\treturn ans;\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450393,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=25alMWqAOLo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=25alMWqAOLo",
                "codeTag": "Unknown"
            },
            {
                "id": 1807685,
                "title": "easy-solution-with-image-explanation-swap-100-c",
                "content": "**Time Complexity : O(N!) * O(N)**\\n**Space Complexity : O(N)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/4dff7997-f962-4adc-8082-c52ffa8fa09b_1646079113.775907.jpeg)\\n\\n```\\nclass Solution\\n{\\n    void solve(int ind, vector<int> &nums,vector<vector<int>>&ans)\\n    {\\n        if (ind == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = ind; i < nums.size(); i++)\\n        {\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }\\n\\n    public:\\n        vector<vector < int>> permute(vector<int> &nums)\\n        {\\n            vector<vector<int>>ans;\\n            solve(0,nums,ans);\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    void solve(int ind, vector<int> &nums,vector<vector<int>>&ans)\\n    {\\n        if (ind == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = ind; i < nums.size(); i++)\\n        {\\n            swap(nums[ind],nums[i]);\\n            solve(ind+1,nums,ans);\\n            swap(nums[ind],nums[i]);\\n        }\\n    }\\n\\n    public:\\n        vector<vector < int>> permute(vector<int> &nums)\\n        {\\n            vector<vector<int>>ans;\\n            solve(0,nums,ans);\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791024,
                "title": "python-3-50ms-dfs-solution",
                "content": "```\\nclass Solution:\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums):\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470228,
                "title": "my-python-solutions-with-time-space-analysis",
                "content": "attempt 1, recursion\\n```\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.6 MB, less than 14.31%\\n    #\\n    # note:\\n    #     * return list of permutations\\n    #     * fix 1 position and use recursion to permute the others\\n    #\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def helper(nums, path):\\n            if not nums:\\n                res.append(path)\\n            else:\\n                for i in range(len(nums)):\\n                    helper(nums[:i] + nums[i + 1:], path + [nums[i]])\\n        res = []\\n        helper(nums, [])\\n        return res\\n```\\nattempt 2, backtrack\\n```\\n    # peeked https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.3 MB, less than 70.36%\\n    #\\n    # note:\\n    #     * used an additional set @visited to tracke the index of elements\\n    #       visited, so that we won\\'t visit them again[]\\n    #     * this is DFS, so we keep adding @visited until @path contains all the\\n    #       elements and the record the result in @res\\n    #     * when an index is added to @visited, it means the corresponding\\n    #       element is fixed at a certain position in @path, if later we want to\\n    #       change it, it is removed from @visited\\n    #\\n    # example:\\n    #     nums = [1,2,3]\\n    #                           __ initial path\\n    #                          /\\n    #                         v\\n    #          ______________[]_________________          -> level0, P(3,0) nodes\\n    #         /               \\\\                 \\\\\\n    #        [1]              [2]               [3]       -> level1, P(3,1) nodes\\n    #       /   \\\\            /   \\\\             /   \\\\\\n    #    [1,2]  [1,3]      [2,1]  [2,3]      [3,1]  [3,2] -> level2, P(3,2) nodes\\n    #     /       \\\\        /       \\\\         /       \\\\\\n    # [1,2,3]  [1,3,2] [2,1,3]  [2,3,2]  [3,1,2]  [3,2,1] -> level3, P(3,3) nodes\\n    #\\n    # time: O(n!) < time complexity <= O(n*n!)\\n    #     * backtrack() is called with each node in the tree shown above as its\\n    #       @path parameter, so the time would be O(# of nodes in the tree)\\n    #     * (# of nodes in the tree) = P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) <= n! + n! + ... + n! = (n * n!)\\n    #       because P(n, k) = n!/(n-k)! <= n!\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) > n!\\n    #       because P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #               = n!/n! + n!/(n-1)! + ... + n!/(n-n)!\\n    #               = n!(1/n! + 1/(n-1)! + ... + 1/(n-n)!)\\n    #               < n!*1\\n    #\\n    # space: O(n), regardless the space for the solutions\\n    #     * to keep the solutions: O(n*n!)\\n    #       we have n! solutions, each has length n\\n    #     * @visited: O(n)\\n    #     * stack: O(n), considering the longest path\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(path):\\n            if len(path) == n:\\n                res.append(path)\\n            else:\\n                for i in range(n):\\n                    if i not in visited:\\n                        visited.add(i)\\n                        backtrack(path + [nums[i]])\\n                        visited.remove(i)\\n        res, visited, n = [], set(), len(nums)\\n        backtrack([])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.6 MB, less than 14.31%\\n    #\\n    # note:\\n    #     * return list of permutations\\n    #     * fix 1 position and use recursion to permute the others\\n    #\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def helper(nums, path):\\n            if not nums:\\n                res.append(path)\\n            else:\\n                for i in range(len(nums)):\\n                    helper(nums[:i] + nums[i + 1:], path + [nums[i]])\\n        res = []\\n        helper(nums, [])\\n        return res\\n```\n```\\n    # peeked https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking\\n    # Runtime: 28 ms, faster than 99.47%\\n    # Memory Usage: 14.3 MB, less than 70.36%\\n    #\\n    # note:\\n    #     * used an additional set @visited to tracke the index of elements\\n    #       visited, so that we won\\'t visit them again[]\\n    #     * this is DFS, so we keep adding @visited until @path contains all the\\n    #       elements and the record the result in @res\\n    #     * when an index is added to @visited, it means the corresponding\\n    #       element is fixed at a certain position in @path, if later we want to\\n    #       change it, it is removed from @visited\\n    #\\n    # example:\\n    #     nums = [1,2,3]\\n    #                           __ initial path\\n    #                          /\\n    #                         v\\n    #          ______________[]_________________          -> level0, P(3,0) nodes\\n    #         /               \\\\                 \\\\\\n    #        [1]              [2]               [3]       -> level1, P(3,1) nodes\\n    #       /   \\\\            /   \\\\             /   \\\\\\n    #    [1,2]  [1,3]      [2,1]  [2,3]      [3,1]  [3,2] -> level2, P(3,2) nodes\\n    #     /       \\\\        /       \\\\         /       \\\\\\n    # [1,2,3]  [1,3,2] [2,1,3]  [2,3,2]  [3,1,2]  [3,2,1] -> level3, P(3,3) nodes\\n    #\\n    # time: O(n!) < time complexity <= O(n*n!)\\n    #     * backtrack() is called with each node in the tree shown above as its\\n    #       @path parameter, so the time would be O(# of nodes in the tree)\\n    #     * (# of nodes in the tree) = P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) <= n! + n! + ... + n! = (n * n!)\\n    #       because P(n, k) = n!/(n-k)! <= n!\\n    #     * note that P(n, 0) + P(n, 1) + ... + P(n, n) > n!\\n    #       because P(n, 0) + P(n, 1) + ... + P(n, n)\\n    #               = n!/n! + n!/(n-1)! + ... + n!/(n-n)!\\n    #               = n!(1/n! + 1/(n-1)! + ... + 1/(n-n)!)\\n    #               < n!*1\\n    #\\n    # space: O(n), regardless the space for the solutions\\n    #     * to keep the solutions: O(n*n!)\\n    #       we have n! solutions, each has length n\\n    #     * @visited: O(n)\\n    #     * stack: O(n), considering the longest path\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(path):\\n            if len(path) == n:\\n                res.append(path)\\n            else:\\n                for i in range(n):\\n                    if i not in visited:\\n                        visited.add(i)\\n                        backtrack(path + [nums[i]])\\n                        visited.remove(i)\\n        res, visited, n = [], set(), len(nums)\\n        backtrack([])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1435474,
                "title": "c-faster-than-100-both-methods",
                "content": "The difference between both the solutions is just the space complexity . The approach is also kinda similar , in the latter instead of visited array we are swapping to save the space consumed by visited array.\\n\\n```\\nclass Solution {\\npublic:\\n\\t//TIme complexity = O(n! * n)\\n\\t//Space complexity = O(n) + O(n) ( Extra space consumed by visited array)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums , vector<int> &vec,int visited[])\\n    {\\n        if(vec.size()==nums.size())\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                vec.push_back(nums[i]);\\n                visited[i]=1;\\n                solve(ans,nums,vec,visited);\\n                visited[i]=0;\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int n = nums.size();\\n        int visited[n];\\n        for(int i=0;i<nums.size();i++) visited[i]=0;\\n        solve(ans,nums,vec,visited);\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Time complexity = O(n! * n)\\n\\t//Space complexity = O(n)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums ,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[index]);\\n            solve(ans,nums,index+1);\\n            swap(nums[i],nums[index]);\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solve(ans,nums,index);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Happy Coding\\nIf you like it , Do upvote**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//TIme complexity = O(n! * n)\\n\\t//Space complexity = O(n) + O(n) ( Extra space consumed by visited array)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums , vector<int> &vec,int visited[])\\n    {\\n        if(vec.size()==nums.size())\\n        {\\n            ans.push_back(vec);\\n            return;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!visited[i])\\n            {\\n                vec.push_back(nums[i]);\\n                visited[i]=1;\\n                solve(ans,nums,vec,visited);\\n                visited[i]=0;\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> vec;\\n        int n = nums.size();\\n        int visited[n];\\n        for(int i=0;i<nums.size();i++) visited[i]=0;\\n        solve(ans,nums,vec,visited);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// Time complexity = O(n! * n)\\n\\t//Space complexity = O(n)\\n    void solve(vector<vector<int>> &ans , vector<int> &nums ,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[index]);\\n            solve(ans,nums,index+1);\\n            swap(nums[i],nums[index]);\\n        }\\n    }\\n    \\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solve(ans,nums,index);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301912,
                "title": "general-recursive-approach-c-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> store;\\n        \\n        helper(nums, 0, store);\\n        \\n        return store;\\n    }\\n    \\n    void helper(vector<int> current, int pos, vector<vector<int>> &store)\\n    {\\n        if(pos == current.size())\\n        {\\n            store.push_back(current);       //Push the number when the permute is formed\\n            return;\\n        }\\n        else\\n            for(int idx = pos; idx < current.size(); idx++)\\n            {\\n                swap(current[pos], current[idx]);       //Swap each index recursively\\n                helper(current, pos + 1, store);        //Perform for next each Permutation\\n            }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> store;\\n        \\n        helper(nums, 0, store);\\n        \\n        return store;\\n    }\\n    \\n    void helper(vector<int> current, int pos, vector<vector<int>> &store)\\n    {\\n        if(pos == current.size())\\n        {\\n            store.push_back(current);       //Push the number when the permute is formed\\n            return;\\n        }\\n        else\\n            for(int idx = pos; idx < current.size(); idx++)\\n            {\\n                swap(current[pos], current[idx]);       //Swap each index recursively\\n                helper(current, pos + 1, store);        //Perform for next each Permutation\\n            }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925113,
                "title": "fast-1-ms-easy-java-backtracking-explained",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> listOfPermutations = new ArrayList<>(); //list to hold the permutations\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        generatePermutations(new ArrayList<Integer>(), nums);\\n        return listOfPermutations;\\n    }\\n    \\n    private void generatePermutations(List<Integer> permutation, int[] nums){\\n        if(permutation.size() == nums.length){ \\n            List<Integer> validPermutation = new ArrayList<Integer>(permutation);\\n            listOfPermutations.add(validPermutation);\\n            return;\\n        }\\n        \\n        /*Start a for loop for every number in the nums[] array and recursively call\\n        the backtracking function until a valid permutation is obtained. Since we do not want\\n        permutations with repeated numbers, we will skip a number if it has already been added\\n        to the permutation.*/\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(permutation.contains(nums[i])){  //skip if already added\\n                continue;\\n            }\\n            permutation.add(nums[i]);\\n            generatePermutations(permutation, nums);\\n            permutation.remove(permutation.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> listOfPermutations = new ArrayList<>(); //list to hold the permutations\\n    \\n    public List<List<Integer>> permute(int[] nums) {\\n        generatePermutations(new ArrayList<Integer>(), nums);\\n        return listOfPermutations;\\n    }\\n    \\n    private void generatePermutations(List<Integer> permutation, int[] nums){\\n        if(permutation.size() == nums.length){ \\n            List<Integer> validPermutation = new ArrayList<Integer>(permutation);\\n            listOfPermutations.add(validPermutation);\\n            return;\\n        }\\n        \\n        /*Start a for loop for every number in the nums[] array and recursively call\\n        the backtracking function until a valid permutation is obtained. Since we do not want\\n        permutations with repeated numbers, we will skip a number if it has already been added\\n        to the permutation.*/\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(permutation.contains(nums[i])){  //skip if already added\\n                continue;\\n            }\\n            permutation.add(nums[i]);\\n            generatePermutations(permutation, nums);\\n            permutation.remove(permutation.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776226,
                "title": "golang-javascript-solution",
                "content": "# GOLANG\\n> Runtime: 0 ms, faster than 100.00% of Go online submissions for Permutations.\\nMemory Usage: 2.7 MB, less than 60.71% of Go online submissions for Permutations.\\n```GOLANG\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\thelper(nums, []int{}, &res)\\n\\treturn res\\n}\\n\\nfunc helper(source []int, ans []int, ansList *[][]int) {\\n\\tif len(source) == 0 {\\n\\t\\t*ansList = append(*ansList, ans)\\n\\t\\treturn\\n\\t}\\n\\tfor i, e := range source {\\n\\t\\tnewSource := append(append([]int{}, source[:i]...), source[i+1:]...)\\n\\t\\thelper(newSource, append(ans, e), ansList)\\n\\t}\\n}\\n```\\n\\n# JAVASCRIPT\\n> Runtime: 144 ms, faster than 9.43% of JavaScript online submissions for Permutations.\\nMemory Usage: 39.5 MB, less than 67.24% of JavaScript online submissions for Permutations.\\n\\n```JS\\nvar permute = function(nums) {\\n    let res = []\\n    function help(arr2){\\n        if (arr2.length==nums.length)\\n            return res.push(arr2)\\n        for(let e of nums)\\n            if (!arr2.includes(e))\\n                help([...arr2, e])\\n    }\\n    help([])\\n    return res\\n};\\n```",
                "solutionTags": [],
                "code": "```GOLANG\\nfunc permute(nums []int) [][]int {\\n\\tvar res [][]int\\n\\thelper(nums, []int{}, &res)\\n\\treturn res\\n}\\n\\nfunc helper(source []int, ans []int, ansList *[][]int) {\\n\\tif len(source) == 0 {\\n\\t\\t*ansList = append(*ansList, ans)\\n\\t\\treturn\\n\\t}\\n\\tfor i, e := range source {\\n\\t\\tnewSource := append(append([]int{}, source[:i]...), source[i+1:]...)\\n\\t\\thelper(newSource, append(ans, e), ansList)\\n\\t}\\n}\\n```\n```JS\\nvar permute = function(nums) {\\n    let res = []\\n    function help(arr2){\\n        if (arr2.length==nums.length)\\n            return res.push(arr2)\\n        for(let e of nums)\\n            if (!arr2.includes(e))\\n                help([...arr2, e])\\n    }\\n    help([])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751309,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def backtrack(self, nums, vis = set(), r = []):\\n        if len(r) == len(nums):\\n            self.res.append([*r])\\n            return\\n        \\n        for n in nums:\\n            if n not in vis:\\n                # Place\\n                vis.add(n)\\n                r.append(n)\\n                # Explore\\n                self.backtrack(nums, vis, r)\\n                # Backtrack\\n                vis.remove(n)\\n                r.pop()\\n                \\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.res = []\\n        self.backtrack(nums)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def backtrack(self, nums, vis = set(), r = []):\\n        if len(r) == len(nums):\\n            self.res.append([*r])\\n            return\\n        \\n        for n in nums:\\n            if n not in vis:\\n                # Place\\n                vis.add(n)\\n                r.append(n)\\n                # Explore\\n                self.backtrack(nums, vis, r)\\n                # Backtrack\\n                vis.remove(n)\\n                r.pop()\\n                \\n        \\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        self.res = []\\n        self.backtrack(nums)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558360,
                "title": "general-iterative-approach-with-queue-in-swift",
                "content": "**General Approach**\\nI prefer solving backtracking problems iteratively with a simple queue. The general approach I take:\\n1. Add element to queue\\n2. Loop over input\\n3. Loop over current queue size\\n4. Remove first element from queue\\n5. Use the removed element\\n\\n**Permutations**\\nhttps://leetcode.com/problems/permutations/\\n\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\\n\\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Permutations II**\\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\\n\\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n**Subset**\\nhttps://leetcode.com/problems/subsets/\\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\\n\\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\\n\\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\\n\\n**Letter Combinations of a Phone Number**\\nhttps://leetcode.com/problems/letter-combinations-of-a-phone-number/\\n\\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\\n\\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Queue"
                ],
                "code": "```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // inserted 1 at 0th index\\n[2, 1] [1, 2] // inserted 2 in indexes 0-2 for prior queue element\\n[3, 2, 1][2, 3, 1][2,1,3][3,1,2][1,3,2][1,2,3] // inserted 3 in indexes 0-3 for prior queue elements\\n```\n```\\nfunc permute(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\n// Input: [1,1,2,2]\\n//                                              []                                INSERT 1\\n//                                             [1]                                INSERT 1\\n//                                            [1,1]                               INSERT 2\\n//           [2,1,1]                         [1,2,1]               [1,1,2]        INSERT 2\\n// [2,2,1,1][2,1,2,1] [1,2,2,1]        [2,1,1,2],[1,2,1,2]        [1,1,2,2]\\n```\n```\\nfunc permuteUnique(_ nums: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tif nums.isEmpty { return result }\\n\\tresult.append( [] )\\n\\tfor num in nums {\\n\\t\\tlet count = result.count\\n\\t\\tfor _ in 0 ..< count {\\n\\t\\t\\tlet prefix = result.removeFirst()\\n\\t\\t\\tfor j in 0 ... prefix.count {\\n\\t\\t\\t\\tvar tmp = prefix\\n\\t\\t\\t\\ttmp.insert(num, at: j)\\n\\t\\t\\t\\tresult.append(tmp)   \\n\\t\\t\\t\\tif j < prefix.count && prefix[j] == num { break }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```\n```\\nInput: [1, 2, 3]\\n[] // Add Element\\n[1] // Add to []\\n[2] // Add to []\\n[3] // Add to []\\n[1, 3] // Add to [1]\\n[2, 3] // Add to [2]\\n[1, 2, 3] // Add to [1, 2]\\n```\n```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tfor num in nums {\\n\\t\\tlet count = q.count\\n\\t\\tfor i in 0 ..< count {\\n\\t\\t\\tq.append(q[i] + [num])\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: [1,2,2]\\n[] // Add Empty Case\\n[1] // Add 1 to []\\n[2] // Add 2 to []\\n[1, 2] // Add 2 to [1]\\n[2, 2] // Add 2 to [2]\\n[1, 2, 2] // Add 2 to [1,2]\\n```\n```\\nfunc subsetsWithDup(_ nums: [Int]) -> [[Int]] {\\n\\tvar q = [[Int]]()\\n\\tq.append([])\\n\\tvar count = q.count\\n\\tvar nums = nums.sorted() // Simplifies skipping duplicates\\n\\tfor (i, num) in nums.enumerated() {\\n\\t\\tlet start = (i > 0 && nums[i-1] == num) ? count : 0\\n\\t\\tcount = q.count\\n\\t\\tfor j in start ..< count {\\n\\t\\t\\tq.append( q[j] + [num] )\\n\\t\\t}\\n\\t}\\n\\treturn q\\n}\\n```\n```\\nInput: \"23\"\\n[] // Empty\\na\\na b\\na b c\\nb c ad\\nb c ad ae \\nb c ad ae af \\n... and so on...\\n```\n```\\nfunc letterCombinations(_ digits: String) -> [String] {\\n    var phoneDict = [\"2\" : \"abc\", \"3\" : \"def\", \"4\" : \"ghi\", \"5\" : \"jkl\", \"6\" : \"mno\", \"7\" : \"pqrs\", \"8\" : \"tuv\", \"9\" : \"wxyz\"]\\n    if digits.count == 0 { return [] }\\n    var res = [\"\"]\\n    for (i, digit) in digits.enumerated() {\\n        let size = res.count\\n        for _ in 0 ..< size {\\n            let stringDigit = String(digit) // digit is Character so must convert to String\\n            let prefix = res.removeFirst()\\n            for letter in phoneDict[stringDigit]! {\\n                res.append(prefix + String(letter))\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485894,
                "title": "c-no-recursion-8-lines-stl-no-explanation-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> ourResult;\\n        vector<int> singleIter = nums;\\n\\t\\tourResult.push_back(singleIter);\\n        next_permutation(singleIter.begin(), singleIter.end());\\n        while (singleIter != nums)\\n        {\\n            ourResult.push_back(singleIter);\\n            next_permutation(singleIter.begin(), singleIter.end());\\n        }\\n        return ourResult;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>> ourResult;\\n        vector<int> singleIter = nums;\\n\\t\\tourResult.push_back(singleIter);\\n        next_permutation(singleIter.begin(), singleIter.end());\\n        while (singleIter != nums)\\n        {\\n            ourResult.push_back(singleIter);\\n            next_permutation(singleIter.begin(), singleIter.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 428429,
                "title": "simple-and-easy-c-backtracking-solution-98-fast",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    \\n    void permute(vector<int> nums, int i, vector<vector<int>> &ans) {\\n        if(i == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j = i; j < nums.size(); j++) {\\n            swap(nums[i],nums[j]);\\n            permute(nums,i+1,ans);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permute(nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    void permute(vector<int> nums, int i, vector<vector<int>> &ans) {\\n        if(i == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for(int j = i; j < nums.size(); j++) {\\n            swap(nums[i],nums[j]);\\n            permute(nums,i+1,ans);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permute(nums,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309478,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 291565,
                "title": "easiest-golang-solution-99-4ms",
                "content": "```\\nfunc permute(nums []int) [][]int {\\n    answer := make([][]int, 0)\\n    aux(&answer, 0, nums)\\n\\treturn answer\\n}\\n\\nfunc aux(answer *[][]int, idx int, nums []int) {\\n    if idx == len(nums) {\\n        c := make([]int, len(nums))\\n        copy(c, nums)\\n        *answer = append(*answer, c)\\n        return\\n    }\\n    for i := idx; i < len(nums); i++ {\\n        nums[idx], nums[i] = nums[i], nums[idx]\\n        aux(answer, idx + 1, nums)\\n        nums[i], nums[idx] = nums[idx], nums[i]\\n    }\\n    return\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc permute(nums []int) [][]int {\\n    answer := make([][]int, 0)\\n    aux(&answer, 0, nums)\\n\\treturn answer\\n}\\n\\nfunc aux(answer *[][]int, idx int, nums []int) {\\n    if idx == len(nums) {\\n        c := make([]int, len(nums))\\n        copy(c, nums)\\n        *answer = append(*answer, c)\\n        return\\n    }\\n    for i := idx; i < len(nums); i++ {\\n        nums[idx], nums[i] = nums[i], nums[idx]\\n        aux(answer, idx + 1, nums)\\n        nums[i], nums[idx] = nums[idx], nums[i]\\n    }\\n    return\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176521,
                "title": "clear-python-beats-99",
                "content": "```\\nclass Solution:\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n = len(nums)\\n        if n < 1: return [[]]\\n        \\n        def DFS(nums, level, current, res):\\n            if level == n: res.append(current)\\n            else:\\n                for num in nums:\\n                    if num not in current: # I wonder if this will be even faster with a set\\n                        DFS(nums, level+1, current + [num], res)\\n        \\n        res = []\\n        DFS(nums,0,[],res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n = len(nums)\\n        if n < 1: return [[]]\\n        \\n        def DFS(nums, level, current, res):\\n            if level == n: res.append(current)\\n            else:\\n                for num in nums:\\n                    if num not in current: # I wonder if this will be even faster with a set\\n                        DFS(nums, level+1, current + [num], res)\\n        \\n        res = []\\n        DFS(nums,0,[],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160656,
                "title": "cpp-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> orig = nums;\\n        vector<vector<int> > result;\\n        do{\\n            result.push_back(nums);\\n            next_permutation(nums.begin(),nums.end());\\n        }while(orig!=nums);\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nOnce youre done with this problem do check out\\n\\nhttps://leetcode.com/problems/palindrome-permutation-ii/description/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> orig = nums;\\n        vector<vector<int> > result;\\n        do{\\n            result.push_back(nums);\\n            next_permutation(nums.begin(),nums.end());\\n        }while(orig!=nums);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153304,
                "title": "ruby-recursive-solution-with-comments",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer[][]}\\ndef permute(nums)\\n  res = []\\n  add_number(res, nums, [])\\n  res\\nend\\n\\ndef add_number(res, nums, curr)\\n  # set numbers left based on current\\n  left = nums - curr\\n  \\n  # stop when there is nothing left to add\\n  if left.empty?\\n    res << curr\\n  end\\n  \\n  # for each number left\\n  left.each do |l|\\n    # add number to current solution\\n    add_number(res, nums, curr + [l])\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer[][]}\\ndef permute(nums)\\n  res = []\\n  add_number(res, nums, [])\\n  res\\nend\\n\\ndef add_number(res, nums, curr)\\n  # set numbers left based on current\\n  left = nums - curr\\n  \\n  # stop when there is nothing left to add\\n  if left.empty?\\n    res << curr\\n  end\\n  \\n  # for each number left\\n  left.each do |l|\\n    # add number to current solution\\n    add_number(res, nums, curr + [l])\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18236,
                "title": "c-easy-understand-solution-recursion",
                "content": "```\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> temp;    \\n            help(ans, temp, nums, i);\\n        }\\n        return ans;\\n    }\\n    void help(vector<vector<int>>& ans, vector<int> cur, vector<int> nums, int cur_idx){\\n        cur.push_back(nums[cur_idx]);\\n        nums.erase(nums.begin() + cur_idx);\\n        if(nums.empty()){\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++)\\n            help(ans, cur, nums, i);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> temp;    \\n            help(ans, temp, nums, i);\\n        }\\n        return ans;\\n    }\\n    void help(vector<vector<int>>& ans, vector<int> cur, vector<int> nums, int cur_idx){\\n        cur.push_back(nums[cur_idx]);\\n        nums.erase(nums.begin() + cur_idx);\\n        if(nums.empty()){\\n            ans.push_back(cur);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++)\\n            help(ans, cur, nums, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18328,
                "title": "backtracking-python",
                "content": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        answer = []\\n        rec = [0 for i in xrange(len(nums))]\\n        def dfs(ans):\\n            if len(ans) == len(nums):\\n                answer.append(ans[:])\\n                return\\n            for i in xrange(len(nums)):\\n                if rec[i] != 1:\\n                    rec[i] = 1\\n                    dfs(ans + [nums[i]])\\n                    rec[i] = 0\\n        dfs([])\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def permute(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        answer = []\\n        rec = [0 for i in xrange(len(nums))]\\n        def dfs(ans):\\n            if len(ans) == len(nums):\\n                answer.append(ans[:])\\n                return\\n            for i in xrange(len(nums)):\\n                if rec[i] != 1:\\n                    rec[i] = 1\\n                    dfs(ans + [nums[i]])\\n                    rec[i] = 0\\n        dfs([])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18428,
                "title": "my-12ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> permute(vector<int>& nums) {\\n            vector<vector<int>> res;\\n            create(nums,res,0);\\n            return res;\\n        }\\n        \\n        void create(vector<int>& nums,vector<vector<int>> &res,int n)\\n        {\\n            if(n==nums.size()-1)\\n                res.push_back(nums);\\n            else\\n            {\\n                for(int i=n;i<nums.size();i++)\\n                {\\n                    swap(nums[i],nums[n]);\\n                    create(nums,res,n+1);\\n                    swap(nums[i],nums[n]);\\n                }\\n            }\\n        }\\n        \\n        void swap(int &a,int &b)\\n        {\\n            int tmp=a;\\n            a=b;\\n            b=tmp;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> permute(vector<int>& nums) {\\n            vector<vector<int>> res;\\n            create(nums,res,0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18494,
                "title": "my-iterative-solution-in-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        \\n        if(n == 0)\\n            return res;\\n\\n        stack <vector<int>> perm;\\n        perm.push(nums);\\n        \\n        for(int fix_pos = 0;fix_pos < n - 1;fix_pos++)  \\n        /*For fix_pos => 0 -> n times, 1-> n-1 times ..... n -1-> 2times */\\n        {\\n            stack <vector<int>> temp;\\n            vector<int> vec;\\n            while(!perm.empty())\\n            {\\n                vec = perm.top();\\n                perm.pop();\\n                for(int i = fix_pos;i < n;i++) /* swap around this fix_pos and generate new perms */\\n                {\\n                    std::swap(vec[i],vec[fix_pos]);\\n                    temp.push(vec);\\n                    std::swap(vec[i],vec[fix_pos]); /*swap back to retain original vec */\\n                }\\n            }\\n            std::swap(perm,temp); /* swap stack as we want result in perm */\\n        }\\n        \\n        while(!perm.empty())\\n        {\\n            res.push_back(perm.top());\\n            perm.pop();\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        \\n        if(n == 0)\\n            return res;\\n\\n        stack <vector<int>> perm;\\n        perm.push(nums);\\n        \\n        for(int fix_pos = 0;fix_pos < n - 1;fix_pos++)  \\n        /*For fix_pos => 0 -> n times, 1-> n-1 times ..... n -1-> 2times */\\n        {\\n            stack <vector<int>> temp;\\n            vector<int> vec;\\n            while(!perm.empty())\\n            {\\n                vec = perm.top();\\n                perm.pop();\\n                for(int i = fix_pos;i < n;i++) /* swap around this fix_pos and generate new perms */\\n                {\\n                    std::swap(vec[i],vec[fix_pos]);\\n                    temp.push(vec);\\n                    std::swap(vec[i],vec[fix_pos]); /*swap back to retain original vec */\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 18521,
                "title": "iterative-c-11-solution",
                "content": "The move semantic is sometimes helpful.\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> v(1,vector<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            vector<vector<int>> tv(move(v));\\n            for (int j = 0; j < tv.size(); ++j) {\\n                for (int k = 0; k <= tv[0].size(); ++k) {\\n                    vector<int> tmp(tv[j]);\\n                    tmp.insert(tmp.begin()+k,nums[i]);\\n                    v.push_back(move(tmp));\\n                }\\n            }\\n        }\\n        return v;\\n    }",
                "solutionTags": [],
                "code": "The move semantic is sometimes helpful.\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> v(1,vector<int>());\\n        for (int i = 0; i < nums.size(); ++i) {\\n            vector<vector<int>> tv(move(v));\\n            for (int j = 0; j < tv.size(); ++j) {\\n                for (int k = 0; k <= tv[0].size(); ++k) {\\n                    vector<int> tmp(tv[j]);\\n                    tmp.insert(tmp.begin()+k,nums[i]);\\n                    v.push_back(move(tmp));\\n                }\\n            }\\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4072449,
                "title": "c-beats-100-recursion-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n# Approach\\n***(Also explained in the code)***\\n1. The `permute` function takes a vector of integers `nums` and returns a vector of vectors containing all possible permutations of `nums`.\\n\\n1. We use a recursive function `solve` to generate permutations. It takes the current state of `nums`, the result vector `ans`, and the current index as parameters.\\n\\n1. In the `solve` function, we start with a base case: If we have processed all elements (i.e., **index >= nums.size()**), we add the current permutation to the result vector `ans`.\\n\\n1. In the recursive part, we iterate through the remaining elements (starting from `index`) and swap the current element with each of them. This generates different permutations.\\n\\n1. After swapping, we recursively call `solve` with the updated `nums` and `index + 1` to generate permutations for the remaining elements.\\n\\n1. Finally, we backtrack by swapping back to the original state to explore other possibilities.\\n\\n\\n***(\\'a\\', \\'b\\', and \\'c\\' here represents numbers.)***\\n\\n\\n![Screenshot 2023-09-21 175006.png](https://assets.leetcode.com/users/images/7eda35cc-7e3c-4239-adb1-82b9774c2cf6_1695304514.7908428.png)\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n$$O(n)$$\\n\\n\\n- **Space complexity:**\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // Recursive function to generate permutations\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index) {\\n        // Base case: If we have processed all elements, add the permutation to the result\\n        if (index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        // Recursion: Try all possible swaps for the current index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Swap the elements at index and i\\n            swap(nums[index], nums[i]);\\n            // Recursively generate permutations for the remaining elements\\n            solve(nums, ans, index + 1);\\n            // Backtrack by swapping back to the original state\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, ans, index); // Start generating permutations from index 0\\n        return ans;\\n    }\\n};\\n\\n```\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Recursive function to generate permutations\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index) {\\n        // Base case: If we have processed all elements, add the permutation to the result\\n        if (index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        // Recursion: Try all possible swaps for the current index\\n        for (int i = index; i < nums.size(); i++) {\\n            // Swap the elements at index and i\\n            swap(nums[index], nums[i]);\\n            // Recursively generate permutations for the remaining elements\\n            solve(nums, ans, index + 1);\\n            // Backtrack by swapping back to the original state\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, ans, index); // Start generating permutations from index 0\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957700,
                "title": "best-solution",
                "content": "# Approach\\nBacktracking\\n\\n# Complexity\\n- Time complexity:\\n$$O(n!*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void permutations(int idx, vector<int>& nums, vector<vector<int>>& ans) {\\n        if (idx == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            swap(nums[idx], nums[i]);\\n            permutations(idx+1, nums, ans);\\n            swap(nums[idx], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void permutations(int idx, vector<int>& nums, vector<vector<int>>& ans) {\\n        if (idx == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            swap(nums[idx], nums[i]);\\n            permutations(idx+1, nums, ans);\\n            swap(nums[idx], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        permutations(0, nums, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874190,
                "title": "simple-1-liner-by-using-builtin-function-and-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(permutations(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return list(permutations(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711565,
                "title": "c-easy-recursion-solution-for-beginers",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe will swap the current element and next element.for example take [1,2,3] we can choose any element so choose 1 and swap it with 1 and swap it with 2 so the array becomes [1,2,3] and [2,1,3] resepctively. continue with other elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n!*n)\\nn!-->for generating  permutations\\nn--->for inserting the permutation to answer\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)-->no extra space is used\\nauxilary space-O(n)(depth of the recursion)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& n,vector<vector<int>>& ans)\\n    {\\n        if(i==n.size())\\n        {\\n            ans.push_back(n);\\n            return;\\n        }\\n        for(int j=i;j<n.size();j++)\\n        {\\n            \\n            swap(n[i],n[j]);\\n            solve(i+1,n,ans);\\n            swap(n[i],n[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& n) {\\n        vector<vector<int>> ans;\\n         solve(0,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& n,vector<vector<int>>& ans)\\n    {\\n        if(i==n.size())\\n        {\\n            ans.push_back(n);\\n            return;\\n        }\\n        for(int j=i;j<n.size();j++)\\n        {\\n            \\n            swap(n[i],n[j]);\\n            solve(i+1,n,ans);\\n            swap(n[i],n[j]);\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& n) {\\n        vector<vector<int>> ans;\\n         solve(0,n,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328876,
                "title": "set-recursion-backtracking",
                "content": "we make a initial call and iterate over whole list , if element we are picking is not in set then \\nwe add to our perm list and add it in set and  recursively call again and once we reach the base case where len(arr) == len(permGenerated) then we add perm to res list and now call goes back to the for loop , and upon the return we remove the element we had added to perm and also remove it from the set.\\nGo Through Code and let me know if you need a decisive tree for it .\\n```\\nclass Solution:\\n    def permute(self, arr: List[int]) -> List[List[int]]:\\n        \\n        ans  = []\\n        def bt(res,check) :\\n            if len(res) == len(arr) :\\n                ans.append(res[:])\\n                return\\n            \\n            for i in arr :\\n                if i not in check :\\n                    check.add(i)\\n                    res.append(i)\\n                    bt(res,check)\\n                    res.remove(i)\\n                    check.remove(i)\\n        bt([],set())\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "we make a initial call and iterate over whole list , if element we are picking is not in set then \\nwe add to our perm list and add it in set and  recursively call again and once we reach the base case where len(arr) == len(permGenerated) then we add perm to res list and now call goes back to the for loop , and upon the return we remove the element we had added to perm and also remove it from the set.\\nGo Through Code and let me know if you need a decisive tree for it .\\n```\\nclass Solution:\\n    def permute(self, arr: List[int]) -> List[List[int]]:\\n        \\n        ans  = []\\n        def bt(res,check) :\\n            if len(res) == len(arr) :\\n                ans.append(res[:])\\n                return\\n            \\n            for i in arr :\\n                if i not in check :\\n                    check.add(i)\\n                    res.append(i)\\n                    bt(res,check)\\n                    res.remove(i)\\n                    check.remove(i)\\n        bt([],set())\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3059260,
                "title": "recursion-c-easy-approach",
                "content": "\\n```\\nclass Solution {\\n    int n;\\n     vector<vector<int>> ans;\\n     void solve(vector<int> nums, vector<int> v){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(int i=0; i<nums.size(); i++){\\n             int x=nums[i];\\n             v.push_back(x);\\n             nums.erase(nums.begin()+i);\\n             solve(nums,v);\\n             v.pop_back();\\n            nums.insert(nums.begin()+i, x);\\n         }\\n     }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> v; n=nums.size();\\n        solve(nums,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n     vector<vector<int>> ans;\\n     void solve(vector<int> nums, vector<int> v){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(int i=0; i<nums.size(); i++){\\n             int x=nums[i];\\n             v.push_back(x);\\n             nums.erase(nums.begin()+i);\\n             solve(nums,v);\\n             v.pop_back();\\n            nums.insert(nums.begin()+i, x);\\n         }\\n     }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<int> v; n=nums.size();\\n        solve(nums,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053533,
                "title": "c-backtracking-explained-with-comments",
                "content": "# Intuition\\nSince we need to find all the possible permutations, backtracking is needed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid print(int i, vector<int> &nums, vector<vector<int>> &ans){\\n    if(i==nums.size()){\\n        ans.push_back(nums);//one permutation instance\\n        return;\\n    }\\n    for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);//modifying nums\\n        print(i+1,nums,ans);recursively calling the print function\\n        swap(nums[i],nums[j]);//backtracking step\\n    }\\n}\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        print(0,nums,ans);\\n        return  ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid print(int i, vector<int> &nums, vector<vector<int>> &ans){\\n    if(i==nums.size()){\\n        ans.push_back(nums);//one permutation instance\\n        return;\\n    }\\n    for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);//modifying nums\\n        print(i+1,nums,ans);recursively calling the print function\\n        swap(nums[i],nums[j]);//backtracking step\\n    }\\n}\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        print(0,nums,ans);\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025444,
                "title": "python3-1-line-code-using-function-for-fun",
                "content": "- # Code\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:        \\n        return permutations(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:        \\n        return permutations(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689366,
                "title": "c-recursion-100-faster",
                "content": "```\\nvoid solve(vector<int>& nums,vector<vector<int>>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            v.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            swap(nums[i],nums[j]);\\n            solve(nums,v,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n          \\n    }\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>>v;\\n        int i=0;\\n        solve(nums,v,i);\\n        return v;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nvoid solve(vector<int>& nums,vector<vector<int>>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            v.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++)\\n        {\\n            swap(nums[i],nums[j]);\\n            solve(nums,v,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n          \\n    }\\n    vector<vector<int>> permute(vector<int>& nums) \\n    {\\n        vector<vector<int>>v;\\n        int i=0;\\n        solve(nums,v,i);\\n        return v;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428738,
                "title": "js-clear-explanation-faster-than-99-90",
                "content": "**How to solve this problem?**\\n\\nSo, according to LeetCode, this problem is supposed to be solved with recursion/backtracking. If the problem is solved with recursion, then we have to figure out what is the base case for recursive calls and what is the recursive case. In order for the algorithm to work, we need our recursive case to get to the base case eventually by decreasing the problem size. \\n\\n**Solution explained**\\n\\nIn this problem all we have is a `nums` array, so probably we need to shrink the array size, until we hit the base case, and then work our way up, while keeping in mind the fact that we shrinked the array size, we do not want to lose any data. This is where the backtracking part fits in. \\n\\nNow, the base case is probably an array of size 1. Permutations of the `[3]` array is just `[[3]]`. How do we reduce our initial problem to the base case? We could simply go through each element of the array, removing the first element of the array. If we do that, the recursive case should work it\\'s way to the base case. Then we need to handle the results returned by the base case in the recursive case and return the new result.\\n\\nFor example, let us take the array of size 2: `nums = [1, 2]`. If we remove the first element, we get just `[2]`, this is our base case. In order to complete the permutations array, we should add the missing `1` to the permutations returned by the base case, which will get us `[[2, 1]]`. Then we add the missing `1` back to the `nums` array, we get `nums = [2, 1]`. We remove `2`, since this is our first element now and get just `[1]`. This is, again, the base case. Then we add the `2` to the end and get `[1, 2]`. We add up the results to make `result = [[2, 1], [1, 2]]` and we can return this value. If it works for the array of size 2, it should work for an array of any size.\\n\\nHere is the resulting code:\\n```js\\nvar permute = function(nums) {\\n    const result = [];\\n\\t// - Base case\\n    if(nums.length === 1) {\\n\\t    // If there\\'s just 1 element, we simply return a copy\\n\\t\\t// of that array\\n        return [[...nums]];\\n    }\\n\\t// - Recursive case\\n\\t// We move through each number in `nums`\\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\t// Remove the first element of `nums`\\n        const n = nums.shift();\\n\\t\\t// Now we have reduced the `nums` size to \\n\\t\\t// `nums.length - 1`, this will get us to the\\n\\t\\t// base case eventually\\n        const perms = permute(nums);\\n\\t\\t// Traverse through each of the permutations\\n\\t\\t// returned by a recursive call\\n        for(let perm of perms) {\\n\\t\\t    // We add the number that we shifted earlier\\n\\t\\t\\t// to reduce the problem size to the back of\\n\\t\\t\\t// the permutation array\\n            perm.push(n);\\n\\t\\t\\t// We add this permutation to the result array\\n            result.push(perm);\\n        }\\n\\t\\t// Finally, we add the number we shifted back\\n\\t\\t// to the array\\n        nums.push(n);\\n    }\\n\\t// Return the result\\n    return result;\\n};\\n```\\n\\n**Further runtime improvement**\\n\\nWhat if we make our base case an array of size 2? Figuring out what the permutations of a 2-sized array is pretty straightforward. For example, permutations of `[1, 2]` are `[[1, 2], [2, 1]]`. So if we change our base case to an array of size 2, we could get rid of a few extra recursive calls, and save some time.\\n\\n```js\\n\\t// - Base case\\n    if(nums.length === 2) {\\n        return [[nums[0], nums[1]], [nums[1], nums[0]]];\\n    }\\n```\\n\\nThis should get your solution to the top 99.90% of JS solutions.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```js\\nvar permute = function(nums) {\\n    const result = [];\\n\\t// - Base case\\n    if(nums.length === 1) {\\n\\t    // If there\\'s just 1 element, we simply return a copy\\n\\t\\t// of that array\\n        return [[...nums]];\\n    }\\n\\t// - Recursive case\\n\\t// We move through each number in `nums`\\n    for(let i = 0; i < nums.length; i++) {\\n\\t\\t// Remove the first element of `nums`\\n        const n = nums.shift();\\n\\t\\t// Now we have reduced the `nums` size to \\n\\t\\t// `nums.length - 1`, this will get us to the\\n\\t\\t// base case eventually\\n        const perms = permute(nums);\\n\\t\\t// Traverse through each of the permutations\\n\\t\\t// returned by a recursive call\\n        for(let perm of perms) {\\n\\t\\t    // We add the number that we shifted earlier\\n\\t\\t\\t// to reduce the problem size to the back of\\n\\t\\t\\t// the permutation array\\n            perm.push(n);\\n\\t\\t\\t// We add this permutation to the result array\\n            result.push(perm);\\n        }\\n\\t\\t// Finally, we add the number we shifted back\\n\\t\\t// to the array\\n        nums.push(n);\\n    }\\n\\t// Return the result\\n    return result;\\n};\\n```\n```js\\n\\t// - Base case\\n    if(nums.length === 2) {\\n        return [[nums[0], nums[1]], [nums[1], nums[0]]];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278089,
                "title": "c-easy-simple-solution-permutations",
                "content": "class Solution {\\npublic:\\nvector<vector<int>> ans;\\nvoid permutation(vector<int>&a, int ind, int n)\\n{\\n    if(ind==n)\\n    {\\n        ans.push_back(a);\\n        return;\\n    }\\n    for(int i=ind;i<n;i++)\\n    {\\n        swap(a[ind],a[i]);\\n        permutation(a,ind+1,n);\\n        swap(a[ind],a[i]);\\n    }\\n}\\nvector<vector<int>> permute(vector<int>& nums) {\\n    permutation(nums,0,nums.size());\\n    return ans;\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\nvector<vector<int>> ans;\\nvoid permutation(vector<int>&a, int ind, int n)\\n{\\n    if(ind==n)\\n    {\\n        ans.push_back(a);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2133771,
                "title": "simple-recursive-solution-c",
                "content": "```\\n//recursive solution \\n    void perm(int pos,vector<int>& v,vector<vector<int>>& ans)\\n    {\\n        if(pos>=v.size())\\n        {\\n            ans.push_back(v);\\n        }\\n        for(int i=pos;i<v.size();i++)\\n        {\\n            swap(v[i],v[pos]); //first swap to get the ith element on desired position\\n            perm(pos+1,v,ans); // recursive call for remaining elements\\n            swap(v[i],v[pos]); //back tracking or cleaning\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        perm(0,nums,ans);\\n        return ans;\\n    }\\n\\t```\\n**\\tIF YOU FIND IT HELPFUL PLEASE UPVOTE IT**\\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n//recursive solution \\n    void perm(int pos,vector<int>& v,vector<vector<int>>& ans)\\n    {\\n        if(pos>=v.size())\\n        {\\n            ans.push_back(v);\\n        }\\n        for(int i=pos;i<v.size();i++)\\n        {\\n            swap(v[i],v[pos]); //first swap to get the ith element on desired position\\n            perm(pos+1,v,ans); // recursive call for remaining elements\\n            swap(v[i],v[pos]); //back tracking or cleaning\\n        }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        perm(0,nums,ans);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703219,
                "title": "c-easy-to-understand-backtracking",
                "content": "![image](https://assets.leetcode.com/users/images/12d39195-f555-42ab-b69c-23ae3a954661_1642698221.311954.jpeg)\\n\\n\\n```\\nvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n        if(i==nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);\\n        helper(res,nums,i+1);\\n        swap(nums[i],nums[j]);\\n    }\\n        return;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res,nums,0);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid helper(vector<vector<int>> &res , vector<int> &nums,int i){\\n        if(i==nums.size()){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int j=i;j<nums.size();j++){\\n        swap(nums[i],nums[j]);\\n        helper(res,nums,i+1);\\n        swap(nums[i],nums[j]);\\n    }\\n        return;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res,nums,0);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684545,
                "title": "permutations-java-backtracking-inline-explanation",
                "content": "### bactracking Approach\\n```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list; \\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> list, List<Integer> temp, int [] nums){\\n        if (temp.size()==nums.length){\\n            list.add(new ArrayList(temp));//if the the temp list equals nums length then add to resultant list\\n            }else{\\n            for(int i=0;i<nums.length;i++){\\n                if(temp.contains(nums[i]))\\n                    continue;\\n                temp.add(nums[i]);//Add the current traversing element from nums\\n                backtrack(list, temp, nums);//Backtrack to its previous node by calling backtrack function recursively\\n                temp.remove(temp.size()-1);//remove the last element of the temp to find another way from the prev node which we got ofter backtracking \\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<>(), nums);\\n        return list; \\n        \\n    }\\n    \\n    public void backtrack(List<List<Integer>> list, List<Integer> temp, int [] nums){\\n        if (temp.size()==nums.length){\\n            list.add(new ArrayList(temp));//if the the temp list equals nums length then add to resultant list\\n            }else{\\n            for(int i=0;i<nums.length;i++){\\n                if(temp.contains(nums[i]))\\n                    continue;\\n                temp.add(nums[i]);//Add the current traversing element from nums\\n                backtrack(list, temp, nums);//Backtrack to its previous node by calling backtrack function recursively\\n                temp.remove(temp.size()-1);//remove the last element of the temp to find another way from the prev node which we got ofter backtracking \\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661636,
                "title": "how-to-approach-the-problem-both-recursive-and-iterative-way",
                "content": "\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        This can be solved using iterative way too\\n        we need queue for this\\n        Idea is to push empty list into queue\\n        then we will graze over each no in array\\n            for each no we will graze over all lists into queue\\n                for each list we will graze over each idx including last\\n                    if it make upto the length of nums\\n                        then add to ans\\n                    else\\n                        add to queue\\n        for eg.[1,2,3]\\n                                    [ ]\\n                                     | for 1\\n                                    [1]\\n                                /          \\\\ for 2\\n                            [2,1]           [1,2]\\n                        /   |   \\\\          /    |   \\\\ for 3\\n                      321   231 213       312   132  123  now add it to answer\\n        tc = O(n * n!)\\n        sc = O(n!) for queue\\n                                     \\n        \"\"\"\\n        q = deque()\\n        q.append([])\\n        n = len(nums)\\n        ans = []\\n        for currIdx in range(n):\\n            currEle = nums[currIdx]\\n            queueLen = len(q)\\n            for currListIdx in range(queueLen):\\n                innerPermute = q.popleft()\\n                for idxInCurrList in range(len(innerPermute) + 1):\\n                    newPermute = innerPermute.copy()\\n                    newPermute.insert(idxInCurrList,currEle)\\n                    if len(newPermute) == n:\\n                        ans.append(newPermute)\\n                    else:\\n                        q.append(newPermute)\\n        return ans\\n    \\n    def recursive(self,nums):\\n        \"\"\"\\n        we can do it recursively\\n        Idea is to graze over numbers array\\n        means for each curr idx\\n            graze over curr path for each position\\n                insert ele at curr idx in curr path\\n                and recur\\n        for eg. [1,2,3]\\n                                    [ ]\\n                                     |\\n                                    [1]\\n                            /                       \\\\\\n                         [2,1]                      [1,2]\\n                    /      |    \\\\          /           |       \\\\\\n              [3,2,1]   [2,3,1] [2,1,3]   [3,1,2]   [1,3,2]    [1,2,3]\\n              \\n        base case is if curr idx is reached end\\n            then attach curr path copy to answer\\n            \\n        tc = O(n * n!) for any n length array or string there are n! permutations\\n        sc = O(n!) to store all recursive calls of permutation\\n        \"\"\"\\n        def backtrack(nums,currIdx,n,ans,currPath):\\n            if currIdx == n:\\n                ans.append(currPath)\\n                return\\n            for i in range(len(currPath) + 1):\\n                newList = currPath.copy()\\n                newList.insert(i,nums[currIdx])\\n                backtrack(nums,currIdx + 1,n,ans,newList)\\n                \\n        currPath = []\\n        ans = []\\n        n = len(nums)\\n        backtrack(nums,0,n,ans,currPath)\\n        return ans\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Queue"
                ],
                "code": "\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        \"\"\"\\n        This can be solved using iterative way too\\n        we need queue for this\\n        Idea is to push empty list into queue\\n        then we will graze over each no in array\\n            for each no we will graze over all lists into queue\\n                for each list we will graze over each idx including last\\n                    if it make upto the length of nums\\n                        then add to ans\\n                    else\\n                        add to queue\\n        for eg.[1,2,3]\\n                                    [ ]\\n                                     | for 1\\n                                    [1]\\n                                /          \\\\ for 2\\n                            [2,1]           [1,2]\\n                        /   |   \\\\          /    |   \\\\ for 3\\n                      321   231 213       312   132  123  now add it to answer\\n        tc = O(n * n!)\\n        sc = O(n!) for queue\\n                                     \\n        \"\"\"\\n        q = deque()\\n        q.append([])\\n        n = len(nums)\\n        ans = []\\n        for currIdx in range(n):\\n            currEle = nums[currIdx]\\n            queueLen = len(q)\\n            for currListIdx in range(queueLen):\\n                innerPermute = q.popleft()\\n                for idxInCurrList in range(len(innerPermute) + 1):\\n                    newPermute = innerPermute.copy()\\n                    newPermute.insert(idxInCurrList,currEle)\\n                    if len(newPermute) == n:\\n                        ans.append(newPermute)\\n                    else:\\n                        q.append(newPermute)\\n        return ans\\n    \\n    def recursive(self,nums):\\n        \"\"\"\\n        we can do it recursively\\n        Idea is to graze over numbers array\\n        means for each curr idx\\n            graze over curr path for each position\\n                insert ele at curr idx in curr path\\n                and recur\\n        for eg. [1,2,3]\\n                                    [ ]\\n                                     |\\n                                    [1]\\n                            /                       \\\\\\n                         [2,1]                      [1,2]\\n                    /      |    \\\\          /           |       \\\\\\n              [3,2,1]   [2,3,1] [2,1,3]   [3,1,2]   [1,3,2]    [1,2,3]\\n              \\n        base case is if curr idx is reached end\\n            then attach curr path copy to answer\\n            \\n        tc = O(n * n!) for any n length array or string there are n! permutations\\n        sc = O(n!) to store all recursive calls of permutation\\n        \"\"\"\\n        def backtrack(nums,currIdx,n,ans,currPath):\\n            if currIdx == n:\\n                ans.append(currPath)\\n                return\\n            for i in range(len(currPath) + 1):\\n                newList = currPath.copy()\\n                newList.insert(i,nums[currIdx])\\n                backtrack(nums,currIdx + 1,n,ans,newList)\\n                \\n        currPath = []\\n        ans = []\\n        n = len(nums)\\n        backtrack(nums,0,n,ans,currPath)\\n        return ans\\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1564385,
                "title": "python-3-recursion-faster-than-99-97",
                "content": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]):\\n        if len(nums) == 1: return [nums]\\n        if len(nums) == 2: return [list(nums), list(nums)[::-1]]\\n        \\n        if type(nums) is not deque: nums = deque(nums)\\n\\n        result = deque()\\n        for _ in range(len(nums)):\\n            num = nums.popleft()  # fix first number\\n\\n            perm_results = self.permute(nums)\\n            for perm in perm_results:\\n                perm.append(num) # add the fixed number to all sub permutations\\n            result += perm_results\\n\\n            nums.append(num) # return the fixed number into the end\\n\\n        return result\\n\\n```\\n![image](https://assets.leetcode.com/users/images/c22bb704-ba60-4baf-8966-c4608a111588_1636278377.334533.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def permute(self, nums: List[int]):\\n        if len(nums) == 1: return [nums]\\n        if len(nums) == 2: return [list(nums), list(nums)[::-1]]\\n        \\n        if type(nums) is not deque: nums = deque(nums)\\n\\n        result = deque()\\n        for _ in range(len(nums)):\\n            num = nums.popleft()  # fix first number\\n\\n            perm_results = self.permute(nums)\\n            for perm in perm_results:\\n                perm.append(num) # add the fixed number to all sub permutations\\n            result += perm_results\\n\\n            nums.append(num) # return the fixed number into the end\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451507,
                "title": "c-0ms-backtracking-solution-with-explanation",
                "content": "The idea is to generate all possible permutations, by repeatedly swapping the first(left-most) element with every other element in the array. Then swapping the second element(hence `leftIdx + 1`) with every element towards its right, and so on. This is achieved via backtracking.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, int leftIdx, int rightIdx){\\n        if(leftIdx == rightIdx){  // all the numbers in the current permutation have been considered\\n            res.push_back(nums);  // hence, push them into result\\n        } else {\\n            for(int i = leftIdx; i<=rightIdx; i++){\\n                swap(nums[i], nums[leftIdx]);    // swap and call it again\\n                backtrack(res, nums, leftIdx + 1, rightIdx);\\n                swap(nums[i], nums[leftIdx]);    // revert the change (backtrack)\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(res, nums, 0, nums.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, int leftIdx, int rightIdx){\\n        if(leftIdx == rightIdx){  // all the numbers in the current permutation have been considered\\n            res.push_back(nums);  // hence, push them into result\\n        } else {\\n            for(int i = leftIdx; i<=rightIdx; i++){\\n                swap(nums[i], nums[leftIdx]);    // swap and call it again\\n                backtrack(res, nums, leftIdx + 1, rightIdx);\\n                swap(nums[i], nums[leftIdx]);    // revert the change (backtrack)\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        backtrack(res, nums, 0, nums.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421884,
                "title": "js-backtracking-dfs",
                "content": "```\\n\\n//approach: backtracking (DFS)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (nth -1 value), so then you can now start with other value add to that 0th value\\nvar permute = function(nums) {\\n    let resultArray = new Array();\\n    \\n    function helper(nums, permutedValueArr){\\n        \\n        if(nums.length == 0){ \\n            resultArray.push([...permutedValueArr]);  //push the copy of the permuted array \\n            return;\\n        }\\n        \\n        for(let i = 0; i < nums.length; i++){\\n            //choose\\n            permutedValueArr.push(nums[i]); //0th value\\n            \\n            let decreasedNums = nums.filter((n, index) => index != i);\\n            \\n            //explore\\n            helper(decreasedNums, permutedValueArr);   //passing in the new decreased nums array\\n            \\n            //unchoose\\n            permutedValueArr.pop();  //start removing the elements from the last so you can make possible combinations of values with that 0th value \\n        }\\n        \\n    }\\n    \\n    helper(nums, new Array());\\n    \\n    return resultArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n//approach: backtracking (DFS)\\n//basic template of backtracking would be to loop, choose, explore and unchoose\\n//loop: you want to iterate over all the numbers so that you can find it\\'s possible values\\n//choose: you start with the index value(the 0th index number), so that you can find the next combined possible values for the 0th value\\n//explore: basically recursion to add all the next values to the 0th value\\n//unchoose: you pop the value (nth -1 value), so then you can now start with other value add to that 0th value\\nvar permute = function(nums) {\\n    let resultArray = new Array();\\n    \\n    function helper(nums, permutedValueArr){\\n        \\n        if(nums.length == 0){ \\n            resultArray.push([...permutedValueArr]);  //push the copy of the permuted array \\n            return;\\n        }\\n        \\n        for(let i = 0; i < nums.length; i++){\\n            //choose\\n            permutedValueArr.push(nums[i]); //0th value\\n            \\n            let decreasedNums = nums.filter((n, index) => index != i);\\n            \\n            //explore\\n            helper(decreasedNums, permutedValueArr);   //passing in the new decreased nums array\\n            \\n            //unchoose\\n            permutedValueArr.pop();  //start removing the elements from the last so you can make possible combinations of values with that 0th value \\n        }\\n        \\n    }\\n    \\n    helper(nums, new Array());\\n    \\n    return resultArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378285,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var permute = function(nums) {\\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(temp, nums) {\\n          if(nums.length == 0) {\\n              result.push([...temp])\\n              return\\n           }\\n        \\n          for(let i=0; i<nums.length; i++) {\\n              temp.push(nums[i])\\n              nums.splice(i, 1)\\n              backtracking(temp, nums)\\n              nums.splice(i, 0, temp.pop())\\n           }\\n        }\\n        backtracking(temp, nums)\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "\\n\\n    var permute = function(nums) {\\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(temp, nums) {\\n          if(nums.length == 0) {\\n              result.push([...temp])\\n              return\\n           }\\n        \\n          for(let i=0; i<nums.length; i++) {\\n              temp.push(nums[i])\\n              nums.splice(i, 1)\\n              backtracking(temp, nums)\\n              nums.splice(i, 0, temp.pop())\\n           }\\n        }\\n        backtracking(temp, nums)\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1203474,
                "title": "simplest-java-solution-no-backtracking-simple-iteration-recursion",
                "content": "```\\n    // To create all permutations of integers contained in nums array,\\n    // we realize that for each num, there needs to be a list of integers with this num as the first member in that list.\\n    // Once we have that, we realize that for each remaining num, there needs to be a list of integers that has this num as the next member in that list.\\n    // Once we have that, we realize that for each remaining num, we need to do the same as above.\\n    // The key realization is that we need to have a new copy of the list at each step when we add a num to it.\\n    //\\n    // So, we start with an empty list of integers called sublist, and iterate over the given nums,\\n    // creating a new copy from the sublist and adding the current num to that copy, but only if the current num is not already in the sublist.\\n    // We keep doing this until the size of the sublist becomes equal to the number of given nums,\\n    // which means that one permutation is complete, so we add this sublist to the result.\\n    // When we are done iterating over all the nums, our result will have all the permutations.\\n    // \\n    // You can visualize this with a tree/branching approach, e.g., for nums = [1, 2, 3]\\n    //                                 start with empty sublist\\n    //                                        [ ]\\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //              /                          |                             \\\\  \\n    //            1                            2                              3\\n    //   new copy of sublist           new copy of sublist             new copy of sublist\\n    //   add 1 to this copy            add 2 to this copy              add 3 to this copy\\n    //           [1]                           [2]                             [3]\\n    // \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //    /     |        \\\\              /        |      \\\\                 /      |       \\\\\\n    //   1      2         3            1         2       3              1        2        3\\n    //   x     new copy  new copy     new copy   x     new copy      new copy  new copy   x          \\n    //         add 2     add 3        add 1            add 3         add 1     add 2              \\n    //         [1,2]     [1,3]        [2,1]            [2,3]         [3,1]     [3,2]                  \\n    //                                                                                   \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //         |           |            |               |             |           |              \\n    //         3           2            3               1             2           1                \\n    //       new copy    new copy     new copy        new copy      new copy    new copy                \\n    //       add 3       add 2        add 3           add 1         add 2       add 1                 \\n    //      [1,2,3]     [1,3,2]      [2,1,3]         [2,3,1]       [3,1,2]     [3,2,1]\\n    //\\n    //  if (size of sublist == nums.length), add this sublist to result\\n    // [    [1,2,3]    [1,3,2]       [2,1,3]         [2,3,1]      [3,1,2]      [3,2,1] ] = result\\n    // done\\n    //  \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        // start with an empty sublist\\n        List<Integer> sublist = new ArrayList<Integer>();\\n        helper(nums, result, sublist);\\n        return result;\\n    }\\n    \\n    private void helper(int[]nums, List<List<Integer>> result, List<Integer> sublist) {\\n        // if all nums are in the sublist, add this sublist to the result\\n        if (sublist.size() == nums.length) {\\n            result.add(sublist);\\n\\t\\t\\treturn;\\n        }\\n\\n        // for each num, if that num is not in the sublist, create a new copy of sublist and add the num to it\\n        for (int num : nums) {\\n            if (!sublist.contains(num)) {\\n                List<Integer> copy = new ArrayList<>(sublist);\\n                copy.add(num);\\n                // pass the new copy of sublist for the next recursion\\n                helper(nums, result, copy);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // To create all permutations of integers contained in nums array,\\n    // we realize that for each num, there needs to be a list of integers with this num as the first member in that list.\\n    // Once we have that, we realize that for each remaining num, there needs to be a list of integers that has this num as the next member in that list.\\n    // Once we have that, we realize that for each remaining num, we need to do the same as above.\\n    // The key realization is that we need to have a new copy of the list at each step when we add a num to it.\\n    //\\n    // So, we start with an empty list of integers called sublist, and iterate over the given nums,\\n    // creating a new copy from the sublist and adding the current num to that copy, but only if the current num is not already in the sublist.\\n    // We keep doing this until the size of the sublist becomes equal to the number of given nums,\\n    // which means that one permutation is complete, so we add this sublist to the result.\\n    // When we are done iterating over all the nums, our result will have all the permutations.\\n    // \\n    // You can visualize this with a tree/branching approach, e.g., for nums = [1, 2, 3]\\n    //                                 start with empty sublist\\n    //                                        [ ]\\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //              /                          |                             \\\\  \\n    //            1                            2                              3\\n    //   new copy of sublist           new copy of sublist             new copy of sublist\\n    //   add 1 to this copy            add 2 to this copy              add 3 to this copy\\n    //           [1]                           [2]                             [3]\\n    // \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //    /     |        \\\\              /        |      \\\\                 /      |       \\\\\\n    //   1      2         3            1         2       3              1        2        3\\n    //   x     new copy  new copy     new copy   x     new copy      new copy  new copy   x          \\n    //         add 2     add 3        add 1            add 3         add 1     add 2              \\n    //         [1,2]     [1,3]        [2,1]            [2,3]         [3,1]     [3,2]                  \\n    //                                                                                   \\n    // for each num that\\'s not already in the sublist, create a copy of the sublist and add the num to it\\n    //         |           |            |               |             |           |              \\n    //         3           2            3               1             2           1                \\n    //       new copy    new copy     new copy        new copy      new copy    new copy                \\n    //       add 3       add 2        add 3           add 1         add 2       add 1                 \\n    //      [1,2,3]     [1,3,2]      [2,1,3]         [2,3,1]       [3,1,2]     [3,2,1]\\n    //\\n    //  if (size of sublist == nums.length), add this sublist to result\\n    // [    [1,2,3]    [1,3,2]       [2,1,3]         [2,3,1]      [3,1,2]      [3,2,1] ] = result\\n    // done\\n    //  \\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        // start with an empty sublist\\n        List<Integer> sublist = new ArrayList<Integer>();\\n        helper(nums, result, sublist);\\n        return result;\\n    }\\n    \\n    private void helper(int[]nums, List<List<Integer>> result, List<Integer> sublist) {\\n        // if all nums are in the sublist, add this sublist to the result\\n        if (sublist.size() == nums.length) {\\n            result.add(sublist);\\n\\t\\t\\treturn;\\n        }\\n\\n        // for each num, if that num is not in the sublist, create a new copy of sublist and add the num to it\\n        for (int num : nums) {\\n            if (!sublist.contains(num)) {\\n                List<Integer> copy = new ArrayList<>(sublist);\\n                copy.add(num);\\n                // pass the new copy of sublist for the next recursion\\n                helper(nums, result, copy);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076700,
                "title": "elegant-kotlin-solution",
                "content": "```\\nfun permute(nums: IntArray): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\tbacktrack(result, ArrayList(), nums.toMutableList())\\n\\treturn result\\n}\\n\\nprivate fun backtrack(result: MutableList<List<Int>>, tmpList: List<Int>, nums: MutableList<Int>) {\\n\\tif (nums.isEmpty()) {\\n\\t\\tresult.add(tmpList)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor (i in nums.indices) {\\n\\t\\tval numsNew = ArrayList<Int>(nums).also {\\n\\t\\t\\tit.removeAt(i)\\n\\t\\t}\\n\\n\\t\\tbacktrack(result, tmpList + nums[i], numsNew) // \"+\" creates copy of tmpList with appended nums[i] \\n\\t}\\n}\\n ```",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfun permute(nums: IntArray): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\tbacktrack(result, ArrayList(), nums.toMutableList())\\n\\treturn result\\n}\\n\\nprivate fun backtrack(result: MutableList<List<Int>>, tmpList: List<Int>, nums: MutableList<Int>) {\\n\\tif (nums.isEmpty()) {\\n\\t\\tresult.add(tmpList)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor (i in nums.indices) {\\n\\t\\tval numsNew = ArrayList<Int>(nums).also {\\n\\t\\t\\tit.removeAt(i)\\n\\t\\t}\\n\\n\\t\\tbacktrack(result, tmpList + nums[i], numsNew) // \"+\" creates copy of tmpList with appended nums[i] \\n\\t}\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 986577,
                "title": "easiest-to-understand-beats-93-java",
                "content": "Enjoy.\\n\\n```\\nclass Solution {\\n    \\n    // Add permutations for the numbers one by one \\n    // A new number can go between all the numbers in an existing list\\n    // See this\\n    // Existing list [] add 1\\n    // Existing list [[1]] add 2 - see that 2 can go as 0th item and 1th item\\n    // Existing list [[2, 1], [1, 2]] add 3 - see that for each list, 3 can go as 0th, 1th and 2nd item\\n    // Existing list [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] add 4  - ....\\n    \\n    public List<List<Integer>> permute(int[] nums) {   \\n          List<List<Integer>> result = new ArrayList<>();\\n          for(int num : nums) {\\n              result = addNumToLists( result,  num) ;\\n          }\\n          return result;\\n    }\\n    \\n    public List<List<Integer>> addNumToLists(List<List<Integer>> lists, int num) { \\n        List<List<Integer>> result = new ArrayList<>();   \\n        if(lists.isEmpty()) {\\n            List<Integer> newlist = new ArrayList<>();\\n            newlist.add(num);\\n            result.add(newlist);\\n        } else {\\n            for(List<Integer> list : lists) {\\n                int size = list.size();\\n                for(int i = 0 ; i <= size ; i++ ) {\\n                    List<Integer> newList = new ArrayList<>(list);\\n                    newList.add(i,num);\\n                    result.add(newList);\\n                }\\n            } \\n        }        \\n        //Turn on output to see how it works\\n        //System.out.println(result);\\n        return result;    \\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Add permutations for the numbers one by one \\n    // A new number can go between all the numbers in an existing list\\n    // See this\\n    // Existing list [] add 1\\n    // Existing list [[1]] add 2 - see that 2 can go as 0th item and 1th item\\n    // Existing list [[2, 1], [1, 2]] add 3 - see that for each list, 3 can go as 0th, 1th and 2nd item\\n    // Existing list [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] add 4  - ....\\n    \\n    public List<List<Integer>> permute(int[] nums) {   \\n          List<List<Integer>> result = new ArrayList<>();\\n          for(int num : nums) {\\n              result = addNumToLists( result,  num) ;\\n          }\\n          return result;\\n    }\\n    \\n    public List<List<Integer>> addNumToLists(List<List<Integer>> lists, int num) { \\n        List<List<Integer>> result = new ArrayList<>();   \\n        if(lists.isEmpty()) {\\n            List<Integer> newlist = new ArrayList<>();\\n            newlist.add(num);\\n            result.add(newlist);\\n        } else {\\n            for(List<Integer> list : lists) {\\n                int size = list.size();\\n                for(int i = 0 ; i <= size ; i++ ) {\\n                    List<Integer> newList = new ArrayList<>(list);\\n                    newList.add(i,num);\\n                    result.add(newList);\\n                }\\n            } \\n        }        \\n        //Turn on output to see how it works\\n        //System.out.println(result);\\n        return result;    \\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904215,
                "title": "simple-diagram-python-code-beating-97-in-speed-and-100-in-space",
                "content": "The concept is that for **N** elements we pick one by one and swap it with itself and the rest of the element consisting that element and then we move to next element and do the same.\\n![image](https://assets.leetcode.com/users/images/4dbd465d-f79a-43e0-9cba-fe81ab71b1e4_1603277897.2668254.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        p=[]\\n        def rec(nums,i):\\n            if i==len(nums)-1:\\n                p.append(nums[:])\\n                return\\n            for j in range(i,len(nums)):\\n                nums[i],nums[j]=nums[j],nums[i] #swap\\n                rec(nums,i+1)\\n                nums[i],nums[j]=nums[j],nums[i]  #reswap so that we get the prev array\\n        rec(nums,0)\\n        return p\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        p=[]\\n        def rec(nums,i):\\n            if i==len(nums)-1:\\n                p.append(nums[:])\\n                return\\n            for j in range(i,len(nums)):\\n                nums[i],nums[j]=nums[j],nums[i] #swap\\n                rec(nums,i+1)\\n                nums[i],nums[j]=nums[j],nums[i]  #reswap so that we get the prev array\\n        rec(nums,0)\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842210,
                "title": "ruby-backtracking",
                "content": "```\\ndef permute(nums)\\n  results = []\\n  backtrack(nums, [], results)\\n  results\\nend\\n\\ndef backtrack(list, temp, results)\\n  if temp.length == list.length\\n    results << temp.dup\\n  end\\n  \\n  list.each do |n|\\n    next if temp.include? n\\n    temp << n\\n    backtrack(list, temp, results)\\n    temp.pop\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef permute(nums)\\n  results = []\\n  backtrack(nums, [], results)\\n  results\\nend\\n\\ndef backtrack(list, temp, results)\\n  if temp.length == list.length\\n    results << temp.dup\\n  end\\n  \\n  list.each do |n|\\n    next if temp.include? n\\n    temp << n\\n    backtrack(list, temp, results)\\n    temp.pop\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 705100,
                "title": "c-simple-recursive-solution-with-explanation",
                "content": "Purmutations recursive function.\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\n\\n```\\n#include <stdlib.h>\\n\\n/*\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\nFor example:\\n\\n    for the permutations of [1, 2, 3] first we get the permutations of [1, 2].\\n        that [[1, 2], [2, 1]]\\n    then for each of them pushes 3 between the numbers in all available positions.\\n        for [1, 2] we get [1, 2, 3], [3, 1, 2], [1, 3, 2].\\n        for [2, 1] we get [2, 1, 3], [3, 2, 1], [2, 3, 1]. \\n        \\n*note - Assumes the table is in the right size.\\n*/\\nint fill_permutations(int nums[], int nums_size, int *permutations_table[])\\n{\\n    int permutations_amount = 0;\\n    int i = 0;\\n    // Holds the line we are currently writing the permutations to.\\n    int line_index = 0;\\n    // The column we are pushing the last number to.\\n    int column_index = 0;\\n    // Used for pushing the last number between the other numbers.\\n    int temp = 0;\\n    \\n    // Exit rule.\\n    if (0 == nums_size)\\n    {\\n        return 0;\\n    }\\n    if (1 == nums_size)\\n    {\\n        permutations_table[0][0] = nums[0];\\n        return 1;\\n    }\\n    \\n    // Fills the permutations of the numbers excluding the last one.\\n    permutations_amount = fill_permutations(nums, nums_size - 1, permutations_table);\\n    line_index = permutations_amount;\\n    \\n    for (i = 0; i < permutations_amount; ++i)\\n    {\\n        // First we push the last number to the permutation at the end. Thats one of the permutations.\\n        permutations_table[i][nums_size - 1] = nums[nums_size - 1];\\n        \\n        // Then we create all the other permutations of that line.\\n        for (column_index = 0; column_index < nums_size - 1; ++column_index)\\n        {\\n            // We copy that permutation to a new line at the end.\\n            memcpy(permutations_table[line_index], permutations_table[i], nums_size * sizeof(nums[0]));\\n            // Then we switch the last number with each of the other numbers.\\n            temp = permutations_table[line_index][column_index];\\n            permutations_table[line_index][column_index] = permutations_table[line_index][nums_size - 1];\\n            permutations_table[line_index][nums_size - 1] = temp;\\n            line_index++;\\n        }\\n    }\\n    \\n    return line_index;\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **permutations = NULL;\\n    int *columns_sizes = NULL;\\n    int permutations_amount = 1;\\n    int i = 0;\\n    \\n    // Determine the amount of permutations.\\n    for (i = 1; i <= numsSize; i++)\\n    {\\n        permutations_amount *= i;\\n    }\\n    permutations = (int**)malloc(sizeof(int*) * permutations_amount);\\n    columns_sizes = (int*)malloc(sizeof(int) * permutations_amount);\\n    \\n    for (i = 0; i < permutations_amount; i++)\\n    {\\n        // Assign the column sizes.\\n        columns_sizes[i] = numsSize;    \\n        // Allocates the permutations rows.\\n        permutations[i] = (int*)malloc(sizeof(int) * numsSize); \\n    }\\n    \\n    // Fills the permutations.\\n    (void)fill_permutations(nums, numsSize, permutations);\\n    \\n    *returnSize = permutations_amount;\\n    *returnColumnSizes = columns_sizes;\\n    \\n    return permutations;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <stdlib.h>\\n\\n/*\\nEach time takes the permutations of the numbers excluding the last one.\\nThen for each permutation takes the last number and pushes it between the numbers in all available positions.\\nFor example:\\n\\n    for the permutations of [1, 2, 3] first we get the permutations of [1, 2].\\n        that [[1, 2], [2, 1]]\\n    then for each of them pushes 3 between the numbers in all available positions.\\n        for [1, 2] we get [1, 2, 3], [3, 1, 2], [1, 3, 2].\\n        for [2, 1] we get [2, 1, 3], [3, 2, 1], [2, 3, 1]. \\n        \\n*note - Assumes the table is in the right size.\\n*/\\nint fill_permutations(int nums[], int nums_size, int *permutations_table[])\\n{\\n    int permutations_amount = 0;\\n    int i = 0;\\n    // Holds the line we are currently writing the permutations to.\\n    int line_index = 0;\\n    // The column we are pushing the last number to.\\n    int column_index = 0;\\n    // Used for pushing the last number between the other numbers.\\n    int temp = 0;\\n    \\n    // Exit rule.\\n    if (0 == nums_size)\\n    {\\n        return 0;\\n    }\\n    if (1 == nums_size)\\n    {\\n        permutations_table[0][0] = nums[0];\\n        return 1;\\n    }\\n    \\n    // Fills the permutations of the numbers excluding the last one.\\n    permutations_amount = fill_permutations(nums, nums_size - 1, permutations_table);\\n    line_index = permutations_amount;\\n    \\n    for (i = 0; i < permutations_amount; ++i)\\n    {\\n        // First we push the last number to the permutation at the end. Thats one of the permutations.\\n        permutations_table[i][nums_size - 1] = nums[nums_size - 1];\\n        \\n        // Then we create all the other permutations of that line.\\n        for (column_index = 0; column_index < nums_size - 1; ++column_index)\\n        {\\n            // We copy that permutation to a new line at the end.\\n            memcpy(permutations_table[line_index], permutations_table[i], nums_size * sizeof(nums[0]));\\n            // Then we switch the last number with each of the other numbers.\\n            temp = permutations_table[line_index][column_index];\\n            permutations_table[line_index][column_index] = permutations_table[line_index][nums_size - 1];\\n            permutations_table[line_index][nums_size - 1] = temp;\\n            line_index++;\\n        }\\n    }\\n    \\n    return line_index;\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\\n    int **permutations = NULL;\\n    int *columns_sizes = NULL;\\n    int permutations_amount = 1;\\n    int i = 0;\\n    \\n    // Determine the amount of permutations.\\n    for (i = 1; i <= numsSize; i++)\\n    {\\n        permutations_amount *= i;\\n    }\\n    permutations = (int**)malloc(sizeof(int*) * permutations_amount);\\n    columns_sizes = (int*)malloc(sizeof(int) * permutations_amount);\\n    \\n    for (i = 0; i < permutations_amount; i++)\\n    {\\n        // Assign the column sizes.\\n        columns_sizes[i] = numsSize;    \\n        // Allocates the permutations rows.\\n        permutations[i] = (int*)malloc(sizeof(int) * numsSize); \\n    }\\n    \\n    // Fills the permutations.\\n    (void)fill_permutations(nums, numsSize, permutations);\\n    \\n    *returnSize = permutations_amount;\\n    *returnColumnSizes = columns_sizes;\\n    \\n    return permutations;\\n}\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1996537,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1576744,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568476,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1565738,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1572686,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1569264,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996589,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996522,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996529,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568871,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996537,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1576744,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568476,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1565738,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1572686,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1569264,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996589,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996522,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1996529,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1568871,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Always nice coming back to problems that used to be really hard and now they\\'re super easy :)"
                    },
                    {
                        "username": "Demaxl",
                        "content": "fr bro"
                    },
                    {
                        "username": "ihsansfd",
                        "content": "come back 1 year later after you\\'re hiatus from algo and it\\'ll be hard again, as I\\'m experiencing now :)"
                    },
                    {
                        "username": "PeruguSindhu",
                        "content": "return list(itertools.permutations(nums))"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@aaradhyakul](/aaradhyakul) nah bro, you ain\\'t using the wrong language( at least if you use c++, idk about other languages). There\\'s something called \\n`next_permutation(nums.begin(), nums.end());`\\n\\nJust mix in a few loops and an answer vector, and your good to go!"
                    },
                    {
                        "username": "amitak0707",
                        "content": "[@satyam_rai15](/satyam_rai15) lol"
                    },
                    {
                        "username": "gamg1337",
                        "content": "[@Braderbell](/Braderbell) You can just write return permutations(nums)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@rahulnegi2021](/rahulnegi2021) Or instead:\\nInterviewer: What\\'s the time complexity of your code?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "Dont even have to cast it as a list, can just return itertools.permutations(nums)"
                    },
                    {
                        "username": "aaradhyakul",
                        "content": "I thought my algorithms were weak, now I know I was just using the wrong language."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Wow!!"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Interviewer: Can we now discuss the salary? "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The most hard working python programmer:"
                    },
                    {
                        "username": "SadHing",
                        "content": "Bro,that\\'s a crime"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Brother, stop it."
                    },
                    {
                        "username": "ACodeMonkey",
                        "content": "![image](https://assets.leetcode.com/users/images/03a8d102-6cae-455a-bc38-a5639095f309_1604555230.6002908.png)\\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "init \\'per\\' in permute() function"
                    },
                    {
                        "username": "wshaoxuan",
                        "content": "It seems the test cases of leetcode does not consider the inputs that have same numbers in the collection?\\nFor example, [1,3,3]."
                    },
                    {
                        "username": "spirit01",
                        "content": "constraints says all nums should be unique\\n"
                    },
                    {
                        "username": "Sangdil021",
                        "content": "check the constraints!\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "guys this comment was 10 years ago, it\\'s probably not specified at that time, don\\'t be so mean lol"
                    },
                    {
                        "username": "GraphicsMonster",
                        "content": "It\\'s one of the constraints. The array does not contain duplicate elements."
                    },
                    {
                        "username": "jdesai07",
                        "content": "[@AdityaBhate](/AdityaBhate)  can you stop spamming please"
                    },
                    {
                        "username": "ldygon94",
                        "content": "\"Given an array nums of -> distinct <- integers\""
                    },
                    {
                        "username": "MAvtushenko",
                        "content": "Did you read the constraints?.."
                    },
                    {
                        "username": "shuaigejiushiwo",
                        "content": "As the title, what\\'s the time complexity? \\nI calculated as O(n!).\\nAny idea?"
                    },
                    {
                        "username": "zenfred",
                        "content": "Might be _O(n·n!)_, or does it make no difference?"
                    },
                    {
                        "username": "_priyank_",
                        "content": "You are running a for loop. It cant be just n!"
                    },
                    {
                        "username": "gsrivas4",
                        "content": "I generated the tree structure of the recursion call and understood that time complexity of this problem is O(n * n!). However, I do not understand how this could be proved mathematically using T(n) = O(1) + n * T(n-1) kind of approach. If someone can explain this. "
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "Can you provide the tree structure of the recursion call? It would be helpful."
                    },
                    {
                        "username": "_priyank_",
                        "content": "It is T(n) = n + n*T(n-1) in my case as I am running a for loop in each recursive call"
                    },
                    {
                        "username": "jdesai07",
                        "content": "Hey [@gsrivas4](/gsrivas4), did you figure it out?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations/solutions/2992590/easiest-faang-method-ever/?orderBy=hot"
                    },
                    {
                        "username": "ak_3101",
                        "content": "Backtrack week "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Backtrack Month !!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It's done by backtracking before . Resubmit\n# Try  Permutations ||"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Same"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Permutation & combination back to back haha, let\\'s get it! \\uD83D\\uDE0A"
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I share my java solution using recursion for permutation."
                    }
                ]
            },
            {
                "id": 1997422,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996984,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996843,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1854475,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1574574,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1567719,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1997262,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1996543,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 1571114,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 2046549,
                "content": [
                    {
                        "username": "Ludacris2G",
                        "content": "Wow I\\'m still too stupid to solve any problems. Not surprising"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "I hate maths"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "People have comments here from almost 10 years ago \\uD83D\\uDEB6"
                    },
                    {
                        "username": "zenfred",
                        "content": "I forgot recursion... and ACed it with 4 for-loops instead `_(:з」∠)_`"
                    },
                    {
                        "username": "kamoplazu",
                        "content": "my input : [1, 1, 1]\\n\\ni thing results : [[1, 1, 1]]\\n\\nbut it works\\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]\\n\\nI don\\'t know why duplication is allowed.\\n"
                    },
                    {
                        "username": "neelbhatta22",
                        "content": "i tried to run and test case said nums[0]:1 and nums[1]:1 to have differing values , hence the array must have unique elements, same goes for [1,3,3]"
                    },
                    {
                        "username": "Dairop",
                        "content": "There are no duplicates as inputs"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/fb8c3aa4-2050-4c57-85dd-1319637f72f1_1642263915.6762493.jpeg)\\n\\n"
                    },
                    {
                        "username": "julkar9",
                        "content": "If you have trouble remembering the typical algorithm, think of this as a complete graph. \nNow run dfs for each i , for i in nums. \nkeep a list, L to store traversal of len(nums) then add it to the final list of lists.\nThe adj nodes of each node is, i for i in nums if i not in L.\n\nBeats 97% of solutions time wise, however very poor space complexity."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "back to classical problems....."
                    },
                    {
                        "username": "michael28",
                        "content": "The question:\\n\\nhttps://leetcode.com/problems/permutations/\\n\\nReports that the correct results for all permutations of [1, 3, 3] is:\\n\\n[[1,3,3],[1,3,3],[3,1,3],[3,3,1],[3,1,3],[3,3,1]]\\n\\nHowever, there are results repeated in that list.  As long as 3 and 3 are the same value, we can not list [1,3,3] and [1,3,3].  I believe that the solution required to pass the question is treating these as unique values which they are not.\\n\\nAm I perhaps misinterpreting the question?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "\"All the integers of nums are unique\""
                    },
                    {
                        "username": "Saan007",
                        "content": "the example here is permutation II problem\\n"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "n! is the number of lists will be produced by the permutations\\n"
                    }
                ]
            },
            {
                "id": 2037614,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2026872,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2010218,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2008108,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 2001048,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1999060,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1998169,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997657,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997485,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997454,
                "content": [
                    {
                        "username": "ploral",
                        "content": "Can someone tell me why we backtrack in this question? I did it without backtracking and it seems to work fine."
                    },
                    {
                        "username": "jinia_konar",
                        "content": "What is the logical difference between 2 code snippet?\nWhy is setting vis array differently in the code gives different answers whereas the purpose is same?\n``` java\n class Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        vis[i] = true;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n            }\n        }\n        vis[i] = false;\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: `[[1,2,3],[3,1,2]]`\n\nand \n```java\nclass Solution {\n    List<List<Integer>> ans;\n    int n;\n    void util(int[] nums, int i, boolean[] vis, List<Integer> temp) {\n        if(i<0 || i>=n) return;\n        if(temp.size() == n) {\n            ans.add(new ArrayList<>(temp));\n            return;\n        }\n        for(int j=0;j<n;j++) {\n            if(j!=i && vis[j]!=true) {\n                vis[j] = true;\n                List<Integer> cur = new ArrayList<>(temp);\n                cur.add(nums[j]);\n                util(nums, j, vis, cur);\n                vis[j] = false;\n            }\n        }\n    }\n\n    public List<List<Integer>> permute(int[] nums) {\n        n = nums.length;\n        boolean[] vis = new boolean[n];\n        Arrays.fill(vis, false);\n        ans = new ArrayList<>();\n        \n        for(int i=0;i<n;i++) {\n            vis[i] = true;\n            util(nums, i, vis, new ArrayList<>(List.of(nums[i])));\n            vis[i] = false;\n        }\n        return ans;\n    }\n}\n```\nAnswer to first test case: as expected"
                    },
                    {
                        "username": "jinia_konar",
                        "content": "Figured out the issue in the above code snippet\\nBasically I have missed unmarking the vis array when temp.size() == n"
                    },
                    {
                        "username": "jGRASP",
                        "content": "this is a garbage question. the answer is always gonna be n factorial. who cares."
                    },
                    {
                        "username": "psionl0",
                        "content": "The question isn\\'t asking you how many permutations. It\\'s asking you to list all of them."
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "Spent plenty of time, trying to understand why my solution is not working. I'm using global variable `answer` for storing result.\nThe reason was that `answer` was not cleared after previous test case. Didn't know about this detail, because, for example, codeforces initializes your program every test case.\n[screenshot on imgur](https://imgur.com/a/JS3JKxN)"
                    },
                    {
                        "username": "vladimirxsky",
                        "content": "[@Harsh-br0](/Harsh-br0) why not global variables?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "You are supposed to use instance variable in respective language"
                    },
                    {
                        "username": "bharsa09",
                        "content": "backtrack problems always give me back pain... :("
                    },
                    {
                        "username": "shishant_1",
                        "content": "[@sameer bhardwaj](/bharsa09) It looks hard in initial stage, but its very easy."
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://youtu.be/ZrCi95QCQmE\\nNice explanation"
                    },
                    {
                        "username": "indian001",
                        "content": "Problem Titile: Permutations \\uD83D\\uDE03\\nYou can return the answer in any order \\uD83D\\uDE11"
                    },
                    {
                        "username": "mkuian",
                        "content": "It is hard, not medium problem\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I'm all for calling out the scores of hard problems ranked medium but this one is barely even a medium. Boilerplate backtracking"
                    },
                    {
                        "username": "natitati",
                        "content": "I have no idea how I managed to solve this and beat 100% of runtime, but I want complain."
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Guys i need time complexity and analysis onmy funny solution,\\nI took inspiration from bogosort\\n\\nMy algo is:\\nTake all the numbers  of array \\nrandomise them and store in hash so if we dont find the permutation already in hash we keep on randomising the numbers and add into hash.\\n\\nBy randomising i mean if i have 1,2,3 as number randomising will give a random combination 1,3,2, and store it in hash, I will end function when size of hash is n! thus converting hash to list will give me all permutation , worst case is O(infinity) but what is best case? "
                    }
                ]
            },
            {
                "id": 1997358,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997353,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997079,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1997032,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996894,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996834,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996798,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996719,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996709,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996696,
                "content": [
                    {
                        "username": "SG-C",
                        "content": "Ha Ha \\uD83D\\uDE01 Another Basic Backtracking Solution."
                    },
                    {
                        "username": "shubhharkawat",
                        "content": "I am getting the following error, can someone help, but the code is able to print the correct answer and even return it when the function is used internally.\\n\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\nLine 45 in _driver (Solution.py)\\n    _driver()\\nLine 52 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'int\\' object is not iterable\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\nLine 48 in <listcomp> (./python3/__serializer__.py)\\nLine 48 in serialize_list (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'list<list<integer>>\\')\\nLine 43 in _driver (Solution.py)"
                    },
                    {
                        "username": "leongweizhi03",
                        "content": "Is there a solution where no global variables are used?"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you are coding in C/C++ where arguments can be passed by reference then no global variables are needed."
                    },
                    {
                        "username": "sunny8080",
                        "content": "### **4 Different Approach**, with `Iterative` and `Backtracking` Solution\n### [Click Here ](https://leetcode.com/problems/permutations/solutions/3852229/c-java-faster-and-easy-4-approach-iterative-backtracking-beats/)\n### [C++/Java] 👍👍"
                    },
                    {
                        "username": "psionl0",
                        "content": "When I first tackled this problem, I couldn\\'t understand backtracking so I solved it using factoradics: https://leetcode.com/problems/permutations/solutions/3305990/c-solution-using-factoradics/\\nHowever, this time around I could easily do the backtracking so it was a good exercise to practice this technique."
                    },
                    {
                        "username": "sonuishwar",
                        "content": "why 1st way implementation slower than 2nd way, the only difference is in place of the declaration of the result vector.\\n\\n//first way implementation\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void permuteRec(vector<int>& nums, int begin) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) { \\n        permuteRec(nums, 0); \\n        return result; \\n                             \\n    }\\n};\\n\\n//second way implementation\\nclass Solution {\\npublic:\\n    void permuteRec(vector<int>& nums, int begin, vector<vector<int>>& result) { \\n            if (begin == nums.size()) { \\n                        result.push_back(nums); \\n            return; \\n            } \\n        for (int i = begin; i < nums.size(); i++) { \\n            swap(nums[begin], nums[i]); \\n            permuteRec(nums, begin + 1, result); \\n            swap(nums[begin], nums[i]); \\n        } \\n    } \\n                                                                                                   \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        permuteRec(nums, 0, result); \\n        return result; \\n                             \\n    }\\n};"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Backtracking week!"
                    },
                    {
                        "username": "vetor",
                        "content": "woow yesterday combinations today combinations"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "It\\'s backtracking week!"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Already done Resubmit now :)"
                    }
                ]
            },
            {
                "id": 1996613,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1996527,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1996519,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1992957,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1991558,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1971626,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1947870,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1935616,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1912947,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1911137,
                "content": [
                    {
                        "username": "marco_seven",
                        "content": "is this week is Recursion / Backtracking week?"
                    },
                    {
                        "username": "Braderbell",
                        "content": "2 days in a row where it\\'s just a one-line solution with a python itertools library function"
                    },
                    {
                        "username": "AlecLC",
                        "content": "See what the interviewer says"
                    },
                    {
                        "username": "leetcode__id",
                        "content": "It is Backtracking week!"
                    },
                    {
                        "username": "ShubhamK1",
                        "content": "just use library and generate all permutations\nfrom itertools import permutations\nhttps://leetcode.com/problems/permutations/submissions/1007640503/"
                    },
                    {
                        "username": "imsahilsaini32",
                        "content": "Can anyone check why it not working??\\n    void fun(vector<int> &v,set<int> &s){\\n         if(v.size()==n){\\n             ans.push_back(v);\\n             return;\\n         }\\n         for(auto i:s){\\n             v.push_back(i);\\n             s.erase(i);\\n             fun(v,s);\\n             s.insert(i);\\n             v.pop_back();\\n         }\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        set<int> s;\\n        n=nums.size();\\n        for(auto i:nums){\\n            s.insert(i);\\n        }\\n        vector<int> v;\\n        fun(v,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "motopia01",
                        "content": "the problem is clear for me but i dont understand to do with the tow last variables at the prototype."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This can also be solved using bitmask"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this solution with 100% beats also with lowest space complexity that;s mean 100% beats in space. We know that if we call import java.util.* then it calls all the package methods of the util package. If we call specific functions from the util package (ex: java.util.io, java.util.Arrays, etc.) then it could be take less time complexity because of JRE is not taking time more to find the all package function of util package, if somebody is done with 100% beats in this solution reply and let\\'s discuss on this topic."
                    },
                    {
                        "username": "egretrteg",
                        "content": "class Solution {\\npublic:\\n    int fact(int n)\\n    {\\n        int ans=1;\\n        while(n!=1)\\n        {\\n            ans=ans*n;\\n            n--;\\n        }\\n        return ans;\\n    }\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        for(int i=0;i<(fact(nums.size())-1);i++)\\n        {\\n            next_permutation(nums.begin(),nums.end());\\n            ans.push_back(nums);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 What should be the time complexity of recursive approach"
                    }
                ]
            },
            {
                "id": 1872896,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1809209,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1802701,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1787336,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1785105,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784368,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1774225,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752626,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1737361,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724555,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "What am I  doing wrong? I am getting this error\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: stack-overflow on address 0x7fff3729dff8 (pc 0x000000334461 bp 0x00000000000c sp 0x7fff3729dff0 T0)\\n==31==ABORTING\\n\\n\\nclass Solution {\\n    private:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index){\\n        //base case\\n        if(index >= nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int j = index; j<nums.size(); j++){\\n            swap(nums[index], nums[j]);\\n            //recursion solving it\\n            solve(nums,ans ,index);\\n            swap(nums[index], nums[j]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        //vector inside vector\\n        vector<vector<int>> ans;\\n        int index = 0;\\n        //recursion solving it\\n        solve(nums, ans , index);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "mridulsaggi",
                        "content": "your recursion call is missing index+1\\n"
                    },
                    {
                        "username": "ankush920",
                        "content": "Quick reading  of optimized code  eye healthy code :-\\nclass Solution {\\npublic:\\n\\n///find useful upvote it vro :)\\n\\n void help( vector<int>store, vector<vector<int>>&answer ,vector<int>nums , int len)\\n {\\n\\n    if( store.size() == len)\\n    {\\n\\n        answer.push_back(store);\\n         return ;\\n    }\\n\\n int n = nums.size();\\n    for( int i = 0  ;  i<n ;i++)\\n    {\\n         swap(nums[i], nums[n-1]);    //// put all possbility to last place    \\n\\n         store.push_back(nums[n-1]);   //swap all the possiblity to store\\n\\n         int value = nums[n-1];\\n\\n         nums.pop_back();\\n\\n         help(store , answer , nums, len); /// call for remain permutation\\n\\n         nums.push_back(value);     ///backtrack undo all changes\\n\\n           swap(nums[i], nums[n-1]);  /////nullifying changes\\n           store.pop_back();     ////nullifying changes\\n\\n    }\\n\\n    return;\\n\\n }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n\\n    vector<int>store;   /// it will  use to make different combinaton \\n     vector<vector<int>>answer ;  /// use to store final answer\\n\\n     \\n      \\n     \\n     help(store, answer ,nums , nums.size()); \\n\\n     return answer;\\n    }\\n};"
                    },
                    {
                        "username": "ywhbrth",
                        "content": "Why doesn\\'t this work? I don\\'t understand...\\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        currPermut = []\\n        allPermut = []\\n        availableNums = {n for n in nums}\\n        self.helper(currPermut, allPermut, availableNums)\\n        return allPermut\\n    \\n    def helper(self, currPermut, allPermut, availableNums):\\n        if not availableNums:\\n            allPermut.append(currPermut[:])\\n            return\\n        \\n        for n in availableNums:\\n            availableNums.remove(n)\\n            currPermut.append(n)\\n            self.helper(currPermut, allPermut, availableNums)\\n            availableNums.add(n)\\n```"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "Where my error? How know?\\n`var permute = function(nums) {\\n\\tfunction perm(arr,n = null) {\\n\\t\\tif (arr.length === 0) return [];\\n\\t\\tif (arr.length === 1) return arr;\\n\\t\\tif (arr.length === 2) return n === null ? [[arr[0],arr[1]],[arr[1],arr[0]]] : [[n,arr[0],arr[1]],[n,arr[1],arr[0]]];\\n\\t\\tlet result = [];\\n\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\tlet a = arr.shift();\\n\\t\\t\\tresult = [...result,...perm(arr,a)];\\n\\t\\t\\tarr.push(a)\\n\\t\\n\\t\\t}\\n\\t\\treturn result\\n\\n\\t}\\n   return perm(nums)\\n\\t   \\n};`\\nGet error:\\n`Runtime Error\\nLine 39 in solution.js\\n             throw new TypeError(__serialize__(ret) + \" is not valid value for the expected return type list<list<integer>>\");\\n             ^\\nTypeError: [1] is not valid value for the expected return type list<list<integer>>\\n    Line 39: Char 20 in solution.js (Object.<anonymous>)\\n    Line 16: Char 8 in runner.js (Object.runner)\\n    Line 25: Char 26 in solution.js (Object.<anonymous>)\\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\\n    at Module.load (node:internal/modules/cjs/loader:981:32)\\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\\n    at node:internal/main/run_main_module:17:47`\\n\\nWhen I change return perm(nums) on console.log(perm(nums)) I see result."
                    },
                    {
                        "username": "HarshXGA",
                        "content": "Why does it work without backtracking? \\neven if i do not re-swap the current answer, all testcases pass. "
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        return permutations(nums)\\n"
                    },
                    {
                        "username": "ksumit1109",
                        "content": "What is the issue in this code?????\\n\\n\\nvar permute = function(nums){\\n    let ans = \"\"\\n    let index =0;\\n     solve(nums,ans,index)\\n     return ans;}\\nfunction solve(nums,ans,index){\\n        if(index>=nums.length){\\n            ans.push(nums);\\n            return;\\n        }\\n        for(var j=index;j<nums.length;j++){\\n            swap(nums[index],nums[j])\\n            solve(nums,ans,index);\\n            swap(nums[index],nums[j])\\n        }\\n    }\\n\\n\\nfunction swap(a, b) {\\n  return [b, a]\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "joyschen",
                        "content": "Isn\\'t the space complexity O(1) for the backtracking algorithm? The output isn\\'t supposed be counted in the space complexity, is it? "
                    },
                    {
                        "username": "coding_theuncoded",
                        "content": "class Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        List<List<Integer>> total = new ArrayList<>();\\n        boolean[] check = new boolean[nums.length];\\n        Arrays.fill(check,false);\\n        dfs(0,nums.length,nums,list,total,check);\\n        return total;\\n    }\\n    public void dfs(int i, int n,int[] array, List<Integer> list, List<List<Integer>> total, boolean[] check){\\n        if(i==n){\\n            total.add(new ArrayList(list));\\n            return ;\\n        }\\n        for(int j=0;j<n;j++){\\n            if(!check[j]){\\n                check[j]=true;\\n                list.add(array[j]);\\n                dfs(i+1,n, array, list,total, check);\\n            }\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722175,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1721780,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1715050,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1714572,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1709502,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1707559,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1696029,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1694585,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1693441,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            },
            {
                "id": 1689573,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/46_permutations.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "harsh_goyal",
                        "content": "  `def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            visited.add(i)\n            perm(res, visited, **subset+[nums[i]]**, nums)\n            visited.remove(i)   \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n\ngives output as expected that is [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] but\n\n\n`def perm(res, visited, subset, nums):\n    if len(subset) == len(nums):\n        res.append(subset)\n    for i in range(len(nums)):\n        if i not in visited:\n            **subset.append(nums[i])**\n            visited.add(i)\n            perm(res, visited, subset, nums)\n            visited.remove(i)\n            **subset.remove(nums[i]) **     \ndef permute(nums):\n    visited = set()\n    res = []\n    subset = []\n    perm(res,visited,subset,nums)\n    return res\n    \nprint(permute([1,2,3])) `\n   \ngives output as [[], [], [], [], [], []]\n\nI have tried executing them. But observed the difference in output.\n\nI have highlighted the difference in code please help me understand why this is the case"
                    },
                    {
                        "username": "lucafersko55",
                        "content": "Why this code doesn't work as expected.\nIt returns  empty two-d arrays, like this: [[],[],[],[],[],[]]. \n \nvar permute = function(nums) {\n    let res = []; \n    let path = [];\n    let vis = new Array(50).fill(0);\n    function dfs(nums, u) {\n        if(u === nums.length) {\n            res.push(path);\n            return;\n        }\n        for(let i = 0; i < nums.length; ++i) {\n            if(!vis[i]) {\n                // console.log(nums[i]);\n                console.log(path.length);\n                path.push(nums[i]);\n                vis[i] = 1;\n                dfs(nums, u + 1);\n                vis[i] = 0;\n                path.pop();\n\n            }\n        }\n    }\n    dfs(nums, 0);\n    return res;\n};"
                    },
                    {
                        "username": "sahilyadav9857",
                        "content": "Using Recursion\\nclass Solution {\\nprivate:\\n    void solve(vector<int>&nums, int index, vector<vector<int>>&ans){\\n        if(index>=nums.size()){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++){\\n            swap(nums[index], nums[i]);\\n            solve(nums, index+1, ans);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int index=0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "simple c++ approach to solve this question:\\n\\nclass Solution {\\n    private:\\n    void helper(vector<vector<int>>&ans,vector<int>nums,vector<int>&curr,unordered_map<int,bool>&m1 ){\\n\\n        if(curr.size()==nums.size()){\\n            ans.push_back(curr);\\n            return ;\\n        }\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(!m1[nums[i]]){\\n                curr.push_back(nums[i]);\\n                m1[nums[i]]=true ;\\n\\n                helper(ans,nums,curr,m1);\\n                m1[nums[i]]=false ;\\n                curr.pop_back();\\n            }\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\n        vector<vector<int>>v1 ;\\n        vector<int>curr ;\\n        unordered_map<int,bool>m1 ;\\n        helper(v1,nums,curr,m1);\\n        return v1 ;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Shivkant_Pandey",
                        "content": "def permute(self, nums: List[int]) -> List[List[int]]:\\n        \\n        l=list(itertools.permutations(nums))\\n        return l\\n        "
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Best Solution -->\\nhttps://leetcode.com/problems/permutations/solutions/2848093/2-approach-easy-c-solution-striver/"
                    },
                    {
                        "username": "Ashish_0007",
                        "content": "class Solution {\\npublic:\\n    void solve(vector<int>& nums, int index, vector<vector<int>>& ans) {\\n\\n        if(index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i=index; i<nums.size(); i++) {\\n            swap(nums[i], nums[index]);\\n            solve(nums, index+1, ans);\\n            swap(nums[i], nums[index]);\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        int index = 0;\\n        solve(nums, index, ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "dhuang1993",
                        "content": "Python3 Fibonacci O(n) very easy to understand \\n\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        if len(nums) == 1:\\n            return [nums]\\n        elif len(nums) == 2:\\n            return [nums, nums[::-1]]\\n        else:\\n            last = nums[-1]\\n            ans = []\\n            for perm in self.permute(nums[:-1]):\\n                for i in range(len(perm) + 1):\\n                    temp = list(perm)\\n                    temp.insert(i,last)\\n                    ans.append(temp)\\n            return ans\\n```"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Hello I have a problem with my Testcase and my submission.\\nThe Testcase return me Accepted but not the Submission for the same test.\\nIf anyone can help me understand please, it will be very helpful. Thanks.\\n\\n `class Solution {\\npublic:\\n\\n    void permutation(vector<int>& nums,vector<vector<int>>&r,int k=0) {\\n        \\n        static vector<bool>c(nums.size(),false);\\n        static vector<int>v(nums.size(),-1);\\n        if(k==nums.size()){\\n            r.push_back(v);\\n        }else{\\n            for(int i=0;i<nums.size();i++){\\n                if(c[i]==false){\\n                    c[i]=true;\\n                    v[k]=nums[i];\\n                    permutation(nums,r,k+1);\\n                    c[i]=false;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permute(vector<int>& nums) {\\n    \\n        vector<vector<int>>r;\\n        permutation(nums,r);\\n\\n        return r;\\n    }\\n}; `\\n\\n--------------------------Testcase-------------------------------\\nAccepted\\nRuntime: 2 ms\\nInput\\nnums = [1,0]\\nOutput\\n[[1,0],[0,1]]\\nExpected\\n[[1,0],[0,1]]\\n--------------------------Submission----------------------------\\nWrong Answer\\nInput\\nnums = [0,1]\\nOutput\\n[[0,1,1],[1,0,1]]\\nExpected\\n[[0,1],[1,0]]"
                    }
                ]
            }
        ]
    }
]