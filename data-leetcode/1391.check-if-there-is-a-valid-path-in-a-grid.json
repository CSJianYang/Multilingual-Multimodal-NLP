[
    {
        "title": "Largest Time for Given Digits",
        "question_content": "Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nReturn the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\n&nbsp;\nExample 1:\n\nInput: arr = [1,2,3,4]\nOutput: \"23:41\"\nExplanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n\nExample 2:\n\nInput: arr = [5,5,5,5]\nOutput: \"\"\nExplanation: There are no valid 24-hour times as \"55:55\" is not valid.\n\n&nbsp;\nConstraints:\n\n\tarr.length == 4\n\t0 <= arr[i] <= 9",
        "solutions": [
            {
                "id": 200693,
                "title": "java-python-3-11-liner-o-64-w-comment-6-ms",
                "content": "`A[i], A[j], A[k], & A[l]` are the `4` elements of `A`, where `i, j, k & l` are the permutation of `0, 1, 2, & 3`, e.g.,\\n`(A[i], A[j], A[k], A[l]) = (A[2], A[0], A[3], A[1])` or `(A[i], A[j], A[k], A[l]) = (A[3], A[1], A[2], A[0])`, etc. \\n\\n`i, j, k & l` can have `4! = 24` different values, but their sum is always same: `6`.\\n\\nTherefore, since `i + j + k + l = 0 + 1 + 2 + 3 = 6`, we have `l = 6 - i - j - k`.\\n\\n```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\\nUse Python lib:\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```\\n**Analysis:**\\n\\nThe inner most  loop at most iterates 4 * 4 * 4 = 64 times.",
                "solutionTags": [],
                "code": "```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 200517,
                "title": "python-1-line-check-permutations-o-24",
                "content": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201564,
                "title": "c-4-lines-0-ms-prev-permutation",
                "content": "There are too many corner cases, so it\\'s easier to just brute-force all 24 combinations and find the maximum over valid ones.\\n\\nThanks to [@AdamTai](https://leetcode.com/adamtai) for pointing out that, since we permutating from smallest to largest, the last valid combination is also the largest one. Therefore, we can sort the input descending, iterate from largest to smallest using ```prev_permutation``` and return the first valid time.\\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "solutionTags": [],
                "code": "```prev_permutation```\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822874,
                "title": "python-check-all-permutations-explained",
                "content": "In this problem we are asked to check if some possible permutation of digits creates maximum possible valid time. One way to handle this problem is to just check all possible `4! = 24` permutations: this number is quite small and we can afford it. So, we:\\n\\n1. Create `out = \"\"`, here we will keep our answer.\\n2. Check all permutations of `A`, in python there is special function for it, why not use it: for each permutation check if it is valid time: hour need to be `<=23` and minutes need to be `<=59`, which can be written as `P[2] <= 5`.\\n3. Now, compare new build time with our current maximum and choose best of them. This is all!\\n\\n**Complexity**: time complexity is `O(1)`, but more strictrly it is `O(k!)`, we need to check all permutations in any case, where `k=4` is size of `A`. Space complexity is `O(1)` also, which is more like `O(k)` to keep our answer and compare it with `out`.\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211540,
                "title": "python-simple-obvious-solution",
                "content": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 823064,
                "title": "java-without-permutations-and-backtracking-beats-100-space-and-runtime",
                "content": "We need to rearrange the array of 4 digits such that it produces largest Time.\\n\\nfor Rearrange the Array I have created function ```rearrange(int maxValue,int index,int[] a)``` details below :\\n \\n Function arguments :\\n  1. maxValue -- maximum value for the given Index\\n  2. index -- for which index we need to rearrange the array\\n  3.  a[] - input array containing 4 digits\\n\\nreturns **TRUE** if we have found the **maximum element for index in a[]** else returns **FALSE**\\n\\nNow, Using above function we have to rearrange the array from left to right. \\n\\nThere are 2 type of cases, as mentioned below :\\n\\n***CASE 1***  - **23:59 , 19:59 , 09:59**\\n\\n\\tif 1st digit is 2 then 2nd digit value can  be 0<=value<=3\\n\\telse if 1st digit is less than 2 then 2nd digit value can be 0<=value<=9\\n\\tfor 3rd digit 0<=value<=5\\n\\tfor 4rth digit 0<=value<=9\\n\\nBelow code summarize the above cases and rearrange the array:\\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\n***CASE 2*** : **06:26 , 16:26**\\n\\n**Now Case 1 will fail, when 1st digit can be 0 or 1**\\n\\nso, when Case 1 returns false value, then we can check Case 2 digits condition and rearrange them :\\n\\n\\t1st digit  :  0<=value<=1\\n\\t2nd digit  : 0<=value<=9\\n\\t3rd digit  : 0<=value<=5\\n\\t4rth digit  : 0<=value<=9\\n\\nbelow code summarize the above cases to rearrange:\\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\nSo, after adding both ( CASE 1 || CASE 2), we get the below code:\\n\\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```\\n\\nAfter rearrangement we just simply convert the array to time format\\n\\nBelow is the final Code\\n\\n```\\nclass Solution {\\n    \\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n\\t\\t// find the maximum number for the given index which should be less than equal\\n\\t\\t// to maxValue\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n\\t\\t// number not found\\n        if(max==-1) return false;\\n    \\n\\t// put the number to its correct index \\n\\t// swap it put at correct position\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n\\t\\n\\t\\n    \\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "```rearrange(int maxValue,int index,int[] a)```\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822967,
                "title": "c-just-loop-and-check-validity-on-the-fly-0-ms-beats-100-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like the solution, please **Upvote!**\\nHave a great day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202234,
                "title": "java-super-short-solution",
                "content": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309364,
                "title": "100-c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}       \\n\\t\\t\\t}while(next_permutation(A.begin(),A.end()));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 450045,
                "title": "java-greedy-dfs-backtracking-solution-very-easy-to-understand-1ms",
                "content": "Since we want to find the max, we should try the max digit allowed from left to right.\\nFor exmaple, at the first digit, we can try 2, then 1, then 0.\\nat the 2nd digit, if the 1st on is 2, we try 3,2,....,0. Otherwise, try 9,8,7,....,1,0.\\nSince we are following the numerical order, it guarantees that the first permutarion found by the DFS helper is the max.  \\n```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536484,
                "title": "python3-easy-understanding-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823156,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=QJeI-gBTp1k)\\nhttps://www.youtube.com/watch?v=QJeI-gBTp1k\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200823,
                "title": "java-iterative-15-lines",
                "content": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 207126,
                "title": "elegant-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823706,
                "title": "find-all-permutations-easy-to-understand-solution-with-steps",
                "content": "**Steps :**\\n1) Sort the input array\\n2) Find all the valid permutations and store in a list\\n3) Since the list is sorted, the last element in the list is our required timestamp\\n4) If list is empty then return an empty string\\n\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }\\n    \\n    private void findValidPermutations(int[] A, List<String> list, StringBuilder sb, boolean[] used){\\n        \\n        if(sb.length() == A.length){\\n            if(isValid(sb.toString()))\\n                list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i = 0; i < A.length; i++){\\n            \\n            if(used[i])\\n                continue;\\n            \\n            if(i > 0 && A[i] == A[i-1] && !used[i - 1])\\n                continue;\\n            \\n            used[i] = true;\\n            sb.append(A[i]);\\n            \\n            findValidPermutations(A, list, sb, used);\\n            \\n            sb.deleteCharAt(sb.length() - 1);\\n            used[i] = false;\\n        }\\n    }\\n    \\n    private boolean isValid(String str){\\n        \\n        int hour = Integer.valueOf( str.substring(0,2));\\n        int minute = Integer.valueOf( str.substring(2, 4));\\n \\n        return hour < 24 && minute <= 59;\\n        \\n    }\\n    \\n    private String formatTimeStamp(String str){\\n        \\n        String hour = str.substring(0,2);\\n        String minute = str.substring(2,4);\\n        \\n        return hour + \":\" + minute;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823571,
                "title": "java-detailed-short-code-answer-array-permutation-followed-by-the-validity-check",
                "content": "To do so, we first need to perform the **permutation** of the array number, then pick all the **valid time combination** and find the **max** one. Here is the code:\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823132,
                "title": "c-very-easy-newbie-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        do\\n        {\\n            string sub1=res.substr(0,2);\\n            string sub2=res.substr(2);\\n            int f=stoi(sub1);\\n            int sec=stoi(sub2);\\n            if(f>=0&&f<=23&&sec>=0&&sec<=59)\\n            {\\n                ans=max(ans,sub1+\":\"+sub2);\\n            }\\n           \\n        }while(next_permutation(res.begin(),res.end()));\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 822956,
                "title": "c-simple-step-by-step-solution-explained-100-time-55-space",
                "content": "Man, wasn\\'t this the tricky one! But my bad for trying to filter too many edge cases initially, instead of trusting the rest of my logic a bit more.\\n\\nAnyway, let\\'s go with first things first: I declared a couple of class variables: `res` (our result) and `digits`, an array to store the frequency of the digits, so that they could be used by my helper `addMaxEqualLowerThan`, which in turn was created to avoid needless code duplications.\\n\\nThe harder part is to form the largest possible HH part with our digits: if we do that, the rest is relatively simple, as we just need to create the largest possible MM part.\\n\\nTo do so, we need to consider a few more things, but let\\'s move on with the logic: first of all we need to populate `digits` so that it has the frequency of the digit `i` stored in the `i`th cell.\\n\\nOnce we have done that, we can quickly loop through it and check our exit conditions:\\n* having reached `i == 2` and having `sum == 0` means we cannot form any hour;\\n* being at `i == 3` and having `sum == 1` when `digits[2] != 0` again means we cannot form hours (ie: we only have a `2` in that range);\\n* being at `i == 5` and having `sum < 2` means we might be able to form a hour, but then we would like a necessary digit (`<= 5`) for the minutes.\\n\\nIf did not return `res` and are still going on, time to check immediately for the best case: HH starting with `2`, a case we consider onlu if `sum > 2` (and, incidentally, the sole reason for which I did not make `sum` an internal variable of the second loop).\\n\\nWe add `2` (in this specific instance, since we know that `digits[2]`, `addMaxEqualLowerThan(2)` is equivalent to `digits[2]--; res.push_back(\\'2\\');` and then we call our helper again to get any digit `<= 3`; if by then our solution `reas` is still just `\"2\"`, we backtrack, resetting `res` to be empty.\\n\\nIf that was the case, we just invoke our helper to add any digit `<= 1`, followed by any digit `<= 9` (which would be just any digit, period, I guess?).\\n\\nTime to add `\\':\\'` and to easily slide into the MM part: we add any digit `<= 5`, followed by any digit `<= 9`.\\n\\nIf by any chance by now we got a `res` under `5` characters of length, we return an empty string, otherwise we return our successfully computed largest possible time :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822907,
                "title": "python-simplest-explained-easy-to-understand-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823747,
                "title": "java-solution-easy-code",
                "content": "* ***Please upvote if helpful!!***\\n\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823627,
                "title": "python-3-largest-time-for-given-digits",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 244890,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529280,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\\n\\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636459,
                "title": "python3-8-lines-permutations-t-m-96-78",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```\\n\\n\\n[https://leetcode.com/submissions/detail/810938755/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824095,
                "title": "94-62-javascript-clean-backtracking-with-short-circuit-optimization",
                "content": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712038,
                "title": "c-4-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919164,
                "title": "c-faster-than-100-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604515,
                "title": "python3-o-1-solution-without-using-in-built-functions",
                "content": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370419,
                "title": "c-easiest-solution-ever",
                "content": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }\\n                    \\n                    else{\\n                        \\n                        string hour=\"\";\\n                        hour=to_string(arr[i])+to_string(arr[j]);\\n                        \\n                        string minute=\"\";\\n                        minute=to_string(arr[k])+to_string(arr[6-i-j-k]);\\n                        \\n                        string s=hour+\":\"+minute;\\n                        \\n                        // Condition checking\\n                        \\n                        if(hour<\"24\" && minute<\"60\" && s>result){\\n                            result=s;\\n                        }\\n                        \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n        /* Time Complexity O(4*4*4) , Space Complexity O(1) */\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 854491,
                "title": "c-faster-than-100",
                "content": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824210,
                "title": "python-3-solution",
                "content": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "solutionTags": [],
                "code": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 824060,
                "title": "python-using-custom-lt-gt-and-eq",
                "content": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823752,
                "title": "python-3-today-s-one-liner",
                "content": "Find the max permutation where the first 2 digits are < 24 and the last 2 digits are < 60. Default to empty string if not found.\\n\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\\n\\nWrapped for readability:\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823371,
                "title": "largest-time-for-given-digits-in-c",
                "content": "Just check all permutations and update hour, minute. If valid result found, format it and return.\\n\\n```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823341,
                "title": "java-10lines-easy",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751721,
                "title": "java-backtracking-solution",
                "content": "I tried this in a mock exam. I had one hour and 2 questions. I did the other question in 10 mins. I was trying to solve this one using simple if else logics then after 40 mins realized I could not do it. Then I thought, lets try backtracking solution where you pick one digit and then try putting the rest on other places and see if it works. I was able to solve it within 5-6 mins. \\n```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687711,
                "title": "ruby-2-line-solution",
                "content": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 538181,
                "title": "c-faster-than-95-83-less-than-100-mem-o-1",
                "content": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 513643,
                "title": "javascript-permutation-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```\\n\\n* 172/172 cases passed (52 ms)\\n* Your runtime beats 96.08 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.8 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475504,
                "title": "swift-fast-8m-100",
                "content": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\\n\\nalso I have 2 very stupid solutions, just for fun\\n\\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\\n\\nor even more, we could store calculated values\\n\\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439679,
                "title": "java-1-ms",
                "content": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "solutionTags": [],
                "code": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 406661,
                "title": "python3-6-line-via-permutation",
                "content": "It is tempting to think that this problem falls in the regime of \"greedy algorithm\". But a closer look reveals that one has to enumerate all possibilities and find the largest one due to complicated constraints on digits. \\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nSome comment: In practice, I\\'d write the comparison part as below. But in Python, tuple comparison is a lot slower comparing to number comparison. So to improve the percentage, the exising style is used. \\n\\n```\\n(h, m) > (hour, minute)\\n```\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nEdited on 12/16/2020\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\n(h, m) > (hour, minute)\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352795,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}{T[1]}:{T[2]}{T[3]}\" if len(T) !=0 else \"00:00\" if A == [0,0,0,0] else \"\"\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCodeID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}",
                "codeTag": "Java"
            },
            {
                "id": 239233,
                "title": "c-solution",
                "content": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200580,
                "title": "c-simple-code-next-permutation",
                "content": "Using the next_permutation in c++, we can simply generate all permutations and just check 1 by 1.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949801,
                "title": "easy-python-solution-strings-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764422,
                "title": "using-if-else-if-and-only-loop-brute-force-solution-in-java",
                "content": "Here is the  basic and most brute force approach solution.  Over here I have made the basic If\\'s that are needed to keep in mind to solve it. \\n\\n\\n# Complexity\\n- Time complexity: The Time complexity is O(nlog). \\n\\n- Space complexity: The space Complexity is O(n);\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }\\n        //for hour need to get the first digit...1 or 2.. or 0\\n        //when list contains 2 zeores....\\n        if(list.contains(0))\\n        {\\n            List<Integer> l1= new ArrayList<>(list);\\n            int count=0;\\n            while(l1.contains(0) && count<2)\\n            {\\n                l1.remove((Integer)0);\\n                count++;\\n            }\\n            if(count==2)\\n            {\\n                Collections.sort(l1);\\n                System.out.println(l1);\\n                String str=\"\";\\n                if(l1.get(1)<=2 && l1.get(0)<=2)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                if(l1.get(0)==0 && l1.get(1)==0)\\n                {\\n                    return \"00:00\";\\n                } \\n                if(l1.get(0)==1 && l1.get(1)<=9 && l1.get(1)>2)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n                if(l1.get(0)==2 && l1.get(1)<=3)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n\\n                if(l1.get(0)==2 && l1.get(1)<=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+l1.get(1)+\"0\";\\n                }\\n                if(l1.get(0)==2 && l1.get(1)>=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+\"0\"+l1.get(1);\\n                }\\n                if(l1.get(1)<=1 && l1.get(0)<=1)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                else if(l1.get(0)>5)\\n                {\\n                    return \"0\"+l1.get(1)+\":0\"+l1.get(0);\\n                }\\n                return \"0\"+l1.get(1)+\":\"+l1.get(0)+\"0\"; \\n            }\\n        }\\n            for(int i=2;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p1=i;// 2\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        int flag=0;\\n        if(p1==2)\\n        {\\n            for(int i=3;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        else if(p1<=1)\\n        {\\n            for(int i=9;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(p1==Integer.MIN_VALUE || p2==Integer.MIN_VALUE)\\n        {\\n            return \"\";\\n        }\\n        Collections.sort(list);\\n        String str=\"\";\\n        if(list.get(0)==0)\\n        {\\n            if(list.get(1)<=5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(1)+\"\"+list.get(0);\\n            }\\n            else if(list.get(1)>5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(0)+\"\"+list.get(1);\\n            }\\n        }\\n        int dd1=list.get(0)+list.get(1)*10;\\n        int dd2=list.get(0)*10+list.get(1);\\n        if(dd1>=dd2 && dd1<=59)\\n        {\\n            str=dd1+\"\";\\n        }\\n        else if(dd2<dd1 && dd2<=59)\\n        {\\n            str=dd2+\"\";\\n        }\\n        else if(dd1>59 && dd2>59)\\n        {\\n            if(list.get(0)>5)\\n            {\\n                if(p2==0)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                else if(p1==0 && p2<=5)\\n                {\\n                    return p1+\"\"+list.get(1)+\":\"+p2+\"\"+list.get(0);\\n                }\\n                else if(p2==1)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                return \"\";\\n            }\\n            else if(p2==2 && p1>=0)\\n            {\\n                return \"\";\\n            }\\n            return \"\";\\n        }\\n        str=p1+\"\"+p2+\":\"+str;\\n        return str;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2358664,
                "title": "c-iterative-solution-backward-time-travel",
                "content": "A clock has 4 digits. For each position, there are some limitations. For example, in the first position of a time, you can put only 0, 1, or 2. The same goes for the other positions too. If you want to do this then the problem will become so complicated. So, here I come up with a brute-force approach. Just start the time from 23:59, then run a simple loop. In each loop the time will go backward by 1 minute, i.e 23:59, then  23:58, 23:57... The loop will end when the time is 00:00. For each time, check if all digits in the current time are present in the given array. We can check it by mapping the given digits. If we find all digits we can return the current time, which is our answer. If we finish our loop without a valid solution then the answer is empty string. Check the code for more clarification. :)  \\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0};\\n        for (auto it : arr) {\\n            mp[it]++;\\n        }\\n        while (1) {\\n            string s;\\n            string m, h;\\n            m = to_string(min);\\n            h = to_string(hour);\\n            if (m.size() == 1)m = \\'0\\' + m;\\n            if (h.size() == 1)h = \\'0\\' + h;\\n            int tmp[12];\\n            for (int i = 0; i < 10; i++) {\\n                tmp[i] = mp[i];\\n\\n            }\\n            s = h + \":\" + m;\\n            bool f = true;\\n            for (int i = 0; i < 5 and f; i++) {\\n                if (i == 2)continue;\\n                if (tmp[s[i] - \\'0\\']) {\\n                    tmp[s[i] - \\'0\\']--;\\n                }\\n                else f = false;\\n            }\\n            if (f)return s;\\n            min--;\\n            if (min < 0) {\\n                min = 59;\\n                hour--;\\n            }\\n            if (hour < 0)break;\\n        }\\n        return \"\";\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2243093,
                "title": "generate-permutation-and-get-the-conditionally-max-one",
                "content": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093775,
                "title": "c-backtracking-permutation-approach",
                "content": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/daadbec4-5b0a-4d95-ab6a-8407f52bd994_1653985012.9550817.png)\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856698,
                "title": "runtime-1-ms-faster-than-100-00-of-java-online-submissions-for-largest-time-for-given-digits",
                "content": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1784653,
                "title": "faster-than-100-in-python",
                "content": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "solutionTags": [],
                "code": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707920,
                "title": "python-regex-and-itertools-permutations",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704853,
                "title": "simple-commented-c",
                "content": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634912,
                "title": "949-python3-in-case-the-interviewer-asks-u-to-write-the-permutation-using-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584831,
                "title": "fastest-python3-solution-in-just-1-line-of-actual-code",
                "content": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455545,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }\\n                }\\n            } \\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1405149,
                "title": "python-1-liner-92",
                "content": "\\n```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "solutionTags": [],
                "code": "```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1377045,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912416,
                "title": "java-0-ms",
                "content": "There are two valid options:\\n- 0..1; any; 0..5; any;\\n- 2; 0..3; 0..5; any;\\n\\nSo for the first case we need to have at least one digit to be in range of 0..1 and at least two digits in range of 0..5. It\\'s because 0..5 range includes 0..1.\\n\\nThe second case is slightly more complicated. \\'2\\' is a must. For range 0..3 we need to have at least two digits because \\'2\\' falls into this rang. Then we need to have one more for range 0..5 and again, because it includes 0..3 and \\'2\\' it should be 3+.\\n\\nPresent input as an array of ten elements each containing number of digits from input. For example for input [2, 9, 9, 1] it will be\\n[ 0, 1, 1, 0, 0, 0, 0, 0, 0, 2 ]\\n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\\n\\ncalculate baskets:\\n[0..1] - 1\\n[0..3] - 2\\n[0..5] - 2\\n\\nAs we see the condition for [2; 0..3; 0..5; any] is not fullfilled. While we have \\'2\\' and 0..3 range, we lack digit in 0..5 range. However [0..1; any; 0..5; any] can be successfully combined.\\n\\nNow all we need to do - is to get max value from the range.\\n\\n```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910662,
                "title": "dfs-in-java-easy-to-understand-beats-80",
                "content": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "solutionTags": [],
                "code": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 845666,
                "title": "easy-and-understandable-c-solution",
                "content": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```\\n\\nIf u like the solution then please upvote!",
                "solutionTags": [],
                "code": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827631,
                "title": "c-cpp-beats-100-of-solution-0-ms-simple-brute-force",
                "content": "Simple Brute force solution beats 100% of submissions. \\nThink of some corner cases, what digits can be possible on first and second place. \\nWe need maximum time, so start from max digits. \\n\\nPlease find the solution below . If this is useful to you , please help to upvote.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827133,
                "title": "fixed-my-code-fails-test-on-submit-but-passes-same-test-on-run-code-what-gives",
                "content": "Anyone experience this weirdness on this or another problem.\\n\\nMy code fails a test on `Submit`, but passes that same test on `Run Code`.\\n\\nThe test is test `52` if tests are 1-indexed (I get `51/172 / 172 test cases passed.` and then this test fails). The test input is `[0,0,1,0]`, expected result `\"10:00\"`.\\n\\nWhen my code is run against this test on `Submit`, the result is incorrectly `\"00:00\"`; however, when my code is run against this test on `Run Code` using `Custom Testcase`, the result is correct (`\"10:00\"`). Was wondering if anyone has experienced this kind of discrepancy before and what might be the causes for same deterministic code running on the same input to produce different results depending on where it\\'s running. Seems odd.\\n\\nHere\\'s my code:\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825315,
                "title": "clean-and-production-quality-python3",
                "content": "Create valid permuations \\nwe can use `itertools` but if the interviewer says not to use it. it might take longer. The advantage in creating your own is that you wont make invalid permutations. \\n\\nMake a Dateobj so you can compare it cleanly. \\n\\n```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "solutionTags": [],
                "code": "```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824499,
                "title": "simple-brute-force-in-constant-time-most-easy-solution-try-max-to-min",
                "content": "Too much **frustate** from edge cases after that Tried Indirect Idea\\n\\n**Now try from Max time to Min time, Brute Force\\n23:59 to 00:00** \\n\\nIf we able to find then return it else empty string\\n\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```\\n\\n***Time Complexity : O(24 * 60) ~ O(1)\\nSpace complexity: O(1)***\\n\\n**Feel free to comment if any improvement needed**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824368,
                "title": "greedy-dfs-c-0ms-best100",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9},end;         // es[] acts to provide upper inclusive limit for value in particular pos\\n        if(sz==2)return gdfs(a+\\':\\',A);                // add \\':\\' in between\\n        if(sz==5){ans=a;return true;}                 // choose the first best ans, return true to stop all recusions\\n        if(a[0]<\\'2\\')es[1]=9;                          // another important ;P condition.\\n        end=es[sz];\\n        for(int i=end;i>-1;i--)                      // iterate in a greedy fashion\\n            for(auto &j:A){     \\n                if(i==j){                                       \\n                    j=-1;                                       \\n                    if(gdfs(a+char(\\'0\\'+i),A))return true;\\n                    j=i;\\n                }\\n            }\\n        return false;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        gdfs(\"\",A);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9}",
                "codeTag": "Java"
            },
            {
                "id": 824312,
                "title": "c-92-time-solution-backtracking-o-1",
                "content": "#### The idea is constrained backtracking\\nWe have the following rules:\\nHH -> have to be less than 24\\nMM -> Have to be less than 60\\n\\nCreate all possible permutations, and then save the largest one that is valid.\\nWe need to sort first to simply create ascending permutaions, but because the array is length of 4, the sort is also O(1).\\n\\n\\n#### Time complexity breakthrough:\\nSince we have only 4 items in A, we will create 4! permutations.\\nThis results in O(1)\\n\\nIf we had N length array, the complexity would be O(N!)\\n\\n#### Space complexity:\\nSame as time here.\\nDeepest recursion stack is 4.\\n\\n\\n```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824240,
                "title": "largest-time-for-given-digits-c-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824204,
                "title": "java-count-digits-and-find-max-based-on-condition-simple-to-understand-21ms-40mb",
                "content": "\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824133,
                "title": "python3-simple-python3-solution-5-lines",
                "content": "The size of the possible search space is `4!=24`; thus, a simple brute force solution will be enough.\\n\\nHere I used `permutation` for simplicity.\\n\\nThe time complexity of this question is `O(C)`.\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```\\n\\nThank you.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824023,
                "title": "c-short-std-sort-std-prev-permutation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823732,
                "title": "javascript-dfs-backtrack-explained-99-speed",
                "content": "Compute all permutations but do not store them all at once. A DFS backtrack generates permutations dynamically and when the base condition of all digits having been used is satisfied, the resulting time is checked for validity and for whether it surpasses the maximum observed. Return the maximum found through the DFS with appropriate formatting.\\n\\n```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823637,
                "title": "c-brute-force-with-linq-7-lines",
                "content": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "solutionTags": [],
                "code": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823509,
                "title": "java-faster-than-90-simple-logic-map-based",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823457,
                "title": "c-4ms-permutation-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823424,
                "title": "javascript-brute-force-short-but-slow",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823276,
                "title": "java-simple-for-loops",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823260,
                "title": "javascript-backtrack-with-comments",
                "content": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823242,
                "title": "c-find-permutations-and-only-check-and-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }\\n    bool cmp(string s1 , string s2)\\n    {\\n        for(int i = 0;i<4;i++)\\n        {\\n            if(s1[i] > s2[i])\\n                return true;\\n            else if(s1[i] == s2[i]){}\\n            else if(s1[i] < s2[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n       \\n        string temp = \"\";\\n        for(int i : A)\\n            temp += to_string(i);\\n        \\n        sort(temp.begin() , temp.end());\\n        \\n        int a = stoi(temp);\\n        if(a == 0)\\n            return \"00:00\";\\n        \\n        int count = 0;\\n     \\n        \\n        \\n        // take the cases of zero\\n       \\n        string res = \"\";\\n        string val = \"0000\";\\n        \\n        cout<<temp<<\" \";\\n        do{\\n            string x = temp;\\n            if(check(x) && cmp(x,val))\\n            {\\n                cout<<x<<\" \";\\n                res = x;\\n                val = x;\\n            }\\n        }while(next_permutation(temp.begin() , temp.end()));\\n        \\n        if(res.length() == 0)\\n            return \"\";\\n        string ans = res.substr(0,2) + \\':\\' + res.substr(2,2);\\n        \\n        return ans;\\n       \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823171,
                "title": "c-regex-pattern-matching-with-backtracking",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823166,
                "title": "java-easy-to-understand-solution-1ms-faster",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823144,
                "title": "java-solution-using-treemap-faster-than-90-submissions",
                "content": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "solutionTags": [],
                "code": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 823137,
                "title": "python3",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823120,
                "title": "python-calculate-all-possibility",
                "content": "Number of permutation = 4 ! = 24 so it it O(1)\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823100,
                "title": "simple-iterative-solution-with-video-explaination",
                "content": "https://www.youtube.com/watch?v=Y-uGoJqDtBM\\nIterative solution in constant time as the size of input array is fixed ie 4.\\n\\nTime Complexity is O(1)\\n\\n````\\nclass Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }\\n                    \\n                    int hoursTens = A[i];\\n                    int hoursUnits = A[j];\\n\\n                    int minsTens = A[k];\\n                    int minsUnit = A[6-i-j-k];\\n                    \\n                    \\n                    int hour = hoursTens*10 + hoursUnits;\\n                    \\n                    int min = minsTens * 10+ minsUnit;\\n                    \\n                    int totalTime  = hour*60 + min;\\n                    if(hour<24 && min< 60 && (totalTime)> maxTime){ //if we have a better time within hour and min constraint\\n                        maxTime = totalTime;\\n                        maxHours = hour;\\n                        maxMin = min;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(maxHours == -1 || maxMin == -1){\\n            return \"\";\\n        } else {\\n            // 9:45 => 09:45 , 7:8 = > 07:08\\n            return padding(maxHours) + \":\" + padding(maxMin); \\n        }\\n        \\n    }\\n    private String padding(int no){\\n        String str = \"\"+no;\\n        if(str.length()==1){\\n            str = \"0\" + str;\\n        }\\n        return str;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 823055,
                "title": "largest-time-for-given-digits-using-greedy-stl-library",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822981,
                "title": "python-o-4-by-permutation-w-hint",
                "content": "![image](https://assets.leetcode.com/users/images/68fdc533-7cca-4b33-ac11-9413cb8a4fdc_1598950579.2524464.png)\\n\\n[image source](https://picclick.com/Car-Clock-12-Volt-Led-Digital-Dash-Panel-264092407158.html)\\n\\n---\\n\\n**Hint**:\\n\\na.\\nConsider input is 4 digits, and permutations cost is **O( 4! ) = 24**, which is **small enough**.\\n\\nTherefore we enumerate all permutation, validate its time range, and update maximum clock time.\\n\\n---\\n\\nb. \\nOuput format is **HH:MM**, remember to apply **zero padding on the front** if needed.\\n\\nFor example:\\n1:23 is wrong, which doesn\\'t match the output format.\\n**0**1:23 is correct.\\n\\n---\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations)\\n\\n[2] [Python official docs about f-string](https://www.python.org/dev/peps/pep-0498/#how-to-denote-f-strings)\\n\\n[3] [Wiki: 24-hour clock time](https://en.wikipedia.org/wiki/24-hour_clock)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822934,
                "title": "cool-creative-python-solution",
                "content": "the idea is to try to create all permutations of times and return the max\\n\\n```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751205,
                "title": "c",
                "content": "### [\\u53C2\\u8003](https://www.cnblogs.com/grandyang/p/13123589.html)\\n```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732927,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "codeTag": "Java"
            },
            {
                "id": 677961,
                "title": "rust-nested-iterators-for-the-lulz",
                "content": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671731,
                "title": "concise-and-simple-js-solution",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568343,
                "title": "java-solution-beats-97-5-time-100-space",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545697,
                "title": "c-permutation-and-validation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523682,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495040,
                "title": "java-code-arrayutils-help",
                "content": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "solutionTags": [],
                "code": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 454440,
                "title": "949-largest-time-for-given-digits-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Brute Force - Permutation**\\n| O(T): O(nn) | O(S): O(nn) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\\nAlternative: one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200517/Python-1-line-Check-Permutations-O(24)\\n\\n\\n**II). Sort and Permutation**\\n| O(T): O(n^2lgn) | O(S): O(nn) | Rt: 20ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\\nAlternative: lengthy one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\\nComment: pay attention to the default value of next. \\n\\n\\n**III). Brute Force**\\n| O(T): O(n^3) | O(S): O(1) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200693/Java-11-liner-O(64)-w-comment-6-ms.\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 364813,
                "title": "java-dfs-1ms",
                "content": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 356682,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nStarting from highest possible timestamp `23:59`, we will go round the clock decrementing the time and stopping when we are able to find all the digits from the current timestamp. \\n\\nEasy way to check that is extract digits and sort them (`curr` in the code) and sort and compare with sorted input `a`. \\n\\n```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336615,
                "title": "easy-to-understand-javascript-solution-with-comments-52ms-94-100",
                "content": "Going down from 23 hours to 0 hours. If hours are found - check if minutes are valid.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 318695,
                "title": "go-with-no-permutations-in-20lines",
                "content": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273984,
                "title": "c-17-lines-code-i-think-no-one-write-c-shorter-then-me",
                "content": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246742,
                "title": "java-5ms-beats-100-sort-brute-force-stopping-on-1st-valid-time",
                "content": "Sort the array, use the brute force solution but start from largest to smallest number, so the first valid time found is the largest possible time\\n\\n```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246468,
                "title": "use-c-next-permutation",
                "content": "C++ offers next_permutation in STL.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240461,
                "title": "python3-100-with-easy-filter",
                "content": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 235821,
                "title": "c-very-short-prev-permutation-beats-100",
                "content": "Since we generate permutations in decreasing order, we know that first valid found is biggest, so we can stop our search.\\n```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "solutionTags": [],
                "code": "```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201871,
                "title": "c-javascript-solution-implemented-next-permutation",
                "content": "C++\\n\\n```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\\n\\nJavascript\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201327,
                "title": "brute-force-python-20ms-beats-100",
                "content": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201313,
                "title": "golang-recursive-and-iterative-solutions-suggestions-welcome",
                "content": "Recursive solution was easier to figure out first and runs all test cases in 4ms\\n\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\\n\\nIterative solution runs all test cases in 0ms\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200984,
                "title": "java-super-easy-o-24-9ms-solution-beats-100",
                "content": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 200653,
                "title": "backtrack-permutation",
                "content": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200649,
                "title": "java-o-24-60",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200560,
                "title": "java-permutation-solution",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200556,
                "title": "java-no-permutation-no-brute-force-warning-messy-code-ahead-6ms-10ms",
                "content": "Code messy AF.   [6ms-10ms]\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200530,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9};\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        int[] cur = new int[4];\\n        Arrays.fill(cur, -1);\\n        \\n        findLargest(A, new boolean[4], cur, 0);\\n        return time == null ? \"\" : time;\\n    }\\n    \\n    private void findLargest(int[] A, boolean[] used, int[] cur, int pos) {\\n        if (pos == 4) {\\n            String s = \"\" + cur[0] + cur[1] + \":\" + cur[2] + cur[3];\\n            if (time == null || time.compareTo(s) < 0) {\\n                time = s;\\n            }\\n            return;\\n        }\\n        if (pos == 1) {\\n            if (cur[0] == 1 || cur[0] == 0){\\n                max[1] = 9;\\n            } else if (cur[0] == 2) {\\n                max[1] = 3;\\n            }\\n        }\\n        for (int j = 0; j < 4; j++) {\\n            if (used[j] || A[j] > max[pos]) continue;\\n            cur[pos] = A[j];\\n            used[j]  = true;\\n            findLargest(A, used, cur, pos + 1);\\n            cur[pos] = -1;\\n            used[j] = false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9}",
                "codeTag": "Java"
            },
            {
                "id": 200495,
                "title": "python-straightforward-permutation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099326,
                "title": "brute-forcce",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 4062057,
                "title": "43ms-handles-difficult-edge-case-o-n-log-n-time",
                "content": "This question is definitely do-able in 30 minutes or less if you have not encountered it before just really try your best to beat out the edge case early. I was able to solve this problem in 29 minutes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978551,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973855,
                "title": "solution-with-itertools-permutations-method",
                "content": "# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSee coments for explanation ^\\n\\n# Code\\n```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973305,
                "title": "javascript-recursion",
                "content": "# Code\\n```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965020,
                "title": "python3-solution-using-itertools-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953733,
                "title": "c-permutations",
                "content": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941043,
                "title": "simple-c-solution-using-backtracking-and-permutation-beats-100-of-user-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding all the permutation of the string that can make a valid time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDiskard the time that is not in the range of the 24 hr and 60min.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936462,
                "title": "typescript-there-2-possibility-2-0-3-0-5-0-9-and-0-1-0-9-0-5-0-9-no-permutations",
                "content": "# Intuition\\nThere 2 possible \"independent\" formats that we need to check\\n[2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9]. We need to check both because one of them might not work while another provides solution. And we can not be sure that one of them is bigger because we impose [0-3] second hour digit limit even in cases when first hour is in range [0-1]. There were 2 options either for 1 format create dependency so if we have first hour digit [0-1] don\\'t impose [0-3] limit on 2nd hour digit or just calculate 2 formats independently and compare them. I chose 2nd option as I think it\\'s easier to understand. \\n*Side node: permutations feel for me as a brute force solution. I don\\'t understand why we need to try all possible options when it\\'s not necessary.*\\n# Approach\\n1. Calculate 2 variants for 2 possible formats [2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9] choosing maximum digit for each position\\n2. If both formats work choose winner by comparing them in minutes, if only one works choose it.\\n3. Format the winner.\\n\\n# Complexity\\n- Time complexity:\\nFor each digit we select max from the rest it\\'s $$O(n)$$ so in total  $$O(n^2)$$, ignoring the fact that we do it 2 times. Comparing digits is also $$O(n)$$. Considering $$n == 4$$ of cause in practive it\\'s $$O(1)$$\\n\\n- Space complexity:\\n`leftDigits` gives us $$O(n)$$\\n\\n# Code\\n```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918553,
                "title": "c-solution-beats-100-in-runtime-and-90-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861090,
                "title": "simple-verbose-python-solution",
                "content": "\\n# Complexity\\n- Time complexity: since len(arr) is a constant the time compexity of this slution is O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834863,
                "title": "steps-explained-succinct-java-solution-easy-to-understand",
                "content": "# Intuition\\nThere are two points to consider:\\n1. We already have the digits that make up the largest timestamp\\n2. We know the range of these numbers. That is the timestamp can range from 00:00 until 23:59. So the input must be a combination of these numbers\\n\\n# Approach\\n1. This is a brute force approach in which we try to get all possible combinations are match it against the input\\n2. We work our way in descending manner to get the largest match first.\\n3. We apply two for loops one for hour which begins at 23 and decrements by 1 and another inner for loop for minutes that begins at 59 and decrements by 1.\\n4. At each iteration we try to get the digits that make up that timestamp.\\n5. We do this by using division and modulus operations\\n6. Once obtained we sort this timestamp and compare against the input which is also sorted.\\n7. Return if match is found, else return \"\".\\n\\nThis is my first time posting a solution and I had a lot of help from the solutions already discussed. If you have any suggestions, corrections or inputs, they are welcome.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820492,
                "title": "most-intuitive-approach",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764677,
                "title": "recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3759784,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Enumeration"
                ],
                "code": "```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746902,
                "title": "java-forming-permutations-via-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687655,
                "title": "todays-ram",
                "content": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }\\n                return;    \\n            }\\n            \\n            for(int j=0;j<4;j++)\\n            {\\n                if(now[j]==\\' \\')\\n                {\\n                    now[j]=(\\'0\\'+arr[i]);\\n                    solve(i+1,arr,now);\\n                    now[j]=\\' \\';\\n                }\\n            }\\n        }\\n            \\n        string largestTimeFromDigits(vector<int>& arr) \\n        {\\n            string now=\"    \"; \\n            solve(0,arr,now);\\n            if(is==false)\\n                return \"\";\\n            string res=s.substr(0,2);\\n            res+=\":\";\\n            res+=s.substr(2);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3638784,
                "title": "simple-permutate-the-string-for-valid-times",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate all time permutations and discard non-valid solutions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort array and convert it to a string.\\nTwo upper limits exist: 24:00 and for minutes 6;  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ ==> while will always take 4! iterations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632821,
                "title": "try-all-and-check-for-the-latest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3576635,
                "title": "python-brute-force-approach-using-basic-data-structure",
                "content": "# Intuition\\nSolving with basic data structure\\n\\n# Approach\\nCreate a hash table to keep all possible combinations and then find all possible or valid time and keep them in list and then find the latest time from the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556991,
                "title": "python3-permutations",
                "content": "\\n```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542995,
                "title": "js-solution-using-recursion-to-generate-all-possible-permutations",
                "content": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526827,
                "title": "simple-java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497997,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434292,
                "title": "c-simple-solution-easy-to-understand-solution-with-steps",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(24 * 60 * 4!),\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417786,
                "title": "python-simple-looping",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}\\n        \\n        #O(1)\\n        for i in range(5):\\n            #spacer\\n            if i == 2:\\n                continue\\n            assigned = False\\n            \\n            #edge case\\n            #we were allowed to take 2 so fill the second slot in with the largest number we have remaining\\n            if i == 1 and int(res[0]) < 2:\\n                #4 at most\\n                mx = max(c)\\n                res[i] = str(mx)\\n                c[mx] -=1\\n                if c[mx] == 0:\\n                    del c[mx]\\n                continue\\n                \\n            #try all number ranges for the given postion and take the largest\\n            for j in range(cycl[i] -1,-1,-1):\\n                #edge case\\n                #if there are more than 2 numbers greater than 5 in the list than we cant take 2 as the first number since we will need it in the second position\\n                if i == 0 and j == 2 and great5 >= 2:\\n                    continue\\n                \\n                #if we have this number remaining use it and remove it from our dict\\n                if j in c:\\n                    assigned = True\\n                    res[i] = str(j)\\n                    c[j] -=1\\n                    if c[j] == 0:\\n                        del c[j]\\n                    break\\n            \\n            #we could not assign this position\\n            if not assigned:\\n                return \"\"\\n        \\n        res[2] = \":\"\\n        return \\'\\'.join(res)\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}",
                "codeTag": "Java"
            },
            {
                "id": 3377329,
                "title": "c-easy-to-understand-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372155,
                "title": "python-backtracking-no-library-functions",
                "content": "# Intuition\\nThis seemed like a backtracking problem because we want to greedily assign the largest digits first and then gradually try lower options if that doesn\\'t lead to a solution.\\n\\n# Approach\\nWe keep a stack for the current solution in `sol` and we explore at most 4 levels (one for each digit spot). Custom logic for the maximum digit of each level.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367607,
                "title": "java-solution-permutation",
                "content": "# Code\\n```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348920,
                "title": "recursion-permutation-of-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346672,
                "title": "simple-typescript-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338937,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325015,
                "title": "java-easy-to-understand-permutations",
                "content": "```\\nclass Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }\\n        for(int i = ind;i < 4;i++) {\\n            swap(arr, ind, i);\\n            generatePermutations(ind + 1, arr, al);\\n            swap(arr, ind, i);\\n        }\\n    }\\n    private void swap( int[] arr, int i, int j) {\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] =  temp;\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        ArrayList<int[]> al = new ArrayList<>();\\n        generatePermutations(0, arr, al);\\n        StringBuilder sb = new StringBuilder();\\n        int max = 0;\\n        for(int[] a : al) {\\n           int hh = a[0] * 10 + a[1];\\n           int mm = a[2] * 10 + a[3];\\n      \\n           if(hh >= 0 && hh <= 23) {\\n               if(mm >= 0 && mm <= 59){\\n                   if(hh * 100 + mm >= max){\\n                        max = hh * 100 + mm;\\n                        sb = new StringBuilder();\\n                  \\n                        if(hh <= 9 && mm <= 9){\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        }\\n                        else if(hh <= 9)\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                        else if(mm <= 9)\\n                            sb.append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        else \\n                            sb.append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                       \\n                     }\\n                }\\n            }\\n       \\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1795252,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            },
            {
                "id": 1989416,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if There is a Valid Path in a Grid",
        "question_content": "<p>You are given an <code>m x n</code> <code>grid</code>. Each cell of <code>grid</code> represents a street. The street of <code>grid[i][j]</code> can be:</p>\n\n<ul>\n\t<li><code>1</code> which means a street connecting the left cell and the right cell.</li>\n\t<li><code>2</code> which means a street connecting the upper cell and the lower cell.</li>\n\t<li><code>3</code> which means a street connecting the left cell and the lower cell.</li>\n\t<li><code>4</code> which means a street connecting the right cell and the lower cell.</li>\n\t<li><code>5</code> which means a street connecting the left cell and the upper cell.</li>\n\t<li><code>6</code> which means a street connecting the right cell and the upper cell.</li>\n</ul>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/main.png\" style=\"width: 450px; height: 708px;\" />\n<p>You will initially start at the street of the upper-left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code>. <strong>The path should only follow the streets</strong>.</p>\n\n<p><strong>Notice</strong> that you are <strong>not allowed</strong> to change any street.</p>\n\n<p>Return <code>true</code><em> if there is a valid path in the grid or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/e1.png\" style=\"width: 455px; height: 311px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,4,3],[6,5,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/e2.png\" style=\"width: 455px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2,1],[1,2,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,2]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 547371,
                "title": "java-clean-bfs",
                "content": "credit to @uwi, some modification\\n```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    //the idea is you need to check port direction match, you can go to next cell and check whether you can come back.\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                //go to the next cell and come back to orign to see if port directions are same\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    //the idea is you need to check port direction match, you can go to next cell and check whether you can come back.\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                //go to the next cell and come back to orign to see if port directions are same\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547229,
                "title": "python-union-find",
                "content": "# Explanation\\nAssume we have input A[2][2]. (Thanks @Gad2017 for this diagram)\\n<img src=\"https://assets.leetcode.com/users/lee215/image_1584946037.png\" alt=\"diagram\" width=\"600\"/>\\n\\nThe center of `A[0][0]` has coordinates `[0, 0]`\\nThe center of `A[i][j]` has coordinates `[2i, 2j]`\\nThe top edge of `A[i][j]` has coordinates `[2i-1, 2j]`\\nThe left edge of `A[i][j]` has coordinates `[2i, 2j-1]`\\nThe bottom edge of `A[i][j]` has coordinates `[2i+1, 2j]`\\nThe right edge of `A[i][j]` has coordinates `[2i, 2j+1]`\\n\\nThen we apply **Union Find**:\\nif `A[i][j]` in [2, 5, 6]: connect center and top\\nif `A[i][j]` in [1, 3, 5]: connect center and left\\nif `A[i][j]` in [2, 3, 4]: connect center and bottom\\nif `A[i][j]` in [1, 4, 6]: connect center and right\\n<br>\\n\\n\\n# Complexity\\nTime `O(MN) * O(UF)`\\nSpace `O(MN)`\\n<br>\\n\\n**Python:**\\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\\n\\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n\\n        def merge(i, j, di, dj):\\n            uf[find((i, j))] = find((i + di, j + dj))\\n\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\\n                if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\\n                if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\\n                if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\\n        return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\\n\\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n\\n        def merge(i, j, di, dj):\\n            uf[find((i, j))] = find((i + di, j + dj))\\n\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\\n                if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\\n                if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\\n                if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\\n        return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 547225,
                "title": "c-with-picture-track-direction-upscaled-grid",
                "content": "#### Approach 1: Track Direction\\nYou do not need to search for a path. You just follow the existing path until you can, and check if you reach your destination. The only variable here is your initial direction: e.g. if you start at a turn, you can go either down or right. \\n\\nLet\\'s define 4 directions: right (0), left (1), down (2) and up (3). Each road type can continue from some direction, and can change it to another direction. For example, for road type 3, you can continue from left, and it changes your direction to down. Or, you can continue from up and change to left. We track these rules in `turns`.\\n\\nThanks [arenard](https://leetcode.com/arenard/) for spotting the \"infinite loop\" problem in the initial implementation!\\n\\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nunordered_map<int, int> turns[7]{{}, \\n    {{0, 0}, {1, 1}}, {{2, 2}, {3, 3}}, {{0, 2}, {3, 1}}, \\n    {{3, 0}, {1, 2}}, {{0, 3}, {2, 1}}, {{2, 0}, {1, 3}}};\\nbool trace(vector<vector<int>> &g, int dir) {\\n    int i = 0, j = 0, m = g.size(), n = g[0].size();\\n    while(min(i, j) >= 0 && i < m && j < n) {\\n        auto road = g[i][j];\\n        if (turns[road].count(dir) == 0)\\n            return false;\\n        if (i == m - 1 && j == n - 1)\\n            return true;\\n        dir = turns[road][dir];\\n        i += dirs[dir].first, j += dirs[dir].second;\\n        if (i == 0 && j == 0)\\n            return false;\\n    }\\n    return false;        \\n}\\nbool hasValidPath(vector<vector<int>>& g) {\\n    return trace(g, 0) || trace(g, 1) || trace(g, 2) || trace(g, 3);\\n}\\n```\\n#### Approach 2: DFS on Upscaled Grid\\nThis is inspired by a similar solution for [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/discuss/205674/C%2B%2B-with-picture-DFS-on-upscaled-grid).\\n\\nWe can upscale the input grid to [n * 3][n * 3] grid and draw \"roads\" there. Then, we use DFS to trace the way from start to finish. Picture below says it all. Thanks [gaurav_ec](https://leetcode.com/gaurav_ec/) for pushing the idea!\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1585020742.png)\\n\\n```cpp\\nbool dfs(vector<vector<bool>> &g, int i, int j) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || !g[i][j])\\n        return false;\\n    if (i == g.size() - 2 && j == g[i].size() - 2)\\n        return true;\\n    g[i][j] = false;\\n    return dfs(g, i - 1, j) || dfs(g, i + 1, j) || dfs(g, i, j + 1) || dfs(g, i, j - 1);\\n}\\nbool hasValidPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            auto r = grid[i][j];\\n            g[i * 3 + 1][j * 3 + 1] = true;\\n            g[i * 3 + 1][j * 3 + 0] = r == 1 || r == 3 || r == 5;\\n            g[i * 3 + 1][j * 3 + 2] = r == 1 || r == 4 || r == 6;\\n            g[i * 3 + 0][j * 3 + 1] = r == 2 || r == 5 || r == 6;\\n            g[i * 3 + 2][j * 3 + 1] = r == 2 || r == 3 || r == 4;\\n        }\\n    return dfs(g, 1, 1);    \\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nunordered_map<int, int> turns[7]{{}, \\n    {{0, 0}, {1, 1}}, {{2, 2}, {3, 3}}, {{0, 2}, {3, 1}}, \\n    {{3, 0}, {1, 2}}, {{0, 3}, {2, 1}}, {{2, 0}, {1, 3}}};\\nbool trace(vector<vector<int>> &g, int dir) {\\n    int i = 0, j = 0, m = g.size(), n = g[0].size();\\n    while(min(i, j) >= 0 && i < m && j < n) {\\n        auto road = g[i][j];\\n        if (turns[road].count(dir) == 0)\\n            return false;\\n        if (i == m - 1 && j == n - 1)\\n            return true;\\n        dir = turns[road][dir];\\n        i += dirs[dir].first, j += dirs[dir].second;\\n        if (i == 0 && j == 0)\\n            return false;\\n    }\\n    return false;        \\n}\\nbool hasValidPath(vector<vector<int>>& g) {\\n    return trace(g, 0) || trace(g, 1) || trace(g, 2) || trace(g, 3);\\n}\\n```\n```cpp\\nbool dfs(vector<vector<bool>> &g, int i, int j) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || !g[i][j])\\n        return false;\\n    if (i == g.size() - 2 && j == g[i].size() - 2)\\n        return true;\\n    g[i][j] = false;\\n    return dfs(g, i - 1, j) || dfs(g, i + 1, j) || dfs(g, i, j + 1) || dfs(g, i, j - 1);\\n}\\nbool hasValidPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            auto r = grid[i][j];\\n            g[i * 3 + 1][j * 3 + 1] = true;\\n            g[i * 3 + 1][j * 3 + 0] = r == 1 || r == 3 || r == 5;\\n            g[i * 3 + 1][j * 3 + 2] = r == 1 || r == 4 || r == 6;\\n            g[i * 3 + 0][j * 3 + 1] = r == 2 || r == 5 || r == 6;\\n            g[i * 3 + 2][j * 3 + 1] = r == 2 || r == 3 || r == 4;\\n        }\\n    return dfs(g, 1, 1);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 547263,
                "title": "python-easy-dfs",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if not grid:\\n            return true\\n        directions = {1: [(0,-1),(0,1)],\\n                      2: [(-1,0),(1,0)],\\n                      3: [(0,-1),(1,0)],\\n                      4: [(0,1),(1,0)],\\n                      5: [(0,-1),(-1,0)],\\n                      6: [(0,1),(-1,0)]}\\n        visited = set()\\n        goal = (len(grid)-1, len(grid[0]) - 1)\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == goal:\\n                return True\\n            for d in directions[grid[i][j]]:\\n                ni, nj = i+d[0], j+d[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited and (-d[0], -d[1]) in directions[grid[ni][nj]]:\\n                    if dfs(ni, nj):\\n                        return True\\n            return False\\n        return dfs(0,0)\\n```\\nWhy ```(-d[0], -d[1]) in directions[grid[ni][nj]]```:?\\n\\nWhen traversing from one cell to the next. the next cell must have a direction that is the opposite of the direction we are moving in for the cells to be connected. For example, if we are moving one unit to the right, then from the next cell it must be possible to go one unit to the left, otherwise it\\'s not actually connected.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if not grid:\\n            return true\\n        directions = {1: [(0,-1),(0,1)],\\n                      2: [(-1,0),(1,0)],\\n                      3: [(0,-1),(1,0)],\\n                      4: [(0,1),(1,0)],\\n                      5: [(0,-1),(-1,0)],\\n                      6: [(0,1),(-1,0)]}\\n        visited = set()\\n        goal = (len(grid)-1, len(grid[0]) - 1)\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == goal:\\n                return True\\n            for d in directions[grid[i][j]]:\\n                ni, nj = i+d[0], j+d[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited and (-d[0], -d[1]) in directions[grid[ni][nj]]:\\n                    if dfs(ni, nj):\\n                        return True\\n            return False\\n        return dfs(0,0)\\n```\n```(-d[0], -d[1]) in directions[grid[ni][nj]]```",
                "codeTag": "Java"
            },
            {
                "id": 553574,
                "title": "java-dfs-solution-clean-code",
                "content": "```java\\npublic class Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    int[][][] DIR = new int[][][]{\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{-1, 0}, {0, 1}}\\n    };\\n    boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r == m - 1 && c == n - 1) return true; // Reach bottom-right cell -> Valid path\\n        visited[r][c] = true;\\n        for (int[] nextDir : DIR[grid[r][c] - 1]) {\\n            int nr = r + nextDir[0], nc = c + nextDir[1];\\n            if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) continue;\\n            for (int[] backDir : DIR[grid[nr][nc] - 1]) { // Check next cell can go back to current cell\\n                if (nr + backDir[0] == r && nc + backDir[1] == c) {\\n                    if (dfs(grid, m, n, nr, nc, visited)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nComplexity\\n- Time & Space: `O(m*n)`, where `m` is the number of rows, `n` is the number of columns of `grid`",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    int[][][] DIR = new int[][][]{\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{-1, 0}, {0, 1}}\\n    };\\n    boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r == m - 1 && c == n - 1) return true; // Reach bottom-right cell -> Valid path\\n        visited[r][c] = true;\\n        for (int[] nextDir : DIR[grid[r][c] - 1]) {\\n            int nr = r + nextDir[0], nc = c + nextDir[1];\\n            if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) continue;\\n            for (int[] backDir : DIR[grid[nr][nc] - 1]) { // Check next cell can go back to current cell\\n                if (nr + backDir[0] == r && nc + backDir[1] == c) {\\n                    if (dfs(grid, m, n, nr, nc, visited)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573840,
                "title": "c-dfs-100-space-and-faster-than-76",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_valid(int x,int y,vector<vector<int> > &grid)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size())\\n            return 0;\\n        return 1;\\n    }\\n    void dfs(int x,int y,vector<vector<bool> > &visited,vector<vector<int> > &grid){\\n        if(visited[x][y])\\n            return;\\n        visited[x][y] = 1;\\n        int up,down,left,right;\\n        up=down=left=right=0;\\n        if(grid[x][y] == 1)\\n            left=right=1;\\n        else if(grid[x][y] == 2)\\n            up=down=1;\\n        else if(grid[x][y] == 3)\\n            left=down=1;\\n        else if(grid[x][y] == 4)\\n            down=right=1;\\n        else if(grid[x][y] == 5)\\n            up = left = 1;\\n        else\\n            right=up=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==3 || grid[new_x][new_y]==4))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==5 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(left)\\n       {\\n            int new_x=x,new_y=y-1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==4 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n       }\\n        if(right)\\n       {\\n            int new_x=x,new_y=y+1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==3 || grid[new_x][new_y]==5))\\n                dfs(new_x,new_y,visited,grid);\\n       }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n)\\n            return 1;\\n        int m = grid[0].size();\\n        vector <vector<bool> > visited(n,vector<bool>(m,0));\\n        dfs(0,0,visited,grid);\\n        return visited[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_valid(int x,int y,vector<vector<int> > &grid)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size())\\n            return 0;\\n        return 1;\\n    }\\n    void dfs(int x,int y,vector<vector<bool> > &visited,vector<vector<int> > &grid){\\n        if(visited[x][y])\\n            return;\\n        visited[x][y] = 1;\\n        int up,down,left,right;\\n        up=down=left=right=0;\\n        if(grid[x][y] == 1)\\n            left=right=1;\\n        else if(grid[x][y] == 2)\\n            up=down=1;\\n        else if(grid[x][y] == 3)\\n            left=down=1;\\n        else if(grid[x][y] == 4)\\n            down=right=1;\\n        else if(grid[x][y] == 5)\\n            up = left = 1;\\n        else\\n            right=up=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==3 || grid[new_x][new_y]==4))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==5 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(left)\\n       {\\n            int new_x=x,new_y=y-1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==4 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n       }\\n        if(right)\\n       {\\n            int new_x=x,new_y=y+1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==3 || grid[new_x][new_y]==5))\\n                dfs(new_x,new_y,visited,grid);\\n       }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n)\\n            return 1;\\n        int m = grid[0].size();\\n        vector <vector<bool> > visited(n,vector<bool>(m,0));\\n        dfs(0,0,visited,grid);\\n        return visited[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679168,
                "title": "java-just-stupid-enum-cases-not-clean-but-straightforward",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int[][] visited=new int[m][n];\\n        return dfs(grid, 0, 0, m, n, visited);\\n    }\\n    public boolean dfs(int[][] grid, int i, int j, int m, int n, int[][] visited){\\n        if(i==m-1 && j==n-1) return true;\\n        if(i<0 || i>=m || j<0 || j>=n || visited[i][j]==1) return false;\\n        visited[i][j]=1;\\n        if(grid[i][j]==1){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5 ) && dfs(grid, i, j+1, m, n, visited) )) return true;\\n        }else if(grid[i][j]==2){\\n            if( (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited)) || \\n                (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==3){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==4){\\n            if( ((i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)) && dfs(grid, i+1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }else if(grid[i][j]==5){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else{\\n            if( (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int[][] visited=new int[m][n];\\n        return dfs(grid, 0, 0, m, n, visited);\\n    }\\n    public boolean dfs(int[][] grid, int i, int j, int m, int n, int[][] visited){\\n        if(i==m-1 && j==n-1) return true;\\n        if(i<0 || i>=m || j<0 || j>=n || visited[i][j]==1) return false;\\n        visited[i][j]=1;\\n        if(grid[i][j]==1){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5 ) && dfs(grid, i, j+1, m, n, visited) )) return true;\\n        }else if(grid[i][j]==2){\\n            if( (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited)) || \\n                (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==3){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==4){\\n            if( ((i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)) && dfs(grid, i+1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }else if(grid[i][j]==5){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else{\\n            if( (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249569,
                "title": "python-bfs-very-simple",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True\\n\\n            visited.add((r,c))\\n            s = grid[r][c]\\n\\n            for dr, dc in DIRECTIONS[s]:\\n                nr, nc = r+dr, c+dc\\n                if isValidMove(nr,nc):\\n                    ns = grid[nr][nc]\\n                    if (-dr,-dc) in DIRECTIONS[ns]:\\n                        q.append((nr, nc))\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True\\n\\n            visited.add((r,c))\\n            s = grid[r][c]\\n\\n            for dr, dc in DIRECTIONS[s]:\\n                nr, nc = r+dr, c+dc\\n                if isValidMove(nr,nc):\\n                    ns = grid[nr][nc]\\n                    if (-dr,-dc) in DIRECTIONS[ns]:\\n                        q.append((nr, nc))\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547633,
                "title": "python-super-easy-idea-just-walk-the-maze-based-on-the-rule",
                "content": "0 means going right, 1 means upwards, 2 means downwards, 3 means going left. \\n\\nAt cell with type 1, you can either enter it with right direction and leave it keeping the same direction, or enter it with left and leave for the left cell. So the rule for cell \\'1\\' is `{0: 0, 3: 3}`, and we can do the same transition rule for the other types.\\n\\nThen we can start walking in the maze. The initial position is (0, 0), and the initial direction can have two cases. If we walk outside of the maze, walk to a visited position or reach a pixel which does not permit the current direction, we exit the loop and return `False`.\\n\\nRuntime: 1460 ms, faster than 87.50% of Python3 online submissions for Check if There is a Valid Path in a Grid.\\nMemory Usage: 27.6 MB, less than 100.00% of Python3 online submissions for Check if There is a Valid Path in a Grid.\\n\\n```\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dict for transition rule\\n        rules = {\\n            1: {0: 0, 3: 3},\\n            2: {1: 1, 2: 2},\\n            3: {0: 2, 1: 3},\\n            4: {1: 0, 3: 2},\\n            5: {0: 1, 2: 3},\\n            6: {2: 0, 3: 1},\\n        }\\n        \\n        # dict for update rule\\n        moves = {\\n            0: (0, 1),\\n            1: (-1, 0),\\n            2: (1, 0),\\n            3: (0, -1),\\n        }\\n        \\n        x, y = (0, 0)\\n        k = grid[0][0]\\n        d = list(rules[k].keys())\\n        d1, d2 = d[0], d[1]\\n        \\n        def walkMaze(x, y, d):\\n            visited = set([(x, y)])\\n            while True:\\n                if x < 0 or x >= m or y < 0 or y >= n:\\n                    return False\\n                \\n                k = grid[x][y]\\n                if d not in rules[k]:\\n                    return False\\n                \\n                if (x, y) == (m - 1, n - 1):\\n                    return True\\n                \\n                d = rules[k][d]\\n                x, y = (x + moves[d][0], y + moves[d][1])\\n                if (x, y) in visited: # there is a loop\\n                    return False\\n                visited.add((x, y))\\n        \\n        return walkMaze(x, y, d1) or walkMaze(x, y, d2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dict for transition rule\\n        rules = {\\n            1: {0: 0, 3: 3},\\n            2: {1: 1, 2: 2},\\n            3: {0: 2, 1: 3},\\n            4: {1: 0, 3: 2},\\n            5: {0: 1, 2: 3},\\n            6: {2: 0, 3: 1},\\n        }\\n        \\n        # dict for update rule\\n        moves = {\\n            0: (0, 1),\\n            1: (-1, 0),\\n            2: (1, 0),\\n            3: (0, -1),\\n        }\\n        \\n        x, y = (0, 0)\\n        k = grid[0][0]\\n        d = list(rules[k].keys())\\n        d1, d2 = d[0], d[1]\\n        \\n        def walkMaze(x, y, d):\\n            visited = set([(x, y)])\\n            while True:\\n                if x < 0 or x >= m or y < 0 or y >= n:\\n                    return False\\n                \\n                k = grid[x][y]\\n                if d not in rules[k]:\\n                    return False\\n                \\n                if (x, y) == (m - 1, n - 1):\\n                    return True\\n                \\n                d = rules[k][d]\\n                x, y = (x + moves[d][0], y + moves[d][1])\\n                if (x, y) in visited: # there is a loop\\n                    return False\\n                visited.add((x, y))\\n        \\n        return walkMaze(x, y, d1) or walkMaze(x, y, d2)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 617817,
                "title": "c-dfs-solution",
                "content": "```\\nCredits to :-https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/573840/C%2B%2B-DFS-100-Space-and-Faster-than-76\\n\\nWe will be solving w be solving this using dfs.\\n\\nOur idea of solving will be to start from top left corner and work ourselves to the bottom right corner.\\n\\nWe keep a visited boolean array that tells about each cell wether it is visited or not.\\nAll we want to do in this question is to check if the bottommost right cell is visited or not.\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y,vector<vector<int>> &grid)                //This is a boolean function to check we are within the matrix.\\n    {\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size())return false;\\n        return true;\\n    }\\n    void dfs(int x,int y,vector<vector<bool>> &vis,vector<vector<int>> &grid)\\n    {\\n        if(vis[x][y])return;                //We dont want to backtrack our visited steps\\n        vis[x][y]=true;\\n        int up,down,left,right;\\n        up=down=left=right=0;                //These are intuitiv just look at the diagram \\n        if(grid[x][y]==1)\\n            left=right=1;\\n        else if(grid[x][y]==2)\\n            up=down=1;\\n        else if(grid[x][y]==3)\\n            left=down=1;\\n        else if(grid[x][y]==4)\\n            down=right=1;\\n        else if(grid[x][y]==5)\\n            left=up=1;\\n        else\\n            up=right=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;            //Think this in terms of the matrix and not the routes.I can go up a cell means i can go up a row which mean i-1\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==3||grid[new_x][new_y]==4))  //The way to get the second part of the if case is to check from my current cell what all routes will allow me to go up\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==5||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(right)\\n        {\\n            int new_x=x,new_y=y+1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==5||grid[new_x][new_y]==3))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(left)\\n        {\\n            int new_x=x,new_y=y-1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==4||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)return false;\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));           //Boolean array with the size of grid checking if a cell is visited or not\\n        dfs(0,0,vis,grid);                                           //We start our dfs function from top left corner and work ourselves to the bottom right corner.\\n        return vis[n-1][m-1];                                       //All we care about is if the last cell is visited or not.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nCredits to :-https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/573840/C%2B%2B-DFS-100-Space-and-Faster-than-76\\n\\nWe will be solving w be solving this using dfs.\\n\\nOur idea of solving will be to start from top left corner and work ourselves to the bottom right corner.\\n\\nWe keep a visited boolean array that tells about each cell wether it is visited or not.\\nAll we want to do in this question is to check if the bottommost right cell is visited or not.\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y,vector<vector<int>> &grid)                //This is a boolean function to check we are within the matrix.\\n    {\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size())return false;\\n        return true;\\n    }\\n    void dfs(int x,int y,vector<vector<bool>> &vis,vector<vector<int>> &grid)\\n    {\\n        if(vis[x][y])return;                //We dont want to backtrack our visited steps\\n        vis[x][y]=true;\\n        int up,down,left,right;\\n        up=down=left=right=0;                //These are intuitiv just look at the diagram \\n        if(grid[x][y]==1)\\n            left=right=1;\\n        else if(grid[x][y]==2)\\n            up=down=1;\\n        else if(grid[x][y]==3)\\n            left=down=1;\\n        else if(grid[x][y]==4)\\n            down=right=1;\\n        else if(grid[x][y]==5)\\n            left=up=1;\\n        else\\n            up=right=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;            //Think this in terms of the matrix and not the routes.I can go up a cell means i can go up a row which mean i-1\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==3||grid[new_x][new_y]==4))  //The way to get the second part of the if case is to check from my current cell what all routes will allow me to go up\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==5||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(right)\\n        {\\n            int new_x=x,new_y=y+1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==5||grid[new_x][new_y]==3))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(left)\\n        {\\n            int new_x=x,new_y=y-1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==4||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)return false;\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));           //Boolean array with the size of grid checking if a cell is visited or not\\n        dfs(0,0,vis,grid);                                           //We start our dfs function from top left corner and work ourselves to the bottom right corner.\\n        return vis[n-1][m-1];                                       //All we care about is if the last cell is visited or not.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775048,
                "title": "play-the-game-dfs-solution-the-most-readable-solution-you-re-going-to-find",
                "content": "I was bored so I wanted to make something out of an annoying problem.\\n\\nAt each cell in the board i,j, we test to see two things, we can move in each direction, and for each direction that we can move in, if the piece there can accept us from moving in that direction. \\n\\nNow this is more like playing a game, rather than a coding exercise.\\n\\nThe hash table moveTo notes who can move up right down left, and acceptFrom denotes the pieces which can accept someone incoming from up right down and left.\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[int]]) -> bool:\\n        if not A:\\n            return True\\n        m, n = len(A), len(A[0])\\n        visited = [[False]*n for _ in range(m)]\\n        moveTo = {\\n            \"up\": {2,5,6},\\n            \"right\": {1,4,6},\\n            \"down\": {2,3,4},\\n            \"left\" : {1,3,5}\\n        }\\n        acceptFrom = {\\n            \"up\": {2,3,4},\\n            \"right\": {1,3,5},\\n            \"down\": {2,5,6},\\n            \"left\": {1,4,6}\\n        }\\n        def inBound(i,j):\\n            return 0 <= i and i <= m-1 and 0 <= j and j <= n-1\\n        def dfs(i,j):\\n            if visited[i][j]:   return False\\n            if i == m-1 and j == n-1:   return True\\n            visited[i][j] = True\\n            curr = A[i][j]\\n            up = A[i-1][j] if inBound(i-1,j) else False\\n            right = A[i][j+1] if inBound(i,j+1) else False\\n            down = A[i+1][j] if inBound(i+1,j) else False\\n            left = A[i][j-1] if inBound(i,j-1) else False\\n            possible = False\\n            if not possible and curr in moveTo[\"up\"] and up and up in acceptFrom[\"up\"]:\\n                possible = dfs(i-1, j)\\n            if not possible and curr in moveTo[\"right\"] and right and right in acceptFrom[\"right\"]:\\n                possible = dfs(i, j+1)\\n            if not possible and curr in moveTo[\"down\"] and down and down in acceptFrom[\"down\"]:\\n                possible = dfs(i+1,j)\\n            if not possible and curr in moveTo[\"left\"] and left and left in acceptFrom[\"left\"]:\\n                possible = dfs(i,j-1)\\n            return possible\\n        return dfs(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[int]]) -> bool:\\n        if not A:\\n            return True\\n        m, n = len(A), len(A[0])\\n        visited = [[False]*n for _ in range(m)]\\n        moveTo = {\\n            \"up\": {2,5,6},\\n            \"right\": {1,4,6},\\n            \"down\": {2,3,4},\\n            \"left\" : {1,3,5}\\n        }\\n        acceptFrom = {\\n            \"up\": {2,3,4},\\n            \"right\": {1,3,5},\\n            \"down\": {2,5,6},\\n            \"left\": {1,4,6}\\n        }\\n        def inBound(i,j):\\n            return 0 <= i and i <= m-1 and 0 <= j and j <= n-1\\n        def dfs(i,j):\\n            if visited[i][j]:   return False\\n            if i == m-1 and j == n-1:   return True\\n            visited[i][j] = True\\n            curr = A[i][j]\\n            up = A[i-1][j] if inBound(i-1,j) else False\\n            right = A[i][j+1] if inBound(i,j+1) else False\\n            down = A[i+1][j] if inBound(i+1,j) else False\\n            left = A[i][j-1] if inBound(i,j-1) else False\\n            possible = False\\n            if not possible and curr in moveTo[\"up\"] and up and up in acceptFrom[\"up\"]:\\n                possible = dfs(i-1, j)\\n            if not possible and curr in moveTo[\"right\"] and right and right in acceptFrom[\"right\"]:\\n                possible = dfs(i, j+1)\\n            if not possible and curr in moveTo[\"down\"] and down and down in acceptFrom[\"down\"]:\\n                possible = dfs(i+1,j)\\n            if not possible and curr in moveTo[\"left\"] and left and left in acceptFrom[\"left\"]:\\n                possible = dfs(i,j-1)\\n            return possible\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551075,
                "title": "java-concise-dfs-solution",
                "content": "If I can receive from right, I can give to left as well. If I receive from up, I give it to down as well.\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int rows = grid.length , cols = grid[0].length;\\n        boolean[][] vis = new boolean[rows][cols];\\n        Map<Integer,Set<Character>> map = new HashMap<>();\\n        map.put(1,new HashSet<>(Arrays.asList(\\'L\\',\\'R\\')));\\n        map.put(2,new HashSet<>(Arrays.asList(\\'U\\',\\'D\\')));\\n        map.put(3,new HashSet<>(Arrays.asList(\\'R\\',\\'U\\')));\\n        map.put(4,new HashSet<>(Arrays.asList(\\'L\\',\\'U\\')));\\n        map.put(5,new HashSet<>(Arrays.asList(\\'R\\',\\'D\\')));\\n        map.put(6,new HashSet<>(Arrays.asList(\\'L\\',\\'D\\')));\\n        return dfs(grid,0,0,rows,cols,map,\\'~\\',vis);\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y,int rows,int cols,Map<Integer,Set<Character>> map,char dir,boolean[][] vis){\\n        if(x == rows || x < 0 || y == cols || y < 0 || vis[x][y] || dir != \\'~\\' && !map.get(grid[x][y]).contains(dir)) return false;\\n        if(x == rows-1 && y == cols-1) return true;\\n        vis[x][y] = true;\\n        if(map.get(grid[x][y]).contains(\\'L\\') && dfs(grid,x,y+1,rows,cols,map,\\'R\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'R\\') && dfs(grid,x,y-1,rows,cols,map,\\'L\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'U\\') && dfs(grid,x+1,y,rows,cols,map,\\'D\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'D\\') && dfs(grid,x-1,y,rows,cols,map,\\'U\\',vis)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int rows = grid.length , cols = grid[0].length;\\n        boolean[][] vis = new boolean[rows][cols];\\n        Map<Integer,Set<Character>> map = new HashMap<>();\\n        map.put(1,new HashSet<>(Arrays.asList(\\'L\\',\\'R\\')));\\n        map.put(2,new HashSet<>(Arrays.asList(\\'U\\',\\'D\\')));\\n        map.put(3,new HashSet<>(Arrays.asList(\\'R\\',\\'U\\')));\\n        map.put(4,new HashSet<>(Arrays.asList(\\'L\\',\\'U\\')));\\n        map.put(5,new HashSet<>(Arrays.asList(\\'R\\',\\'D\\')));\\n        map.put(6,new HashSet<>(Arrays.asList(\\'L\\',\\'D\\')));\\n        return dfs(grid,0,0,rows,cols,map,\\'~\\',vis);\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y,int rows,int cols,Map<Integer,Set<Character>> map,char dir,boolean[][] vis){\\n        if(x == rows || x < 0 || y == cols || y < 0 || vis[x][y] || dir != \\'~\\' && !map.get(grid[x][y]).contains(dir)) return false;\\n        if(x == rows-1 && y == cols-1) return true;\\n        vis[x][y] = true;\\n        if(map.get(grid[x][y]).contains(\\'L\\') && dfs(grid,x,y+1,rows,cols,map,\\'R\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'R\\') && dfs(grid,x,y-1,rows,cols,map,\\'L\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'U\\') && dfs(grid,x+1,y,rows,cols,map,\\'D\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'D\\') && dfs(grid,x-1,y,rows,cols,map,\\'U\\',vis)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310590,
                "title": "c-easiest-bfs-solution-with-constant-space",
                "content": "# Intuition\\nWe can move from one cell to the other 4 possible cells only if they are not visited already and there exist the path in between them .\\n\\n# Approach\\nWe will be using Breadth First Search Approach \\nFor that we need to remember that from a current type of path, on what types of path can we move to if we go in left direction , right , up or down each .\\n\\nFor that we use 3D Vector mp where mp[i][j][k] denotes , that from path i if we go in direction j , then can we reach on path k or not?\\n\\nwhere 1 <= i , k <= 7; \\n       0 <= j <= 3;\\nj = 0 denotes -> Left Direction \\nj = 1 denotes -> Right Direction \\nj = 2 denotes -> UpWards \\nj = 3 denotes -> Downwards \\n\\nFor ex , mp[4][1][3] is true as we can move from path 4 to path 3 bygoing right direction\\n\\nSimilarly mp[1][3][2] is false because we can move from path 1 to path 2 by going downwards.\\n\\nWe start from cell (0,0) by pushing it into q and to mark it visited we multiply its value with -1 so that we can remember the path type and also mark it visted at the same time .\\n\\n// If somehow you find this solution helpful an Upvote will ve appreciated .\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int m , n;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = -grid[0][0];\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<vector<vector<int>>> mp(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n\\n        // 1 , 0\\n        mp[1][0][1] = 1;\\n        mp[1][0][4] = 1;\\n        mp[1][0][6] = 1;\\n\\n        // 1 , 1\\n        mp[1][1][1] = 1;\\n        mp[1][1][3] = 1;\\n        mp[1][1][5] = 1;\\n\\n        // 2 , 2\\n        mp[2][2][2] = 1;\\n        mp[2][2][3] = 1;\\n        mp[2][2][4] = 1;\\n\\n        // 2 , 3\\n        mp[2][3][2] = 1;\\n        mp[2][3][5] = 1;\\n        mp[2][3][6] = 1;\\n\\n        //3 0\\n        mp[3][0][1] = 1;\\n        mp[3][0][4] = 1;\\n        mp[3][0][6] = 1;\\n\\n        //3 3\\n        mp[3][3][2] = 1;\\n        mp[3][3][5] = 1;\\n        mp[3][3][6] = 1;\\n        \\n        // 4 1\\n        mp[4][1][1] = 1;\\n        mp[4][1][3] = 1;\\n        mp[4][1][5] = 1;\\n        \\n\\n        // 4 3\\n        mp[4][3][2] = 1;\\n        mp[4][3][5] = 1;\\n        mp[4][3][6] = 1;\\n\\n        // 5 0\\n        mp[5][0][1] = 1;\\n        mp[5][0][4] = 1;\\n        mp[5][0][6] = 1;\\n\\n        // 5 2\\n        mp[5][2][2] = 1;\\n        mp[5][2][2] = 1;\\n        mp[5][2][4] = 1;\\n\\n        // 6 1\\n        mp[6][1][1] = 1;\\n        mp[6][1][3] = 1;\\n        mp[6][1][5] = 1;\\n\\n        // 6 2\\n        mp[6][2][2] = 1;\\n        mp[6][2][3] = 1;\\n        mp[6][2][4] = 1;\\n\\n\\n        while(!q.empty())\\n        {\\n               int x = q.front().first;\\n               int y = q.front().second;\\n               int pos = -grid[x][y];\\n               q.pop();\\n\\n               if(x == m-1 && y == n-1)\\n               return true;\\n               \\n               // 0  -> Left       \\n               if(y-1>=0)\\n               {\\n                   if(grid[x][y-1] > 0 && mp[pos][0][grid[x][y-1]])\\n                   {\\n                       q.push({x,y-1});\\n                       grid[x][y-1] = -grid[x][y-1];\\n                   }               \\n                }   \\n\\n               // 1  -> Right\\n               if(y+1 < n)\\n               {\\n                   if(grid[x][y+1] > 0 && mp[pos][1][grid[x][y+1]])\\n                   {\\n                       q.push({x,y+1});\\n                       grid[x][y+1] = -grid[x][y+1];\\n                   }               \\n                }   \\n\\n               // 2   -> Up\\n               if(x-1>=0)\\n               {\\n                   if(grid[x-1][y] > 0 && mp[pos][2][grid[x-1][y]])\\n                   {\\n                       q.push({x-1,y});\\n                       grid[x-1][y] = -grid[x-1][y];\\n                   }\\n               }   \\n\\n               // 3   ->  Down     \\n               if(x+1<m)\\n               {\\n                   if(grid[x+1][y] > 0 && mp[pos][3][grid[x+1][y]])\\n                   {\\n                       q.push({x+1,y});\\n                       grid[x+1][y] = -grid[x+1][y];\\n                   }               \\n                }   \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m , n;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = -grid[0][0];\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<vector<vector<int>>> mp(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n\\n        // 1 , 0\\n        mp[1][0][1] = 1;\\n        mp[1][0][4] = 1;\\n        mp[1][0][6] = 1;\\n\\n        // 1 , 1\\n        mp[1][1][1] = 1;\\n        mp[1][1][3] = 1;\\n        mp[1][1][5] = 1;\\n\\n        // 2 , 2\\n        mp[2][2][2] = 1;\\n        mp[2][2][3] = 1;\\n        mp[2][2][4] = 1;\\n\\n        // 2 , 3\\n        mp[2][3][2] = 1;\\n        mp[2][3][5] = 1;\\n        mp[2][3][6] = 1;\\n\\n        //3 0\\n        mp[3][0][1] = 1;\\n        mp[3][0][4] = 1;\\n        mp[3][0][6] = 1;\\n\\n        //3 3\\n        mp[3][3][2] = 1;\\n        mp[3][3][5] = 1;\\n        mp[3][3][6] = 1;\\n        \\n        // 4 1\\n        mp[4][1][1] = 1;\\n        mp[4][1][3] = 1;\\n        mp[4][1][5] = 1;\\n        \\n\\n        // 4 3\\n        mp[4][3][2] = 1;\\n        mp[4][3][5] = 1;\\n        mp[4][3][6] = 1;\\n\\n        // 5 0\\n        mp[5][0][1] = 1;\\n        mp[5][0][4] = 1;\\n        mp[5][0][6] = 1;\\n\\n        // 5 2\\n        mp[5][2][2] = 1;\\n        mp[5][2][2] = 1;\\n        mp[5][2][4] = 1;\\n\\n        // 6 1\\n        mp[6][1][1] = 1;\\n        mp[6][1][3] = 1;\\n        mp[6][1][5] = 1;\\n\\n        // 6 2\\n        mp[6][2][2] = 1;\\n        mp[6][2][3] = 1;\\n        mp[6][2][4] = 1;\\n\\n\\n        while(!q.empty())\\n        {\\n               int x = q.front().first;\\n               int y = q.front().second;\\n               int pos = -grid[x][y];\\n               q.pop();\\n\\n               if(x == m-1 && y == n-1)\\n               return true;\\n               \\n               // 0  -> Left       \\n               if(y-1>=0)\\n               {\\n                   if(grid[x][y-1] > 0 && mp[pos][0][grid[x][y-1]])\\n                   {\\n                       q.push({x,y-1});\\n                       grid[x][y-1] = -grid[x][y-1];\\n                   }               \\n                }   \\n\\n               // 1  -> Right\\n               if(y+1 < n)\\n               {\\n                   if(grid[x][y+1] > 0 && mp[pos][1][grid[x][y+1]])\\n                   {\\n                       q.push({x,y+1});\\n                       grid[x][y+1] = -grid[x][y+1];\\n                   }               \\n                }   \\n\\n               // 2   -> Up\\n               if(x-1>=0)\\n               {\\n                   if(grid[x-1][y] > 0 && mp[pos][2][grid[x-1][y]])\\n                   {\\n                       q.push({x-1,y});\\n                       grid[x-1][y] = -grid[x-1][y];\\n                   }\\n               }   \\n\\n               // 3   ->  Down     \\n               if(x+1<m)\\n               {\\n                   if(grid[x+1][y] > 0 && mp[pos][3][grid[x+1][y]])\\n                   {\\n                       q.push({x+1,y});\\n                       grid[x+1][y] = -grid[x+1][y];\\n                   }               \\n                }   \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531370,
                "title": "c-dfs",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    map<int,set<pair<int,int>>> dxy; // directions in which we can move from particular cell value\\n    \\n    bool solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>> &visited){\\n        int n=grid.size(), m=grid[0].size();\\n        if(i==n-1 && j==m-1) return true;\\n        visited[i][j]=true;\\n        \\n        set<pair<int,int>> st=dxy[grid[i][j]];\\n        set<pair<int,int>> :: iterator it;\\n        for(it=st.begin();it!=st.end();it++){\\n            int d1=it->first, d2=it->second;\\n            int x=i+d1, y=j+d2; // next cell position\\n            if(x>=0 && y>=0 && x<n && y<m && visited[x][y]==false){\\n                int next=grid[x][y];\\n\\t\\t\\t\\t// we also need to check that it possible to reach back to cuurent cell from next cell for valid move\\n                if(dxy[next].find({-d1,-d2})!=dxy[next].end() && solve(grid,x,y,visited)) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n\\t\\t\\n        dxy[1].insert({{0,-1},{0,1}});\\n        dxy[2].insert({{-1,0},{1,0}});\\n        dxy[3].insert({{0,-1},{1,0}});\\n        dxy[4].insert({{0,1},{1,0}});\\n        dxy[5].insert({{-1,0},{0,-1}});\\n        dxy[6].insert({{-1,0},{0,1}});\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        return solve(grid,0,0,visited);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<int,set<pair<int,int>>> dxy; // directions in which we can move from particular cell value\\n    \\n    bool solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>> &visited){\\n        int n=grid.size(), m=grid[0].size();\\n        if(i==n-1 && j==m-1) return true;\\n        visited[i][j]=true;\\n        \\n        set<pair<int,int>> st=dxy[grid[i][j]];\\n        set<pair<int,int>> :: iterator it;\\n        for(it=st.begin();it!=st.end();it++){\\n            int d1=it->first, d2=it->second;\\n            int x=i+d1, y=j+d2; // next cell position\\n            if(x>=0 && y>=0 && x<n && y<m && visited[x][y]==false){\\n                int next=grid[x][y];\\n\\t\\t\\t\\t// we also need to check that it possible to reach back to cuurent cell from next cell for valid move\\n                if(dxy[next].find({-d1,-d2})!=dxy[next].end() && solve(grid,x,y,visited)) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n\\t\\t\\n        dxy[1].insert({{0,-1},{0,1}});\\n        dxy[2].insert({{-1,0},{1,0}});\\n        dxy[3].insert({{0,-1},{1,0}});\\n        dxy[4].insert({{0,1},{1,0}});\\n        dxy[5].insert({{-1,0},{0,-1}});\\n        dxy[6].insert({{-1,0},{0,1}});\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        return solve(grid,0,0,visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602788,
                "title": "easy-to-understand-dsu-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799828,
                "title": "dfs-c-very-naive-solution-nice-problem-w-nice-solution",
                "content": "Please Upvote :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Travel each cell if it can be entered and unvisited.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Basic dfs \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(2 * ( n * m ))\\n# Code\\n```\\nclass Solution {\\n    int n,m;\\n    bool vis[305][305];\\n    vector<vector<int>>g;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        dfs(0,0);\\n        return vis[n-1][m-1];\\n    }\\n\\n    void dfs(int ux, int uy){\\n        vis[ux][uy]=true;\\n        int vx,vy;\\n\\n        if(g[ux][uy] == 1 || g[ux][uy]==4 || g[ux][uy]==6) {vx=ux, vy=uy+1; if(valid(vx, vy) && L_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 1 || g[ux][uy]==3 || g[ux][uy]==5) {vx=ux, vy=uy-1; if(valid(vx, vy) && R_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==3 || g[ux][uy]==4) {vx=ux+1, vy=uy; if(valid(vx, vy) && D_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==5 || g[ux][uy]==6) {vx=ux-1, vy=uy; if(valid(vx, vy) && U_enter(vx,vy)) dfs(vx, vy);} \\n\\n    }\\n    bool valid(int x , int y){\\n        if(x>=0 && y>=0 && x<n && y<m && !vis[x][y] ) return true;\\n        return false;\\n    }\\n    bool L_enter(int x, int y){\\n        if(g[x][y]%2) return true;\\n        return false;\\n    }\\n    bool R_enter(int x, int y){\\n        if(g[x][y]==1 || g[x][y]==4 || g[x][y]==6) return true;\\n        return false;\\n    }\\n    bool D_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==5 || g[x][y]==6) return true;\\n        return false;\\n    }\\n     bool U_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==3 || g[x][y]==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    bool vis[305][305];\\n    vector<vector<int>>g;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        dfs(0,0);\\n        return vis[n-1][m-1];\\n    }\\n\\n    void dfs(int ux, int uy){\\n        vis[ux][uy]=true;\\n        int vx,vy;\\n\\n        if(g[ux][uy] == 1 || g[ux][uy]==4 || g[ux][uy]==6) {vx=ux, vy=uy+1; if(valid(vx, vy) && L_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 1 || g[ux][uy]==3 || g[ux][uy]==5) {vx=ux, vy=uy-1; if(valid(vx, vy) && R_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==3 || g[ux][uy]==4) {vx=ux+1, vy=uy; if(valid(vx, vy) && D_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==5 || g[ux][uy]==6) {vx=ux-1, vy=uy; if(valid(vx, vy) && U_enter(vx,vy)) dfs(vx, vy);} \\n\\n    }\\n    bool valid(int x , int y){\\n        if(x>=0 && y>=0 && x<n && y<m && !vis[x][y] ) return true;\\n        return false;\\n    }\\n    bool L_enter(int x, int y){\\n        if(g[x][y]%2) return true;\\n        return false;\\n    }\\n    bool R_enter(int x, int y){\\n        if(g[x][y]==1 || g[x][y]==4 || g[x][y]==6) return true;\\n        return false;\\n    }\\n    bool D_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==5 || g[x][y]==6) return true;\\n        return false;\\n    }\\n     bool U_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==3 || g[x][y]==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993874,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<vector<int>>& grid, int i ,int j, int m, int n)\\n    {\\n        if(i == m-1 && j == n-1) return true;\\n        \\n        if(grid[i][j] == 0) return false;\\n        \\n        if(grid[i][j] == 1)\\n        {\\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    j < n-1 && (grid[i][j+1] == 3 || grid[i][j+1] == 5 || grid[i][j+1] == 1) && dfs(grid,i,j+1,m,n));\\n        }\\n        else if(grid[i][j] == 2)\\n        {\\n            grid[i][j] = 0;\\n            return ((i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 3)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 ||grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 4)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 5)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) && dfs(grid,i,j-1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else if(grid[i][j] == 6)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else\\n        {\\n            grid[i][j] = 0;    \\n            return false;\\n         }    \\n    }    \\n    \\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        return dfs(grid,0,0,grid.size(), grid[0].size());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<vector<int>>& grid, int i ,int j, int m, int n)\\n    {\\n        if(i == m-1 && j == n-1) return true;\\n        \\n        if(grid[i][j] == 0) return false;\\n        \\n        if(grid[i][j] == 1)\\n        {\\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    j < n-1 && (grid[i][j+1] == 3 || grid[i][j+1] == 5 || grid[i][j+1] == 1) && dfs(grid,i,j+1,m,n));\\n        }\\n        else if(grid[i][j] == 2)\\n        {\\n            grid[i][j] = 0;\\n            return ((i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 3)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 ||grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 4)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 5)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) && dfs(grid,i,j-1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else if(grid[i][j] == 6)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else\\n        {\\n            grid[i][j] = 0;    \\n            return false;\\n         }    \\n    }    \\n    \\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        return dfs(grid,0,0,grid.size(), grid[0].size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408547,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis is a standard DFS problem. Build out your directions matrix or mappings, then initiate a DFS from the first square. Whats unique to this problem is that you have to make sure the roads connect back to the previous cell. I actually completley forgot about this use case ;)\\n\\n### Solution\\n```\\n    private static Map<Integer, Integer[][]> map;\\n    static {\\n        Map<Integer, Integer[][]> aMap = new HashMap();\\n        aMap.put(1, new Integer[][] {{0,-1}, {0, 1}});\\n        aMap.put(2, new Integer[][] {{1, 0}, {-1,0}});\\n        aMap.put(3, new Integer[][] {{0,-1}, {1, 0}});\\n        aMap.put(4, new Integer[][] {{0, 1}, {1, 0}});\\n        aMap.put(5, new Integer[][] {{0,-1}, {-1,0}});\\n        aMap.put(6, new Integer[][] {{0, 1}, {-1,0}});\\n        map = Collections.unmodifiableMap(aMap);\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        return dfs(0, 0, grid, new boolean[grid.length][grid[0].length]);\\n    }\\n    \\n    private boolean dfs(int x, int y, int[][] grid, boolean[][] visited) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1) return true;\\n        visited[x][y] = true;\\n        \\n        for (Integer[] next : map.get(grid[x][y])) {\\n            int newX = x + next[0], newY = y + next[1];\\n            if (!outOfBounds(newX, newY, grid) && !visited[newX][newY]) {\\n                // need to check if I can get back to current cell from newX,newY\\n                for (Integer[] rev : map.get(grid[newX][newY])) {\\n                    if (newX + rev[0] == x && newY + rev[1] == y) {\\n                        if (dfs(newX, newY, grid, visited)) return true;\\n                    }\\n                }\\n            }            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean outOfBounds(int x, int y, int[][] grid) {\\n        return x < 0 || y < 0 || x >= grid.length || y >= grid[0].length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static Map<Integer, Integer[][]> map;\\n    static {\\n        Map<Integer, Integer[][]> aMap = new HashMap();\\n        aMap.put(1, new Integer[][] {{0,-1}, {0, 1}});\\n        aMap.put(2, new Integer[][] {{1, 0}, {-1,0}});\\n        aMap.put(3, new Integer[][] {{0,-1}, {1, 0}});\\n        aMap.put(4, new Integer[][] {{0, 1}, {1, 0}});\\n        aMap.put(5, new Integer[][] {{0,-1}, {-1,0}});\\n        aMap.put(6, new Integer[][] {{0, 1}, {-1,0}});\\n        map = Collections.unmodifiableMap(aMap);\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        return dfs(0, 0, grid, new boolean[grid.length][grid[0].length]);\\n    }\\n    \\n    private boolean dfs(int x, int y, int[][] grid, boolean[][] visited) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1) return true;\\n        visited[x][y] = true;\\n        \\n        for (Integer[] next : map.get(grid[x][y])) {\\n            int newX = x + next[0], newY = y + next[1];\\n            if (!outOfBounds(newX, newY, grid) && !visited[newX][newY]) {\\n                // need to check if I can get back to current cell from newX,newY\\n                for (Integer[] rev : map.get(grid[newX][newY])) {\\n                    if (newX + rev[0] == x && newY + rev[1] == y) {\\n                        if (dfs(newX, newY, grid, visited)) return true;\\n                    }\\n                }\\n            }            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean outOfBounds(int x, int y, int[][] grid) {\\n        return x < 0 || y < 0 || x >= grid.length || y >= grid[0].length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359262,
                "title": "c-easy-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //store the directions in which you can move for every street\\n        vector<vector<pair<int,int>>> dir(7);\\n        \\n        dir[1]={{0,-1},{0,1}};\\n        dir[2]={{1,0},{-1,0}};\\n        dir[3]={{0,-1},{1,0}};\\n        dir[4]={{0,1},{1,0}};\\n        dir[5]={{-1,0},{0,-1}};\\n        dir[6]={{-1,0},{0,1}};\\n        \\n        //start at the cell 0 and move into the streets in which there is a path (use the dir arr to get the moves for a street)\\n        \\n        return dfs(0,0,grid,dir,m,n);\\n        \\n    }\\n    bool dfs(int i,int j,vector<vector<int>>& grid,vector<vector<pair<int,int>>>& dir,int& m,int& n)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        \\n        int val=grid[i][j];\\n        //change grid[i][j] to 0  to avoid visiting again\\n        \\n        //example if array is [[4,3],[6,5]] \\n        //we stuck in a loop\\n        grid[i][j]=0;\\n        \\n        //explore all the paths\\n        int x;\\n        int y;\\n        for(int k=0;k<2;k++)\\n        {\\n            x=i+dir[val][k].first;\\n            y=j+dir[val][k].second;\\n            if(x<0 || y<0  || x>=m || y>=n || grid[x][y]==0)\\n                continue;\\n            \\n            int nxt=grid[x][y];\\n            int x1=x+dir[nxt][0].first;\\n            int x2=x+dir[nxt][1].first;\\n            int y1=y+dir[nxt][0].second;\\n            int y2=y+dir[nxt][1].second;\\n            \\n            //if there is a path connecting [i,j] and the [x,y] \\n            //you can check if one of  the directions of [x,y] cell is the [i,j]\\n            \\n            if((x1==i && y1==j) || (x2==i && y2==j) )\\n                if(dfs(x,y,grid,dir,m,n))\\n                   return true;\\n        }\\n        grid[i][j]=val;\\n        return false;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //store the directions in which you can move for every street\\n        vector<vector<pair<int,int>>> dir(7);\\n        \\n        dir[1]={{0,-1},{0,1}};\\n        dir[2]={{1,0},{-1,0}};\\n        dir[3]={{0,-1},{1,0}};\\n        dir[4]={{0,1},{1,0}};\\n        dir[5]={{-1,0},{0,-1}};\\n        dir[6]={{-1,0},{0,1}};\\n        \\n        //start at the cell 0 and move into the streets in which there is a path (use the dir arr to get the moves for a street)\\n        \\n        return dfs(0,0,grid,dir,m,n);\\n        \\n    }\\n    bool dfs(int i,int j,vector<vector<int>>& grid,vector<vector<pair<int,int>>>& dir,int& m,int& n)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        \\n        int val=grid[i][j];\\n        //change grid[i][j] to 0  to avoid visiting again\\n        \\n        //example if array is [[4,3],[6,5]] \\n        //we stuck in a loop\\n        grid[i][j]=0;\\n        \\n        //explore all the paths\\n        int x;\\n        int y;\\n        for(int k=0;k<2;k++)\\n        {\\n            x=i+dir[val][k].first;\\n            y=j+dir[val][k].second;\\n            if(x<0 || y<0  || x>=m || y>=n || grid[x][y]==0)\\n                continue;\\n            \\n            int nxt=grid[x][y];\\n            int x1=x+dir[nxt][0].first;\\n            int x2=x+dir[nxt][1].first;\\n            int y1=y+dir[nxt][0].second;\\n            int y2=y+dir[nxt][1].second;\\n            \\n            //if there is a path connecting [i,j] and the [x,y] \\n            //you can check if one of  the directions of [x,y] cell is the [i,j]\\n            \\n            if((x1==i && y1==j) || (x2==i && y2==j) )\\n                if(dfs(x,y,grid,dir,m,n))\\n                   return true;\\n        }\\n        grid[i][j]=val;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603032,
                "title": "c-bfs-much-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool isVal (int ni, int nj) {\\n\\t\\treturn !(ni < 0 or ni >= n or nj < 0 or nj >= m);\\n\\t}\\n\\n\\tbool hasValidPath(vector<vector<int>> &grid) {\\n\\t\\tn = grid.size(), m = grid[0].size();\\n\\t\\tvis.insert({0, 0}), q.push({0, 0});\\n\\t\\tsetDirAndPath();\\n\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto nd = q.front(); q.pop();\\t\\t\\t\\n\\t\\t\\tint i = nd.first, j = nd.second;\\n\\t\\t\\t\\n\\t\\t\\tif (i == n - 1 and j == m - 1) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t\\tfor (auto d : dir[grid[i][j]]) {\\n\\t\\t\\t\\tint ni = i + d.first, nj = j + d.second;\\n\\t\\t\\t\\tif (isVal(ni,nj) and path[d].count(grid[ni][nj]) and !vis.count({ni, nj})) {\\n\\t\\t\\t\\t\\tvis.insert({ni, nj});\\n\\t\\t\\t\\t\\tq.push({ni, nj});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\t\\n\\nprivate:\\n\\tint n, m;\\n\\tunordered_map<int, vector<pair<int, int>>> dir;\\n\\tmap<pair<int, int>, set<int>> path;\\n\\tset<pair<int, int>> vis;\\n\\tqueue<pair<int, int>> q;\\n\\n\\tvoid setDirAndPath() {\\n\\t\\tdir[1] = {{0, -1}, {0, 1}}, dir[2] = {{ -1, 0}, {1, 0}}, dir[3] = {{0, -1}, {1, 0}};\\n\\t\\tdir[4] = {{0, 1}, {1, 0}}, dir[5] = {{0, -1}, { -1, 0}}, dir[6] = {{0, 1}, { -1, 0}};\\n\\n\\t\\tpath[{-1, 0}].insert({2, 3, 4}), path[{1, 0}].insert({2, 5, 6});\\n\\t\\tpath[{0, 1}].insert({1, 3, 5}), path[{0, -1}].insert({1, 4, 6});\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tbool isVal (int ni, int nj) {\\n\\t\\treturn !(ni < 0 or ni >= n or nj < 0 or nj >= m);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3541190,
                "title": "python-solution-with-dfs-and-untion-find",
                "content": "\\n**Title: Valid Path in a Grid - Union-Find Solution\\n**\\nDescription:\\n\\nThe problem asks us to determine whether there exists a valid path in a given grid, where each cell represents a street with specific connections. We are not allowed to change any streets, and the valid path should start from the upper-left cell and end at the bottom-right cell.\\n\\nThis solution utilizes the Union-Find algorithm to efficiently determine the validity of the path. The approach begins by initializing a parent dictionary using a defaultdict and assigning each cell as its own parent. Additionally, a rank matrix is created to keep track of the rank of each cell.\\n\\nNext, the valid connections for right and down directions are defined using dictionaries. These dictionaries map each street type to the set of valid connections it has with neighboring cells. For example, street 1 can connect with streets 1, 3, and 5 to the right.\\n\\nThen, a nested loop iterates through each cell in the grid. For each cell, the algorithm checks the valid connections in the right and down directions. If a valid connection is found, the algorithm performs the union operation using the Union-Find data structure. This operation merges the sets containing the cells to connect them.\\n\\nFinally, the algorithm checks if the upper-left cell (0, 0) and the bottom-right cell (m-1, n-1) are in the same connected component. This is done by calling the find function on both cells and comparing their roots. If they belong to the same component, it indicates the existence of a valid path from the start to the end.\\n\\nThe solution efficiently handles the grid\\'s connectivity using the Union-Find algorithm, allowing for quick determination of a valid path. By exploring the valid connections and performing unions between cells, the algorithm accurately determines if a valid path exists in the given grid.\\n\\nThe overall time complexity of this solution is O(m * n * \\u03B1(m * n)), where m and n are the dimensions of the grid, and \\u03B1 denotes the inverse Ackermann function. This time complexity arises from the union-find operations performed on the cells in the grid.\\n\\nOverall, this solution provides an efficient approach to solve the problem by leveraging the Union-Find algorithm and considering the valid connections between the cells in the grid.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        parent=defaultdict(int)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                parent[(i,j)]=(i,j)\\n        \\n        rank=[[0 for j in range(len(grid[0]))] for i in range(len(grid))]\\n        directions=[(1,0),(0,1)]\\n        def inbound(row,col):\\n            return 0<=row<=len(grid)-1 and 0<=col<=len(grid[0])-1\\n        def find(x):\\n            root=x\\n            while root!=parent[root]:\\n                root=parent[root]\\n            \\n            while x!=root:\\n                temp=parent[x]\\n                parent[x]=root\\n                x=temp\\n            return root\\n            \\n        def union(pair1,pair2):\\n            parentX=find(pair1)\\n            parentY=find(pair2)\\n            if parentX==parentY:return\\n            if rank[parentX[0]][parentX[1]]==rank[parentY[0]][parentY[1]]:\\n                rank[parentX[0]][parentX[1]]+=1\\n            if rank[parentX[0]][parentX[1]]>rank[parentY[0]][parentY[1]]:\\n                parent[parentY]=parentX\\n            else:\\n                parent[parentX]=parentY\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[i])):\\n                for change_row,change_col in directions:\\n                    new_row=row+change_row\\n                    new_col=col+change_col\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in right[grid[row][col]] and new_col-col==1:\\n                        \\n                        union((row,col),(new_row,new_col))\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in down[grid[row][col]] and new_row-row==1:\\n                        union((row,col),(new_row,new_col))\\n        return find((0,0))==find((len(grid)-1,len(grid[-1])-1))\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        parent=defaultdict(int)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                parent[(i,j)]=(i,j)\\n        \\n        rank=[[0 for j in range(len(grid[0]))] for i in range(len(grid))]\\n        directions=[(1,0),(0,1)]\\n        def inbound(row,col):\\n            return 0<=row<=len(grid)-1 and 0<=col<=len(grid[0])-1\\n        def find(x):\\n            root=x\\n            while root!=parent[root]:\\n                root=parent[root]\\n            \\n            while x!=root:\\n                temp=parent[x]\\n                parent[x]=root\\n                x=temp\\n            return root\\n            \\n        def union(pair1,pair2):\\n            parentX=find(pair1)\\n            parentY=find(pair2)\\n            if parentX==parentY:return\\n            if rank[parentX[0]][parentX[1]]==rank[parentY[0]][parentY[1]]:\\n                rank[parentX[0]][parentX[1]]+=1\\n            if rank[parentX[0]][parentX[1]]>rank[parentY[0]][parentY[1]]:\\n                parent[parentY]=parentX\\n            else:\\n                parent[parentX]=parentY\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[i])):\\n                for change_row,change_col in directions:\\n                    new_row=row+change_row\\n                    new_col=col+change_col\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in right[grid[row][col]] and new_col-col==1:\\n                        \\n                        union((row,col),(new_row,new_col))\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in down[grid[row][col]] and new_row-row==1:\\n                        union((row,col),(new_row,new_col))\\n        return find((0,0))==find((len(grid)-1,len(grid[-1])-1))\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036363,
                "title": "c-solution-union-find-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100000];\\n    int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    bool union_(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y) return true;\\n        parent[y] = x;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        for(int i = 0; i < 100000; i++)\\n            parent[i] = i;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                \\n                int x = i, y = j;\\n                for(int k = 0; k < 4; k++) {\\n                    int nx =  x + dx[k];\\n                    int ny = y + dy[k];\\n                    \\n                    \\n                    if(nx < 0 or nx >= n or ny < 0 or ny >= m)\\n                        continue;\\n                    int way = g[nx][ny];\\n                    int curr = g[x][y];\\n                    \\n                    // top\\n                    if(k == 0) {\\n                        if(curr == 5 or curr == 6 or curr == 2) {\\n                            if(way == 2 or way == 3 or way == 4)\\n                                union_(x * m + y, nx * m + ny);\\n                        }  \\n                    }\\n                    // right\\n                     if(k == 1) {\\n                         if(curr == 1 or curr == 4 or curr == 5) {\\n                            if(way == 3 or way == 5 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                     }\\n                    // down\\n                    if(k == 2) {\\n                        if(curr == 3 or curr == 4 or curr == 2) {\\n                            if(way == 2 or way == 5 or way == 6)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    }\\n                    // left\\n                    if(k == 3) {\\n                        if(curr == 3 or curr == 5 or curr == 1) {\\n                            if(way == 4 or way == 6 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    } \\n                }   \\n                // if (0, 0) and (n - 1, m - 1) are connected too return true\\n                if(find(0) == find(n * m - 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100000];\\n    int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    bool union_(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y) return true;\\n        parent[y] = x;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        for(int i = 0; i < 100000; i++)\\n            parent[i] = i;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                \\n                int x = i, y = j;\\n                for(int k = 0; k < 4; k++) {\\n                    int nx =  x + dx[k];\\n                    int ny = y + dy[k];\\n                    \\n                    \\n                    if(nx < 0 or nx >= n or ny < 0 or ny >= m)\\n                        continue;\\n                    int way = g[nx][ny];\\n                    int curr = g[x][y];\\n                    \\n                    // top\\n                    if(k == 0) {\\n                        if(curr == 5 or curr == 6 or curr == 2) {\\n                            if(way == 2 or way == 3 or way == 4)\\n                                union_(x * m + y, nx * m + ny);\\n                        }  \\n                    }\\n                    // right\\n                     if(k == 1) {\\n                         if(curr == 1 or curr == 4 or curr == 5) {\\n                            if(way == 3 or way == 5 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                     }\\n                    // down\\n                    if(k == 2) {\\n                        if(curr == 3 or curr == 4 or curr == 2) {\\n                            if(way == 2 or way == 5 or way == 6)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    }\\n                    // left\\n                    if(k == 3) {\\n                        if(curr == 3 or curr == 5 or curr == 1) {\\n                            if(way == 4 or way == 6 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    } \\n                }   \\n                // if (0, 0) and (n - 1, m - 1) are connected too return true\\n                if(find(0) == find(n * m - 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484358,
                "title": "c-bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool bfs(vector<vector<int>>& g,int r,int c,vector<vector<bool>>&vi){\\n        vector<vector<pair<int,int>>>dirr(7);\\n        dirr[1] = {{0,-1},{0,1}};\\n        dirr[2] = {{-1,0},{1,0}};\\n        dirr[3] = {{0,-1},{1,0}};\\n        dirr[4] = {{0,1},{1,0}};\\n        dirr[5] = {{0,-1},{-1,0}};\\n        dirr[6] = {{0,1},{-1,0}};\\n        queue<pair<int,int>>q;\\n        q.push({r,c});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x==g.size()-1 && y==g[0].size()-1) return true;\\n                \\n                int type=g[x][y];\\n                for (int k = 0; k < 2; k++) {\\n                    int u = x + dirr[type][k].first, v = y + dirr[type][k].second;\\n                    if (u >= 0 && u < g.size() && v >= 0 && v < g[0].size() && vi[u][v] == false) {\\n                        vi[u][v] = true;\\n                        int z=g[u][v];\\n                        int x1=u+dirr[z][0].first;\\n                        int y1=v+dirr[z][0].second;\\n                        int x2=u+dirr[z][1].first;\\n                        int y2=v+dirr[z][1].second;\\n                    \\n                        if((x==x1 && y==y1) || (x==x2 && y==y2))\\n                            q.push({u,v});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        bool valid = bfs(grid,0,0,vis);\\n        return valid;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(vector<vector<int>>& g,int r,int c,vector<vector<bool>>&vi){\\n        vector<vector<pair<int,int>>>dirr(7);\\n        dirr[1] = {{0,-1},{0,1}};\\n        dirr[2] = {{-1,0},{1,0}};\\n        dirr[3] = {{0,-1},{1,0}};\\n        dirr[4] = {{0,1},{1,0}};\\n        dirr[5] = {{0,-1},{-1,0}};\\n        dirr[6] = {{0,1},{-1,0}};\\n        queue<pair<int,int>>q;\\n        q.push({r,c});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x==g.size()-1 && y==g[0].size()-1) return true;\\n                \\n                int type=g[x][y];\\n                for (int k = 0; k < 2; k++) {\\n                    int u = x + dirr[type][k].first, v = y + dirr[type][k].second;\\n                    if (u >= 0 && u < g.size() && v >= 0 && v < g[0].size() && vi[u][v] == false) {\\n                        vi[u][v] = true;\\n                        int z=g[u][v];\\n                        int x1=u+dirr[z][0].first;\\n                        int y1=v+dirr[z][0].second;\\n                        int x2=u+dirr[z][1].first;\\n                        int y2=v+dirr[z][1].second;\\n                    \\n                        if((x==x1 && y==y1) || (x==x2 && y==y2))\\n                            q.push({u,v});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        bool valid = bfs(grid,0,0,vis);\\n        return valid;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446538,
                "title": "python-clean-dfs-easy-to-read-understand",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        visited = set()\\n        rows, cols = len(grid), len(grid[0])\\n        right = (0, 1, {1, 3, 5})\\n        left = (0, -1, {1, 4, 6})\\n        down = (1, 0, {2, 5, 6})\\n        up = (-1, 0, {2, 3, 4})\\n        \\n        directions = {\\n            1: [right, left],\\n            2: [up, down],\\n            3: [left, down],\\n            4: [right, down],\\n            5: [left, up],\\n            6: [right, up]\\n         }\\n        \\n        def traverse(i, j):\\n            if i == rows - 1 and j == cols - 1:\\n                return True\\n            visited.add((i, j))\\n            \\n            for d in directions[grid[i][j]]:\\n                i_next, j_next, valid_next_streets = i + d[0], j + d[1], d[2]\\n                valid_position = 0 <= i_next < rows and 0 <= j_next < cols\\n                if valid_position and grid[i_next][j_next] in valid_next_streets and (i_next, j_next) not in visited:\\n                    if traverse(i_next, j_next):\\n                        return True\\n            return False\\n        \\n        return traverse(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        visited = set()\\n        rows, cols = len(grid), len(grid[0])\\n        right = (0, 1, {1, 3, 5})\\n        left = (0, -1, {1, 4, 6})\\n        down = (1, 0, {2, 5, 6})\\n        up = (-1, 0, {2, 3, 4})\\n        \\n        directions = {\\n            1: [right, left],\\n            2: [up, down],\\n            3: [left, down],\\n            4: [right, down],\\n            5: [left, up],\\n            6: [right, up]\\n         }\\n        \\n        def traverse(i, j):\\n            if i == rows - 1 and j == cols - 1:\\n                return True\\n            visited.add((i, j))\\n            \\n            for d in directions[grid[i][j]]:\\n                i_next, j_next, valid_next_streets = i + d[0], j + d[1], d[2]\\n                valid_position = 0 <= i_next < rows and 0 <= j_next < cols\\n                if valid_position and grid[i_next][j_next] in valid_next_streets and (i_next, j_next) not in visited:\\n                    if traverse(i_next, j_next):\\n                        return True\\n            return False\\n        \\n        return traverse(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051452,
                "title": "python-bfs-with-link-idea-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: graph\\nh: link the cell one by one, for each type of street, there are two ends\\n    we need to consider what type of streets can be connected for each end\\n    use idx to present each end of street\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        connected = {1: {0: [1, 3, 5], 1: {1, 4, 6}}, 2: {0: [2, 3, 4], 1: [2, 5, 6]}, \\n                     3: {0: [1, 4, 6], 1: {2, 5, 6}}, 4: {0: [1, 3, 5], 1: [2, 5, 6]},\\n                     5: {0: [1, 6, 4], 1: [2, 4, 3]}, 6: {0: [2, 4, 3], 1: [3, 1, 5]}}\\n        \\n        directions = {1: [(0, 1), (0, -1)], 2: [(-1, 0), (1, 0)], 3: [(0, -1), (1, 0)],\\n                      4: [(0, 1), (1, 0)], 5: [(0, -1), (-1, 0)], 6: [(-1, 0), (0, 1)]}\\n        \\n        \\n        seen = set()\\n        deque = collections.deque([(0,0)])\\n        \\n        while deque:\\n            #print(deque)\\n            x, y = deque.popleft()\\n            seen.add((x, y))\\n            \\n            if x == m-1 and y == n-1:\\n                return True\\n            \\n            street = grid[x][y]\\n            for idx, (dx, dy) in enumerate(directions[street]):\\n                nx = x+dx\\n                ny = y+dy\\n                if 0<=nx<=m-1 and 0<=ny<=n-1 and (nx, ny) not in seen and grid[nx][ny] in connected[street][idx]:\\n                    deque.append((nx, ny))\\n                    seen.add((nx, ny))\\n        \\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: graph\\nh: link the cell one by one, for each type of street, there are two ends\\n    we need to consider what type of streets can be connected for each end\\n    use idx to present each end of street\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        connected = {1: {0: [1, 3, 5], 1: {1, 4, 6}}, 2: {0: [2, 3, 4], 1: [2, 5, 6]}, \\n                     3: {0: [1, 4, 6], 1: {2, 5, 6}}, 4: {0: [1, 3, 5], 1: [2, 5, 6]},\\n                     5: {0: [1, 6, 4], 1: [2, 4, 3]}, 6: {0: [2, 4, 3], 1: [3, 1, 5]}}\\n        \\n        directions = {1: [(0, 1), (0, -1)], 2: [(-1, 0), (1, 0)], 3: [(0, -1), (1, 0)],\\n                      4: [(0, 1), (1, 0)], 5: [(0, -1), (-1, 0)], 6: [(-1, 0), (0, 1)]}\\n        \\n        \\n        seen = set()\\n        deque = collections.deque([(0,0)])\\n        \\n        while deque:\\n            #print(deque)\\n            x, y = deque.popleft()\\n            seen.add((x, y))\\n            \\n            if x == m-1 and y == n-1:\\n                return True\\n            \\n            street = grid[x][y]\\n            for idx, (dx, dy) in enumerate(directions[street]):\\n                nx = x+dx\\n                ny = y+dy\\n                if 0<=nx<=m-1 and 0<=ny<=n-1 and (nx, ny) not in seen and grid[nx][ny] in connected[street][idx]:\\n                    deque.append((nx, ny))\\n                    seen.add((nx, ny))\\n        \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014516,
                "title": "c-dfs-simple-solution-better-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int> >& grid,vector<vector<bool> >& visited,\\n             int i,int j,int m,int n,char prev){\\n\\n        if(i>=m || i<0 || j>=n ||j<0 || visited[i][j]==true)\\n            return ;\\n        \\n        if(i==m-1 && j==n-1){\\n            if(prev==\\'U\\' && (grid[i][j]==2 || grid[i][j]==6 || grid[i][j]==5))\\n                visited[i][j]=true;\\n            else if(grid[i][j]==1 || grid[i][j]==3 || grid[i][j]==5)\\n                visited[i][j]=true;\\n            return;\\n        }\\n        \\n        visited[i][j]=true;\\n        if(prev==\\'U\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'L\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n        else if(prev==\\'B\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'R\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 && n==1)\\n            return true;\\n        vector<vector<bool> > visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        if(grid[0][0]==2)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');    \\n        else if(grid[0][0]==1)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        else if(grid[0][0]==3)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n        else if(grid[0][0]==4){\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        }\\n        else if(grid[0][0]==6)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        return visited[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int> >& grid,vector<vector<bool> >& visited,\\n             int i,int j,int m,int n,char prev){\\n\\n        if(i>=m || i<0 || j>=n ||j<0 || visited[i][j]==true)\\n            return ;\\n        \\n        if(i==m-1 && j==n-1){\\n            if(prev==\\'U\\' && (grid[i][j]==2 || grid[i][j]==6 || grid[i][j]==5))\\n                visited[i][j]=true;\\n            else if(grid[i][j]==1 || grid[i][j]==3 || grid[i][j]==5)\\n                visited[i][j]=true;\\n            return;\\n        }\\n        \\n        visited[i][j]=true;\\n        if(prev==\\'U\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'L\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n        else if(prev==\\'B\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'R\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 && n==1)\\n            return true;\\n        vector<vector<bool> > visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        if(grid[0][0]==2)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');    \\n        else if(grid[0][0]==1)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        else if(grid[0][0]==3)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n        else if(grid[0][0]==4){\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        }\\n        else if(grid[0][0]==6)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        return visited[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907971,
                "title": "c-bfs-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); //start point\\n\\t\\tvisited[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ // try visit neighbors\\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 || y<0 || x>=m || y>= n || visited[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ // check if neighbor connects to self\\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); //start point\\n\\t\\tvisited[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ // try visit neighbors\\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 || y<0 || x>=m || y>= n || visited[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ // check if neighbor connects to self\\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894395,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir = {\\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n    };\\n    vector<vector<int>>way = {\\n        {}, {1, 3}, {2, 0}, {3, 0}, {1, 0}, {3, 2}, {2, 1}\\n    };\\n    vector<vector<bool>>vis;\\n    int m, n;\\n    bool dfs(int i, int j, vector<vector<int>>& grid){\\n        if(i == m - 1 && j == n - 1) return true;\\n        vis[i][j] = true;\\n        for(int c : way[grid[i][j]]){\\n            int x = i + dir[c][0];\\n            int y = j + dir[c][1];\\n            if(x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]){\\n                for(int d : way[grid[x][y]]){\\n                    if(x + dir[d][0] == i && y + dir[d][1] == j && dfs(x, y, grid)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vis.resize(m, vector<bool>(n, false));\\n        return dfs(0, 0, grid);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>dir = {\\n        {1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 868006,
                "title": "simple-python-union-find-solution-considering-pairwise-connectivity",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.leaders = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.leaders[x] != x:\\n            self.leaders[x] = self.find(self.leaders[x])\\n        return self.leaders[x]\\n\\n    def union(self, x, y):\\n        p = self.find(x)\\n        q = self.find(y)\\n        if p == q: \\n            return False\\n        if self.ranks[p] < self.ranks[q]:\\n            self.leaders[p] = q\\n        elif self.ranks[p] > self.ranks[q]:\\n            self.leaders[q] = p\\n        else:        \\n            self.leaders[q] = p\\n            self.ranks[p] += 1\\n        return True\\n    \\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        uf = UnionFind(m * n)\\n        for x in range(m):\\n            for y in range(n):\\n                if y + 1 <= n - 1 and grid[x][y + 1] in right[grid[x][y]]:\\n                    uf.union(x * n + y, x * n + y + 1)\\n                if x + 1 <= m - 1 and grid[x + 1][y] in down[grid[x][y]]:\\n                    uf.union(x * n + y, (x + 1) * n + y)\\n        return uf.find(0) == uf.find(m * n - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.leaders = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.leaders[x] != x:\\n            self.leaders[x] = self.find(self.leaders[x])\\n        return self.leaders[x]\\n\\n    def union(self, x, y):\\n        p = self.find(x)\\n        q = self.find(y)\\n        if p == q: \\n            return False\\n        if self.ranks[p] < self.ranks[q]:\\n            self.leaders[p] = q\\n        elif self.ranks[p] > self.ranks[q]:\\n            self.leaders[q] = p\\n        else:        \\n            self.leaders[q] = p\\n            self.ranks[p] += 1\\n        return True\\n    \\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        uf = UnionFind(m * n)\\n        for x in range(m):\\n            for y in range(n):\\n                if y + 1 <= n - 1 and grid[x][y + 1] in right[grid[x][y]]:\\n                    uf.union(x * n + y, x * n + y + 1)\\n                if x + 1 <= m - 1 and grid[x + 1][y] in down[grid[x][y]]:\\n                    uf.union(x * n + y, (x + 1) * n + y)\\n        return uf.find(0) == uf.find(m * n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844887,
                "title": "faster-100-javascript-while-simple-data-structure",
                "content": "```\\nfunction hasValidPath(grid) {\\n    if (grid[0][0] === 5) return false;\\n    if (grid[grid.length-1][grid[0].length-1] === 4) return false;\\n\\n    const info = types[grid[0][0]];\\n\\n    const [input1, input2] = Object.keys(info);\\n    \\n\\t// try to go through both inputs\\n    return (\\n        isPathValid(input1, grid) ||\\n        isPathValid(input2, grid)\\n    );\\n};\\n\\nfunction isPathValid(input, grid) {\\n    const n = grid.length - 1;\\n    const m = grid[0].length - 1;\\n\\n    let i = 0;\\n    let j = 0;\\n\\n    while ((i >= 0 && i <= n) && (j >= 0 && j <= m)) {\\n\\n        const curr = grid[i][j];\\n        const currInfo = types[curr];\\n\\n        if (!currInfo[input]) {\\n            return false;\\n        }\\n\\n        if (i === n && j === m) {\\n            return true;\\n        }\\n        \\n        const currOutput = currInfo[input];\\n        input = inputFromOutput[currOutput]\\n        if (currOutput === \\'up\\') {\\n            i--;\\n        }\\n        else if (currOutput === \\'right\\') {\\n            j++;\\n        }\\n        else if (currOutput === \\'down\\') {\\n            i++;\\n        }\\n        else if (currOutput === \\'left\\') {\\n            j--;\\n        }\\n\\n        // find a loop\\n        if (i === 0 && j === 0) return false;\\n    }\\n    // overflow boandaries but didn\\'t reach a destenation\\n    return false;\\n}\\n\\nconst inputFromOutput = {\\n    left: \\'right\\',\\n    right: \\'left\\',\\n    up: \\'down\\',\\n    down: \\'up\\'\\n}\\n\\n// store types as input : output\\nconst types = {\\n    1: { left: \\'right\\', right: \\'left\\' },\\n    2: { up: \\'down\\', down: \\'up\\' },\\n    3: { left: \\'down\\', down: \\'left\\' },\\n    4: { down: \\'right\\', right: \\'down\\' },\\n    5: { up: \\'left\\', left: \\'up\\' },\\n    6: { right: \\'up\\', up: \\'right\\' }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction hasValidPath(grid) {\\n    if (grid[0][0] === 5) return false;\\n    if (grid[grid.length-1][grid[0].length-1] === 4) return false;\\n\\n    const info = types[grid[0][0]];\\n\\n    const [input1, input2] = Object.keys(info);\\n    \\n\\t// try to go through both inputs\\n    return (\\n        isPathValid(input1, grid) ||\\n        isPathValid(input2, grid)\\n    );\\n};\\n\\nfunction isPathValid(input, grid) {\\n    const n = grid.length - 1;\\n    const m = grid[0].length - 1;\\n\\n    let i = 0;\\n    let j = 0;\\n\\n    while ((i >= 0 && i <= n) && (j >= 0 && j <= m)) {\\n\\n        const curr = grid[i][j];\\n        const currInfo = types[curr];\\n\\n        if (!currInfo[input]) {\\n            return false;\\n        }\\n\\n        if (i === n && j === m) {\\n            return true;\\n        }\\n        \\n        const currOutput = currInfo[input];\\n        input = inputFromOutput[currOutput]\\n        if (currOutput === \\'up\\') {\\n            i--;\\n        }\\n        else if (currOutput === \\'right\\') {\\n            j++;\\n        }\\n        else if (currOutput === \\'down\\') {\\n            i++;\\n        }\\n        else if (currOutput === \\'left\\') {\\n            j--;\\n        }\\n\\n        // find a loop\\n        if (i === 0 && j === 0) return false;\\n    }\\n    // overflow boandaries but didn\\'t reach a destenation\\n    return false;\\n}\\n\\nconst inputFromOutput = {\\n    left: \\'right\\',\\n    right: \\'left\\',\\n    up: \\'down\\',\\n    down: \\'up\\'\\n}\\n\\n// store types as input : output\\nconst types = {\\n    1: { left: \\'right\\', right: \\'left\\' },\\n    2: { up: \\'down\\', down: \\'up\\' },\\n    3: { left: \\'down\\', down: \\'left\\' },\\n    4: { down: \\'right\\', right: \\'down\\' },\\n    5: { up: \\'left\\', left: \\'up\\' },\\n    6: { right: \\'up\\', up: \\'right\\' }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719337,
                "title": "easy-c-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        vector<vector<int>> vis(grid.size(),vector<int>(N,0));\\n        if(grid.size()==0) return false;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n                                \\n        map<int,pair<char,char>> path;\\n        map<char,pair<int,int>> next;\\n        map<char,vector<int>> check;\\n        \\n        path.insert({1,{\\'L\\',\\'R\\'}});\\n        path.insert({2,{\\'U\\',\\'D\\'}});\\n        path.insert({3,{\\'L\\',\\'D\\'}});\\n        path.insert({4,{\\'R\\',\\'D\\'}});\\n        path.insert({5,{\\'L\\',\\'U\\'}});\\n        path.insert({6,{\\'R\\',\\'U\\'}});\\n        \\n        check.insert({\\'L\\',{1,4,6}});\\n        check.insert({\\'R\\',{1,3,5}});\\n        check.insert({\\'U\\',{2,3,4}});\\n        check.insert({\\'D\\',{2,5,6}});\\n        \\n        next.insert({\\'L\\',{0,-1}});\\n        next.insert({\\'R\\',{0,1}});\\n        next.insert({\\'U\\',{-1,0}});\\n        next.insert({\\'D\\',{1,0}});\\n                                \\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            vis[r][c]=1;\\n            if(r==(grid.size()-1) && c==(grid[0].size()-1) ) return true;\\n            q.pop();\\n            int data = grid[r][c];\\n            int rr1 = r+next[path[data].first].first;\\n            int cc1 = c+next[path[data].first].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].first][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n            rr1 = r+next[path[data].second].first;\\n            cc1 = c+next[path[data].second].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].second][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        vector<vector<int>> vis(grid.size(),vector<int>(N,0));\\n        if(grid.size()==0) return false;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n                                \\n        map<int,pair<char,char>> path;\\n        map<char,pair<int,int>> next;\\n        map<char,vector<int>> check;\\n        \\n        path.insert({1,{\\'L\\',\\'R\\'}});\\n        path.insert({2,{\\'U\\',\\'D\\'}});\\n        path.insert({3,{\\'L\\',\\'D\\'}});\\n        path.insert({4,{\\'R\\',\\'D\\'}});\\n        path.insert({5,{\\'L\\',\\'U\\'}});\\n        path.insert({6,{\\'R\\',\\'U\\'}});\\n        \\n        check.insert({\\'L\\',{1,4,6}});\\n        check.insert({\\'R\\',{1,3,5}});\\n        check.insert({\\'U\\',{2,3,4}});\\n        check.insert({\\'D\\',{2,5,6}});\\n        \\n        next.insert({\\'L\\',{0,-1}});\\n        next.insert({\\'R\\',{0,1}});\\n        next.insert({\\'U\\',{-1,0}});\\n        next.insert({\\'D\\',{1,0}});\\n                                \\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            vis[r][c]=1;\\n            if(r==(grid.size()-1) && c==(grid[0].size()-1) ) return true;\\n            q.pop();\\n            int data = grid[r][c];\\n            int rr1 = r+next[path[data].first].first;\\n            int cc1 = c+next[path[data].first].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].first][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n            rr1 = r+next[path[data].second].first;\\n            cc1 = c+next[path[data].second].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].second][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635713,
                "title": "python3-dfs-solution-check-if-there-is-a-valid-path-in-a-grid",
                "content": "This is just a variation of a conventional dfs problem. I did the following modifications:\\n*  `directions` contains the delta of coordinates when moving up, right, down, left (in clockwise order).\\n*  `streetDirections` maps street type to the directions (index of the directions list) that we can go from that type of street.\\n*  Mark street visited by negating the street type. At the end, if last street type is negative, then there is a valid path.\\n*  The `dfs` function takes an extra argument which is the outgoing direction. Inside `dfs`, this direction is turned into the opposite direction and check whether the current type can accept traffic from that direction. For example, if parent type is 2 and it goes down (direction 2), we need to check if the current type can accept traffic from up (direction 0, i.e. (2+2) % 4). \\n*  Start at 0, 0 with direction both 0 and 3. If the start street can\\'t accept from any of these directions, it would return immediately.\\n```\\nclass Solution:\\n    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n    streetDirections = {\\n       1: [1, 3],\\n       2: [0, 2],\\n       3: [2, 3],\\n       4: [1, 2],\\n       5: [0, 3],\\n       6: [0, 1]\\n    }\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(i: int, j: int, oppositeDirection: int) -> None:\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:\\n                return\\n            v = grid[i][j]\\n            sd = Solution.streetDirections[v]\\n            direction = (oppositeDirection + 2) % 4\\n            if direction not in sd:\\n                return\\n            grid[i][j] = -v\\n            for d in sd:\\n                delta = Solution.directions[d]\\n                dfs(i+delta[0], j+delta[1], d)\\n        dfs(0, 0, 0)\\n        dfs(0, 0, 3)\\n        return grid[m-1][n-1] < 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n    streetDirections = {\\n       1: [1, 3],\\n       2: [0, 2],\\n       3: [2, 3],\\n       4: [1, 2],\\n       5: [0, 3],\\n       6: [0, 1]\\n    }\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(i: int, j: int, oppositeDirection: int) -> None:\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:\\n                return\\n            v = grid[i][j]\\n            sd = Solution.streetDirections[v]\\n            direction = (oppositeDirection + 2) % 4\\n            if direction not in sd:\\n                return\\n            grid[i][j] = -v\\n            for d in sd:\\n                delta = Solution.directions[d]\\n                dfs(i+delta[0], j+delta[1], d)\\n        dfs(0, 0, 0)\\n        dfs(0, 0, 3)\\n        return grid[m-1][n-1] < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561344,
                "title": "clean-very-easy-to-understand-java-dfs",
                "content": "```\\nclass Solution {\\n    Valid roads[];\\n    boolean visited[][];\\n\\n    class Valid{\\n        List<Integer> left, right, top, down;\\n\\n        public Valid(){\\n            left = right = top = down = new ArrayList<>();\\n        }        \\n    }\\n    \\n    public boolean isValid(int i, int j, int m, int n){\\n        if(i < 0 || j < 0 || i > m-1 || j > n-1 || visited[i][j]) return false;\\n        return true; \\n    }\\n    \\n    public boolean dfs(int[][] grid, int i, int j){\\n        int m = grid.length, n = grid[0].length, curr = grid[i][j];\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        visited[i][j] = true; \\n                    \\n        if (isValid(i-1, j, m, n) && roads[curr].top.contains(grid[i-1][j]) && dfs(grid, i-1, j)) return true;\\n        if (isValid(i+1, j, m, n) && roads[curr].down.contains(grid[i+1][j]) && dfs(grid, i+1, j)) return true;\\n        if (isValid(i, j-1, m, n) && roads[curr].left.contains(grid[i][j-1]) && dfs(grid, i, j-1)) return true;\\n        if (isValid(i, j+1, m, n) && roads[curr].right.contains(grid[i][j+1]) && dfs(grid, i, j+1)) return true;\\n                \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        roads = new Valid[7];\\n \\n        for(int i = 1; i <= 6; i++) roads[i] = new Valid(); \\n            \\n        roads[1].left = roads[3].left = roads[5].left =  Arrays.asList(1, 4, 6);\\n        roads[1].right = roads[4].right = roads[6].right =  Arrays.asList(1, 3, 5);\\n        roads[2].top = roads[5].top = roads[6].top =  Arrays.asList(2, 3, 4);\\n        roads[2].down = roads[3].down = roads[4].down =  Arrays.asList(2, 5, 6);\\n        \\n        return dfs(grid, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Valid roads[];\\n    boolean visited[][];\\n\\n    class Valid{\\n        List<Integer> left, right, top, down;\\n\\n        public Valid(){\\n            left = right = top = down = new ArrayList<>();\\n        }        \\n    }\\n    \\n    public boolean isValid(int i, int j, int m, int n){\\n        if(i < 0 || j < 0 || i > m-1 || j > n-1 || visited[i][j]) return false;\\n        return true; \\n    }\\n    \\n    public boolean dfs(int[][] grid, int i, int j){\\n        int m = grid.length, n = grid[0].length, curr = grid[i][j];\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        visited[i][j] = true; \\n                    \\n        if (isValid(i-1, j, m, n) && roads[curr].top.contains(grid[i-1][j]) && dfs(grid, i-1, j)) return true;\\n        if (isValid(i+1, j, m, n) && roads[curr].down.contains(grid[i+1][j]) && dfs(grid, i+1, j)) return true;\\n        if (isValid(i, j-1, m, n) && roads[curr].left.contains(grid[i][j-1]) && dfs(grid, i, j-1)) return true;\\n        if (isValid(i, j+1, m, n) && roads[curr].right.contains(grid[i][j+1]) && dfs(grid, i, j+1)) return true;\\n                \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        roads = new Valid[7];\\n \\n        for(int i = 1; i <= 6; i++) roads[i] = new Valid(); \\n            \\n        roads[1].left = roads[3].left = roads[5].left =  Arrays.asList(1, 4, 6);\\n        roads[1].right = roads[4].right = roads[6].right =  Arrays.asList(1, 3, 5);\\n        roads[2].top = roads[5].top = roads[6].top =  Arrays.asList(2, 3, 4);\\n        roads[2].down = roads[3].down = roads[4].down =  Arrays.asList(2, 5, 6);\\n        \\n        return dfs(grid, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559775,
                "title": "java-dfs-explanation-easy-solution-using-directions-enum",
                "content": "Enums could be a great replacement to direction arrays as they are easy to use and understand.\\n\\nHere I have used the direction enum to depict left/right/up/down directions.\\n\\nIt\\'s a simple dfs solution where when you are at a current cell you do the following:\\n* make sure it\\'s within grid\\'s boundary\\n* make sure it\\'s an unvisited cell\\n* make sure whatever direction was used to enter into this cell, is actually allowed.\\n* make sure it\\'s not the destination (it it is then return true as you were able to reach cell)\\n* then, out of all the possible 4 directions proceed with all the  directions towards which you can proceed from current cell (i.e. not knowing whether the other cell will accept or not. just make sure current cell allows outgoing from current cell. incoming will be checked in the starting of function of the other cell).\\n* if none returns true, then not possible and return false.\\n\\nMain thing to note here is the doesConnect() function. It takes the type of the cell and a direction (can be outgoing direction or the incoming direction). Doesn\\'t matter.\\n\\n```\\nclass Solution {\\n    // 9 depicts visited cell\\n    public boolean hasValidPath(int[][] grid) {\\n        return travel(grid,0,0,direction.START);\\n    }\\n    private boolean travel(int[][] grid, int i, int j, direction dir){\\n        if(dir!=direction.START){\\n            // boundary and visited check\\n            if(i<0 || j<0 || i>= grid.length || j>= grid[0].length || grid[i][j] == 9) return false;\\n            // acceptance check (whether this cell allows entry from the given direction)\\n            if(!doesConnect(grid[i][j],dir)) return false;\\n        }\\n        // destination check\\n        if(i==grid.length-1 && j==grid[0].length-1) return true;\\n        // visit\\n        int type = grid[i][j];\\n        grid[i][j] = 9;\\n        \\n        // all directions out of 4, where this can send next\\n        if((doesConnect(type,direction.UP) && travel(grid,i-1,j,direction.DOWN)) ||\\n           (doesConnect(type,direction.DOWN) && travel(grid,i+1,j,direction.UP)) ||\\n           (doesConnect(type,direction.LEFT) && travel(grid,i,j-1,direction.RIGHT)) ||\\n           (doesConnect(type,direction.RIGHT) && travel(grid,i,j+1,direction.LEFT))\\n            ) return true;\\n        // unvisit\\n        grid[i][j] = type;\\n        return false;\\n    }\\n    private boolean doesConnect(int type, direction dir){\\n        if(dir==direction.UP){\\n            return type == 2 || type == 5 || type == 6;\\n        } else if(dir==direction.DOWN){\\n            return type == 2 || type == 3 || type == 4;\\n        } else if(dir==direction.LEFT){\\n            return type == 1 || type == 3 || type == 5;\\n        } else if(dir==direction.RIGHT){\\n            return type == 1 || type == 4 || type == 6;\\n        }\\n        return false;\\n    }\\n}\\n\\nenum direction {\\n    LEFT,RIGHT,UP,DOWN,START;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // 9 depicts visited cell\\n    public boolean hasValidPath(int[][] grid) {\\n        return travel(grid,0,0,direction.START);\\n    }\\n    private boolean travel(int[][] grid, int i, int j, direction dir){\\n        if(dir!=direction.START){\\n            // boundary and visited check\\n            if(i<0 || j<0 || i>= grid.length || j>= grid[0].length || grid[i][j] == 9) return false;\\n            // acceptance check (whether this cell allows entry from the given direction)\\n            if(!doesConnect(grid[i][j],dir)) return false;\\n        }\\n        // destination check\\n        if(i==grid.length-1 && j==grid[0].length-1) return true;\\n        // visit\\n        int type = grid[i][j];\\n        grid[i][j] = 9;\\n        \\n        // all directions out of 4, where this can send next\\n        if((doesConnect(type,direction.UP) && travel(grid,i-1,j,direction.DOWN)) ||\\n           (doesConnect(type,direction.DOWN) && travel(grid,i+1,j,direction.UP)) ||\\n           (doesConnect(type,direction.LEFT) && travel(grid,i,j-1,direction.RIGHT)) ||\\n           (doesConnect(type,direction.RIGHT) && travel(grid,i,j+1,direction.LEFT))\\n            ) return true;\\n        // unvisit\\n        grid[i][j] = type;\\n        return false;\\n    }\\n    private boolean doesConnect(int type, direction dir){\\n        if(dir==direction.UP){\\n            return type == 2 || type == 5 || type == 6;\\n        } else if(dir==direction.DOWN){\\n            return type == 2 || type == 3 || type == 4;\\n        } else if(dir==direction.LEFT){\\n            return type == 1 || type == 3 || type == 5;\\n        } else if(dir==direction.RIGHT){\\n            return type == 1 || type == 4 || type == 6;\\n        }\\n        return false;\\n    }\\n}\\n\\nenum direction {\\n    LEFT,RIGHT,UP,DOWN,START;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550049,
                "title": "c-dfs",
                "content": "I encoded each type of road as a 4-tuple with corresponding directions {North, East, South, West}. If road **a** connects **b** and we\\'re moving in some direction {0, 1, 2, 3} then their opposite components must be equal to 1. By opposite I mean for example North and South, Weast and East. \\n\\nI used a simple dfs-approach. Starting from the top-left cell check each unvisited neighbour road if it is connected to the current cell.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> roads = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, 1}, {0, 1, 1, 0}, {1, 0, 0, 1}, {1, 1, 0, 0}};\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n    \\n    bool connected(int a, int b, int k){\\n        return roads[a][k] && roads[b][(k + 2) % 4];\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i == grid.size() - 1 && j == grid.front().size() - 1)\\n            return true;\\n        \\n        if(!visited[i][j]){\\n            visited[i][j] = true;\\n            \\n            for(int k = 0; k < dirs.size() ++k){\\n                int di = i + dirs[k].first;\\n                int dj = j + dirs[k].second;\\n                \\n                if(di >= 0 && di < grid.size() && dj >= 0 && dj < grid.front().size() && connected(grid[i][j] - 1, grid[di][dj] - 1, k) && dfs(grid, di, dj))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        visited.resize(grid.size(), vector<bool>(grid.front().size()));\\n        return dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> roads = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, 1}, {0, 1, 1, 0}, {1, 0, 0, 1}, {1, 1, 0, 0}};\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n    \\n    bool connected(int a, int b, int k){\\n        return roads[a][k] && roads[b][(k + 2) % 4];\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i == grid.size() - 1 && j == grid.front().size() - 1)\\n            return true;\\n        \\n        if(!visited[i][j]){\\n            visited[i][j] = true;\\n            \\n            for(int k = 0; k < dirs.size() ++k){\\n                int di = i + dirs[k].first;\\n                int dj = j + dirs[k].second;\\n                \\n                if(di >= 0 && di < grid.size() && dj >= 0 && dj < grid.front().size() && connected(grid[i][j] - 1, grid[di][dj] - 1, k) && dfs(grid, di, dj))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        visited.resize(grid.size(), vector<bool>(grid.front().size()));\\n        return dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549804,
                "title": "java-graph-cutting-union-find",
                "content": "Follow the [idea](https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/547229/Python-Union-Find) and give a java veriosn:\\n\\n```java\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int t = 2*n + 1;\\n        UF uf = new UF((2*m + 1)*(2*n + 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j, t));\\n                }\\n                if (grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j + 2, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 2, 2*j + 1, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i, 2*j + 1, t));\\n                }\\n            }\\n        }\\n        return uf.isConnected(g(1, 1, t), g(2*m - 1, 2*n - 1, t));\\n    }\\n    \\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n    \\n    class UF {\\n        private int[] parents;\\n        \\n        public UF(int n) {\\n            parents = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            return node;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 != root2) {\\n                parents[root1] = root2;\\n            }\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n    }\\n}\\n```\\n\\n**explanation**\\n\\na classic 2D-array Union-Find tranform to 1D is :\\n```\\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n```\\n\\nSimilar basic 2D Union-Find problem : [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n\\nAnd I called this type of problems **Graph Cutting Union Find**\\n\\nSimilar graph cutting uf problem : [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int t = 2*n + 1;\\n        UF uf = new UF((2*m + 1)*(2*n + 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j, t));\\n                }\\n                if (grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j + 2, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 2, 2*j + 1, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i, 2*j + 1, t));\\n                }\\n            }\\n        }\\n        return uf.isConnected(g(1, 1, t), g(2*m - 1, 2*n - 1, t));\\n    }\\n    \\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n    \\n    class UF {\\n        private int[] parents;\\n        \\n        public UF(int n) {\\n            parents = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            return node;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 != root2) {\\n                parents[root1] = root2;\\n            }\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n    }\\n}\\n```\n```\\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547945,
                "title": "java-dfs-map",
                "content": "In DFS, add a map to define what are all compatible configurations for 1 to 6 along 4 directions.\\nR -> To the right\\nL -> To the left\\nU -> Upwards\\nD -> Downwards.\\n0 - is only for starting left top cell.\\nNormal DFS + checking what was the prior cell before coming to current cell using \"dir\". Checking if current grid value is compatible with previous \"dir\".\\nEnd condition is met once we reach the destination.\\nRun time 83 ms\\tSpace 258.4 MB\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        createMap(map);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, visited, 0, 0, map, \"0\");\\n    }\\n    \\n    boolean dfs(int[][] grid, boolean[][] visited, int x, int y, Map<String, List<Integer>> map, String dir) {\\n        int rows = grid.length - 1;\\n        int cols = grid[0].length - 1;\\n        if(x < 0 || x > rows || y < 0 || y > cols || visited[x][y]) {\\n            return false;\\n        }\\n        if(!map.containsKey(dir)) {\\n            return false;\\n        }\\n        if(!map.get(dir).contains(grid[x][y])) {\\n            return false;\\n        }\\n        if(x == rows && y == cols) {\\n            return true;\\n        }\\n        visited[x][y] = true;\\n        boolean result = dfs(grid, visited, x + 1, y, map, grid[x][y] + \"D\")\\n            || dfs(grid, visited, x, y + 1, map, grid[x][y] + \"R\")\\n            || dfs(grid, visited, x - 1, y , map, grid[x][y] + \"U\")\\n            || dfs(grid, visited, x, y - 1, map, grid[x][y] + \"L\");\\n        visited[x][y] = false;\\n        return result;\\n    }\\n    \\n      void createMap(Map<String, List<Integer>> map) {\\n        List<Integer> oneThreeFive = Arrays.asList(1,3,5);\\n        List<Integer> twoThreeFour = Arrays.asList(2,3,4);\\n        List<Integer> oneFourSix = Arrays.asList(1,4,6);\\n        List<Integer> twoFiveSix = Arrays.asList(2,5,6);\\n        map.put(\"0\", Arrays.asList(1,2,3,4,5,6));\\n        map.put(\"1R\", oneThreeFive);\\n        map.put(\"1L\", oneFourSix);\\n        map.put(\"2D\", twoFiveSix);\\n        map.put(\"2U\", twoThreeFour);\\n        map.put(\"3L\", oneFourSix);\\n        map.put(\"3D\", twoFiveSix);\\n        map.put(\"4R\", oneThreeFive);\\n        map.put(\"4D\", twoFiveSix);\\n        map.put(\"5L\", oneFourSix);\\n        map.put(\"5U\", twoThreeFour);\\n        map.put(\"6R\", oneThreeFive);\\n        map.put(\"6U\", twoThreeFour);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        createMap(map);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, visited, 0, 0, map, \"0\");\\n    }\\n    \\n    boolean dfs(int[][] grid, boolean[][] visited, int x, int y, Map<String, List<Integer>> map, String dir) {\\n        int rows = grid.length - 1;\\n        int cols = grid[0].length - 1;\\n        if(x < 0 || x > rows || y < 0 || y > cols || visited[x][y]) {\\n            return false;\\n        }\\n        if(!map.containsKey(dir)) {\\n            return false;\\n        }\\n        if(!map.get(dir).contains(grid[x][y])) {\\n            return false;\\n        }\\n        if(x == rows && y == cols) {\\n            return true;\\n        }\\n        visited[x][y] = true;\\n        boolean result = dfs(grid, visited, x + 1, y, map, grid[x][y] + \"D\")\\n            || dfs(grid, visited, x, y + 1, map, grid[x][y] + \"R\")\\n            || dfs(grid, visited, x - 1, y , map, grid[x][y] + \"U\")\\n            || dfs(grid, visited, x, y - 1, map, grid[x][y] + \"L\");\\n        visited[x][y] = false;\\n        return result;\\n    }\\n    \\n      void createMap(Map<String, List<Integer>> map) {\\n        List<Integer> oneThreeFive = Arrays.asList(1,3,5);\\n        List<Integer> twoThreeFour = Arrays.asList(2,3,4);\\n        List<Integer> oneFourSix = Arrays.asList(1,4,6);\\n        List<Integer> twoFiveSix = Arrays.asList(2,5,6);\\n        map.put(\"0\", Arrays.asList(1,2,3,4,5,6));\\n        map.put(\"1R\", oneThreeFive);\\n        map.put(\"1L\", oneFourSix);\\n        map.put(\"2D\", twoFiveSix);\\n        map.put(\"2U\", twoThreeFour);\\n        map.put(\"3L\", oneFourSix);\\n        map.put(\"3D\", twoFiveSix);\\n        map.put(\"4R\", oneThreeFive);\\n        map.put(\"4D\", twoFiveSix);\\n        map.put(\"5L\", oneFourSix);\\n        map.put(\"5U\", twoThreeFour);\\n        map.put(\"6R\", oneThreeFive);\\n        map.put(\"6U\", twoThreeFour);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547411,
                "title": "python3-bfs-using-states",
                "content": "`Street 1` can only move left `(0, -1)` or right `(0, 1)` and the only streets that can be connected when going left is `Street 1, 4, 6` and when doing right is `Street 1, 3, 5`.\\n`Street 2` can only move down `(1, 0)` or up `(-1, 0)` and the only streets that can be connected when going down is `Street 2, 5, 6` and when going up is `Street 2, 3, 4`.\\n`Street 3,4,5,6` with the same concept.\\n\\nThe rest is just BFS until we get to `(m-1, n-1)` if possible.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R = {(0, -1): {1, 4, 6}}, {(0, 1): {1, 3, 5}} \\n        U, D = {(-1, 0): {2, 3, 4}}, {(1, 0): {2, 5, 6}}         \\n        states = {\\n            1: {**L, **R},\\n            2: {**U, **D},\\n            3: {**L, **D},\\n            4: {**R, **D},\\n            5: {**L, **U},\\n            6: {**R, **U}\\n        }\\n        \\n        q = collections.deque([(0, 0)])\\n        visited = set()\\n        m, n = len(grid), len(grid[0])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            if (x, y) == (m-1, n-1):\\n                return True\\n            street = grid[x][y]\\n            for dx, dy in states[street]:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and  0 <= j < n and (i, j) not in visited and grid[i][j] in states[street][dx,dy]:\\n                    q.append((i, j))\\n                    visited.add((i, j))\\n        return False  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R = {(0, -1): {1, 4, 6}}, {(0, 1): {1, 3, 5}} \\n        U, D = {(-1, 0): {2, 3, 4}}, {(1, 0): {2, 5, 6}}         \\n        states = {\\n            1: {**L, **R},\\n            2: {**U, **D},\\n            3: {**L, **D},\\n            4: {**R, **D},\\n            5: {**L, **U},\\n            6: {**R, **U}\\n        }\\n        \\n        q = collections.deque([(0, 0)])\\n        visited = set()\\n        m, n = len(grid), len(grid[0])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            if (x, y) == (m-1, n-1):\\n                return True\\n            street = grid[x][y]\\n            for dx, dy in states[street]:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and  0 <= j < n and (i, j) not in visited and grid[i][j] in states[street][dx,dy]:\\n                    q.append((i, j))\\n                    visited.add((i, j))\\n        return False  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089053,
                "title": "ugly-but-running-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int row = 0;\\n        int col = 0;\\n        vis.resize(grid.size(),vector<bool>(grid[0].size(),false));\\n        return fun(grid,row,col,n,m);    \\n    }\\n    bool fun(vector<vector<int>>&grid,int row,int col,int &n,int &m)\\n    {\\n         cout<<\"row = \"<<row<<\" \"<<\"col = \"<<col<<endl;\\n         if(row == (n-1) and col == (m-1))\\n         {\\n             cout<<\"hello\"<<endl;\\n             return true;   //condition has fullfilled\\n         }\\n\\n         if(row < 0 or row >= n or col < 0 or col >= m)\\n         {\\n              return false;  //out of bound condition\\n         }\\n        \\n         int nextrow  = -1;\\n         int nextcol = -1;\\n\\n         int num = grid[row][col];\\n         if(num == 1)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 1))  //4 6 \\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 3 or grid[row][col+1] == 5  or grid[row][col+1] == 1)) // 3 5\\n             b = fun(grid,row,col+1,n,m);   //moving the right side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 2)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 3 or grid[row-1][col] == 4 or grid[row-1][col] == 2)) // 3 4\\n             a = fun(grid,row-1,col,n,m);   //moving the upper side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 5 or grid[row+1][col] == 6 or grid[row+1][col] == 2))  //5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 3)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n            \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1]==1 or grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 3))  //1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6))  //2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 4)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5 or grid[row][col+1] == 4))  //1 3 5\\n             a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6)) // 2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         if(num == 5)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 1 or grid[row][col-1] == 4 or grid[row][col-1] == 6)) // 1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col]==2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) // 2 3 4\\n             b = fun(grid,row-1,col,n,m);    //moving the upper cell\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 6)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n              vis[row][col] = true;\\n\\n              if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5)) //1 3 5\\n              a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n              if(a == true) return true;\\n\\n              if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) //2 3 4\\n              b = fun(grid,row-1,col,n,m);   //moving the upper cell\\n\\n              vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         return false;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row < 0 or row >= n or col < 0 or col >= m)\\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int row = 0;\\n        int col = 0;\\n        vis.resize(grid.size(),vector<bool>(grid[0].size(),false));\\n        return fun(grid,row,col,n,m);    \\n    }\\n    bool fun(vector<vector<int>>&grid,int row,int col,int &n,int &m)\\n    {\\n         cout<<\"row = \"<<row<<\" \"<<\"col = \"<<col<<endl;\\n         if(row == (n-1) and col == (m-1))\\n         {\\n             cout<<\"hello\"<<endl;\\n             return true;   //condition has fullfilled\\n         }\\n\\n         if(row < 0 or row >= n or col < 0 or col >= m)\\n         {\\n              return false;  //out of bound condition\\n         }\\n        \\n         int nextrow  = -1;\\n         int nextcol = -1;\\n\\n         int num = grid[row][col];\\n         if(num == 1)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 1))  //4 6 \\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 3 or grid[row][col+1] == 5  or grid[row][col+1] == 1)) // 3 5\\n             b = fun(grid,row,col+1,n,m);   //moving the right side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 2)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 3 or grid[row-1][col] == 4 or grid[row-1][col] == 2)) // 3 4\\n             a = fun(grid,row-1,col,n,m);   //moving the upper side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 5 or grid[row+1][col] == 6 or grid[row+1][col] == 2))  //5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 3)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n            \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1]==1 or grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 3))  //1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6))  //2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 4)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5 or grid[row][col+1] == 4))  //1 3 5\\n             a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6)) // 2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         if(num == 5)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 1 or grid[row][col-1] == 4 or grid[row][col-1] == 6)) // 1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col]==2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) // 2 3 4\\n             b = fun(grid,row-1,col,n,m);    //moving the upper cell\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 6)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n              vis[row][col] = true;\\n\\n              if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5)) //1 3 5\\n              a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n              if(a == true) return true;\\n\\n              if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) //2 3 4\\n              b = fun(grid,row-1,col,n,m);   //moving the upper cell\\n\\n              vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         return false;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row < 0 or row >= n or col < 0 or col >= m)\\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355051,
                "title": "c-dfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n*m)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 || j < 0 || i >= n || j >= m) return false;\\n        if(i == n-1 && j == m-1) return true; \\n        vis[i][j] = true;\\n\\n        bool reached = false;\\n        if(grid[i][j] == 1) {\\n            if(j+1 < m && !vis[i][j+1] && grid[i][j+1] != 2) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && grid[i][j-1] != 2) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 2) {\\n            if(i-1 >= 0 && !vis[i-1][j] && grid[i-1][j] != 1) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && grid[i+1][j] != 1) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 3) {\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 6 || grid[i+1][j] == 5)) {\\n                reached = solve(i+1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 4) {\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 1 || grid[i][j+1] == 3)) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        } \\n        else if(grid[i][j] == 5) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 5)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 6) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 3 || grid[i][j+1] == 1)) {\\n                reached = reached | solve(i,j+1,grid,vis);\\n            }\\n        }\\n\\n        return reached;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();       \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        return solve(0,0,grid,vis);\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 || j < 0 || i >= n || j >= m) return false;\\n        if(i == n-1 && j == m-1) return true; \\n        vis[i][j] = true;\\n\\n        bool reached = false;\\n        if(grid[i][j] == 1) {\\n            if(j+1 < m && !vis[i][j+1] && grid[i][j+1] != 2) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && grid[i][j-1] != 2) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 2) {\\n            if(i-1 >= 0 && !vis[i-1][j] && grid[i-1][j] != 1) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && grid[i+1][j] != 1) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 3) {\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 6 || grid[i+1][j] == 5)) {\\n                reached = solve(i+1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 4) {\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 1 || grid[i][j+1] == 3)) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        } \\n        else if(grid[i][j] == 5) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 5)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 6) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 3 || grid[i][j+1] == 1)) {\\n                reached = reached | solve(i,j+1,grid,vis);\\n            }\\n        }\\n\\n        return reached;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();       \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        return solve(0,0,grid,vis);\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966529,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n\\n- Space complexity:O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //if(grid[grid.size()-1][grid[0].size()-1]!=6 && grid[grid.size()-1][grid[0].size()-1]!=1){return false;}\\n        int p1=0, p2=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int>>v1(grid.size(), vector<int>(grid[0].size(), 1));\\n        queue<pair<int, int>>q;\\n        v[0][0]=1;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            int x=q.front().first, y=q.front().second;\\n            p1=x; p2=y;\\n            //cout<<x<<\" \"<<y<<endl;\\n            q.pop();\\n            //if(v==v1){break;}\\n            if(x==grid.size()-1 && y==grid[0].size()-1){return true;}\\n            if(grid[x][y]==1){\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==3 || grid[x][y+1]==5 || grid[x][y+1]==1)){\\n                    v[x][y+1]=1;\\n                    q.push({x, y+1});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    v[x][y-1]=1;\\n                    q.push({x, y-1});\\n                }\\n            }\\n            //if(grid[x][y]==2){\\n            else if(grid[x][y]==2){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==4 || grid[x-1][y]==3 || grid[x-1][y]==2)){\\n                    q.push({x-1, y});\\n                    v[x-1][y]=1;\\n                }\\n            }\\n            else if(grid[x][y]==3){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==4){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3) || grid[x][y+1]==5){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==5){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==2 || grid[x-1][y]==3 || grid[x-1][y]==4)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==1 || grid[x][y-1]==4 || grid[x][y-1]==3)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==6){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==1 || grid[x-1][y]==3 || grid[x-1][y]==5)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3 || grid[x][y+1]==5)){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                cout<<v[i][j]<<\" \";\\n            }cout<<endl;\\n        }\\n        if(p1!=grid.size()-1 && p2!=grid[0].size()-1){return false;}\\n        if(v[grid.size()-1][grid[0].size()-1]==0){return false;}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //if(grid[grid.size()-1][grid[0].size()-1]!=6 && grid[grid.size()-1][grid[0].size()-1]!=1){return false;}\\n        int p1=0, p2=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int>>v1(grid.size(), vector<int>(grid[0].size(), 1));\\n        queue<pair<int, int>>q;\\n        v[0][0]=1;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            int x=q.front().first, y=q.front().second;\\n            p1=x; p2=y;\\n            //cout<<x<<\" \"<<y<<endl;\\n            q.pop();\\n            //if(v==v1){break;}\\n            if(x==grid.size()-1 && y==grid[0].size()-1){return true;}\\n            if(grid[x][y]==1){\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==3 || grid[x][y+1]==5 || grid[x][y+1]==1)){\\n                    v[x][y+1]=1;\\n                    q.push({x, y+1});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    v[x][y-1]=1;\\n                    q.push({x, y-1});\\n                }\\n            }\\n            //if(grid[x][y]==2){\\n            else if(grid[x][y]==2){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==4 || grid[x-1][y]==3 || grid[x-1][y]==2)){\\n                    q.push({x-1, y});\\n                    v[x-1][y]=1;\\n                }\\n            }\\n            else if(grid[x][y]==3){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==4){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3) || grid[x][y+1]==5){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==5){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==2 || grid[x-1][y]==3 || grid[x-1][y]==4)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==1 || grid[x][y-1]==4 || grid[x][y-1]==3)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==6){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==1 || grid[x-1][y]==3 || grid[x-1][y]==5)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3 || grid[x][y+1]==5)){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                cout<<v[i][j]<<\" \";\\n            }cout<<endl;\\n        }\\n        if(p1!=grid.size()-1 && p2!=grid[0].size()-1){return false;}\\n        if(v[grid.size()-1][grid[0].size()-1]==0){return false;}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2876272,
                "title": "100-faster-i-don-t-think-anyone-has-done-this-yet",
                "content": "# Intuition\\nJust do as the question says.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$ *since each cell is visited at most once*\\n\\n- Space complexity:\\n$$O(N)$$ *for queue*\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        paths = {\\n            1: [\"L\",\"R\"],\\n            2: [\"U\",\"D\"],\\n            3: [\"L\",\"D\"],\\n            4: [\"R\",\"D\"],\\n            5: [\"L\",\"U\"],\\n            6: [\"R\",\"U\"]\\n        }\\n        directions = {\\n            \"R\": (0,1),\\n            \"L\": (0,-1),\\n            \"D\": (1,0),\\n            \"U\": (-1,0)\\n        }\\n        opposites = {\\n            \"R\": \"L\",\\n            \"L\": \"R\",\\n            \"U\": \"D\",\\n            \"D\": \"U\"\\n        }\\n\\n        visited = set()\\n        queue = deque()\\n        queue.append(((0,0),None))\\n\\n        while queue:\\n            cur,prev = queue.popleft()\\n            x,y = cur\\n            \\n            if x<0 or x>=m or y<0 or y>=n: continue\\n            \\n            street = grid[x][y]\\n            if prev and prev not in paths[street]: continue\\n            if x == m-1 and y == n-1: return True\\n\\n            for path in paths[street]:\\n                if path == prev: continue\\n                dx,dy = directions[path]\\n                newx,newy = x+dx,y+dy\\n                if (newx,newy) not in visited:\\n                    visited.add((newx,newy))\\n                    queue.append(((newx,newy),opposites[path]))\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        paths = {\\n            1: [\"L\",\"R\"],\\n            2: [\"U\",\"D\"],\\n            3: [\"L\",\"D\"],\\n            4: [\"R\",\"D\"],\\n            5: [\"L\",\"U\"],\\n            6: [\"R\",\"U\"]\\n        }\\n        directions = {\\n            \"R\": (0,1),\\n            \"L\": (0,-1),\\n            \"D\": (1,0),\\n            \"U\": (-1,0)\\n        }\\n        opposites = {\\n            \"R\": \"L\",\\n            \"L\": \"R\",\\n            \"U\": \"D\",\\n            \"D\": \"U\"\\n        }\\n\\n        visited = set()\\n        queue = deque()\\n        queue.append(((0,0),None))\\n\\n        while queue:\\n            cur,prev = queue.popleft()\\n            x,y = cur\\n            \\n            if x<0 or x>=m or y<0 or y>=n: continue\\n            \\n            street = grid[x][y]\\n            if prev and prev not in paths[street]: continue\\n            if x == m-1 and y == n-1: return True\\n\\n            for path in paths[street]:\\n                if path == prev: continue\\n                dx,dy = directions[path]\\n                newx,newy = x+dx,y+dy\\n                if (newx,newy) not in visited:\\n                    visited.add((newx,newy))\\n                    queue.append(((newx,newy),opposites[path]))\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665841,
                "title": "basic-bfs-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        drn = {\\n            1: [(0, -1), (0, 1)] ,\\n            2: [(-1, 0), (1, 0)] ,\\n            3: [(0, -1), (1, 0)] ,\\n            4: [(0, 1), (1, 0)] ,\\n            5: [(0, -1), (-1, 0)] ,\\n            6: [(0, 1), (-1, 0)] ,\\n        }\\n        \\n        n, m = len(grid), len(grid[0])\\n        visited = {(0, 0)}\\n        is_valid = lambda i, j:  0 <= i < n and 0 <= j < m and (new_i, new_j) not in visited\\n        \\n        queue = deque([(0, 0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == n-1 and j == m-1:\\n                    return True\\n                for i_drn, j_drn in drn[grid[i][j]]:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j) and (-i_drn, -j_drn) in drn[grid[new_i][new_j]]:  # Important BW\\n                        \\n                        visited.add((new_i, new_j))\\n                        queue.append((new_i, new_j))\\n        return False\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        drn = {\\n            1: [(0, -1), (0, 1)] ,\\n            2: [(-1, 0), (1, 0)] ,\\n            3: [(0, -1), (1, 0)] ,\\n            4: [(0, 1), (1, 0)] ,\\n            5: [(0, -1), (-1, 0)] ,\\n            6: [(0, 1), (-1, 0)] ,\\n        }\\n        \\n        n, m = len(grid), len(grid[0])\\n        visited = {(0, 0)}\\n        is_valid = lambda i, j:  0 <= i < n and 0 <= j < m and (new_i, new_j) not in visited\\n        \\n        queue = deque([(0, 0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == n-1 and j == m-1:\\n                    return True\\n                for i_drn, j_drn in drn[grid[i][j]]:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j) and (-i_drn, -j_drn) in drn[grid[new_i][new_j]]:  # Important BW\\n                        \\n                        visited.add((new_i, new_j))\\n                        queue.append((new_i, new_j))\\n        return False\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501296,
                "title": "java-best-solution-ever-dfs",
                "content": "```\\nclass Solution {\\n    \\n    // can we go up\\n    boolean isUp(int val)\\n    {\\n        return val == 2 || val == 5 || val == 6;\\n    }\\n    //can we go left\\n    boolean isLeft(int val)\\n    {\\n        return val == 1 || val == 3 || val == 5;\\n    }\\n    //can we go down\\n    boolean isDown(int val)\\n    {\\n        return val == 2 || val == 3 || val == 4;\\n    }\\n    //can we go right\\n    boolean isRight(int val)\\n    {\\n        return val == 1 || val == 4 || val == 6;\\n    }\\n    \\n    boolean isPath(int[][] grid, int x, int y, \\n                   int m, int n, char sign)\\n    {\\n        if(!(x<m && x>=0 && y<n && y>=0 && grid[x][y] != -1))\\n            return  false;\\n        \\n        if(!(x==0 && y==0))\\n        {\\n              if(sign == \\'U\\' && !isDown(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'L\\' && !isRight(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'D\\' && !isUp(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'R\\' && !isLeft(grid[x][y]))\\n                  return false;\\n        }\\n        \\n        //check if destination cell reached\\n        if(x==m-1 && y==n-1)\\n            return true;\\n        \\n        \\n        int val = grid[x][y];\\n        grid[x][y] = -1;\\n      \\n        if(isUp(val) && isPath(grid, x-1, y, m, n, \\'U\\'))\\n            return true;\\n        if(isLeft(val) && isPath(grid, x, y-1, m, n, \\'L\\'))\\n            return true;\\n        if(isDown(val) && isPath(grid, x+1, y, m, n, \\'D\\'))\\n            return true;\\n        if(isRight(val) && isPath(grid, x, y+1, m, n, \\'R\\'))\\n            return true;\\n        \\n        grid[x][y] = val;\\n        \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n           \\n        return isPath(grid, 0, 0, m, n, \\'0\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // can we go up\\n    boolean isUp(int val)\\n    {\\n        return val == 2 || val == 5 || val == 6;\\n    }\\n    //can we go left\\n    boolean isLeft(int val)\\n    {\\n        return val == 1 || val == 3 || val == 5;\\n    }\\n    //can we go down\\n    boolean isDown(int val)\\n    {\\n        return val == 2 || val == 3 || val == 4;\\n    }\\n    //can we go right\\n    boolean isRight(int val)\\n    {\\n        return val == 1 || val == 4 || val == 6;\\n    }\\n    \\n    boolean isPath(int[][] grid, int x, int y, \\n                   int m, int n, char sign)\\n    {\\n        if(!(x<m && x>=0 && y<n && y>=0 && grid[x][y] != -1))\\n            return  false;\\n        \\n        if(!(x==0 && y==0))\\n        {\\n              if(sign == \\'U\\' && !isDown(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'L\\' && !isRight(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'D\\' && !isUp(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'R\\' && !isLeft(grid[x][y]))\\n                  return false;\\n        }\\n        \\n        //check if destination cell reached\\n        if(x==m-1 && y==n-1)\\n            return true;\\n        \\n        \\n        int val = grid[x][y];\\n        grid[x][y] = -1;\\n      \\n        if(isUp(val) && isPath(grid, x-1, y, m, n, \\'U\\'))\\n            return true;\\n        if(isLeft(val) && isPath(grid, x, y-1, m, n, \\'L\\'))\\n            return true;\\n        if(isDown(val) && isPath(grid, x+1, y, m, n, \\'D\\'))\\n            return true;\\n        if(isRight(val) && isPath(grid, x, y+1, m, n, \\'R\\'))\\n            return true;\\n        \\n        grid[x][y] = val;\\n        \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n           \\n        return isPath(grid, 0, 0, m, n, \\'0\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469650,
                "title": "c-dfs",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> x{1,-1,0,0};\\n    vector<int> y{0,0,1,-1};\\n    bool isvalid(int x,int y,int m,int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n)\\n            return true;\\n        return false;\\n    }\\n    bool solve(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>> &vis,unordered_map<int,vector<vector<int>>> &mp)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        vis[i][j]=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x1=i+x[k];\\n            int y1=j+y[k];\\n            if(isvalid(x1,y1,m,n) && vis[x1][y1]==0)\\n            {\\n                int temp=grid[i][j];\\n                cout<<k;\\n                for(int l=0;l<mp[temp][k].size();l++)\\n                {\\n                    if(mp[temp][k][l]==grid[x1][y1])\\n                    {\\n                        if(solve(grid,x1,y1,m,n,vis,mp))\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        unordered_map<int,vector<vector<int>>> mp{{1,{{},{},{1,3,5},{1,4,6}}},\\n                                                  {2,{{2,5,6},{2,3,4},{},{}}},\\n                                                  {3,{{2,5,6},{},{},{1,4,6}}},\\n                                                  {4,{{2,5,6},{},{1,3,5},{}}},\\n                                                  {5,{{},{2,3,4},{},{1,4,6}}},\\n                                                  {6,{{},{2,3,4},{1,3,5},{}}}};\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        return solve(grid,0,0,m,n,vis,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> x{1,-1,0,0};\\n    vector<int> y{0,0,1,-1};\\n    bool isvalid(int x,int y,int m,int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n)\\n            return true;\\n        return false;\\n    }\\n    bool solve(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>> &vis,unordered_map<int,vector<vector<int>>> &mp)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        vis[i][j]=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x1=i+x[k];\\n            int y1=j+y[k];\\n            if(isvalid(x1,y1,m,n) && vis[x1][y1]==0)\\n            {\\n                int temp=grid[i][j];\\n                cout<<k;\\n                for(int l=0;l<mp[temp][k].size();l++)\\n                {\\n                    if(mp[temp][k][l]==grid[x1][y1])\\n                    {\\n                        if(solve(grid,x1,y1,m,n,vis,mp))\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        unordered_map<int,vector<vector<int>>> mp{{1,{{},{},{1,3,5},{1,4,6}}},\\n                                                  {2,{{2,5,6},{2,3,4},{},{}}},\\n                                                  {3,{{2,5,6},{},{},{1,4,6}}},\\n                                                  {4,{{2,5,6},{},{1,3,5},{}}},\\n                                                  {5,{{},{2,3,4},{},{1,4,6}}},\\n                                                  {6,{{},{2,3,4},{1,3,5},{}}}};\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        return solve(grid,0,0,m,n,vis,mp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455333,
                "title": "python-dfs-2-different-methods",
                "content": "#CODE1:\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n                \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            \\n            visited.add((row,col))\\n            \\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                return traverse(row,col+1,(0,1)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                return traverse(row+1,col,(1,0)) or traverse(row-1,col,(-1,0))\\n            \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                return traverse(row+1,col,(1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                return traverse(row,col+1,(0,1)) or traverse(row+1,col,(1,0))\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                return traverse(row-1,col,(-1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                return traverse(row,col+1,(0,1)) or traverse(row-1,col,(-1,0))\\n            \\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}\\n        #(0,0 for start) rest for incoming directions\\n        validPrev[1]={(0,0),(0,-1),(0,1)}\\n        validPrev[2]={(0,0),(-1,0),(1,0)}\\n        validPrev[3]={(0,0),(0,1),(-1,0)}\\n        validPrev[4]={(0,0),(0,-1),(-1,0)}\\n        validPrev[5]={(0,0),(0,1),(1,0)}\\n        validPrev[6]={(0,0),(0,-1),(1,0)}\\n        \\n        res=traverse(0,0,(0,0))\\n        return res\\n\\n#CODE2: More detailed conditions\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n            \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            visited.add((row,col))\\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                \\n                if prev==0:\\n                    prev=1\\n                    return traverse(row,col+1,prev)\\n                \\n                if prev==1:\\n                    prev=grid[row][col]\\n                    return traverse(row,col+1,prev) or traverse(row,col-1,prev)\\n                elif prev in {5,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n                else:\\n                    prev=1\\n                    return traverse(row,col+1,prev)\\n                \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                \\n                if prev==0:\\n                    prev=2\\n                    return traverse(row+1,col,prev)\\n                \\n                if prev==4 or prev==3:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                elif prev==5 or prev==6:\\n                    prev=grid[row][col]\\n                    return traverse(row-1,col,prev)\\n                else:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev) or traverse(row-1,col,prev)\\n                \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                \\n                if prev==0:\\n                    prev=3\\n                    return traverse(row+1,col,prev)\\n                \\n                if prev==1 or prev==6 or prev==4:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                else:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                if prev==0:\\n                    prev=4\\n                    return traverse(row+1,col,prev) or traverse(row,col+1,prev)\\n                \\n                if prev in {1,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                else:\\n                    prev=4\\n                    return traverse(row,col+1,prev)\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                \\n                if prev==0:\\n                    return False\\n                \\n                if prev in {2,4,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n                else:\\n                    prev=5\\n                    return traverse(row-1,col,prev)\\n                \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                \\n                if prev==0:\\n                    prev=6\\n                    return traverse(row,col+1,prev)\\n                \\n                if prev in {2,3,4}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col+1,prev)\\n                else:\\n                    prev=6\\n                    return traverse(row-1,col,prev)\\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}\\n\\t\\t#Acceptable Previous Values\\n        validPrev[1]={0,1,3,4,5,6}\\n        validPrev[2]={0,2,3,4,5,6}\\n        validPrev[3]={0,1,2,4,5,6}\\n        validPrev[4]={0,1,2,3,5,6}\\n        validPrev[5]={0,1,2,3,4,6}\\n        validPrev[6]={0,1,2,3,4,5}\\n        \\n        return traverse(0,0,0)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n                \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            \\n            visited.add((row,col))\\n            \\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                return traverse(row,col+1,(0,1)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                return traverse(row+1,col,(1,0)) or traverse(row-1,col,(-1,0))\\n            \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                return traverse(row+1,col,(1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                return traverse(row,col+1,(0,1)) or traverse(row+1,col,(1,0))\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                return traverse(row-1,col,(-1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                return traverse(row,col+1,(0,1)) or traverse(row-1,col,(-1,0))\\n            \\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}",
                "codeTag": "Java"
            },
            {
                "id": 2415633,
                "title": "python3-solution-85-faster-and-98-less-memory",
                "content": "This is my first time posting so please excuse me if I\\'ve made any errors.\\n\\nI considered the DFS solution, however with larger maps, the amount of storage becomes quite large. I also notice that the majority of solutions store a \\'visited\\' parameter, which in my view adds more storage than neccessary. \\n\\nMy approach instead just stores an m and n location that moves with the map, code below.\\n\\n```class Solution: \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        # Define the different paths in a dictionary.\\n        pathDict = {1:[1,3], 2:[2,4], 3:[1,4], 4:[3,4], 5:[1,2], 6:[2,3]}\\n        \\n        # Calculate the starting position\\n        M, N = len(grid), len(grid[0])\\n        if M == N == 1:\\n            return(True)\\n        \\n        # Loop through the starting values in the grid.\\n        for startValue in pathDict[grid[0][0]]:\\n            m = n = p = 0\\n            while True:\\n                if startValue == 1:\\n                    n -= 1\\n                    p = 3\\n                elif startValue == 2:\\n                    m -= 1\\n                    p = 4\\n                elif startValue == 3:\\n                    n += 1\\n                    p = 1\\n                elif startValue == 4:\\n                    m += 1\\n                    p = 2\\n                \\n                # Check whether we are outside of the map or append the map.\\n                if m < 0 or n < 0 or m == M or n==N:\\n                        break\\n                elif p in pathDict[grid[m][n]]:\\n                    startValue = (set(pathDict[grid[m][n]]) - set([p])).pop()\\n                else:\\n                    break\\n\\n                # Stopping condition.\\n                if (m,n) == (0,0):\\n                    return(False)\\n                elif m == M-1 and n == N-1:\\n                    return(True)\\n                \\n        return(False)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution: \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        # Define the different paths in a dictionary.\\n        pathDict = {1:[1,3], 2:[2,4], 3:[1,4], 4:[3,4], 5:[1,2], 6:[2,3]}",
                "codeTag": "Java"
            },
            {
                "id": 2382575,
                "title": "javascript",
                "content": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  if (grid[0][0] === 5 || grid[m - 1][n - 1] === 4) return false;\\n\\n  let street = {\\n    1: [\"l\", \"r\"],\\n    2: [\"u\", \"d\"],\\n    3: [\"d\", \"l\"],\\n    4: [\"d\", \"r\"],\\n    5: [\"u\", \"l\"],\\n    6: [\"u\", \"r\"],\\n  };\\n\\n  let dirs = {\\n    l: [0, -1, \"r\"],\\n    r: [0, 1, \"l\"],\\n    u: [-1, 0, \"d\"],\\n    d: [1, 0, \"u\"],\\n  };\\n\\n  let visited = {};\\n  let queue = [];\\n  queue.push([0, 0]);\\n\\n  while (queue.length > 0) {\\n    let [i, j] = queue.shift();\\n    if (i === m - 1 && j === n - 1) return true;\\n    for (let k = 0; k < street[grid[i][j]].length; k++) {\\n      let dir = street[grid[i][j]][k];\\n      let [di, dj, dir_from] = dirs[dir];\\n      let i1 = i + di;\\n      let j1 = j + dj;\\n\\n      if (i1 < 0 || j1 < 0 || i1 >= m || j1 >= n) continue;\\n      if (street[grid[i1][j1]].includes(dir_from)) {\\n        let key = `${i1},${j1}`;\\n        if (visited[key] !== undefined) continue;\\n        visited[key] = true;\\n        queue.push([i1, j1]);\\n      }\\n    }\\n  }\\n  return false;\\n};",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  if (grid[0][0] === 5 || grid[m - 1][n - 1] === 4) return false;\\n\\n  let street = {\\n    1: [\"l\", \"r\"],\\n    2: [\"u\", \"d\"],\\n    3: [\"d\", \"l\"],\\n    4: [\"d\", \"r\"],\\n    5: [\"u\", \"l\"],\\n    6: [\"u\", \"r\"],\\n  };\\n\\n  let dirs = {\\n    l: [0, -1, \"r\"],\\n    r: [0, 1, \"l\"],\\n    u: [-1, 0, \"d\"],\\n    d: [1, 0, \"u\"],\\n  };\\n\\n  let visited = {};\\n  let queue = [];\\n  queue.push([0, 0]);\\n\\n  while (queue.length > 0) {\\n    let [i, j] = queue.shift();\\n    if (i === m - 1 && j === n - 1) return true;\\n    for (let k = 0; k < street[grid[i][j]].length; k++) {\\n      let dir = street[grid[i][j]][k];\\n      let [di, dj, dir_from] = dirs[dir];\\n      let i1 = i + di;\\n      let j1 = j + dj;\\n\\n      if (i1 < 0 || j1 < 0 || i1 >= m || j1 >= n) continue;\\n      if (street[grid[i1][j1]].includes(dir_from)) {\\n        let key = `${i1},${j1}`;\\n        if (visited[key] !== undefined) continue;\\n        visited[key] = true;\\n        queue.push([i1, j1]);\\n      }\\n    }\\n  }\\n  return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2300502,
                "title": "simple-dfs-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]==true)\\n            return false;\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        visited[i][j]=true;\\n        bool a=false,b=false,c=false,d=false,e=false,f=false,g=false,h=false,o=false,p=false,k=false,l=false;\\n        if(grid[i][j]==1){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                a=helper(grid,i,j-1,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                b=helper(grid,i,j+1,m,n,visited);\\n        }\\n        if(grid[i][j]==2){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                c=helper(grid,i-1,j,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                d=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==3){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                e=helper(grid,i,j-1,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                f=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==4){\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                g=helper(grid,i,j+1,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                h=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==5){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                o=helper(grid,i-1,j,m,n,visited);\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                p=helper(grid,i,j-1,m,n,visited);\\n        }\\n        if(grid[i][j]==6){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                k=helper(grid,i-1,j,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                l=helper(grid,i,j+1,m,n,visited);\\n        }\\n        return (a || b || c || d || e || f || g || h || o || p || k || l);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        return helper(grid,0,0,m,n,visited);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool helper(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]==true)\\n            return false;\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        visited[i][j]=true;\\n        bool a=false,b=false,c=false,d=false,e=false,f=false,g=false,h=false,o=false,p=false,k=false,l=false;\\n        if(grid[i][j]==1){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                a=helper(grid,i,j-1,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                b=helper(grid,i,j+1,m,n,visited);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2290772,
                "title": "simple-c-bfs-most-intuitive-commented-full-explanation",
                "content": "Everything in code will be same as **Standard BFS**, only thing is checking of back directions will be necessary before visiting to the next cell, basically checking the connectivity of next cell with current cell.  \\n\\n----\\nFor understanding the **back direction concepts** must dry run this small test case.\\n\\n----\\n**Input :** **`[[1,1,2]]`**,  **`r = 1,  c = 3`**\\n**Output :** **`false`** \\n\\n----\\n![image](https://assets.leetcode.com/users/images/d4310f8b-d5ec-4597-bdf7-e34fd2637698_1657984436.0421526.png)![image](https://assets.leetcode.com/users/images/3b2f8241-2fd8-4e84-ad14-5d6c335326cd_1657984445.5361862.png)![image](https://assets.leetcode.com/users/images/347c159e-a1f2-41c8-b19c-e2c9ef57623f_1657984460.7235923.png)\\n\\n----\\nAs you can see, you will not be able to reach **last cell.**\\nBut you can see in middle cell there is horizontal street which allows to move in last cell.  So, there is not any connecting street from **`2nd`** cell to **`3rd`** cell. that\\'s why we will not be able to reach last cell.\\n\\n**`current cell`** : Where we are right now. \\n**`next cell`** :  Which are connected with current cell via street.\\nThis connectivity will be checked with the help of back directions from the **`next cell`** to the **`current cell`**. \\nHere in this test case,  we will check back directions from every cell.\\n\\nBut twist comes at middle cell :\\n* We have 2 direction from **`middle cell`**, one is already visited **`left cell`** and not visited one is **`right cell`**.  \\n* So, we will be visiting to right cell, and wait here.\\n* First of all check **`back direction`** or **`connectivity`**  from this **`right cell`** towards **`middle cell`**.\\n* If there is a connectivity possible between **`right`** and **`middle`** cell then we will definitely add that **`right cell`** into the queue with respect to **`current`** cell for **`future visit`**.\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 and n==1) return true;\\n        // 2D - direction vector for all streets\\n        // 0th based indexing 0 to 11\\n        \\n        // Let grid value g[i][j] = 4, means we need to follow \"street-4\" direction\\n        // First index of street-4 direction = 2*(4-1) = 6\\n        // Second index of street-4 direction = 2*(4-1)+1 = 7\\n        // dir[6] = {0, 1}\\n        // dir[7] = {1, 0}\\n        vector<vector<int>>dir = {        // Indices   \\n            {0,-1}, {0, 1}, // street 1  -->  0  1\\n            {-1,0}, {1, 0}, // street 2  -->  2  3\\n            {0,-1}, {1, 0}, // street 3  -->  4  5\\n            {0, 1}, {1, 0}, // street 4  -->  6  7\\n            {0,-1}, {-1,0}, // street 5  -->  8  9 \\n            {0, 1}, {-1,0}  // street 6  -->  10  11\\n        };\\n\\n        vector<vector<bool>>vis(m, vector<bool>(n, false));\\n        queue<pair<int,int>>q;\\n        \\n        q.push({0, 0});\\n        vis[0][0] = true;\\n        \\n        while (!q.empty()) \\n        {\\n            auto cur = q.front(); q.pop();\\n\\n            int r = cur.first;\\n            int c = cur.second;\\n            int val = grid[r][c] - 1; // grid values 1 to 6\\n            \\n            if(r==m-1 and c==n-1) return true;\\n            \\n            // 2 directions from every cell\\n            for(int k=0;k<2;k++) // k = 0, k = 1\\n            {\\n                int idx = 2*val+k;   // get index\\n                int nr = r + dir[idx][0];\\n                int nc = c + dir[idx][1];\\n                if (nr < 0 or nr >= m or nc < 0 or nc >= n or vis[nr][nc]==true) continue;\\n                \\n                //  for checking the back direction matches with current cell i.e forming path to next cell\\n                for(int x=0;x<2;x++)\\n                {\\n                    int i = 2*(grid[nr][nc]-1)+x;   // get index\\n                    if(r == nr+dir[i][0] and c == nc+dir[i][1]){\\n                        vis[nr][nc] = true;\\n                        q.push({nr, nc});\\n                    }       \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n*Thanks for Upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 and n==1) return true;\\n        // 2D - direction vector for all streets\\n        // 0th based indexing 0 to 11\\n        \\n        // Let grid value g[i][j] = 4, means we need to follow \"street-4\" direction\\n        // First index of street-4 direction = 2*(4-1) = 6\\n        // Second index of street-4 direction = 2*(4-1)+1 = 7\\n        // dir[6] = {0, 1}\\n        // dir[7] = {1, 0}\\n        vector<vector<int>>dir = {        // Indices   \\n            {0,-1}, {0, 1}, // street 1  -->  0  1\\n            {-1,0}, {1, 0}, // street 2  -->  2  3\\n            {0,-1}, {1, 0}, // street 3  -->  4  5\\n            {0, 1}, {1, 0}, // street 4  -->  6  7\\n            {0,-1}, {-1,0}, // street 5  -->  8  9 \\n            {0, 1}, {-1,0}  // street 6  -->  10  11\\n        };\\n\\n        vector<vector<bool>>vis(m, vector<bool>(n, false));\\n        queue<pair<int,int>>q;\\n        \\n        q.push({0, 0});\\n        vis[0][0] = true;\\n        \\n        while (!q.empty()) \\n        {\\n            auto cur = q.front(); q.pop();\\n\\n            int r = cur.first;\\n            int c = cur.second;\\n            int val = grid[r][c] - 1; // grid values 1 to 6\\n            \\n            if(r==m-1 and c==n-1) return true;\\n            \\n            // 2 directions from every cell\\n            for(int k=0;k<2;k++) // k = 0, k = 1\\n            {\\n                int idx = 2*val+k;   // get index\\n                int nr = r + dir[idx][0];\\n                int nc = c + dir[idx][1];\\n                if (nr < 0 or nr >= m or nc < 0 or nc >= n or vis[nr][nc]==true) continue;\\n                \\n                //  for checking the back direction matches with current cell i.e forming path to next cell\\n                for(int x=0;x<2;x++)\\n                {\\n                    int i = 2*(grid[nr][nc]-1)+x;   // get index\\n                    if(r == nr+dir[i][0] and c == nc+dir[i][1]){\\n                        vis[nr][nc] = true;\\n                        q.push({nr, nc});\\n                    }       \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068073,
                "title": "python-bfs-easy-solution-beats-90",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        move = {\\n            \"N\": (-1, 0),\\n            \"S\": (1, 0),\\n            \"E\": (0, 1),\\n            \"W\": (0, -1),\\n        }\\n        contra = {\\n            \\'N\\': \\'S\\',\\n            \\'E\\': \\'W\\',\\n            \\'S\\': \\'N\\',\\n            \\'W\\': \\'E\\',\\n        }\\n        ops = {\\n            1: [\\'W\\', \\'E\\'],\\n            2: [\\'N\\', \\'S\\'],\\n            3: [\\'W\\', \\'S\\'],\\n            4: [\\'E\\', \\'S\\'],\\n            5: [\\'N\\', \\'W\\'],\\n            6: [\\'N\\', \\'E\\'],\\n        }\\n        \\n        def isValid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        queue = deque([(0,0)])\\n        visited = {(0,0): True}\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == m-1 and j == n-1:\\n                return True\\n            d1, d2 = ops[grid[i][j]]\\n            i1, j1 = move[d1]\\n            i2, j2 = move[d2]\\n            ni1, nj1 = i+i1, j+j1\\n            ni2, nj2 = i+i2, j+j2\\n            if isValid(ni1, nj1) and (ni1, nj1) not in visited:\\n                if contra[d1] in ops[grid[ni1][nj1]]:\\n                    queue.append((ni1, nj1))\\n                    visited[(ni1, nj1)] = True\\n            if isValid(ni2, nj2) and (ni2, nj2) not in visited:\\n                if contra[d2] in ops[grid[ni2][nj2]]:\\n                    queue.append((ni2, nj2))\\n                    visited[(ni2, nj2)] = True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        move = {\\n            \"N\": (-1, 0),\\n            \"S\": (1, 0),\\n            \"E\": (0, 1),\\n            \"W\": (0, -1),\\n        }\\n        contra = {\\n            \\'N\\': \\'S\\',\\n            \\'E\\': \\'W\\',\\n            \\'S\\': \\'N\\',\\n            \\'W\\': \\'E\\',\\n        }\\n        ops = {\\n            1: [\\'W\\', \\'E\\'],\\n            2: [\\'N\\', \\'S\\'],\\n            3: [\\'W\\', \\'S\\'],\\n            4: [\\'E\\', \\'S\\'],\\n            5: [\\'N\\', \\'W\\'],\\n            6: [\\'N\\', \\'E\\'],\\n        }\\n        \\n        def isValid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        queue = deque([(0,0)])\\n        visited = {(0,0): True}\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == m-1 and j == n-1:\\n                return True\\n            d1, d2 = ops[grid[i][j]]\\n            i1, j1 = move[d1]\\n            i2, j2 = move[d2]\\n            ni1, nj1 = i+i1, j+j1\\n            ni2, nj2 = i+i2, j+j2\\n            if isValid(ni1, nj1) and (ni1, nj1) not in visited:\\n                if contra[d1] in ops[grid[ni1][nj1]]:\\n                    queue.append((ni1, nj1))\\n                    visited[(ni1, nj1)] = True\\n            if isValid(ni2, nj2) and (ni2, nj2) not in visited:\\n                if contra[d2] in ops[grid[ni2][nj2]]:\\n                    queue.append((ni2, nj2))\\n                    visited[(ni2, nj2)] = True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999368,
                "title": "java-union-find-with-comments",
                "content": "```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int left = i * m + j - 1;\\n                int right = i * m + j + 1;\\n                int up = (i - 1) * m + j;\\n                int down = (i + 1) * m + j;\\n                int u = i * m + j;\\n                if(grid[i][j] == 1){\\n                    // union left and right \\n                    // if left has right interface\\n                    // (grid[i][j + 1] == 1 || grid[i][j + 1] == 4 || grid[i][j + 1] == 6)\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // if right has left interface\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }else if(grid[i][j] == 2){\\n                    // up and down\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 3){\\n                    // left and down\\n                    // left has right\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 4){\\n                    // right and down\\n                    // right has left\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 &&  (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 5){\\n                    // up and left\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    \\n                    // left has righ\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                }else if(grid[i][j] == 6){\\n                    // up and right\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // right has left\\n                    if(j < m - 1 &&  grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return uf.isConnected(0, n * m - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int left = i * m + j - 1;\\n                int right = i * m + j + 1;\\n                int up = (i - 1) * m + j;\\n                int down = (i + 1) * m + j;\\n                int u = i * m + j;\\n                if(grid[i][j] == 1){\\n                    // union left and right \\n                    // if left has right interface\\n                    // (grid[i][j + 1] == 1 || grid[i][j + 1] == 4 || grid[i][j + 1] == 6)\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // if right has left interface\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }else if(grid[i][j] == 2){\\n                    // up and down\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 3){\\n                    // left and down\\n                    // left has right\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 4){\\n                    // right and down\\n                    // right has left\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 &&  (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 5){\\n                    // up and left\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    \\n                    // left has righ\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                }else if(grid[i][j] == 6){\\n                    // up and right\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // right has left\\n                    if(j < m - 1 &&  grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return uf.isConnected(0, n * m - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958551,
                "title": "java-3-solutions-uf-or-bfs-or-simulation",
                "content": "Hi, here I am providing 3 different solutions on how one can go about solving a problem like this. \\nI think this problem is quite interesting! I drew some inspirations from other posts wrote the following 3 solutions: \\n\\n- In terms of length: BFS < Union Find < Simulation (smaller is better)\\n\\n- In terms of performance: Simulation (100% Speed) < BFS < Union Find (Path Compression + Union by Rank) #smaller is better\\n\\nHere comes BFS solution first:\\nIdea is that we can get to a point by going to that point and check if we can come back.\\n```Java\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] dirs = {\\n            {{0, 1}, {0, -1}}, // 1\\n            {{1, 0}, {-1, 0}}, // 2\\n            {{0, -1}, {1, 0}}, // 3\\n            {{0, 1}, {1, 0}},  // 4\\n            {{-1, 0}, {0, -1}},// 5\\n            {{-1, 0}, {0, 1}}  // 6\\n        };\\n        int n = grid[0].length, m = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!queue.isEmpty()){\\n            int x = queue.peek()[0];\\n            int y = queue.poll()[1];\\n            for (int[] d : dirs[grid[x][y] - 1]){\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                if (nx < 0 || ny < 0 || nx == m || ny == n || visited[nx][ny])\\n                    continue;\\n                for (int[] dd : dirs[grid[nx][ny] - 1]){\\n                    if (nx + dd[0] == x && ny + dd[1] == y){\\n                        visited[nx][ny] = true; // If we can come back, then we can add this to the queue.\\n                        queue.offer(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n```\\n\\nHere is the Union Find solution:\\nIdea is that we can upscale the grid by 2, meaning the grid becomes a matrix with (2 * row + 1, 2 * col + 1) size. \\nAnd a road cell has 9 dots: top-left, top-center, top-right, center-left, center-center, center-right, bottom-left, bottom-center, bottom-right.\\nAnd we union the pieces based on the type of road it is. \\nIn the end, we check if we can get from (1, 1) to (2 * row - 1, 2 * col - 1).\\n```Java\\n    int n, m;\\n    public boolean hasValidPath(int[][] grid) {\\n        n = grid[0].length; m = grid.length;\\n        UF uf = new UF((2 * n + 1) * (2 * m + 1));\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                int v = grid[i][j];\\n                if (v == 2 || v == 5 || v == 6){ // Connect CENTER to TOP\\n                    uf.union(id(i, j, 0, 0), id(i, j, -1, 0));\\n                }\\n                if (v == 1 || v == 4 || v == 6){ // Connect CENTER to RIGHT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, 1));\\n                }\\n                if (v == 2 || v == 3 || v == 4){ // Connect CENTER to BOTTOM\\n                    uf.union(id(i, j, 0, 0), id(i, j, 1, 0));\\n                }\\n                if (v == 1 || v == 3 || v == 5){ // Connect CENTER to LEFT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, -1));\\n                }\\n            }\\n        }\\n        return uf.find(id(0, 0, 0, 0)) == uf.find(id(m - 1, n - 1, 0, 0));\\n    }\\n\\n    private int id(int i, int j, int di, int dj){\\n        return (di + 2 * i + 1) * (2 * n + 1) + (dj + 2 * j + 1);\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n\\n        void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x == y)\\n                return;\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n            }else{\\n                parent[x] = y;\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n```\\n\\nHere comes the fastest but the lengthiest solution: Simulation. \\nIt runs **1200%** (12 times) faster than the previous Union Find solution and scored a 100% Speed, but it is kind of annoying to write it out especially during an interview.\\n\\nIdea is that since the road has a one-to-one relationship, we go in from one side and go out from the other side, we can track of its direction and simulate the whole thing.\\n```Java\\n public boolean hasValidPath(int[][] grid) {\\n        int x = 0, y = 0, n = grid[0].length, m = grid.length, v = grid[0][0];\\n        int UP = 0, DOWN = 1, RIGHT = 2, LEFT = 3;\\n        List<Integer> st = new ArrayList<>();\\n        boolean[][] valid = new boolean[7][4]; // Mark valid directions.\\n        valid[1][RIGHT] = valid[1][LEFT] = valid[2][UP] = valid[2][DOWN] = valid[3][RIGHT] = valid[3][UP] = true;\\n        valid[4][UP] = valid[4][LEFT] = valid[5][RIGHT] = valid[5][DOWN] = valid[6][LEFT] = valid[6][DOWN] = true;\\n        if (v == 1 || v == 3){ // Determine start direction. Note that 4 can start with two and 5 starts with none.\\n            st.add(RIGHT);\\n        }\\n        if (v == 2 || v == 6){\\n            st.add(DOWN);\\n        }\\n        if (v == 4){\\n            st.add(LEFT);\\n            st.add(UP);\\n        }\\n        if (n == 1 && m == 1) // Start at 5 can still be true but only if grid is 1 by 1.\\n            return true;\\n\\n        for (int d : st){ // For each direction, we try to explore the grid\\n            while(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] > 0 && valid[grid[x][y]][d]){ // This cond has to be valid\\n                if (x == m - 1 && y == n - 1)\\n                    return true; // Found the end.\\n                v = grid[x][y];\\n                if (x > 0 && y > 0){ // don\\'t mark (0, 0) as visited because 4 can start twice.\\n                    grid[x][y] = 0;\\n                }\\n                switch(v){ // HardCode the simulation part in.\\n                    case 1 -> y = d == RIGHT? ++y : --y;\\n                    case 2 -> x = d == DOWN? ++x : --x;\\n                    case 3 -> {\\n                        if (d == RIGHT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 4 -> {\\n                        if (d == LEFT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                    case 5 -> {\\n                        if (d == RIGHT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 6 -> {\\n                        if (d == LEFT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false; // Not found.\\n    }\\n```\\n\\nI think this question is quite cool.\\nPlease upvote if it helps you! Thank you.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] dirs = {\\n            {{0, 1}, {0, -1}}, // 1\\n            {{1, 0}, {-1, 0}}, // 2\\n            {{0, -1}, {1, 0}}, // 3\\n            {{0, 1}, {1, 0}},  // 4\\n            {{-1, 0}, {0, -1}},// 5\\n            {{-1, 0}, {0, 1}}  // 6\\n        };\\n        int n = grid[0].length, m = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!queue.isEmpty()){\\n            int x = queue.peek()[0];\\n            int y = queue.poll()[1];\\n            for (int[] d : dirs[grid[x][y] - 1]){\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                if (nx < 0 || ny < 0 || nx == m || ny == n || visited[nx][ny])\\n                    continue;\\n                for (int[] dd : dirs[grid[nx][ny] - 1]){\\n                    if (nx + dd[0] == x && ny + dd[1] == y){\\n                        visited[nx][ny] = true; // If we can come back, then we can add this to the queue.\\n                        queue.offer(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n```\n```Java\\n    int n, m;\\n    public boolean hasValidPath(int[][] grid) {\\n        n = grid[0].length; m = grid.length;\\n        UF uf = new UF((2 * n + 1) * (2 * m + 1));\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                int v = grid[i][j];\\n                if (v == 2 || v == 5 || v == 6){ // Connect CENTER to TOP\\n                    uf.union(id(i, j, 0, 0), id(i, j, -1, 0));\\n                }\\n                if (v == 1 || v == 4 || v == 6){ // Connect CENTER to RIGHT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, 1));\\n                }\\n                if (v == 2 || v == 3 || v == 4){ // Connect CENTER to BOTTOM\\n                    uf.union(id(i, j, 0, 0), id(i, j, 1, 0));\\n                }\\n                if (v == 1 || v == 3 || v == 5){ // Connect CENTER to LEFT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, -1));\\n                }\\n            }\\n        }\\n        return uf.find(id(0, 0, 0, 0)) == uf.find(id(m - 1, n - 1, 0, 0));\\n    }\\n\\n    private int id(int i, int j, int di, int dj){\\n        return (di + 2 * i + 1) * (2 * n + 1) + (dj + 2 * j + 1);\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n\\n        void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x == y)\\n                return;\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n            }else{\\n                parent[x] = y;\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n```\n```Java\\n public boolean hasValidPath(int[][] grid) {\\n        int x = 0, y = 0, n = grid[0].length, m = grid.length, v = grid[0][0];\\n        int UP = 0, DOWN = 1, RIGHT = 2, LEFT = 3;\\n        List<Integer> st = new ArrayList<>();\\n        boolean[][] valid = new boolean[7][4]; // Mark valid directions.\\n        valid[1][RIGHT] = valid[1][LEFT] = valid[2][UP] = valid[2][DOWN] = valid[3][RIGHT] = valid[3][UP] = true;\\n        valid[4][UP] = valid[4][LEFT] = valid[5][RIGHT] = valid[5][DOWN] = valid[6][LEFT] = valid[6][DOWN] = true;\\n        if (v == 1 || v == 3){ // Determine start direction. Note that 4 can start with two and 5 starts with none.\\n            st.add(RIGHT);\\n        }\\n        if (v == 2 || v == 6){\\n            st.add(DOWN);\\n        }\\n        if (v == 4){\\n            st.add(LEFT);\\n            st.add(UP);\\n        }\\n        if (n == 1 && m == 1) // Start at 5 can still be true but only if grid is 1 by 1.\\n            return true;\\n\\n        for (int d : st){ // For each direction, we try to explore the grid\\n            while(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] > 0 && valid[grid[x][y]][d]){ // This cond has to be valid\\n                if (x == m - 1 && y == n - 1)\\n                    return true; // Found the end.\\n                v = grid[x][y];\\n                if (x > 0 && y > 0){ // don\\'t mark (0, 0) as visited because 4 can start twice.\\n                    grid[x][y] = 0;\\n                }\\n                switch(v){ // HardCode the simulation part in.\\n                    case 1 -> y = d == RIGHT? ++y : --y;\\n                    case 2 -> x = d == DOWN? ++x : --x;\\n                    case 3 -> {\\n                        if (d == RIGHT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 4 -> {\\n                        if (d == LEFT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                    case 5 -> {\\n                        if (d == RIGHT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 6 -> {\\n                        if (d == LEFT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false; // Not found.\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886432,
                "title": "python-simple-dfs",
                "content": "\\n    def hasValidPath(self, A):\\n        dict1 = {1:[\"l\",\"r\"], 2:[\"u\",\"d\"], 3:[\"l\",\"d\"], 4:[\"r\",\"d\"], 5:[\"u\",\"l\"], 6:[\"u\",\"r\"]}\\n        \\n        seen = set()\\n        \\n        n, m = len(A), len(A[0])\\n        \\n        ans = [(0,0)]\\n        \\n        while ans:\\n            i, j = ans.pop()\\n\\t\\t\\t\\n            if (i, j) not in seen:\\n                d1, d2 = dict1[A[i][j]]\\n                \\n                for d in [d1, d2]:\\n                    if d == \"u\" and 0<=i-1<n and (i-1,j) not in seen and \"d\" in dict1[A[i-1][j]]:\\n                        ans.append((i-1,j))\\n                    elif d == \"d\" and 0<=i+1<n and (i+1,j) not in seen and \"u\" in dict1[A[i+1][j]]:\\n                        ans.append((i+1,j))\\n                    elif d == \"l\" and 0<=j-1<m and (i,j-1) not in seen and \"r\" in dict1[A[i][j-1]]:\\n                        ans.append((i,j-1))\\n                    elif d == \"r\" and 0<=j+1<m and (i,j+1) not in seen and \"l\" in dict1[A[i][j+1]]:\\n                        ans.append((i,j+1))\\n                        \\n                seen.add((i,j))\\n                \\n                if i+1 == n and j+1 == m:\\n                    return True\\n                \\n        return False",
                "solutionTags": [],
                "code": "\\n    def hasValidPath(self, A):\\n        dict1 = {1:[\"l\",\"r\"], 2:[\"u\",\"d\"], 3:[\"l\",\"d\"], 4:[\"r\",\"d\"], 5:[\"u\",\"l\"], 6:[\"u\",\"r\"]}\\n        \\n        seen = set()\\n        \\n        n, m = len(A), len(A[0])\\n        \\n        ans = [(0,0)]\\n        \\n        while ans:\\n            i, j = ans.pop()\\n\\t\\t\\t\\n            if (i, j) not in seen:\\n                d1, d2 = dict1[A[i][j]]\\n                \\n                for d in [d1, d2]:\\n                    if d == \"u\" and 0<=i-1<n and (i-1,j) not in seen and \"d\" in dict1[A[i-1][j]]:\\n                        ans.append((i-1,j))\\n                    elif d == \"d\" and 0<=i+1<n and (i+1,j) not in seen and \"u\" in dict1[A[i+1][j]]:\\n                        ans.append((i+1,j))\\n                    elif d == \"l\" and 0<=j-1<m and (i,j-1) not in seen and \"r\" in dict1[A[i][j-1]]:\\n                        ans.append((i,j-1))\\n                    elif d == \"r\" and 0<=j+1<m and (i,j+1) not in seen and \"l\" in dict1[A[i][j+1]]:\\n                        ans.append((i,j+1))\\n                        \\n                seen.add((i,j))\\n                \\n                if i+1 == n and j+1 == m:\\n                    return True\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 1731654,
                "title": "cpp-classical-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;  //visited array \\n    int m,n;\\n    \\n    bool fun(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if(i == -1 or j == -1 or i == m or j == n or vis[i][j] == true) return false;\\n        if(i == m-1 and j == n-1){\\n            return true;\\n        }\\n        //Simple classical dfs\\n        \\n        vis[i][j] = true;\\n        \\n        if(grid[i][j] == 1){\\n            \\n            if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5 ) and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n            \\n        }else if(grid[i][j] == 2){\\n            if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n             if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 3){\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n             if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 4){\\n            if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5)  and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n            if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 5){\\n              if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 6){\\n             if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n             if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5)  and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n        }\\n        return false;\\n        \\n        \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vis = vector<vector<bool>> (m,vector<bool> (n));\\n        \\n        return fun(0,0,grid);\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;  //visited array \\n    int m,n;\\n    \\n    bool fun(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if(i == -1 or j == -1 or i == m or j == n or vis[i][j] == true) return false;\\n        if(i == m-1 and j == n-1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1486702,
                "title": "python3-readable-solution-with-comments",
                "content": "```\\nclass Solution:\\n    # define direction identifiers\\n    left, right, up, down = 0, 1, 2, 3\\n    \\n    # define possible directions to move from a given street\\n    moves = {\\n        1: {left, right},\\n        2: {up,   down},\\n        3: {left, down},\\n        4: {down, right},\\n        5: {left, up},\\n        6: {up,   right}\\n    }\\n    \\n    # defind offsets x, y offsets for each direction\\n    offsets = {\\n        left:  ( 0, -1, right), # y offset, x offset, move to return to previous position\\n        right: ( 0,  1, left),\\n        up:    (-1,  0, down),\\n        down:  ( 1,  0, up)\\n    }\\n        \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return True\\n        \\n        # on the start we can possibly move only to right and down\\n        # so there are only two possible paths which can lead as to the final position\\n        for direction in [Solution.right, Solution.down]:\\n            cur_x, cur_y = 0, 0\\n            while 1:\\n                y_offset, x_offset, reverse_move = Solution.offsets[direction]\\n                cur_x += x_offset\\n                cur_y += y_offset\\n                \\n                # break if current road leads us to out of grid\\n                if not (0 <= cur_x < len(grid[0]) and 0 <= cur_y < len(grid)):\\n                    break\\n                # break if current road leads us to incompatible road\\n                if not reverse_move in Solution.moves[grid[cur_y][cur_x]]:\\n                    break\\n                \\n                # we are in the infinite loop\\n                if (cur_x, cur_y) == (0, 0):\\n                    break\\n                \\n                # define next direction\\n                direction = [i for i in Solution.moves[grid[cur_y][cur_x]] if i != reverse_move][0]\\n                if (cur_x, cur_y) == (len(grid[0]) - 1, len(grid) - 1):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # define direction identifiers\\n    left, right, up, down = 0, 1, 2, 3\\n    \\n    # define possible directions to move from a given street\\n    moves = {\\n        1: {left, right},\\n        2: {up,   down},\\n        3: {left, down},\\n        4: {down, right},\\n        5: {left, up},\\n        6: {up,   right}\\n    }\\n    \\n    # defind offsets x, y offsets for each direction\\n    offsets = {\\n        left:  ( 0, -1, right), # y offset, x offset, move to return to previous position\\n        right: ( 0,  1, left),\\n        up:    (-1,  0, down),\\n        down:  ( 1,  0, up)\\n    }\\n        \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return True\\n        \\n        # on the start we can possibly move only to right and down\\n        # so there are only two possible paths which can lead as to the final position\\n        for direction in [Solution.right, Solution.down]:\\n            cur_x, cur_y = 0, 0\\n            while 1:\\n                y_offset, x_offset, reverse_move = Solution.offsets[direction]\\n                cur_x += x_offset\\n                cur_y += y_offset\\n                \\n                # break if current road leads us to out of grid\\n                if not (0 <= cur_x < len(grid[0]) and 0 <= cur_y < len(grid)):\\n                    break\\n                # break if current road leads us to incompatible road\\n                if not reverse_move in Solution.moves[grid[cur_y][cur_x]]:\\n                    break\\n                \\n                # we are in the infinite loop\\n                if (cur_x, cur_y) == (0, 0):\\n                    break\\n                \\n                # define next direction\\n                direction = [i for i in Solution.moves[grid[cur_y][cur_x]] if i != reverse_move][0]\\n                if (cur_x, cur_y) == (len(grid[0]) - 1, len(grid) - 1):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336417,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        def connection(i,j,val):#to know which cells the current cell connects refer the diagram in question\\n            if val==1:\\n                return [[i,j-1],[i,j+1]]\\n            elif val==2:\\n                return [[i-1,j],[i+1,j]]\\n            elif val==3:\\n                return [[i,j-1],[i+1,j]]\\n            elif val==4:\\n                return [[i,j+1],[i+1,j]]\\n            elif val==5:\\n                return [[i,j-1],[i-1,j]]\\n            elif val==6:\\n                return [[i,j+1],[i-1,j]]\\n        def isValidPos(i,j):#to check if current position is valid or not\\n            nonlocal rows,cols,visited\\n            if i<0 or j<0 or i>=rows or j>=cols or visited[i][j]==True:\\n                return False\\n            return True\\n        def func(i,j,visited):\\n            nonlocal grid,rows,cols,flag\\n            if i==rows-1 and j==cols-1:#reached the bottom-right cell of the matrix\\n                flag=True\\n                return\\n            visited[i][j]=True#mark the cell as visited so it does\\'t come into account in further recursive calls\\n            curr=[i,j]\\n            con=connection(i,j,grid[i][j])#list of cells that current cell connects\\n\\n            \\'\\'\\'\\n            check whether adjacent cells can be connected through the current cell and \\n            also the adjacent cell connects to current cell so that we have a path from current\\n            cell to that adjacent cell\\n\\n            [[1,2],[2,1]]-checkout this testcase to know why we have to check for adjacent cell\\n            connections\\n            \\'\\'\\'\\n            if isValidPos(i+1,j) and [i+1,j] in con and curr in connection(i+1,j,grid[i+1][j]):\\n                func(i+1,j,visited)\\n            if isValidPos(i-1,j) and [i-1,j] in con and curr in connection(i-1,j,grid[i-1][j]):\\n                func(i-1,j,visited)\\n            if isValidPos(i,j-1) and [i,j-1] in con and curr in connection(i,j-1,grid[i][j-1]):\\n                func(i,j-1,visited)\\n            if isValidPos(i,j+1) and [i,j+1] in con and curr in connection(i,j+1,grid[i][j+1]):\\n                func(i,j+1,visited)\\n            visited[i][j]=False #backtrack\\n        flag=False\\n        rows=len(grid)\\n        cols=len(grid[0])\\n        visited=[[False for j in range(cols)] for i in range(rows)]\\n        func(0,0,visited)\\n        return flag #able to reach or not\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        def connection(i,j,val):#to know which cells the current cell connects refer the diagram in question\\n            if val==1:\\n                return [[i,j-1],[i,j+1]]\\n            elif val==2:\\n                return [[i-1,j],[i+1,j]]\\n            elif val==3:\\n                return [[i,j-1],[i+1,j]]\\n            elif val==4:\\n                return [[i,j+1],[i+1,j]]\\n            elif val==5:\\n                return [[i,j-1],[i-1,j]]\\n            elif val==6:\\n                return [[i,j+1],[i-1,j]]\\n        def isValidPos(i,j):#to check if current position is valid or not\\n            nonlocal rows,cols,visited\\n            if i<0 or j<0 or i>=rows or j>=cols or visited[i][j]==True:\\n                return False\\n            return True\\n        def func(i,j,visited):\\n            nonlocal grid,rows,cols,flag\\n            if i==rows-1 and j==cols-1:#reached the bottom-right cell of the matrix\\n                flag=True\\n                return\\n            visited[i][j]=True#mark the cell as visited so it does\\'t come into account in further recursive calls\\n            curr=[i,j]\\n            con=connection(i,j,grid[i][j])#list of cells that current cell connects\\n\\n            \\'\\'\\'\\n            check whether adjacent cells can be connected through the current cell and \\n            also the adjacent cell connects to current cell so that we have a path from current\\n            cell to that adjacent cell\\n\\n            [[1,2],[2,1]]-checkout this testcase to know why we have to check for adjacent cell\\n            connections\\n            \\'\\'\\'\\n            if isValidPos(i+1,j) and [i+1,j] in con and curr in connection(i+1,j,grid[i+1][j]):\\n                func(i+1,j,visited)\\n            if isValidPos(i-1,j) and [i-1,j] in con and curr in connection(i-1,j,grid[i-1][j]):\\n                func(i-1,j,visited)\\n            if isValidPos(i,j-1) and [i,j-1] in con and curr in connection(i,j-1,grid[i][j-1]):\\n                func(i,j-1,visited)\\n            if isValidPos(i,j+1) and [i,j+1] in con and curr in connection(i,j+1,grid[i][j+1]):\\n                func(i,j+1,visited)\\n            visited[i][j]=False #backtrack\\n        flag=False\\n        rows=len(grid)\\n        cols=len(grid[0])\\n        visited=[[False for j in range(cols)] for i in range(rows)]\\n        func(0,0,visited)\\n        return flag #able to reach or not\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279886,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool hasValidPath(vector<vector<int>>& grid) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\n\\t\\t\\tvector<vector<bool>>visited(m,vector<bool>(n,false));\\n\\n\\t\\t\\tqueue<pair<int,int>>q;\\n\\t\\t\\tq.push({0,0});\\n\\n\\t\\t\\tvector<int>dir{-1,0,1,0,-1};\\n\\t\\t\\tvisited[0][0]=true;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint len=q.size();\\n\\t\\t\\t\\twhile(len--){\\n\\t\\t\\t\\t\\tpair<int,int>cur=q.front();q.pop();\\n\\t\\t\\t\\t\\tint street=grid[cur.first][cur.second];\\n\\t\\t\\t\\t\\tfor(int i=0;i<4;++i){\\n\\t\\t\\t\\t\\t\\tint nextx=cur.first+dir[i];\\n\\t\\t\\t\\t\\t\\tint nexty=cur.second+dir[i+1];\\n\\t\\t\\t\\t\\t\\tif(nextx<0 || nexty<0 || nextx>=m || nexty>=n || visited[nextx][nexty] || !validRoad(grid[nextx][nexty],street,i))continue;                    \\n\\t\\t\\t\\t\\t\\tif(nextx==m-1 && nexty==n-1)return true;\\n\\t\\t\\t\\t\\t\\tvisited[nextx][nexty]=true;\\n\\t\\t\\t\\t\\t\\tq.push({nextx,nexty});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn visited[m-1][n-1];\\n\\t\\t}\\n\\tprivate:\\n\\t\\tbool validRoad(int next,int cur, int dir){\\n\\t\\t\\tswitch(cur){\\n\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 4:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 5:\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 6:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool hasValidPath(vector<vector<int>>& grid) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\n\\t\\t\\tvector<vector<bool>>visited(m,vector<bool>(n,false));\\n\\n\\t\\t\\tqueue<pair<int,int>>q;\\n\\t\\t\\tq.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1260644,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int> >&grid,int x,int y,vector<vector<int> >&dp)\\n    {\\n        dp[x][y]=1;\\n        if(grid[x][y]==2)\\n        {\\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==3||grid[x-1][y]==4||grid[x-1][y]==2))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n               if(dp[x+1][y]==0&&(grid[x+1][y]==5||grid[x+1][y]==6||grid[x+1][y]==2))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                } \\n            }\\n        }\\n        else if(grid[x][y]==1)\\n        {\\n         if(y>0)\\n         {\\n             if(dp[x][y-1]==0&&(grid[x][y-1]==4||grid[x][y-1]==6||grid[x][y-1]==1))\\n             {\\n                 DFS(grid,x,y-1,dp);\\n             }\\n         }\\n         if(y+1<grid[x].size())\\n         {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==3||grid[x][y+1]==5||grid[x][y+1]==1))\\n             {\\n                 DFS(grid,x,y+1,dp);\\n             }\\n         }\\n        }\\n        else if(grid[x][y]==3)\\n        {\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==6||grid[x][y-1]==4||grid[x][y-1]==1))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n            }\\n        }\\n        else if(grid[x][y]==4)\\n        {\\n            if(x+1<grid.size())\\n            {\\n                \\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n                \\n            }\\n            if(y+1<grid[x].size())\\n            {\\n                \\n                if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==5||grid[x][y+1]==3))\\n                {\\n                    DFS(grid,x,y+1,dp);\\n                }\\n                \\n            }\\n        }\\n        else if(grid[x][y]==5)\\n        {\\n            \\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==4||grid[x-1][y]==3))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==1||grid[x][y-1]==4||grid[x][y-1]==6))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            \\n        }\\n        else if(grid[x][y]==6)\\n        {\\n            \\n          if(x>0)\\n          {\\n              if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==3||grid[x-1][y]==4))\\n              {\\n                  DFS(grid,x-1,y,dp);\\n              }\\n          }\\n            if(y+1<grid[x].size())\\n             {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==3||grid[x][y+1]==5))\\n               {\\n               DFS(grid,x,y+1,dp);\\n               }\\n            }\\n        }\\n     \\n        \\n        return ;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n         \\n         vector<vector<int> >dp(301,vector<int>(301,0));\\n         DFS(grid,0,0,dp);\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int> >&grid,int x,int y,vector<vector<int> >&dp)\\n    {\\n        dp[x][y]=1;\\n        if(grid[x][y]==2)\\n        {\\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==3||grid[x-1][y]==4||grid[x-1][y]==2))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n               if(dp[x+1][y]==0&&(grid[x+1][y]==5||grid[x+1][y]==6||grid[x+1][y]==2))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                } \\n            }\\n        }\\n        else if(grid[x][y]==1)\\n        {\\n         if(y>0)\\n         {\\n             if(dp[x][y-1]==0&&(grid[x][y-1]==4||grid[x][y-1]==6||grid[x][y-1]==1))\\n             {\\n                 DFS(grid,x,y-1,dp);\\n             }\\n         }\\n         if(y+1<grid[x].size())\\n         {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==3||grid[x][y+1]==5||grid[x][y+1]==1))\\n             {\\n                 DFS(grid,x,y+1,dp);\\n             }\\n         }\\n        }\\n        else if(grid[x][y]==3)\\n        {\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==6||grid[x][y-1]==4||grid[x][y-1]==1))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n            }\\n        }\\n        else if(grid[x][y]==4)\\n        {\\n            if(x+1<grid.size())\\n            {\\n                \\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n                \\n            }\\n            if(y+1<grid[x].size())\\n            {\\n                \\n                if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==5||grid[x][y+1]==3))\\n                {\\n                    DFS(grid,x,y+1,dp);\\n                }\\n                \\n            }\\n        }\\n        else if(grid[x][y]==5)\\n        {\\n            \\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==4||grid[x-1][y]==3))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==1||grid[x][y-1]==4||grid[x][y-1]==6))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            \\n        }\\n        else if(grid[x][y]==6)\\n        {\\n            \\n          if(x>0)\\n          {\\n              if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==3||grid[x-1][y]==4))\\n              {\\n                  DFS(grid,x-1,y,dp);\\n              }\\n          }\\n            if(y+1<grid[x].size())\\n             {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==3||grid[x][y+1]==5))\\n               {\\n               DFS(grid,x,y+1,dp);\\n               }\\n            }\\n        }\\n     \\n        \\n        return ;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n         \\n         vector<vector<int> >dp(301,vector<int>(301,0));\\n         DFS(grid,0,0,dp);\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144767,
                "title": "python-3-concise-bfs-coordinate-mapping",
                "content": "```\\ndef hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n, dq, seen = len(grid), len(grid[0]), collections.deque(), set()\\n        if m == n == 1:\\n            return True\\n\\n        dirs = {1: ((0, 1), (0, -1)), 2: ((1, 0), (-1, 0)), 3: ((0, -1), (1, 0)), \\\\\\n                4: ((1, 0), (0, 1)), 5: ((0, -1), (-1, 0)), 6: ((-1, 0), (0, 1))}\\n        \\n        dq.append((0, 0, grid[0][0]))\\n        seen.add((0, 0))\\n        \\n        while dq:\\n            cx, cy, num = dq.popleft()\\n            for dx, dy in dirs[num]:\\n                if 0 <= cx + dx < m and 0 <= cy + dy < n and (cx + dx, cy + dy) not in seen:\\n                    if (-dx, -dy) in dirs[grid[cx + dx][cy + dy]]: \\n                        if cx + dx == m - 1 and cy + dy == n - 1:\\n                            return True\\n                        seen.add((cx + dx, cy + dy))\\n                        dq.append((cx + dx, cy + dy, grid[cx + dx][cy + dy]))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n, dq, seen = len(grid), len(grid[0]), collections.deque(), set()\\n        if m == n == 1:\\n            return True\\n\\n        dirs = {1: ((0, 1), (0, -1)), 2: ((1, 0), (-1, 0)), 3: ((0, -1), (1, 0)), \\\\\\n                4: ((1, 0), (0, 1)), 5: ((0, -1), (-1, 0)), 6: ((-1, 0), (0, 1))}\\n        \\n        dq.append((0, 0, grid[0][0]))\\n        seen.add((0, 0))\\n        \\n        while dq:\\n            cx, cy, num = dq.popleft()\\n            for dx, dy in dirs[num]:\\n                if 0 <= cx + dx < m and 0 <= cy + dy < n and (cx + dx, cy + dy) not in seen:\\n                    if (-dx, -dy) in dirs[grid[cx + dx][cy + dy]]: \\n                        if cx + dx == m - 1 and cy + dy == n - 1:\\n                            return True\\n                        seen.add((cx + dx, cy + dy))\\n                        dq.append((cx + dx, cy + dy, grid[cx + dx][cy + dy]))\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1118089,
                "title": "union-find-quick-union",
                "content": "I know it is slow. I just want to prove UF also works.\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][][] parent; //    int[row][col][2]\\n    public boolean hasValidPath(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0] == null) return false;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        parent = new int[row][col][2];\\n\\n        // init parent matrix\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                parent[i][j][0] = i;\\n                parent[i][j][1] = j;\\n            }\\n        }\\n\\n        boolean[][] upDown = new boolean[7][7];\\n        boolean[][] leftRight = new boolean[7][7];\\n\\n        upDown[2][2] = upDown[2][5] = upDown[2][6] = true;\\n        upDown[3][2] = upDown[3][5] = upDown[3][6] = true;\\n        upDown[4][2] = upDown[4][5] = upDown[4][6] = true;\\n\\n        leftRight[1][1] = leftRight[1][3] = leftRight[1][5] = true;\\n        leftRight[4][1] = leftRight[4][3] = leftRight[4][5] = true;\\n        leftRight[6][1] = leftRight[6][3] = leftRight[6][5] = true;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // connect current node and down node if possible\\n                if(i < row - 1) {\\n                    if(upDown[grid[i][j]][grid[i + 1][j]]){\\n                        union(i, j , i+1, j);\\n                    }\\n                }\\n                // connect current node and right node if possible\\n                if(j < col - 1){\\n                    if(leftRight[grid[i][j]][grid[i][j+1]]){\\n                        union(i, j , i, j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return find(0, 0, row-1, col-1);\\n    }\\n\\n    private int[] root(int x, int y) {\\n        int[] t;\\n        while (x != parent[x][y][0] || y != parent[x][y][1])  {\\n           t = parent[x][y];\\n           x = t[0];\\n           y = t[1];\\n        }\\n        return new int[]{x, y};\\n    }\\n\\n    public boolean find(int ax, int ay, int bx, int by) {\\n        int[] a1 = root(ax, ay);\\n        int[] b1 = root(bx, by);\\n        return a1[0] == b1[0] && a1[1] == b1[1];\\n    }\\n\\n    // Quick Union (faster for this problem)\\n    public void union(int ax, int ay, int bx, int by) {\\n        System.out.println(\"Union(\" +ax  +\", \"+ ay +\"), and (\"+ bx  +\", \"+  by + \")\");\\n        int[] i = root(ax, ay);\\n        int[] j = root(bx, by);\\n        parent[i[0]][i[1]][0] = j[0];\\n        parent[i[0]][i[1]][1] = j[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][][] parent; //    int[row][col][2]\\n    public boolean hasValidPath(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0] == null) return false;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        parent = new int[row][col][2];\\n\\n        // init parent matrix\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                parent[i][j][0] = i;\\n                parent[i][j][1] = j;\\n            }\\n        }\\n\\n        boolean[][] upDown = new boolean[7][7];\\n        boolean[][] leftRight = new boolean[7][7];\\n\\n        upDown[2][2] = upDown[2][5] = upDown[2][6] = true;\\n        upDown[3][2] = upDown[3][5] = upDown[3][6] = true;\\n        upDown[4][2] = upDown[4][5] = upDown[4][6] = true;\\n\\n        leftRight[1][1] = leftRight[1][3] = leftRight[1][5] = true;\\n        leftRight[4][1] = leftRight[4][3] = leftRight[4][5] = true;\\n        leftRight[6][1] = leftRight[6][3] = leftRight[6][5] = true;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // connect current node and down node if possible\\n                if(i < row - 1) {\\n                    if(upDown[grid[i][j]][grid[i + 1][j]]){\\n                        union(i, j , i+1, j);\\n                    }\\n                }\\n                // connect current node and right node if possible\\n                if(j < col - 1){\\n                    if(leftRight[grid[i][j]][grid[i][j+1]]){\\n                        union(i, j , i, j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return find(0, 0, row-1, col-1);\\n    }\\n\\n    private int[] root(int x, int y) {\\n        int[] t;\\n        while (x != parent[x][y][0] || y != parent[x][y][1])  {\\n           t = parent[x][y];\\n           x = t[0];\\n           y = t[1];\\n        }\\n        return new int[]{x, y};\\n    }\\n\\n    public boolean find(int ax, int ay, int bx, int by) {\\n        int[] a1 = root(ax, ay);\\n        int[] b1 = root(bx, by);\\n        return a1[0] == b1[0] && a1[1] == b1[1];\\n    }\\n\\n    // Quick Union (faster for this problem)\\n    public void union(int ax, int ay, int bx, int by) {\\n        System.out.println(\"Union(\" +ax  +\", \"+ ay +\"), and (\"+ bx  +\", \"+  by + \")\");\\n        int[] i = root(ax, ay);\\n        int[] j = root(bx, by);\\n        parent[i[0]][i[1]][0] = j[0];\\n        parent[i[0]][i[1]][1] = j[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105244,
                "title": "python3-dfs-with-backtracking-clean-code",
                "content": "The question is a bit tricky, considering the special case:\\n[[4,1,3], [6,1,2]], where basically you have two choices starting from position (0,0). \\n\\nIf we would know the starting direction, we wouldn\\'t even need backtracking - a single while loop should work.\\n\\nSince there are no other choices, we need to try both possibilities - that is the real reason to keep DFS + backtracking.\\n\\n```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        table = {1: [(0,1),(0,-1)],\\n                2: [(1,0),(-1,0)],\\n                3: [(1,0), (0,-1)],\\n                4: [(1,0), (0,1)],\\n                5: [(-1,0), (0,-1)],\\n                6: [(-1,0), (0,1)]}\\n        \\n        i = j = 0\\n        m, n = len(grid), len(grid[0])\\n\\n        def dfs(i, j):\\n            if i==m-1 and j==n-1:\\n                return True\\n            found = False\\n            for (dx,dy) in table[grid[i][j]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and \\\\\\n                    grid[x][y] != 0 and (-dx, -dy) in table[grid[x][y]]:\\n                        grid[i][j], t = 0, grid[i][j]\\n                        found = found or dfs(x, y)\\n                        grid[i][j] = t\\n            return found\\n\\n        return dfs(0, 0)\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        table = {1: [(0,1),(0,-1)],\\n                2: [(1,0),(-1,0)],\\n                3: [(1,0), (0,-1)],\\n                4: [(1,0), (0,1)],\\n                5: [(-1,0), (0,-1)],\\n                6: [(-1,0), (0,1)]}\\n        \\n        i = j = 0\\n        m, n = len(grid), len(grid[0])\\n\\n        def dfs(i, j):\\n            if i==m-1 and j==n-1:\\n                return True\\n            found = False\\n            for (dx,dy) in table[grid[i][j]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and \\\\\\n                    grid[x][y] != 0 and (-dx, -dy) in table[grid[x][y]]:\\n                        grid[i][j], t = 0, grid[i][j]\\n                        found = found or dfs(x, y)\\n                        grid[i][j] = t\\n            return found\\n\\n        return dfs(0, 0)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 948271,
                "title": "java-both-bfs-and-dfs-solutions-with-easy-explanation",
                "content": "Create an hashmap of paths\\n0,-1 left cell\\n0,1 right cell\\n-1,0 upper cell\\n1,0 lowe cell\\n\\nentries in hash map \\n1 -> { {0,-1},{0,1} } \\nindicates path 1 from left cell and right cell\\nand so on..\\n\\nthe idea is to start from 0,0 cell and go to next cells from the combination\\nif we are at 2,2 and the value is 1 we can either go left (2,1) or right (2,3)\\n\\nwe also have to check that the next cell that we will go to is also a valid cell (with in the grid) and is not visited before\\nwe can keep a visited boolean 2d array to keep check of visited cell\\n\\nwe also have to check the back link i.e the node we are going to next also links back to current back only then the next the next node is worth exploring.\\nin the exampe grid = [[1,2,1],[1,2,1]] we can go from grid[0][0] to grid[0][1] but from grid[0,1] we cannot get back to grid[0][0] thus this is not a complete path.\\n\\nif we find a path that can lead to grid[m-1][n-1] then we return true\\nwe can use either **bfs** or **dfs** to explore the grid. both will have same time complexity O(mn)\\n    \\n\\n\\n\\n```\\nclass Solution {\\n    \\n    HashMap<Integer, int[][]> dirs;\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dirs = new HashMap<>();\\n        dirs.put(1, new int[][]{ {0,-1},{0,1} });\\n        dirs.put(2, new int[][]{ {-1,0},{1,0} });\\n        dirs.put(3, new int[][]{ {0,-1},{1,0} });\\n        dirs.put(4, new int[][]{ {0,1},{1,0} });\\n        dirs.put(5, new int[][]{ {0,-1},{-1,0} });\\n        dirs.put(6, new int[][]{ {0,1},{-1,0} });\\n\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        // return bfs(grid, 0, 0, rows-1, cols-1,  visited);\\n        return dfs(grid, 0, 0, rows-1, cols-1,  visited);\\n    }\\n    \\n    \\n    public boolean bfs(int[][] grid, int startR, int startC, int rows, int cols, boolean[][] visited){\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{startR,startC});\\n\\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int currR = curr[0];\\n            int currC = curr[1];\\n            \\n            visited[currR][currC] = true;\\n            \\n            int path = grid[currR][currC];\\n            \\n            for(int[] dir : dirs.get(path)){\\n                \\n                int nextR = currR+dir[0];\\n                int nextC = currC+dir[1];\\n\\n                if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                    continue;          \\n                \\n                int nextPath = grid[nextR][nextC];\\n                for(int[] backDir : dirs.get(nextPath)){\\n                    int backR = nextR + backDir[0];\\n                    int backC = nextC + backDir[1];\\n                    if(backR == currR && backC == currC){\\n                        q.add(new int[]{nextR, nextC});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        //bfs checks in the end whether we have visited the final position \\n        return visited[rows][cols];\\n    }\\n    \\n    \\n    \\n    public boolean dfs(int[][] grid, int r, int c, int rows, int cols, boolean[][] visited){\\n        //when we have reached end return true;\\n        if(r == rows && c == cols)\\n            return true;\\n        \\n        int path = grid[r][c];\\n        \\n        for(int[] dir : dirs.get(path)){\\n            int nextR = r+dir[0];\\n            int nextC = c+dir[1];\\n            \\n            if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                continue;\\n            \\n            int nextPath = grid[nextR][nextC];\\n            for(int[] backDir : dirs.get(nextPath)){\\n                int backR = nextR + backDir[0];\\n                int backC = nextC + backDir[1];\\n                if(backR == r && backC == c){\\n                    visited[nextR][nextC] = true;\\n                    //return true if there is a path to end from next cell\\n                    if(dfs(grid, nextR, nextC, rows, cols, visited))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        // return false if we haven\\'t reached end\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<Integer, int[][]> dirs;\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dirs = new HashMap<>();\\n        dirs.put(1, new int[][]{ {0,-1},{0,1} });\\n        dirs.put(2, new int[][]{ {-1,0},{1,0} });\\n        dirs.put(3, new int[][]{ {0,-1},{1,0} });\\n        dirs.put(4, new int[][]{ {0,1},{1,0} });\\n        dirs.put(5, new int[][]{ {0,-1},{-1,0} });\\n        dirs.put(6, new int[][]{ {0,1},{-1,0} });\\n\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        // return bfs(grid, 0, 0, rows-1, cols-1,  visited);\\n        return dfs(grid, 0, 0, rows-1, cols-1,  visited);\\n    }\\n    \\n    \\n    public boolean bfs(int[][] grid, int startR, int startC, int rows, int cols, boolean[][] visited){\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{startR,startC});\\n\\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int currR = curr[0];\\n            int currC = curr[1];\\n            \\n            visited[currR][currC] = true;\\n            \\n            int path = grid[currR][currC];\\n            \\n            for(int[] dir : dirs.get(path)){\\n                \\n                int nextR = currR+dir[0];\\n                int nextC = currC+dir[1];\\n\\n                if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                    continue;          \\n                \\n                int nextPath = grid[nextR][nextC];\\n                for(int[] backDir : dirs.get(nextPath)){\\n                    int backR = nextR + backDir[0];\\n                    int backC = nextC + backDir[1];\\n                    if(backR == currR && backC == currC){\\n                        q.add(new int[]{nextR, nextC});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        //bfs checks in the end whether we have visited the final position \\n        return visited[rows][cols];\\n    }\\n    \\n    \\n    \\n    public boolean dfs(int[][] grid, int r, int c, int rows, int cols, boolean[][] visited){\\n        //when we have reached end return true;\\n        if(r == rows && c == cols)\\n            return true;\\n        \\n        int path = grid[r][c];\\n        \\n        for(int[] dir : dirs.get(path)){\\n            int nextR = r+dir[0];\\n            int nextC = c+dir[1];\\n            \\n            if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                continue;\\n            \\n            int nextPath = grid[nextR][nextC];\\n            for(int[] backDir : dirs.get(nextPath)){\\n                int backR = nextR + backDir[0];\\n                int backC = nextC + backDir[1];\\n                if(backR == r && backC == c){\\n                    visited[nextR][nextC] = true;\\n                    //return true if there is a path to end from next cell\\n                    if(dfs(grid, nextR, nextC, rows, cols, visited))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        // return false if we haven\\'t reached end\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859394,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    int [][][] DIR = new int[][][] {\\n        {{0, -1}, {0, 1}},\\n        {{-1, 0}, {1, 0}},\\n        {{0, -1}, {1, 0}},\\n        {{0, 1}, {1, 0}},\\n        {{0, -1}, {-1, 0}},\\n        {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean [][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    public boolean dfs(int [][] grid, int m, int n, int row, int col, boolean [][] visited) {\\n        if (row == m-1 && col == n-1)\\n            return true;\\n        visited[row][col] = true;\\n        for (int [] nextDirection: DIR[grid[row][col]-1]) { // the next possible move\\n            int nextRow = row + nextDirection[0];\\n            int nextCol = col + nextDirection[1];\\n            if (nextRow<0 || nextCol<0 || nextRow>=m || nextCol>=n || visited[nextRow][nextCol])\\n                continue;\\n            for (int [] backDirection: DIR[grid[nextRow][nextCol]-1]) {  // now check whether we can go back from current position\\n                int backRow = nextRow + backDirection[0];\\n                int backCol = nextCol + backDirection[1];\\n                if (backRow == row && backCol == col)\\n                    if (dfs(grid, m, n, nextRow, nextCol, visited))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int [][][] DIR = new int[][][] {\\n        {{0, -1}, {0, 1}},\\n        {{-1, 0}, {1, 0}},\\n        {{0, -1}, {1, 0}},\\n        {{0, 1}, {1, 0}},\\n        {{0, -1}, {-1, 0}},\\n        {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean [][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    public boolean dfs(int [][] grid, int m, int n, int row, int col, boolean [][] visited) {\\n        if (row == m-1 && col == n-1)\\n            return true;\\n        visited[row][col] = true;\\n        for (int [] nextDirection: DIR[grid[row][col]-1]) { // the next possible move\\n            int nextRow = row + nextDirection[0];\\n            int nextCol = col + nextDirection[1];\\n            if (nextRow<0 || nextCol<0 || nextRow>=m || nextCol>=n || visited[nextRow][nextCol])\\n                continue;\\n            for (int [] backDirection: DIR[grid[nextRow][nextCol]-1]) {  // now check whether we can go back from current position\\n                int backRow = nextRow + backDirection[0];\\n                int backCol = nextCol + backDirection[1];\\n                if (backRow == row && backCol == col)\\n                    if (dfs(grid, m, n, nextRow, nextCol, visited))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824184,
                "title": "simple-bfs-works",
                "content": "```\\nclass Solution {\\n    \\n    int[] x = {-1,1,0,0};//up,down,left,right\\n    int[] y = {0,0,-1,1};\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        boolean[][] v = new boolean[grid.length][grid[0].length];\\n        Queue<State> q = new LinkedList<>();\\n        \\n        q.offer(new State(0,0));\\n        v[0][0] = true;\\n        \\n        while(!q.isEmpty()) {\\n            State s = q.poll();\\n            if(s.r == grid.length-1 && s.c == grid[0].length-1)  return true;\\n          \\n            for(int d=0;d<4;d++) {\\n                if(canMove(v,grid,s.r,s.c,d)) {\\n                    int r = s.r+x[d];\\n                    int c = s.c+y[d];\\n                    q.offer(new State(r,c));\\n                    v[r][c] = true;\\n                }\\n            }\\n                                            \\n        }\\n        return false;\\n    }\\n\\n\\n    boolean canMove(boolean[][] v,int[][] grid,int ri,int ci,int d) {\\n        int r=ri+x[d],c=ci+y[d];\\n        if(r<0||r>=v.length||c<0||c>=v[0].length||v[r][c]) return false;\\n        \\n        int type = grid[ri][ci];\\n        int nextType = grid[r][c];\\n        if(type ==1) {\\n            if (d==3) //right\\n               if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n           if (d==2) //left\\n               if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        } \\n        if (type ==2) {\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n            if (d==0) //up\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n        }\\n        if (type ==3) {\\n            if (d==2) //left\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==4) {\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n            if (d==1) //d\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==5) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==2) //l\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        }\\n        if (type ==6) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n        }\\n        return false;\\n    }\\n    \\n    class State {\\n        int r,c;\\n        public State(int r, int c) {\\n            this.r=r;this.c=c;\\n        }\\n    }\\n        \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] x = {-1,1,0,0};//up,down,left,right\\n    int[] y = {0,0,-1,1};\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        boolean[][] v = new boolean[grid.length][grid[0].length];\\n        Queue<State> q = new LinkedList<>();\\n        \\n        q.offer(new State(0,0));\\n        v[0][0] = true;\\n        \\n        while(!q.isEmpty()) {\\n            State s = q.poll();\\n            if(s.r == grid.length-1 && s.c == grid[0].length-1)  return true;\\n          \\n            for(int d=0;d<4;d++) {\\n                if(canMove(v,grid,s.r,s.c,d)) {\\n                    int r = s.r+x[d];\\n                    int c = s.c+y[d];\\n                    q.offer(new State(r,c));\\n                    v[r][c] = true;\\n                }\\n            }\\n                                            \\n        }\\n        return false;\\n    }\\n\\n\\n    boolean canMove(boolean[][] v,int[][] grid,int ri,int ci,int d) {\\n        int r=ri+x[d],c=ci+y[d];\\n        if(r<0||r>=v.length||c<0||c>=v[0].length||v[r][c]) return false;\\n        \\n        int type = grid[ri][ci];\\n        int nextType = grid[r][c];\\n        if(type ==1) {\\n            if (d==3) //right\\n               if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n           if (d==2) //left\\n               if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        } \\n        if (type ==2) {\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n            if (d==0) //up\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n        }\\n        if (type ==3) {\\n            if (d==2) //left\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==4) {\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n            if (d==1) //d\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==5) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==2) //l\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        }\\n        if (type ==6) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n        }\\n        return false;\\n    }\\n    \\n    class State {\\n        int r,c;\\n        public State(int r, int c) {\\n            this.r=r;this.c=c;\\n        }\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724748,
                "title": "java-100-runtime-80-memory-usage-bitwise-operations",
                "content": "Runtime: 3 ms\\nMemory: 53.7 MB\\n\\n```\\nclass Solution {\\n    \\n    private static final byte TOP      = 0b0001;\\n    private static final byte RIGHT    = 0b0010;\\n    private static final byte BOTTOM   = 0b0100;\\n    private static final byte LEFT     = 0b1000;\\n    private static final byte[] STREETS = new byte[]{\\n        0, // Unused\\n        LEFT | RIGHT,   // Street 1\\n        TOP | BOTTOM,   // Street 2\\n        BOTTOM | LEFT,  // Street 3\\n        BOTTOM | RIGHT, // Street 4\\n        TOP | LEFT,     // Street 5\\n        TOP | RIGHT,    // Street 6\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n\\t\\t// Invalid input\\n        if(grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        \\n\\t\\t// Get the first street, remove entry points from the top and left as we do not want to traverse in those directions\\n        int outDirection = STREETS[grid[0][0]] & ~TOP & ~LEFT;\\n\\n        // Attempt to navigate down first, then right second\\n        return navigate(grid, outDirection & BOTTOM) || navigate(grid, outDirection & RIGHT);\\n    }\\n    \\n    public boolean navigate(int[][] grid, int outDirection) {\\n\\n        int width = grid[0].length;\\n        int height = grid.length;\\n        int rowIdx = 0;\\n        int cellIdx = 0;\\n\\n        while(true){\\n\\n            // We got to the bottom right tile, success\\n            if(rowIdx == height-1 && cellIdx == width-1){\\n                return true;\\n            }\\n\\n            int inDirection;\\n\\n            // Determine the direction to navigate out of the current street as well as the how to navigate into the next street\\n            if(outDirection == TOP){\\n                rowIdx--;\\n                inDirection=BOTTOM;\\n            }else if(outDirection == RIGHT){\\n                cellIdx++;\\n                inDirection=LEFT;\\n            }else if(outDirection == BOTTOM){\\n                rowIdx++;\\n                inDirection=TOP;\\n            }else if(outDirection == LEFT){\\n                cellIdx--;\\n                inDirection=RIGHT;\\n            }else{\\n                // Only possible for first tile if it connects top to left\\n                return false;\\n            }\\n\\n            // Prevent out of bounds exceptions\\n            if(rowIdx < 0 || rowIdx >= height || cellIdx < 0 || cellIdx >= width){\\n                return false;\\n            }\\n    \\n\\t        // Prevent circular loops\\n            if(rowIdx == 0 && cellIdx == 0){\\n                return false;\\n            }\\n\\n            // Navigate to the next street\\n            int nextStreet = STREETS[grid[rowIdx][cellIdx]];\\n            \\n            // Determine the out direction for next street by removing the in direction\\n            outDirection = nextStreet & ~inDirection;\\n            \\n            // When we removed the in direction it did not modify the next street, which means it doesn\\'t have an in direciton that matches, abort\\n            if(nextStreet == outDirection){\\n               return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final byte TOP      = 0b0001;\\n    private static final byte RIGHT    = 0b0010;\\n    private static final byte BOTTOM   = 0b0100;\\n    private static final byte LEFT     = 0b1000;\\n    private static final byte[] STREETS = new byte[]{\\n        0, // Unused\\n        LEFT | RIGHT,   // Street 1\\n        TOP | BOTTOM,   // Street 2\\n        BOTTOM | LEFT,  // Street 3\\n        BOTTOM | RIGHT, // Street 4\\n        TOP | LEFT,     // Street 5\\n        TOP | RIGHT,    // Street 6\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n\\t\\t// Invalid input\\n        if(grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        \\n\\t\\t// Get the first street, remove entry points from the top and left as we do not want to traverse in those directions\\n        int outDirection = STREETS[grid[0][0]] & ~TOP & ~LEFT;\\n\\n        // Attempt to navigate down first, then right second\\n        return navigate(grid, outDirection & BOTTOM) || navigate(grid, outDirection & RIGHT);\\n    }\\n    \\n    public boolean navigate(int[][] grid, int outDirection) {\\n\\n        int width = grid[0].length;\\n        int height = grid.length;\\n        int rowIdx = 0;\\n        int cellIdx = 0;\\n\\n        while(true){\\n\\n            // We got to the bottom right tile, success\\n            if(rowIdx == height-1 && cellIdx == width-1){\\n                return true;\\n            }\\n\\n            int inDirection;\\n\\n            // Determine the direction to navigate out of the current street as well as the how to navigate into the next street\\n            if(outDirection == TOP){\\n                rowIdx--;\\n                inDirection=BOTTOM;\\n            }else if(outDirection == RIGHT){\\n                cellIdx++;\\n                inDirection=LEFT;\\n            }else if(outDirection == BOTTOM){\\n                rowIdx++;\\n                inDirection=TOP;\\n            }else if(outDirection == LEFT){\\n                cellIdx--;\\n                inDirection=RIGHT;\\n            }else{\\n                // Only possible for first tile if it connects top to left\\n                return false;\\n            }\\n\\n            // Prevent out of bounds exceptions\\n            if(rowIdx < 0 || rowIdx >= height || cellIdx < 0 || cellIdx >= width){\\n                return false;\\n            }\\n    \\n\\t        // Prevent circular loops\\n            if(rowIdx == 0 && cellIdx == 0){\\n                return false;\\n            }\\n\\n            // Navigate to the next street\\n            int nextStreet = STREETS[grid[rowIdx][cellIdx]];\\n            \\n            // Determine the out direction for next street by removing the in direction\\n            outDirection = nextStreet & ~inDirection;\\n            \\n            // When we removed the in direction it did not modify the next street, which means it doesn\\'t have an in direciton that matches, abort\\n            if(nextStreet == outDirection){\\n               return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584410,
                "title": "python-clean-bfs-solution",
                "content": "I use a map to map the #path to the valid directions, and add valid nodes to the queue, the two nodes must be able to reach each other in order to be connected\\n```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        queue = [(0, 0)]\\n        height, width = len(grid), len(grid[0])\\n        map = {1: [(0, -1), (0, 1)], 2: [(1, 0), (-1, 0)], 3: [(0, -1), (1, 0)], 4: [(0, 1), (1, 0)], 5: [(-1, 0), (0, -1)], 6: [(-1, 0), (0, 1)] }\\n        \\n        while queue:\\n            i, j = queue.pop(0)\\n            path = grid[i][j]\\n            if path == 0:\\n                continue\\n            if i == height - 1 and j == width - 1:\\n                return True\\n\\n            for di, dj in map[path]:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < height and 0 <= nj < width and grid[ni][nj]:\\n                    nextpath = grid[ni][nj]\\n                    if (-di, -dj) in map[nextpath]:\\n                        queue.append((ni, nj))\\n                \\n            grid[i][j] = 0\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        queue = [(0, 0)]\\n        height, width = len(grid), len(grid[0])\\n        map = {1: [(0, -1), (0, 1)], 2: [(1, 0), (-1, 0)], 3: [(0, -1), (1, 0)], 4: [(0, 1), (1, 0)], 5: [(-1, 0), (0, -1)], 6: [(-1, 0), (0, 1)] }\\n        \\n        while queue:\\n            i, j = queue.pop(0)\\n            path = grid[i][j]\\n            if path == 0:\\n                continue\\n            if i == height - 1 and j == width - 1:\\n                return True\\n\\n            for di, dj in map[path]:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < height and 0 <= nj < width and grid[ni][nj]:\\n                    nextpath = grid[ni][nj]\\n                    if (-di, -dj) in map[nextpath]:\\n                        queue.append((ni, nj))\\n                \\n            grid[i][j] = 0\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577528,
                "title": "c",
                "content": "```\\n\\t\\tpublic bool HasValidPath(int[][] grid) {\\n            int[][][] move = new int[7][][];\\n            for (int i = 0; i < 7; i++) move[i] = new int[4][];\\n            move[1][0] = new int[] { 0, 1, 0 };\\n            move[1][2] = new int[] { 0, -1, 2 };\\n            move[2][1] = new int[] { 1, 0, 1 };\\n            move[2][3] = new int[] { -1, 0, 3 };\\n            move[3][0] = new int[] { 1, 0, 1 };\\n            move[3][3] = new int[] { 0, -1, 2 };\\n            move[4][2] = new int[] { 1, 0, 1 };\\n            move[4][3] = new int[] { 0, 1, 0 };\\n            move[5][0] = new int[] { -1, 0, 3 };\\n            move[5][1] = new int[] { 0, -1, 2 };\\n            move[6][1] = new int[] { 0, 1, 0 };\\n            move[6][2] = new int[] { -1, 0, 3 };\\n\\n            int[][] start = new int[][] {\\n                new int[] {  },\\n                new int[] { 0 },\\n                new int[] { 1 },\\n                new int[] { 0 },\\n                new int[] { 2, 3 },\\n                new int[] { 0 },\\n                new int[] { 1 }\\n            };\\n            \\n            int n = grid.Length, m = grid[0].Length;\\n            foreach(int dir in start[grid[0][0]]) {\\n                int x = 0, y = 0;\\n                int d = dir;\\n                bool[][] seen = new bool[n][];\\n                for (int i = 0; i < n; i++) seen[i] = new bool[m];\\n                while (true) {\\n                    if (seen[x][y]) break;\\n                    seen[x][y] = true;\\n                    if (move[grid[x][y]][d] == null) break;\\n                    if (x == n - 1 && y == m - 1) return true;\\n                    var mv = move[grid[x][y]][d];\\n                    x += mv[0];\\n                    y += mv[1];\\n                    d = mv[2];\\n                    if (x < 0 || x >= n || y < 0 || y >= m) break;\\n                }\\n            }\\n            return false;\\n        }\\n```\\nWe have four directions:\\n0 - from left\\n1 - from up\\n2 - from right\\n3 - from down\\nand change in coordinates which depends from direction we came and grid cell type.\\nMove saves the data for each possible direction and cell type, e.g.\\n```move[4][2] = new int[] { 1, 0, 1 };``` means that if we came from direction 2 to cell with type 4 x coordinates will increase to 1 and direction will change to 1.\\nThe array start contains inistial directions for each cell type, note that we have two possible directions for cells with type 4. Additional directions for types 3, 5 and 6 can be ommited.",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic bool HasValidPath(int[][] grid) {\\n            int[][][] move = new int[7][][];\\n            for (int i = 0; i < 7; i++) move[i] = new int[4][];\\n            move[1][0] = new int[] { 0, 1, 0 };\\n            move[1][2] = new int[] { 0, -1, 2 };\\n            move[2][1] = new int[] { 1, 0, 1 };\\n            move[2][3] = new int[] { -1, 0, 3 };\\n            move[3][0] = new int[] { 1, 0, 1 };\\n            move[3][3] = new int[] { 0, -1, 2 };\\n            move[4][2] = new int[] { 1, 0, 1 };\\n            move[4][3] = new int[] { 0, 1, 0 };\\n            move[5][0] = new int[] { -1, 0, 3 };\\n            move[5][1] = new int[] { 0, -1, 2 };\\n            move[6][1] = new int[] { 0, 1, 0 };\\n            move[6][2] = new int[] { -1, 0, 3 };\\n\\n            int[][] start = new int[][] {\\n                new int[] {  },\\n                new int[] { 0 },\\n                new int[] { 1 },\\n                new int[] { 0 },\\n                new int[] { 2, 3 },\\n                new int[] { 0 },\\n                new int[] { 1 }\\n            };\\n            \\n            int n = grid.Length, m = grid[0].Length;\\n            foreach(int dir in start[grid[0][0]]) {\\n                int x = 0, y = 0;\\n                int d = dir;\\n                bool[][] seen = new bool[n][];\\n                for (int i = 0; i < n; i++) seen[i] = new bool[m];\\n                while (true) {\\n                    if (seen[x][y]) break;\\n                    seen[x][y] = true;\\n                    if (move[grid[x][y]][d] == null) break;\\n                    if (x == n - 1 && y == m - 1) return true;\\n                    var mv = move[grid[x][y]][d];\\n                    x += mv[0];\\n                    y += mv[1];\\n                    d = mv[2];\\n                    if (x < 0 || x >= n || y < 0 || y >= m) break;\\n                }\\n            }\\n            return false;\\n        }\\n```\n```move[4][2] = new int[] { 1, 0, 1 };```",
                "codeTag": "Unknown"
            },
            {
                "id": 573445,
                "title": "clear-python-solution-with-comments-backtracking",
                "content": "This is a typical backtracking problem. However, the relationships are a bit complex, so the code might turn out to have some repeating parts. \\nTo write a dry code, we can use some maps to handle the relationships.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 0:\\n            return False\\n        \\n        # Map of direction to the possible street blocks  \\n        self.dirToS = {   \\n            \\'r\\': [1,3,5],\\n            \\'u\\': [2,3,4],\\n            \\'l\\': [1,4,6],\\n            \\'d\\': [2,5,6]\\n        }\\n        # Map of street block to the directions it leads to \\n        self.sToDir = {\\n            1 : [\\'r\\', \\'l\\'],\\n            2 : [\\'u\\', \\'d\\'],\\n            3 : [\\'l\\', \\'d\\'],\\n            4 : [\\'r\\', \\'d\\'],\\n            5 : [\\'l\\', \\'u\\'],\\n            6 : [\\'r\\', \\'u\\']  \\n        }\\n        # Map of direction to the coordinate shifts\\n        self.dirToXy = {\\n            \\'r\\': ( 0,  1),\\n            \\'u\\': (-1,  0),\\n            \\'l\\': ( 0, -1),\\n            \\'d\\': ( 1,  0)\\n        }\\n        \\n        visited = set([])   #must use set (TLE if using list)\\n        return self.helper(grid, 0, 0, visited)\\n    \\n    def helper(self, grid, i, j, visited):\\n        m, n = len(grid), len(grid[0])\\n        \\n        if (i, j) == (m-1, n-1): #arrived at the destination \\n            return True\\n        \\n        cur = grid[i][j]\\n        nextDirs = self.sToDir[cur] \\n\\t\\t\\n        for nextDir in nextDirs:  #nextDir: \\'r\\', \\'u\\', \\'l\\', \\'d\\'\\n            ni = i + self.dirToXy[nextDir][0] #next i\\n            nj = j + self.dirToXy[nextDir][1] #next j \\n            \\n            if ni < 0 or ni >= m or nj < 0 or nj >= n: #out of the boundary \\n                continue\\n            if grid[ni][nj] not in self.dirToS[nextDir]: #street blocks not matching \\n                continue\\n            if (ni, nj) in visited: #visited \\n                continue\\n                \\n            visited.add((ni, nj))\\n            if self.helper(grid, ni, nj, visited): \\n                return True\\n            visited.remove((ni, nj)) #backtracking \\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 0:\\n            return False\\n        \\n        # Map of direction to the possible street blocks  \\n        self.dirToS = {   \\n            \\'r\\': [1,3,5],\\n            \\'u\\': [2,3,4],\\n            \\'l\\': [1,4,6],\\n            \\'d\\': [2,5,6]\\n        }\\n        # Map of street block to the directions it leads to \\n        self.sToDir = {\\n            1 : [\\'r\\', \\'l\\'],\\n            2 : [\\'u\\', \\'d\\'],\\n            3 : [\\'l\\', \\'d\\'],\\n            4 : [\\'r\\', \\'d\\'],\\n            5 : [\\'l\\', \\'u\\'],\\n            6 : [\\'r\\', \\'u\\']  \\n        }\\n        # Map of direction to the coordinate shifts\\n        self.dirToXy = {\\n            \\'r\\': ( 0,  1),\\n            \\'u\\': (-1,  0),\\n            \\'l\\': ( 0, -1),\\n            \\'d\\': ( 1,  0)\\n        }\\n        \\n        visited = set([])   #must use set (TLE if using list)\\n        return self.helper(grid, 0, 0, visited)\\n    \\n    def helper(self, grid, i, j, visited):\\n        m, n = len(grid), len(grid[0])\\n        \\n        if (i, j) == (m-1, n-1): #arrived at the destination \\n            return True\\n        \\n        cur = grid[i][j]\\n        nextDirs = self.sToDir[cur] \\n\\t\\t\\n        for nextDir in nextDirs:  #nextDir: \\'r\\', \\'u\\', \\'l\\', \\'d\\'\\n            ni = i + self.dirToXy[nextDir][0] #next i\\n            nj = j + self.dirToXy[nextDir][1] #next j \\n            \\n            if ni < 0 or ni >= m or nj < 0 or nj >= n: #out of the boundary \\n                continue\\n            if grid[ni][nj] not in self.dirToS[nextDir]: #street blocks not matching \\n                continue\\n            if (ni, nj) in visited: #visited \\n                continue\\n                \\n            visited.add((ni, nj))\\n            if self.helper(grid, ni, nj, visited): \\n                return True\\n            visited.remove((ni, nj)) #backtracking \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557424,
                "title": "72ms-long-but-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/ducmanh/image_1585626349.png)\\n\\n```\\nclass Solution {\\n    int r, c;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        r = grid.size();\\n        c = grid[0].size();\\n        return go(0, 0, grid);\\n    }\\n    bool ok(int y, int x) {\\n        if (y >= r || x >= c || y < 0 || x < 0) {\\n            return 0;\\n        }        \\n        return 1;\\n    }\\n    bool go(int y, int x, vector<vector<int>>& grid) {\\n        if (y == r-1 && x == c-1) {\\n            return 1;\\n        }\\n        if (grid[y][x] == 0) {\\n            return 0;\\n        }\\n        int tmp = grid[y][x];\\n        grid[y][x] = 0;\\n        if (tmp == 1) {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 2) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 3) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 4) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 5) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int r, c;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        r = grid.size();\\n        c = grid[0].size();\\n        return go(0, 0, grid);\\n    }\\n    bool ok(int y, int x) {\\n        if (y >= r || x >= c || y < 0 || x < 0) {\\n            return 0;\\n        }        \\n        return 1;\\n    }\\n    bool go(int y, int x, vector<vector<int>>& grid) {\\n        if (y == r-1 && x == c-1) {\\n            return 1;\\n        }\\n        if (grid[y][x] == 0) {\\n            return 0;\\n        }\\n        int tmp = grid[y][x];\\n        grid[y][x] = 0;\\n        if (tmp == 1) {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 2) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 3) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 4) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 5) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 548459,
                "title": "java-intuitive-single-pass-no-dfs-bfs-with-comments",
                "content": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {},\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{-1, 0}, {0, 1}}\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int i = 0, j = 0; \\n        if (grid[i][j] == 5)\\n            return false;\\n        int[] output = dirs[grid[i][j]][1];\\n        int m = grid.length, n = grid[0].length;\\n        while (!(i == m - 1 && j == n - 1)) { \\n            int[] input = new int[2];\\n            i += output[0];\\n            j += output[1];\\n            input[0] = output[0] * -1; //negative output becomes new input\\n            input[1] = output[1] * -1;\\n            if (isValidInput(i, j, input, grid) == false) return false;\\n            output = findOutput(input, grid[i][j]);\\n        }\\n        return true;\\n    }\\n\\n    private int[] findOutput(int[] input, int street) { //output is the opposite side of the street\\'s input\\n        if (dirs[street][0][0] == input[0] && dirs[street][0][1] == input[1]) return dirs[street][1];\\n        return dirs[street][0];\\n    }\\n\\n    private boolean isValidInput(int i, int j, int[] input, int[][] grid) { //checks if out of bounds and if ends of street pieces meet\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n        int[][] twoends = dirs[grid[i][j]];\\n        for (int[] end : twoends) {\\n            if (end[0] == input[0] && end[1] == input[1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {},\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{-1, 0}, {0, 1}}\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int i = 0, j = 0; \\n        if (grid[i][j] == 5)\\n            return false;\\n        int[] output = dirs[grid[i][j]][1];\\n        int m = grid.length, n = grid[0].length;\\n        while (!(i == m - 1 && j == n - 1)) { \\n            int[] input = new int[2];\\n            i += output[0];\\n            j += output[1];\\n            input[0] = output[0] * -1; //negative output becomes new input\\n            input[1] = output[1] * -1;\\n            if (isValidInput(i, j, input, grid) == false) return false;\\n            output = findOutput(input, grid[i][j]);\\n        }\\n        return true;\\n    }\\n\\n    private int[] findOutput(int[] input, int street) { //output is the opposite side of the street\\'s input\\n        if (dirs[street][0][0] == input[0] && dirs[street][0][1] == input[1]) return dirs[street][1];\\n        return dirs[street][0];\\n    }\\n\\n    private boolean isValidInput(int i, int j, int[] input, int[][] grid) { //checks if out of bounds and if ends of street pieces meet\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n        int[][] twoends = dirs[grid[i][j]];\\n        for (int[] end : twoends) {\\n            if (end[0] == input[0] && end[1] == input[1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548457,
                "title": "dew-it-super-concise-java-super-unreadable-code",
                "content": "**THE BASIC IDEA**\\n* We may enter a cell from any of the four walls - top, right, bottom, left (encoded as 1, 2, 3 and 4 in the code)\\n* If the street in that cell allows, the end result of passing through the cell is a new direction to enter one of the adjacent cells\\n* Since cells always have only one entry point and one exit point, there is (almost) no question of hit and trial - if you are at a cell and you entered a certain way, the next step is deterministic\\n* We say \"almost\" in the above point because the very first cell (0,0) could have a street of type \\'4\\' - in which case, we need to try out both paths - rightward and downward\\n\\nThe idea is pretty simple. However if you can understand this code, you deserve a medal.\\n\\n**THE CODE**\\n```\\nclass Solution {\\n    int m, n;\\n    int[][] grid,\\n        dir = new int[][] { {0,0},{1,0},{0,-1},{-1,0},{0,1} },\\n        startMatrix = new int[][] { {0,0,0},{4,0,1},{1,1,0},{1,1,0},{4,0,1},{-1,0,0},{4,0,1} },\\n        decisionMatrix = new int[][] { {-1,-1,-1,-1,-1},{-1,-1,2,-1,4},{-1,1,-1,3,-1},{-1,-1,-1,2,1},{-1,-1,1,4,-1},{-1,2,-1,-1,3},{-1,4,3,-1,-1} };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(m*n == 1) return true;\\n        int start = grid[0][0], next = startMatrix[start][0], i = startMatrix[start][1], j = startMatrix[start][2];\\n        if(dewIt(next, i, j)) return true;\\n        return (start == 4 && dewIt(1, 1, 0));\\n    }\\n    \\n    private boolean dewIt(int enter, int i, int j) {\\n        boolean[] seen = new boolean[n*m];\\n        while(enter != -1) {\\n            int k = i*n+j;\\n            if(!(i > -1 && j > -1 && i < m && j < n) || seen[k]) break;\\n            else seen[k] = true;\\n            enter =  decisionMatrix[grid[i][j]][enter];\\n            if(enter == -1) break;\\n            else if(i == m-1 && j == n-1) return true;\\n            i += dir[enter][0];\\n            j += dir[enter][1];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int[][] grid,\\n        dir = new int[][] { {0,0},{1,0},{0,-1},{-1,0},{0,1} },\\n        startMatrix = new int[][] { {0,0,0},{4,0,1},{1,1,0},{1,1,0},{4,0,1},{-1,0,0},{4,0,1} },\\n        decisionMatrix = new int[][] { {-1,-1,-1,-1,-1},{-1,-1,2,-1,4},{-1,1,-1,3,-1},{-1,-1,-1,2,1},{-1,-1,1,4,-1},{-1,2,-1,-1,3},{-1,4,3,-1,-1} };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(m*n == 1) return true;\\n        int start = grid[0][0], next = startMatrix[start][0], i = startMatrix[start][1], j = startMatrix[start][2];\\n        if(dewIt(next, i, j)) return true;\\n        return (start == 4 && dewIt(1, 1, 0));\\n    }\\n    \\n    private boolean dewIt(int enter, int i, int j) {\\n        boolean[] seen = new boolean[n*m];\\n        while(enter != -1) {\\n            int k = i*n+j;\\n            if(!(i > -1 && j > -1 && i < m && j < n) || seen[k]) break;\\n            else seen[k] = true;\\n            enter =  decisionMatrix[grid[i][j]][enter];\\n            if(enter == -1) break;\\n            else if(i == m-1 && j == n-1) return true;\\n            i += dir[enter][0];\\n            j += dir[enter][1];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548414,
                "title": "c-no-bfs-dfs-required-single-pass-100",
                "content": "Proof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1584921704.png)\\n\\nReasoning\\n-\\nWe don\\'t actually need to handle branching paths. There\\'s always only one direction the road can lead from our current location. The only exception is if we start on Road Type 4, in which case we can go Right or Down, so we use a boolean to retry exactly one time in that case.\\n\\nThe algorithm is straightforward. Given our current direction and the type of tile in front of us, we know what our new direction will be.\\n\\nAlgorithm\\n-\\n```\\npublic class Solution {\\n    private static readonly int[] starters = {-1, 1, 3, 3, 1, -1, 1};\\n    private static readonly int[,] transformer = {{-1,-1,-1,-1},{0,1,-1,-1},{-1,-1,2,3},{-1,3,0,-1},{3,-1,1,-1},{-1,2,-1,0},{2,-1,-1,1}};\\n    public bool HasValidPath(int[][] grid, bool secondTry = false) {\\n        var row = 0;\\n        var col = 0;\\n        var rowTarget = grid.Length - 1;\\n        var colTarget = grid[0].Length - 1;\\n        var streetType = grid[row][col];\\n        var finalTry = streetType != 4 || secondTry;\\n        var direction = secondTry ? 3 : starters[streetType];\\n        while (direction != -1) {\\n            if (row == rowTarget && col == colTarget) return true;\\n            bool done = true;\\n            switch (direction) {\\n                case 0: // Left\\n                    done = col-- == 0;\\n                    break;\\n                case 1: // Right\\n                    done = col++ == colTarget;\\n                    break;\\n                case 2: // Up\\n                    done = row-- == 0;\\n                    break;\\n                case 3: // Down\\n                    done = row++ == rowTarget;\\n                    break;\\n            }\\n            if (done) break;\\n            streetType = grid[row][col];\\n            direction = transformer[streetType,direction];\\n        }\\n        return finalTry ? false : HasValidPath(grid, true);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private static readonly int[] starters = {-1, 1, 3, 3, 1, -1, 1};\\n    private static readonly int[,] transformer = {{-1,-1,-1,-1},{0,1,-1,-1},{-1,-1,2,3},{-1,3,0,-1},{3,-1,1,-1},{-1,2,-1,0},{2,-1,-1,1}};\\n    public bool HasValidPath(int[][] grid, bool secondTry = false) {\\n        var row = 0;\\n        var col = 0;\\n        var rowTarget = grid.Length - 1;\\n        var colTarget = grid[0].Length - 1;\\n        var streetType = grid[row][col];\\n        var finalTry = streetType != 4 || secondTry;\\n        var direction = secondTry ? 3 : starters[streetType];\\n        while (direction != -1) {\\n            if (row == rowTarget && col == colTarget) return true;\\n            bool done = true;\\n            switch (direction) {\\n                case 0: // Left\\n                    done = col-- == 0;\\n                    break;\\n                case 1: // Right\\n                    done = col++ == colTarget;\\n                    break;\\n                case 2: // Up\\n                    done = row-- == 0;\\n                    break;\\n                case 3: // Down\\n                    done = row++ == rowTarget;\\n                    break;\\n            }\\n            if (done) break;\\n            streetType = grid[row][col];\\n            direction = transformer[streetType,direction];\\n        }\\n        return finalTry ? false : HasValidPath(grid, true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547961,
                "title": "9ms-time-100-memory",
                "content": "```\\nclass Solution {\\n    static int d[][]; // to traverse 4 directions\\n    static int dir[][]; // to know if there is valid route to any of 4 directions from current cell\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        d = new int[][]{{0,-1},{-1,0},{0,1},{1,0}}; \\n        dir =   new int[][]{\\n                    {1,0,1,0},\\n                    {0,1,0,1},\\n                    {1,0,0,1},\\n                    {0,0,1,1},\\n                    {1,1,0,0},\\n                    {0,1,1,0}\\n                };\\n        return helper(grid,0,0);\\n    }\\n    public boolean helper(int grid[][],int x,int y){\\n        if(x==grid.length-1 && y==grid[0].length-1)\\n            return true;\\n        \\n        int curr = grid[x][y];\\n        grid[x][y] = -1; // to avoid loops\\n        for(int i=0;i<4;i++){\\n            int dx = x + d[i][0]; // new row co-ordinate\\n            int dy = y + d[i][1]; // new col co-ordinate\\n            if(dx>=0 && dx<grid.length && dy>=0 && dy<grid[0].length && grid[dx][dy]!=-1){\\n\\t\\t\\t\\t// if there is a route from curr cell to next cell\\n                if(dir[curr-1][i] == dir[grid[dx][dy]-1][(i+2)%4] && dir[curr-1][i] == 1){\\n                    if(helper(grid,dx,dy))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nany further optimizations are helpful, Thanks!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int d[][]; // to traverse 4 directions\\n    static int dir[][]; // to know if there is valid route to any of 4 directions from current cell\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        d = new int[][]{{0,-1},{-1,0},{0,1},{1,0}}; \\n        dir =   new int[][]{\\n                    {1,0,1,0},\\n                    {0,1,0,1},\\n                    {1,0,0,1},\\n                    {0,0,1,1},\\n                    {1,1,0,0},\\n                    {0,1,1,0}\\n                };\\n        return helper(grid,0,0);\\n    }\\n    public boolean helper(int grid[][],int x,int y){\\n        if(x==grid.length-1 && y==grid[0].length-1)\\n            return true;\\n        \\n        int curr = grid[x][y];\\n        grid[x][y] = -1; // to avoid loops\\n        for(int i=0;i<4;i++){\\n            int dx = x + d[i][0]; // new row co-ordinate\\n            int dy = y + d[i][1]; // new col co-ordinate\\n            if(dx>=0 && dx<grid.length && dy>=0 && dy<grid[0].length && grid[dx][dy]!=-1){\\n\\t\\t\\t\\t// if there is a route from curr cell to next cell\\n                if(dir[curr-1][i] == dir[grid[dx][dy]-1][(i+2)%4] && dir[curr-1][i] == 1){\\n                    if(helper(grid,dx,dy))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547822,
                "title": "python-3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tmap = {(1, 0):[(2, 3, 4), (2, 5, 6)], (-1, 0):[(2, 5, 6), (2, 3, 4)], (0, 1):[(1, 4, 6), (1, 3, 5)], (0, -1):[(1, 3, 5), (1, 4, 6)]}\\n\\t\\t\\tstack = [(0, 0)]\\n\\t\\t\\tseen = set()\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tx, y = stack.pop()\\n\\t\\t\\t\\tif x == r - 1 and y == c - 1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor k, v in map.items():\\n\\t\\t\\t\\t\\ta = x + k[0]\\n\\t\\t\\t\\t\\tb = y + k[1]\\n\\t\\t\\t\\t\\tif 0 <= a < r and 0 <= b < c and grid[x][y] in v[0] and grid[a][b] in v[1] and (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tstack.append((a, b))\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tmap = {(1, 0):[(2, 3, 4), (2, 5, 6)], (-1, 0):[(2, 5, 6), (2, 3, 4)], (0, 1):[(1, 4, 6), (1, 3, 5)], (0, -1):[(1, 3, 5), (1, 4, 6)]}",
                "codeTag": "Java"
            },
            {
                "id": 547602,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    int[][] grid;\\n    public boolean hasValidPath(int[][] grid) {\\n        Set<String> visited = new HashSet<String>();\\n        this.grid = grid;\\n        if(grid.length == 0) return true;\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.add(new int[] {0, 0});\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int i = curr[0];\\n            int j = curr[1];\\n            if(i == grid.length  - 1 && j == grid[0].length - 1) return true;\\n            \\n            String key = i + \",\" + j;\\n            \\n            if(visited.contains(key)) continue;\\n            visited.add(key);\\n            \\n            int currSt = grid[i][j];\\n            // up\\n            if(i - 1 >= 0 && !visited.contains((i - 1) + \",\" + j) && up(i, j)) q.add(new int[]{i - 1, j});\\n            // down\\n            if(i + 1 < grid.length && !visited.contains((i + 1) + \",\" + j) && down(i, j)) q.add(new int[]{i + 1, j});\\n            // left\\n            if(j - 1 >= 0 && !visited.contains(i + \",\" + (j - 1)) && left(i, j)) q.add(new int[]{i, j - 1});\\n            //right\\n            if(j + 1 < grid[0].length && !visited.contains(i + \",\" + (j + 1)) && right(i, j)) q.add(new int[]{i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean up(int i, int j) {\\n        int upW = grid[i - 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) return upW == 2 || upW == 3 || upW == 4;\\n        return false;\\n    }\\n    \\n    public boolean down(int i, int j) {\\n        int upW = grid[i + 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) return upW == 2 || upW == 5 || upW == 6;\\n        return false;\\n    }\\n    \\n    public boolean right(int i, int j) {\\n        int upW = grid[i][j + 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) return upW == 1 || upW == 3 || upW == 5;\\n        return false;\\n    }\\n    \\n    public boolean left(int i, int j) {\\n        int upW = grid[i][j - 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) return upW == 1 || upW == 4 || upW == 6;    \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    public boolean hasValidPath(int[][] grid) {\\n        Set<String> visited = new HashSet<String>();\\n        this.grid = grid;\\n        if(grid.length == 0) return true;\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.add(new int[] {0, 0});\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int i = curr[0];\\n            int j = curr[1];\\n            if(i == grid.length  - 1 && j == grid[0].length - 1) return true;\\n            \\n            String key = i + \",\" + j;\\n            \\n            if(visited.contains(key)) continue;\\n            visited.add(key);\\n            \\n            int currSt = grid[i][j];\\n            // up\\n            if(i - 1 >= 0 && !visited.contains((i - 1) + \",\" + j) && up(i, j)) q.add(new int[]{i - 1, j});\\n            // down\\n            if(i + 1 < grid.length && !visited.contains((i + 1) + \",\" + j) && down(i, j)) q.add(new int[]{i + 1, j});\\n            // left\\n            if(j - 1 >= 0 && !visited.contains(i + \",\" + (j - 1)) && left(i, j)) q.add(new int[]{i, j - 1});\\n            //right\\n            if(j + 1 < grid[0].length && !visited.contains(i + \",\" + (j + 1)) && right(i, j)) q.add(new int[]{i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean up(int i, int j) {\\n        int upW = grid[i - 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) return upW == 2 || upW == 3 || upW == 4;\\n        return false;\\n    }\\n    \\n    public boolean down(int i, int j) {\\n        int upW = grid[i + 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) return upW == 2 || upW == 5 || upW == 6;\\n        return false;\\n    }\\n    \\n    public boolean right(int i, int j) {\\n        int upW = grid[i][j + 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) return upW == 1 || upW == 3 || upW == 5;\\n        return false;\\n    }\\n    \\n    public boolean left(int i, int j) {\\n        int upW = grid[i][j - 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) return upW == 1 || upW == 4 || upW == 6;    \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547537,
                "title": "java-split-grid-into-4-parts-and-use-union-find-explanation-with-graph",
                "content": "- step1. each grid has four edges, so we can split each grid into 4 parts by connecting the 2 diagonols, give 4 parts unique id\\n- step2. build connections inside a grid. eg. Street 1 connects left and right edge, so union left part and right part\\n- step3. build connections between grids. \\n    eg. in grid1 the street can reach down edge, grid2 is just below grid1, and the street in it can reach up edge. So we can connect grid1\\'s down part and grid2\\'s up part\\n- Similar question: [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/) \\n![image](https://assets.leetcode.com/users/zyhanghang/image_1584861023.png)\\n\\n```\\nclass Solution {\\n    class UnionFind {\\n        int[] id;\\n        public UnionFind(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx != ry) {\\n                id[rx] = ry;\\n            }\\n        }\\n        public int find(int x) {\\n            if (id[x] != x) {\\n                id[x] = find(id[x]);\\n            }\\n            return id[x];\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        UnionFind uf = new UnionFind(4*m*n);\\n        \\n        //the street which has correspongding direction\\n        Set<Integer> up = new HashSet<>();\\n        up.add(2); up.add(5); up.add(6);\\n        Set<Integer> down = new HashSet<>();\\n        down.add(2); down.add(3); down.add(4);\\n        Set<Integer> left = new HashSet<>();\\n        left.add(1); left.add(3); left.add(5);\\n        Set<Integer> right = new HashSet<>();\\n        right.add(1); right.add(4); right.add(6);\\n        \\n        //build external connection, connect grid with grid if possible \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int idx = i * n + j;\\n                //connect cur grid with downward grid if possible\\n                if (down.contains(grid[i][j])) {\\n                    if (i + 1 < m && up.contains(grid[i+1][j])) {\\n                        int d = (i + 1) * n + j;\\n                        uf.union(idx*4+3, d*4+1);\\n                    }\\n                }\\n                //connect cur grid with rightward grid if possible\\n                if (right.contains(grid[i][j])) {\\n                    if (j + 1 < n && left.contains(grid[i][j+1])) {\\n                        int r = i * n + (j + 1);\\n                        uf.union(idx*4+2, r*4);\\n                    } \\n                }\\n                //connect cur grid with upward grid if possible\\n                if (up.contains(grid[i][j])) {\\n                    if (i - 1 >= 0 && down.contains(grid[i-1][j])) {\\n                        int u = (i-1) * n + j;\\n                        uf.union(idx*4+1, u*4+3);\\n                    } \\n                }\\n                //connect cur grid with leftward grid if possible\\n                if (left.contains(grid[i][j])) {\\n                    if (j - 1 >= 0 && right.contains(grid[i][j-1])) {\\n                        int l = i * n + (j - 1);\\n                        uf.union(idx*4, l*4+2);\\n                    } \\n                }\\n            }\\n        }\\n        \\n        //build internal connection\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int dir = grid[i][j];\\n                int idx = i * n + j;\\n                int b = 4 * idx;\\n                if (dir == 1) {\\n                    uf.union(b, b+2);                   \\n                } else if (dir == 2) {\\n                    uf.union(b+1, b+3);\\n                } else if (dir == 3) {\\n                    uf.union(b, b+3);\\n                } else if (dir == 4) {\\n                    uf.union(b+2, b+3);\\n                } else if (dir == 5) {\\n                    uf.union(b, b+1);\\n                } else {\\n                    uf.union(b+1, b+2);   \\n                }\\n            }\\n        }\\n        \\n        //check if (0, 0) and (m-1, n-1) is connected\\n        int src = 0, des = m*n-1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 4; i++) {\\n            set.add(uf.find(4*src+i));\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            if (set.contains(4*des+i)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] id;\\n        public UnionFind(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx != ry) {\\n                id[rx] = ry;\\n            }\\n        }\\n        public int find(int x) {\\n            if (id[x] != x) {\\n                id[x] = find(id[x]);\\n            }\\n            return id[x];\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        UnionFind uf = new UnionFind(4*m*n);\\n        \\n        //the street which has correspongding direction\\n        Set<Integer> up = new HashSet<>();\\n        up.add(2); up.add(5); up.add(6);\\n        Set<Integer> down = new HashSet<>();\\n        down.add(2); down.add(3); down.add(4);\\n        Set<Integer> left = new HashSet<>();\\n        left.add(1); left.add(3); left.add(5);\\n        Set<Integer> right = new HashSet<>();\\n        right.add(1); right.add(4); right.add(6);\\n        \\n        //build external connection, connect grid with grid if possible \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int idx = i * n + j;\\n                //connect cur grid with downward grid if possible\\n                if (down.contains(grid[i][j])) {\\n                    if (i + 1 < m && up.contains(grid[i+1][j])) {\\n                        int d = (i + 1) * n + j;\\n                        uf.union(idx*4+3, d*4+1);\\n                    }\\n                }\\n                //connect cur grid with rightward grid if possible\\n                if (right.contains(grid[i][j])) {\\n                    if (j + 1 < n && left.contains(grid[i][j+1])) {\\n                        int r = i * n + (j + 1);\\n                        uf.union(idx*4+2, r*4);\\n                    } \\n                }\\n                //connect cur grid with upward grid if possible\\n                if (up.contains(grid[i][j])) {\\n                    if (i - 1 >= 0 && down.contains(grid[i-1][j])) {\\n                        int u = (i-1) * n + j;\\n                        uf.union(idx*4+1, u*4+3);\\n                    } \\n                }\\n                //connect cur grid with leftward grid if possible\\n                if (left.contains(grid[i][j])) {\\n                    if (j - 1 >= 0 && right.contains(grid[i][j-1])) {\\n                        int l = i * n + (j - 1);\\n                        uf.union(idx*4, l*4+2);\\n                    } \\n                }\\n            }\\n        }\\n        \\n        //build internal connection\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int dir = grid[i][j];\\n                int idx = i * n + j;\\n                int b = 4 * idx;\\n                if (dir == 1) {\\n                    uf.union(b, b+2);                   \\n                } else if (dir == 2) {\\n                    uf.union(b+1, b+3);\\n                } else if (dir == 3) {\\n                    uf.union(b, b+3);\\n                } else if (dir == 4) {\\n                    uf.union(b+2, b+3);\\n                } else if (dir == 5) {\\n                    uf.union(b, b+1);\\n                } else {\\n                    uf.union(b+1, b+2);   \\n                }\\n            }\\n        }\\n        \\n        //check if (0, 0) and (m-1, n-1) is connected\\n        int src = 0, des = m*n-1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 4; i++) {\\n            set.add(uf.find(4*src+i));\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            if (set.contains(4*des+i)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547532,
                "title": "bfs-in-java",
                "content": "We use BFS approach to solve the problem. The key is how to define the connectivity. We use an array \"conn\" to represent possible streets in each four direction. So every time, we need to check moving direction based on pair array, and then check if there is a conect between current node and next node. \\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return false;\\n        \\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                if (cell[0] == m - 1 && cell[1] == n - 1) return true;\\n                for (int[] pair : pairs) {\\n                    int x = pair[0] + cell[0];\\n                    int y = pair[1] + cell[1];\\n                    \\n                    if ( x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\\n                    \\n                    if ((pair[0] == -1 && isInArray(conn[0], grid[cell[0]][cell[1]]) && isInArray(conn[3],grid[x][y])) ||\\n                        (pair[0] == 1 && isInArray(conn[3], grid[cell[0]][cell[1]]) && isInArray(conn[0],grid[x][y])) ||\\n                        (pair[1] == -1 && isInArray(conn[1], grid[cell[0]][cell[1]]) && isInArray(conn[2],grid[x][y])) ||\\n                        (pair[1] == 1 && isInArray(conn[2], grid[cell[0]][cell[1]]) && isInArray(conn[1],grid[x][y]))) {\\n\\n                        visited[x][y] = true;\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isInArray(int[] arr, int num) {\\n        boolean res = false;\\n        for (int element : arr) {\\n            if (element == num) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][] pairs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int[][] conn = new int[][]{{2,5,6}, {1,3,5}, {1,4,6}, {2,3,4}};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return false;\\n        \\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                if (cell[0] == m - 1 && cell[1] == n - 1) return true;\\n                for (int[] pair : pairs) {\\n                    int x = pair[0] + cell[0];\\n                    int y = pair[1] + cell[1];\\n                    \\n                    if ( x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\\n                    \\n                    if ((pair[0] == -1 && isInArray(conn[0], grid[cell[0]][cell[1]]) && isInArray(conn[3],grid[x][y])) ||\\n                        (pair[0] == 1 && isInArray(conn[3], grid[cell[0]][cell[1]]) && isInArray(conn[0],grid[x][y])) ||\\n                        (pair[1] == -1 && isInArray(conn[1], grid[cell[0]][cell[1]]) && isInArray(conn[2],grid[x][y])) ||\\n                        (pair[1] == 1 && isInArray(conn[2], grid[cell[0]][cell[1]]) && isInArray(conn[1],grid[x][y]))) {\\n\\n                        visited[x][y] = true;\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isInArray(int[] arr, int num) {\\n        boolean res = false;\\n        for (int element : arr) {\\n            if (element == num) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][] pairs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int[][] conn = new int[][]{{2,5,6}, {1,3,5}, {1,4,6}, {2,3,4}};\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547401,
                "title": "java-union-find-enumeration",
                "content": "The idea of the following solution is quit straight forward: Just enumerate all cases that 2 paths can be considered as connected. \\n\\nSince this is a Union-Find solution, we can always choose ```one direction``` to make decision, that is, ```we do not need check a path from both side```. For example, if we have ```int[][] grid = [[1, 3]]```, then by the definition from this problem, we can only check path 1\\'s right to see whether we can meet a path 1 or path 3 and path 5. If we can meet one of three paths, then unite them with same root. \\n\\nFinally, we just check whether the top left cell and bottom right cell have same root value, that is what```find(0, m * n - 1)```representing for. \\n```\\n\\nclass Solution {\\n    int[] id;\\n    int[] sz;\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        id = new int[m * n];\\n        sz = new int[m * n];\\n        for (int i = 0; i < m * n; i++){\\n            id[i] = i;\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1 || grid[i][j] == 6){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                } else if (grid[i][j] == 2 || grid[i][j] == 3){\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else if (grid[i][j] == 4){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else {\\n                    if (j != 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        unite(i * n + j, i * n + j - 1);\\n                    }\\n                    if (i != 0 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        unite(i * n + j, (i - 1) * n + j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return find(0, m * n - 1);\\n    }\\n    \\n    public boolean find(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n\\n    public int root(int i) {\\n        while (i != id[i]) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n\\n    public void unite(int p, int q) {\\t\\n        int i = root(p);\\n        int j = root(q);\\n        if (sz[i] < sz[j]) {\\n            id[i] = j;\\n            sz[j] += sz[i];\\n        } else {\\n            id[j] = i;\\n            sz[i] += sz[j];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```one direction```\n```we do not need check a path from both side```\n```int[][] grid = [[1, 3]]```\n```find(0, m * n - 1)```\n```\\n\\nclass Solution {\\n    int[] id;\\n    int[] sz;\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        id = new int[m * n];\\n        sz = new int[m * n];\\n        for (int i = 0; i < m * n; i++){\\n            id[i] = i;\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1 || grid[i][j] == 6){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                } else if (grid[i][j] == 2 || grid[i][j] == 3){\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else if (grid[i][j] == 4){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else {\\n                    if (j != 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        unite(i * n + j, i * n + j - 1);\\n                    }\\n                    if (i != 0 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        unite(i * n + j, (i - 1) * n + j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return find(0, m * n - 1);\\n    }\\n    \\n    public boolean find(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n\\n    public int root(int i) {\\n        while (i != id[i]) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n\\n    public void unite(int p, int q) {\\t\\n        int i = root(p);\\n        int j = root(q);\\n        if (sz[i] < sz[j]) {\\n            id[i] = j;\\n            sz[j] += sz[i];\\n        } else {\\n            id[j] = i;\\n            sz[i] += sz[j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547326,
                "title": "java-simple-interactive-dfs",
                "content": "Since it is a one way dfs no splits, it is possible apply DFS iteratively other than by recursion.\\n```\\nclass Solution {\\n    int[][][] dir = new int[][][]{{{0,1},{0,-1}},\\n                            {{1,0},{-1,0}},\\n                            {{1,0}, {0,-1}},\\n                            {{0,1},{1,0}},\\n                            {{-1,0},{0,-1}},\\n                            {{0,1},{-1, 0}}};\\n    public boolean hasValidPath(int[][] g) {\\n        int m = g.length, n = g[0].length;\\n        if (m <= 1 && n <= 1) return true;\\n        if (g[0][0] == 5) return false;\\n        if (g[0][0] == 4) return dfs(0, 0, 0, m, n, g) || dfs(0, 0, 1, m, n, g);\\n        return dfs(0, 0, 0, m, n, g);\\n    }\\n    \\n    private boolean dfs(int i, int j, int prev, int m, int n, int[][] g) {\\n        while (true) {\\n            if (i == m -1 && j == n - 1) return true;\\n            int in = g[i][j] - 1, next = prev == 1 ? 0 : 1;\\n            i += dir[in][prev][0];\\n            j += dir[in][prev][1];\\n            if (i < 0 || i >= m || j< 0 || j >= n) return false;\\n            int nextIn = g[i][j] - 1;\\n            if (dir[in][prev][0] + dir[nextIn][prev][0] == 0 && dir[in][prev][1] + dir[nextIn][prev][1] == 0) {\\n                prev = next;\\n                continue;// try one outlet\\n            }   \\n            if (dir[in][prev][0] + dir[nextIn][next][0] == 0 && dir[in][prev][1] + dir[nextIn][next][1] == 0) {\\n                continue; // try another outlet\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\\nI use recursion in context and got TLE.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dir = new int[][][]{{{0,1},{0,-1}},\\n                            {{1,0},{-1,0}},\\n                            {{1,0}, {0,-1}},\\n                            {{0,1},{1,0}},\\n                            {{-1,0},{0,-1}},\\n                            {{0,1},{-1, 0}}};\\n    public boolean hasValidPath(int[][] g) {\\n        int m = g.length, n = g[0].length;\\n        if (m <= 1 && n <= 1) return true;\\n        if (g[0][0] == 5) return false;\\n        if (g[0][0] == 4) return dfs(0, 0, 0, m, n, g) || dfs(0, 0, 1, m, n, g);\\n        return dfs(0, 0, 0, m, n, g);\\n    }\\n    \\n    private boolean dfs(int i, int j, int prev, int m, int n, int[][] g) {\\n        while (true) {\\n            if (i == m -1 && j == n - 1) return true;\\n            int in = g[i][j] - 1, next = prev == 1 ? 0 : 1;\\n            i += dir[in][prev][0];\\n            j += dir[in][prev][1];\\n            if (i < 0 || i >= m || j< 0 || j >= n) return false;\\n            int nextIn = g[i][j] - 1;\\n            if (dir[in][prev][0] + dir[nextIn][prev][0] == 0 && dir[in][prev][1] + dir[nextIn][prev][1] == 0) {\\n                prev = next;\\n                continue;// try one outlet\\n            }   \\n            if (dir[in][prev][0] + dir[nextIn][next][0] == 0 && dir[in][prev][1] + dir[nextIn][next][1] == 0) {\\n                continue; // try another outlet\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547262,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n        self.moves = {1:[(0,1), (0,-1)], \\n                      2:[(1,0),(-1,0)], \\n                      3:[(1,0),(0,-1)], \\n                      4:[(0,1),(1,0)],\\n                      5:[(-1,0),(0,-1)],\\n                      6:[(-1,0),(0,1)]}\\n        \\n        queue = collections.deque([(0,0)])\\n        seen = set() \\n        while queue:\\n            curr_row, curr_col = queue.popleft() \\n            curr_direction = grid[curr_row][curr_col] \\n            if curr_row == len(grid) - 1 and curr_col == len(grid[-1]) - 1:\\n                return True\\n            \\n            for move in self.moves[curr_direction]:\\n                new_row, new_col = curr_row + move[0], curr_col + move[1]\\n                if self.is_inbounds(grid, new_row, new_col, seen) and self.does_accept(grid, move, new_row, new_col):\\n                    seen.add((new_row, new_col))\\n                    queue.append((new_row, new_col)) \\n        return False \\n    \\n    def does_accept(self, grid, move, row, col):\\n        opposite_move = (move[0] *-1, move[1] * -1) \\n        curr_direction = grid[row][col]\\n        return opposite_move in self.moves[curr_direction] \\n    \\n    \\n    def is_inbounds(self, board, row, col, seen):\\n        return 0 <= row < len(board) and 0 <= col < len(board[row]) and (row, col) not in seen\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n        self.moves = {1:[(0,1), (0,-1)], \\n                      2:[(1,0),(-1,0)], \\n                      3:[(1,0),(0,-1)], \\n                      4:[(0,1),(1,0)],\\n                      5:[(-1,0),(0,-1)],\\n                      6:[(-1,0),(0,1)]}\\n        \\n        queue = collections.deque([(0,0)])\\n        seen = set() \\n        while queue:\\n            curr_row, curr_col = queue.popleft() \\n            curr_direction = grid[curr_row][curr_col] \\n            if curr_row == len(grid) - 1 and curr_col == len(grid[-1]) - 1:\\n                return True\\n            \\n            for move in self.moves[curr_direction]:\\n                new_row, new_col = curr_row + move[0], curr_col + move[1]\\n                if self.is_inbounds(grid, new_row, new_col, seen) and self.does_accept(grid, move, new_row, new_col):\\n                    seen.add((new_row, new_col))\\n                    queue.append((new_row, new_col)) \\n        return False \\n    \\n    def does_accept(self, grid, move, row, col):\\n        opposite_move = (move[0] *-1, move[1] * -1) \\n        curr_direction = grid[row][col]\\n        return opposite_move in self.moves[curr_direction] \\n    \\n    \\n    def is_inbounds(self, board, row, col, seen):\\n        return 0 <= row < len(board) and 0 <= col < len(board[row]) and (row, col) not in seen\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547226,
                "title": "python3-graph-traversal",
                "content": "Algorithm: \\nConvert `grid` into a graph and traverse the graph. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0]) #dimension\\n        \\n        graph = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if   grid[i][j] == 1: graph[i, j] = [(i, j-1), (i, j+1)]\\n                elif grid[i][j] == 2: graph[i, j] = [(i-1, j), (i+1, j)]\\n                elif grid[i][j] == 3: graph[i, j] = [(i, j-1), (i+1, j)]\\n                elif grid[i][j] == 4: graph[i, j] = [(i+1, j), (i, j+1)]\\n                elif grid[i][j] == 5: graph[i, j] = [(i-1, j), (i, j-1)]\\n                else:                 graph[i, j] = [(i-1, j), (i, j+1)] \\n        \\n        #traverse graph\\n        stack = [(0, 0)]\\n        seen = set()\\n        while stack:\\n            i, j = stack.pop()\\n            if i == m-1 and j == n-1: return True \\n            seen.add((i, j)) #mark as visited \\n            for ii, jj in graph[i, j]: \\n                if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen and (i, j) in graph[ii, jj]: \\n                    stack.append((ii, jj))\\n        return False \\n```\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0]) #dimension\\n        \\n        graph = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if   grid[i][j] == 1: graph[i, j] = [(i, j-1), (i, j+1)]\\n                elif grid[i][j] == 2: graph[i, j] = [(i-1, j), (i+1, j)]\\n                elif grid[i][j] == 3: graph[i, j] = [(i, j-1), (i+1, j)]\\n                elif grid[i][j] == 4: graph[i, j] = [(i+1, j), (i, j+1)]\\n                elif grid[i][j] == 5: graph[i, j] = [(i-1, j), (i, j-1)]\\n                else:                 graph[i, j] = [(i-1, j), (i, j+1)] \\n        \\n        #traverse graph\\n        stack = [(0, 0)]\\n        seen = set()\\n        while stack:\\n            i, j = stack.pop()\\n            if i == m-1 and j == n-1: return True \\n            seen.add((i, j)) #mark as visited \\n            for ii, jj in graph[i, j]: \\n                if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen and (i, j) in graph[ii, jj]: \\n                    stack.append((ii, jj))\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 547221,
                "title": "python-dfs-easy-to-understand-clean-code",
                "content": "```\\nclass Solution(object):\\n    \\n    def valid(self, i, j, valid_next, grid):\\n        if i < 0 or j < 0 or i > len(grid) -1 or j > len(grid[0]) - 1:\\n            return False\\n        if grid[i][j] == \\'X\\' or grid[i][j] not in valid_next:\\n            return False\\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return True\\n        cur = grid[i][j]\\n        grid[i][j] = \\'X\\'\\n        for d in self.street_dir[cur]:\\n            x, y = self.dirs[d][0], self.dirs[d][1]\\n            if self.valid(i + x, j + y, self.valid_next[d], grid):\\n                return True\\n        return False\\n\\n    def hasValidPath(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return False\\n        self.valid_next = {\\n            \\'r\\': [1, 3, 5],\\n            \\'l\\': [1, 4, 6],\\n            \\'d\\': [2, 5, 6],\\n            \\'u\\': [2, 3, 4]\\n        }\\n        self.street_dir = {\\n            1: [\\'l\\', \\'r\\'],\\n            2: [\\'u\\', \\'d\\'],\\n            3: [\\'l\\', \\'d\\'],\\n            4: [\\'r\\', \\'d\\'],\\n            5: [\\'l\\', \\'u\\'],\\n            6: [\\'u\\', \\'r\\']\\n        }\\n        self.dirs = {\\n            \\'r\\': [0, 1],\\n            \\'l\\': [0, -1],\\n            \\'u\\': [-1, 0],\\n            \\'d\\': [1, 0]\\n        }\\n        \\n        return self.valid(0, 0, [1, 2, 3, 4, 6], grid)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def valid(self, i, j, valid_next, grid):\\n        if i < 0 or j < 0 or i > len(grid) -1 or j > len(grid[0]) - 1:\\n            return False\\n        if grid[i][j] == \\'X\\' or grid[i][j] not in valid_next:\\n            return False\\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return True\\n        cur = grid[i][j]\\n        grid[i][j] = \\'X\\'\\n        for d in self.street_dir[cur]:\\n            x, y = self.dirs[d][0], self.dirs[d][1]\\n            if self.valid(i + x, j + y, self.valid_next[d], grid):\\n                return True\\n        return False\\n\\n    def hasValidPath(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return False\\n        self.valid_next = {\\n            \\'r\\': [1, 3, 5],\\n            \\'l\\': [1, 4, 6],\\n            \\'d\\': [2, 5, 6],\\n            \\'u\\': [2, 3, 4]\\n        }\\n        self.street_dir = {\\n            1: [\\'l\\', \\'r\\'],\\n            2: [\\'u\\', \\'d\\'],\\n            3: [\\'l\\', \\'d\\'],\\n            4: [\\'r\\', \\'d\\'],\\n            5: [\\'l\\', \\'u\\'],\\n            6: [\\'u\\', \\'r\\']\\n        }\\n        self.dirs = {\\n            \\'r\\': [0, 1],\\n            \\'l\\': [0, -1],\\n            \\'u\\': [-1, 0],\\n            \\'d\\': [1, 0]\\n        }\\n        \\n        return self.valid(0, 0, [1, 2, 3, 4, 6], grid)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089074,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        return fun(grid,0,0,-1);\\n    }\\n    bool fun(vector<vector<int>>&grid,int i,int j,int dir)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(i==m-1 and j==n-1)\\n        {\\n            return true;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        int val=grid[i][j];\\n        vis[i][j]=true;\\n        // 1->up 2->down 3->right 4->left\\n        if(val==1)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j-1,4) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4) \\n            {\\n                if(isvalid(i,j-1))\\n                {\\n                    int v=grid[i][j-1];\\n                    if(v==2 or v==3 or v==5)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j-1,4);\\n                }\\n            }\\n            else if(dir==3)\\n            {\\n                if(isvalid(i,j+1))\\n                {\\n                    int v=grid[i][j+1];\\n                    if(v==2 or v==4 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j+1,3);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==2)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i-1,j,1) or fun(grid,i+1,j,2);\\n            }\\n            else if(dir==1)\\n            {\\n                if(isvalid(i-1,j))\\n                {\\n                    int v=grid[i-1][j];\\n                    if(v==1 or v==5 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i-1,j,1);\\n                }\\n            }\\n            else if(dir==2)\\n            {\\n                if(isvalid(i+1,j))\\n                {\\n                    int v=grid[i+1][j];\\n                    if(v==1 or v==3 or v==4)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i+1,j,2);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==3)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j-1,4);\\n            }\\n            else if(dir==1)\\n            {\\n                // up ->left\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                // right->down\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==4)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==5)\\n        {\\n            if(dir==2)\\n            {\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==6)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==2)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        return fun(grid,0,0,-1);\\n    }\\n    bool fun(vector<vector<int>>&grid,int i,int j,int dir)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(i==m-1 and j==n-1)\\n        {\\n            return true;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        int val=grid[i][j];\\n        vis[i][j]=true;\\n        // 1->up 2->down 3->right 4->left\\n        if(val==1)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j-1,4) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4) \\n            {\\n                if(isvalid(i,j-1))\\n                {\\n                    int v=grid[i][j-1];\\n                    if(v==2 or v==3 or v==5)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j-1,4);\\n                }\\n            }\\n            else if(dir==3)\\n            {\\n                if(isvalid(i,j+1))\\n                {\\n                    int v=grid[i][j+1];\\n                    if(v==2 or v==4 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j+1,3);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==2)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i-1,j,1) or fun(grid,i+1,j,2);\\n            }\\n            else if(dir==1)\\n            {\\n                if(isvalid(i-1,j))\\n                {\\n                    int v=grid[i-1][j];\\n                    if(v==1 or v==5 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i-1,j,1);\\n                }\\n            }\\n            else if(dir==2)\\n            {\\n                if(isvalid(i+1,j))\\n                {\\n                    int v=grid[i+1][j];\\n                    if(v==1 or v==3 or v==4)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i+1,j,2);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==3)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j-1,4);\\n            }\\n            else if(dir==1)\\n            {\\n                // up ->left\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                // right->down\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==4)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==5)\\n        {\\n            if(dir==2)\\n            {\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==6)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==2)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084600,
                "title": "easy-python-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,grid,i,j):\\n        z=grid[i][j]\\n        grid[i][j]=-1\\n        \\n        \\n         \\n        if z==1:\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==2:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==3:\\n            \\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==4:\\n            \\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==5:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==6:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,4,3]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,5,3]:\\n                self.dfs(grid,q,w)\\n\\n\\n            \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.dfs(grid,0,0)\\n        if grid[-1][-1]==-1:\\n            return True\\n        return False\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,grid,i,j):\\n        z=grid[i][j]\\n        grid[i][j]=-1\\n        \\n        \\n         \\n        if z==1:\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==2:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==3:\\n            \\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==4:\\n            \\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==5:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==6:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,4,3]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,5,3]:\\n                self.dfs(grid,q,w)\\n\\n\\n            \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.dfs(grid,0,0)\\n        if grid[-1][-1]==-1:\\n            return True\\n        return False\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075180,
                "title": "python-solution-beated-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R, U, D = 0, 1, 2, 3\\n        exits = {\\n            (L, 1): L,\\n            (R, 1): R,\\n            (U, 2): U,\\n            (D, 2): D,\\n            (L, 3): U,\\n            (D, 3): R,\\n            (R, 4): U,\\n            (D, 4): L,\\n            (L, 5): D,\\n            (U, 5): R,\\n            (U, 6): L,\\n            (R, 6): D,\\n        }\\n        n, m = len(grid), len(grid[0])\\n        def solve(dir, curr):\\n            x, y = 0, 0\\n            while x != n - 1 or y != m - 1:\\n                next_dir = exits[(dir, curr)]\\n                if next_dir == L:\\n                    y += 1\\n                elif next_dir == R:\\n                    y -= 1\\n                elif next_dir == U:\\n                    x += 1\\n                elif next_dir == D:\\n                    x -= 1\\n                if x < 0 or x >= n:\\n                    return False\\n                if y < 0 or y >= m:\\n                    return False\\n                if x == 0 and y == 0:\\n                    return False\\n                if (next_dir, grid[x][y]) not in exits:\\n                    return False\\n                dir, curr = next_dir, grid[x][y]\\n            return True \\n        if grid[0][0] == 1:\\n            return solve(L, 1)\\n        if grid[0][0] == 2:\\n            return solve(U, 2)\\n        if grid[0][0] == 3:\\n            return solve(L, 3)\\n        if grid[0][0] == 4:\\n            return solve(R, 4) or solve(D, 4)\\n        if grid[0][0] == 6:\\n            return solve(U, 6)\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R, U, D = 0, 1, 2, 3\\n        exits = {\\n            (L, 1): L,\\n            (R, 1): R,\\n            (U, 2): U,\\n            (D, 2): D,\\n            (L, 3): U,\\n            (D, 3): R,\\n            (R, 4): U,\\n            (D, 4): L,\\n            (L, 5): D,\\n            (U, 5): R,\\n            (U, 6): L,\\n            (R, 6): D,\\n        }\\n        n, m = len(grid), len(grid[0])\\n        def solve(dir, curr):\\n            x, y = 0, 0\\n            while x != n - 1 or y != m - 1:\\n                next_dir = exits[(dir, curr)]\\n                if next_dir == L:\\n                    y += 1\\n                elif next_dir == R:\\n                    y -= 1\\n                elif next_dir == U:\\n                    x += 1\\n                elif next_dir == D:\\n                    x -= 1\\n                if x < 0 or x >= n:\\n                    return False\\n                if y < 0 or y >= m:\\n                    return False\\n                if x == 0 and y == 0:\\n                    return False\\n                if (next_dir, grid[x][y]) not in exits:\\n                    return False\\n                dir, curr = next_dir, grid[x][y]\\n            return True \\n        if grid[0][0] == 1:\\n            return solve(L, 1)\\n        if grid[0][0] == 2:\\n            return solve(U, 2)\\n        if grid[0][0] == 3:\\n            return solve(L, 3)\\n        if grid[0][0] == 4:\\n            return solve(R, 4) or solve(D, 4)\\n        if grid[0][0] == 6:\\n            return solve(U, 6)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066466,
                "title": "simple-c-code-but-quite-messy",
                "content": "Now u surely need a therapy after seeing my code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool valid(int i,int j,int n,int m)\\n{\\n if(i==n||j==m||i<0||j<0)return false;\\n return true;\\n}\\n bool f(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n {   if(i==grid.size()-1&&j==grid[0].size()-1)return true;\\n    \\n    vis[i][j]=1;\\n     cout<<i<<\" \"<<j<<endl;\\n     bool b=false;\\n     if(grid[i][j]==1)\\n     {\\n         if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==1||grid[i][j-1]==4||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==1||grid[i][j+1]==3||grid[i][j+1]==5))\\n    b=f(i,j+1,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==2)\\n     {\\n  \\n    if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==2||grid[i-1][j]==4||grid[i-1][j]==3))\\n    b=f(i-1,j,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==2||grid[i+1][j]==5||grid[i+1][j]==6))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==3)\\n     {\\nif(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==4||grid[i][j-1]==1||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==4)\\n     { \\nif(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n      if(grid[i][j]==5)\\n     {\\n         \\n    if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==3||grid[i][j-1]==4||grid[i][j-1]==1))\\n    b=f(i,j-1,grid,vis);\\n     if(b==true)return true;\\n     if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n    return b;\\n  \\n     }\\n      if(grid[i][j]==6)\\n     {  \\nif(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n     if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n   \\n    return  b;\\n     }\\n     return false;\\n }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return f(0,0,grid,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool valid(int i,int j,int n,int m)\\n{\\n if(i==n||j==m||i<0||j<0)return false;\\n return true;\\n}\\n bool f(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n {   if(i==grid.size()-1&&j==grid[0].size()-1)return true;\\n    \\n    vis[i][j]=1;\\n     cout<<i<<\" \"<<j<<endl;\\n     bool b=false;\\n     if(grid[i][j]==1)\\n     {\\n         if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==1||grid[i][j-1]==4||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==1||grid[i][j+1]==3||grid[i][j+1]==5))\\n    b=f(i,j+1,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==2)\\n     {\\n  \\n    if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==2||grid[i-1][j]==4||grid[i-1][j]==3))\\n    b=f(i-1,j,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==2||grid[i+1][j]==5||grid[i+1][j]==6))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==3)\\n     {\\nif(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==4||grid[i][j-1]==1||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==4)\\n     { \\nif(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n      if(grid[i][j]==5)\\n     {\\n         \\n    if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==3||grid[i][j-1]==4||grid[i][j-1]==1))\\n    b=f(i,j-1,grid,vis);\\n     if(b==true)return true;\\n     if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n    return b;\\n  \\n     }\\n      if(grid[i][j]==6)\\n     {  \\nif(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n     if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n   \\n    return  b;\\n     }\\n     return false;\\n }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return f(0,0,grid,vis);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4059129,
                "title": "rust-dfs-iterative",
                "content": "# Approach\\n1. A stack is used to store tuples of `(i, j, d)`, where `[i, j]` is the coordinate and `d` represents the direction and `0 <= d < 4`.\\n2. `cell` is a 2D boolean array storing information of all street types, where `cell[x][d]` indicates from a street of value `x`, whether we can move in direction `d`.\\n3. A visited position will be marked with `grid[i][j] = 0;`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn has_valid_path(mut grid: Vec<Vec<i32>>) -> bool {\\n        if grid.len() == 1 && grid[0].len() == 1 {\\n            return true;\\n        }\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let cell = [\\n            [false, false, false, false],\\n            [true, false, true, false],\\n            [false, true, false, true],\\n            [false, true, true, false],\\n            [true, true, false, false],\\n            [false, false, true, true],\\n            [true, false, false, true]\\n        ];\\n        let mut stack = Vec::<(usize, usize, usize)>::new();\\n        for d in 0..4 {\\n            if cell[grid[0][0] as usize][d] {\\n                stack.push((0, 0, d));\\n            }\\n        }\\n        grid[0][0] = 0;\\n        while let Some((i, j, d)) = stack.pop() {\\n            let i2 = i.wrapping_add(dir[d]);\\n            let j2 = j.wrapping_add(dir[d + 1]);\\n            let d_inv = (d + 2) % 4;\\n            if i2 < grid.len()\\n            && j2 < grid[i2].len()\\n            && cell[grid[i2][j2] as usize][d_inv] {\\n                if i2 == grid.len() - 1\\n                && j2 == grid[i2].len() - 1 {\\n                    return true;\\n                }\\n                for d2 in 0..4 {\\n                    if d2 != d_inv\\n                    && cell[grid[i2][j2] as usize][d2] {\\n                        stack.push((i2, j2, d2));\\n                    }\\n                }\\n                grid[i2][j2] = 0;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn has_valid_path(mut grid: Vec<Vec<i32>>) -> bool {\\n        if grid.len() == 1 && grid[0].len() == 1 {\\n            return true;\\n        }\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let cell = [\\n            [false, false, false, false],\\n            [true, false, true, false],\\n            [false, true, false, true],\\n            [false, true, true, false],\\n            [true, true, false, false],\\n            [false, false, true, true],\\n            [true, false, false, true]\\n        ];\\n        let mut stack = Vec::<(usize, usize, usize)>::new();\\n        for d in 0..4 {\\n            if cell[grid[0][0] as usize][d] {\\n                stack.push((0, 0, d));\\n            }\\n        }\\n        grid[0][0] = 0;\\n        while let Some((i, j, d)) = stack.pop() {\\n            let i2 = i.wrapping_add(dir[d]);\\n            let j2 = j.wrapping_add(dir[d + 1]);\\n            let d_inv = (d + 2) % 4;\\n            if i2 < grid.len()\\n            && j2 < grid[i2].len()\\n            && cell[grid[i2][j2] as usize][d_inv] {\\n                if i2 == grid.len() - 1\\n                && j2 == grid[i2].len() - 1 {\\n                    return true;\\n                }\\n                for d2 in 0..4 {\\n                    if d2 != d_inv\\n                    && cell[grid[i2][j2] as usize][d2] {\\n                        stack.push((i2, j2, d2));\\n                    }\\n                }\\n                grid[i2][j2] = 0;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051051,
                "title": "c-bfs-approach",
                "content": "# Intuition\\nmovement from each cell is restricted so we need to check which cell we can move ; these checks are prety exaustive so see carefully and you will understand\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //do bfs and find the path;\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        queue<int> q;\\n        q.push(0);vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            int i = node/m, j = node%m;\\n            \\n            if(i == n-1 && j == m-1)return true;\\n\\n            \\n            if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4){ //try down\\n                if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)){\\n                    vis[i+1][j] = 1;\\n                    q.push((i+1)*m + j);\\n                }\\n            }\\n            if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6){ //try up\\n                if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                    vis[i-1][j] = 1;\\n                    q.push((i-1)*m + j);\\n                }\\n            }\\n\\n            if(grid[i][j] ==1 || grid[i][j] == 3 || grid[i][j] == 5){ //try left\\n                  if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 5 || grid[i][j-1] == 4)){\\n                    vis[i][j-1] = 1;\\n                    q.push((i)*m + j-1);\\n                }\\n            }\\n\\n            if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6){ //try right\\n                  if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5)){\\n                    vis[i][j+1] = 1;\\n                    q.push((i)*m + j+1);\\n                }\\n            }\\n\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //do bfs and find the path;\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        queue<int> q;\\n        q.push(0);vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            int i = node/m, j = node%m;\\n            \\n            if(i == n-1 && j == m-1)return true;\\n\\n            \\n            if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4){ //try down\\n                if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)){\\n                    vis[i+1][j] = 1;\\n                    q.push((i+1)*m + j);\\n                }\\n            }\\n            if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6){ //try up\\n                if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                    vis[i-1][j] = 1;\\n                    q.push((i-1)*m + j);\\n                }\\n            }\\n\\n            if(grid[i][j] ==1 || grid[i][j] == 3 || grid[i][j] == 5){ //try left\\n                  if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 5 || grid[i][j-1] == 4)){\\n                    vis[i][j-1] = 1;\\n                    q.push((i)*m + j-1);\\n                }\\n            }\\n\\n            if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6){ //try right\\n                  if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5)){\\n                    vis[i][j+1] = 1;\\n                    q.push((i)*m + j+1);\\n                }\\n            }\\n\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042995,
                "title": "beats-95-solution-dfs-matrix",
                "content": "![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/f9b87021-ad04-4d23-bb58-12c9b3c4d0fe_1694677295.7041726.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean  chk(int grid[][],int i,int j){ \\n// you pass the matrix grid mark it as -1;\\n        grid[i][j]=-1;\\n// if you reah final return true;\\n        if(i==grid.length-1 && j== grid[0].length-1){return true;}\\n        return false;\\n    }\\n    public static boolean call(int x,int y,int i,int j,int grid[][]){  \\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==-1 ){ \\n            return false;\\n        }\\n   // mainly you have yo remember that you are checking the parent of particular cell if particular cell has parent from where you came then it is good else at last it will return falsewe   \\n![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/b90b40a3-a485-444f-a15a-efe561c44f16_1694677278.1096072.jpeg)\\n\\n        if(grid[i][j]==1 &&((i==x && j-1==y) || (i==x && j+1==y) || (x==-1 && y==-1)) ){\\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i,j+1,grid) || call(i,j,i,j-1,grid);\\n        }\\n        else if(grid[i][j]==2 && ((i-1==x && j==y)  || (i+1==x && j==y)|| (x==-1 && y==-1) )){ \\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i-1,j,grid) || call(i,j,i+1,j,grid); \\n        }\\n        else if(grid[i][j]==3 && ((i==x && j-1==y) || (i+1==x && j==y) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n             return call(i,j,i,j-1,grid) || call(i,j,i+1,j,grid);\\n        }  \\n        else if(grid[i][j]==4 && ( (i+1==x && j==y) || (i==x && j+1==y) ||( x==-1 && y==-1))  ){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j+1,grid) || call(i,j,i+1,j,grid);\\n        }\\n        else if(grid[i][j]==5 && ( ( i==x && j-1==y)|| ( i-1==x && j==y ) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j-1,grid) || call(i,j,i-1,j,grid);\\n        }\\n        else if(grid[i][j]==6 && ( ( i==x && j+1==y) || ( i-1==x && j==y ) || (x==-1 && y==-1))){\\n                  if(chk(grid,i,j)){return true;}\\n                return call(i,j,i,j+1,grid) || call(i,j,i-1,j,grid);\\n\\n        }\\n\\n        return false;\\n    \\n\\n\\n    }\\n\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        return call(-1,-1,0,0,grid);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean  chk(int grid[][],int i,int j){ \\n// you pass the matrix grid mark it as -1;\\n        grid[i][j]=-1;\\n// if you reah final return true;\\n        if(i==grid.length-1 && j== grid[0].length-1){return true;}\\n        return false;\\n    }\\n    public static boolean call(int x,int y,int i,int j,int grid[][]){  \\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==-1 ){ \\n            return false;\\n        }\\n   // mainly you have yo remember that you are checking the parent of particular cell if particular cell has parent from where you came then it is good else at last it will return falsewe   \\n![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/b90b40a3-a485-444f-a15a-efe561c44f16_1694677278.1096072.jpeg)\\n\\n        if(grid[i][j]==1 &&((i==x && j-1==y) || (i==x && j+1==y) || (x==-1 && y==-1)) ){\\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i,j+1,grid) || call(i,j,i,j-1,grid);\\n        }\\n        else if(grid[i][j]==2 && ((i-1==x && j==y)  || (i+1==x && j==y)|| (x==-1 && y==-1) )){ \\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i-1,j,grid) || call(i,j,i+1,j,grid); \\n        }\\n        else if(grid[i][j]==3 && ((i==x && j-1==y) || (i+1==x && j==y) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n             return call(i,j,i,j-1,grid) || call(i,j,i+1,j,grid);\\n        }  \\n        else if(grid[i][j]==4 && ( (i+1==x && j==y) || (i==x && j+1==y) ||( x==-1 && y==-1))  ){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j+1,grid) || call(i,j,i+1,j,grid);\\n        }\\n        else if(grid[i][j]==5 && ( ( i==x && j-1==y)|| ( i-1==x && j==y ) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j-1,grid) || call(i,j,i-1,j,grid);\\n        }\\n        else if(grid[i][j]==6 && ( ( i==x && j+1==y) || ( i-1==x && j==y ) || (x==-1 && y==-1))){\\n                  if(chk(grid,i,j)){return true;}\\n                return call(i,j,i,j+1,grid) || call(i,j,i-1,j,grid);\\n\\n        }\\n\\n        return false;\\n    \\n\\n\\n    }\\n\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        return call(-1,-1,0,0,grid);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035731,
                "title": "cpp-straight-forward-solution-an-attempt-for-improving-readability",
                "content": "I think this problem is easy but a bit tricky to implement.\\nHaven\\'t found a way to write a short while easy understanding solution.\\n\\n# Code\\n```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> directions {\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    }; // down, up, right, left\\n    enum {\\n        down = 0, up = 1, right = 2, left = 3\\n    };\\n    bool atValidPosition(int x, int y)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n\\n        // we need to make sure the first street can connect downward or rightward\\n        int initType {grid[0][0]};\\n        if (initType == 5) return false;\\n        if (initType == 1 || initType == 6) return explore(grid, right);\\n        if (initType == 2 || initType == 3) return explore(grid, down);\\n        return explore(grid, down) || explore(grid, right);\\n    }\\n    bool explore(const vector<vector<int>>& grid, int dir)\\n    {\\n        int x {}, y {};\\n        vector<vector<int>> visited(m, vector(n, 0)); // to avoid cycles\\n        while (atValidPosition(x, y))\\n        {\\n            if (x == m-1 && y == n-1) return true; // end\\n            if (visited[x][y]) return false;\\n            visited[x][y] = 1; \\n\\n            int dx {directions[dir][0]}, dy {directions[dir][1]};\\n            x += dx, y += dy;\\n\\n            if (!atValidPosition(x, y)) return false;\\n\\n            // after making sure the next position is valid\\n            // we need to check if we can make to the next position actually\\n\\n            // given current direction and next type of street\\n            // we can determine if next is reachable from current street\\n            // if it is reachable, we may change current direction according\\n            // to the type of the next street \\n            if ((dir = validMove(dir, grid[x][y])) == -1) return false;\\n        }\\n        return false;\\n    }\\n    int validMove(int dir, int nextType) \\n    {   // if move is invalid return -1\\n        switch (nextType) // down = 0, up = 1, right = 2, left = 3\\n        {\\n        case 1: // accept right or left direction, and do not change direction\\n            if (dir == right || dir == left) return dir; \\n            break;\\n\\n        case 2: // accept down or up direction, and do not change direction\\n            if (dir == down || dir == up) return dir;\\n            break;\\n\\n        case 3: // accept right and return down, or accept up and return left\\n            if (dir == right) return down;\\n            if (dir == up) return left;\\n            break;\\n\\n        case 4: // accept left and return down, or accept up and return right\\n            if (dir == left) return down;\\n            if (dir == up) return right;\\n            break;\\n\\n        case 5: // accept down and return left, or accept right and return up\\n            if (dir == down) return left;\\n            if (dir == right) return up;\\n            break;\\n        \\n        case 6: // accept down and return right, or accept left and return up\\n            if (dir == down) return right;\\n            if (dir == left) return up;\\n            break;\\n\\n        default:\\n            break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> directions {\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    }; // down, up, right, left\\n    enum {\\n        down = 0, up = 1, right = 2, left = 3\\n    };\\n    bool atValidPosition(int x, int y)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n\\n        // we need to make sure the first street can connect downward or rightward\\n        int initType {grid[0][0]};\\n        if (initType == 5) return false;\\n        if (initType == 1 || initType == 6) return explore(grid, right);\\n        if (initType == 2 || initType == 3) return explore(grid, down);\\n        return explore(grid, down) || explore(grid, right);\\n    }\\n    bool explore(const vector<vector<int>>& grid, int dir)\\n    {\\n        int x {}, y {};\\n        vector<vector<int>> visited(m, vector(n, 0)); // to avoid cycles\\n        while (atValidPosition(x, y))\\n        {\\n            if (x == m-1 && y == n-1) return true; // end\\n            if (visited[x][y]) return false;\\n            visited[x][y] = 1; \\n\\n            int dx {directions[dir][0]}, dy {directions[dir][1]};\\n            x += dx, y += dy;\\n\\n            if (!atValidPosition(x, y)) return false;\\n\\n            // after making sure the next position is valid\\n            // we need to check if we can make to the next position actually\\n\\n            // given current direction and next type of street\\n            // we can determine if next is reachable from current street\\n            // if it is reachable, we may change current direction according\\n            // to the type of the next street \\n            if ((dir = validMove(dir, grid[x][y])) == -1) return false;\\n        }\\n        return false;\\n    }\\n    int validMove(int dir, int nextType) \\n    {   // if move is invalid return -1\\n        switch (nextType) // down = 0, up = 1, right = 2, left = 3\\n        {\\n        case 1: // accept right or left direction, and do not change direction\\n            if (dir == right || dir == left) return dir; \\n            break;\\n\\n        case 2: // accept down or up direction, and do not change direction\\n            if (dir == down || dir == up) return dir;\\n            break;\\n\\n        case 3: // accept right and return down, or accept up and return left\\n            if (dir == right) return down;\\n            if (dir == up) return left;\\n            break;\\n\\n        case 4: // accept left and return down, or accept up and return right\\n            if (dir == left) return down;\\n            if (dir == up) return right;\\n            break;\\n\\n        case 5: // accept down and return left, or accept right and return up\\n            if (dir == down) return left;\\n            if (dir == right) return up;\\n            break;\\n        \\n        case 6: // accept down and return right, or accept left and return up\\n            if (dir == down) return right;\\n            if (dir == left) return up;\\n            break;\\n\\n        default:\\n            break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030384,
                "title": "dfs-simple-solution-with-comments-intuitive",
                "content": "# Intuition\\nThis looks like a graph problem we just need to figure out how to connect the cells\\n\\n# Approach\\nIf you are on a cell with street 1 then you can move to either left or right. If you chose to move left then your next cell must be either 1 or or 6 then only it will be connected. Similary if you chose to move right then next cell must be either 1 or 3 or 5.\\nThat\\'s how we can connect cells and solve it using DFS.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<char>>mp; //to map the streets with the direction they can lead\\n    unordered_map<char,vector<int>>dir; // this will map if you want to go to right which street must be there by which you can move to that direction\\n    unordered_map<char,vector<int>>change; // simply change in coordinates if you move to that direction\\n\\n//dfs\\n    bool dfs(vector<vector<int>>& grid,vector<vector<bool>>&vis,int row,int col){\\n        vis[row][col]=true;\\n        int n = grid.size(),m = grid[0].size();\\n        if(row==n-1 && col==m-1) return true;\\n        for(auto i:mp[grid[row][col]]){ //if the grid[row][col] is 1 then I can only move either to left or right similarly to others\\n            char d = i;\\n            int r = row+change[d][0]; // if I am going to left then this will be my coordinates change ie next cell will be r,c\\n            int c = col+change[d][1];\\n            if(r>=0 && r<n && c>=0 && c<m && !vis[r][c]){\\n                for(auto j:dir[d]){\\n                    if(grid[r][c]==j){ // to move left my next cell should be either 1,4,6 so I am checking if my [r][c] has any of these. \\n                        if(dfs(grid,vis,r,c)) return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        mp[1] ={\\'l\\',\\'r\\'}; // By 1 I can move either left or right.\\n        mp[2] ={\\'u\\',\\'d\\'}; // By 2 I can move either up or or down.\\n        mp[3] ={\\'l\\',\\'d\\'};\\n        mp[4] ={\\'r\\',\\'d\\'};\\n        mp[5] ={\\'u\\',\\'l\\'};\\n        mp[6] ={\\'u\\',\\'r\\'};\\n\\n        dir[\\'l\\'] = {1,4,6}; // I want to move left then the next cell should be either 1,4,6\\n        dir[\\'r\\'] = {1,3,5};\\n        dir[\\'u\\'] = {2,3,4};\\n        dir[\\'d\\'] = {2,5,6};\\n\\n        change[\\'l\\'] ={0,-1}; // if I move left my row col will be row+0,col-1\\n        change[\\'r\\'] ={0,1};\\n        change[\\'u\\'] ={-1,0};\\n        change[\\'d\\'] ={1,0};\\n\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        return dfs(grid,vis,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<char>>mp; //to map the streets with the direction they can lead\\n    unordered_map<char,vector<int>>dir; // this will map if you want to go to right which street must be there by which you can move to that direction\\n    unordered_map<char,vector<int>>change; // simply change in coordinates if you move to that direction\\n\\n//dfs\\n    bool dfs(vector<vector<int>>& grid,vector<vector<bool>>&vis,int row,int col){\\n        vis[row][col]=true;\\n        int n = grid.size(),m = grid[0].size();\\n        if(row==n-1 && col==m-1) return true;\\n        for(auto i:mp[grid[row][col]]){ //if the grid[row][col] is 1 then I can only move either to left or right similarly to others\\n            char d = i;\\n            int r = row+change[d][0]; // if I am going to left then this will be my coordinates change ie next cell will be r,c\\n            int c = col+change[d][1];\\n            if(r>=0 && r<n && c>=0 && c<m && !vis[r][c]){\\n                for(auto j:dir[d]){\\n                    if(grid[r][c]==j){ // to move left my next cell should be either 1,4,6 so I am checking if my [r][c] has any of these. \\n                        if(dfs(grid,vis,r,c)) return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        mp[1] ={\\'l\\',\\'r\\'}; // By 1 I can move either left or right.\\n        mp[2] ={\\'u\\',\\'d\\'}; // By 2 I can move either up or or down.\\n        mp[3] ={\\'l\\',\\'d\\'};\\n        mp[4] ={\\'r\\',\\'d\\'};\\n        mp[5] ={\\'u\\',\\'l\\'};\\n        mp[6] ={\\'u\\',\\'r\\'};\\n\\n        dir[\\'l\\'] = {1,4,6}; // I want to move left then the next cell should be either 1,4,6\\n        dir[\\'r\\'] = {1,3,5};\\n        dir[\\'u\\'] = {2,3,4};\\n        dir[\\'d\\'] = {2,5,6};\\n\\n        change[\\'l\\'] ={0,-1}; // if I move left my row col will be row+0,col-1\\n        change[\\'r\\'] ={0,1};\\n        change[\\'u\\'] ={-1,0};\\n        change[\\'d\\'] ={1,0};\\n\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        return dfs(grid,vis,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029092,
                "title": "python-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool: \\n        n=len(grid)\\n        m=len(grid[0])\\n        a=[0]\\n        v=set() \\n         \\n        d={\\n            \\'down\\':[\\n                [2,3,4],[2,5,6]\\n            ],\\n            \\'right\\':[\\n                [1,4,6],[1,3,5]\\n            ],\\n            \\'up\\':[\\n                [2,5,6],[2,3,4]\\n            ],\\n            \\'left\\':[\\n                [1,3,5],[1,4,6]\\n            ]\\n        }   \\n\\n        def dfs(i,j):\\n            if (i,j) in v:\\n                return\\n            if i==n-1 and j==m-1:\\n                a[0]=1\\n                return\\n            v.add((i,j))\\n    \\n            if i-1>=0:\\n                if grid[i][j] in d[\\'up\\'][0] and grid[i-1][j] in d[\\'up\\'][1]:\\n                    dfs(i-1,j)\\n\\n            if i+1<n:\\n                if grid[i][j] in d[\\'down\\'][0] and grid[i+1][j] in d[\\'down\\'][1]:\\n                    dfs(i+1,j)\\n\\n            if j-1>=0:\\n                if grid[i][j] in d[\\'left\\'][0] and grid[i][j-1] in d[\\'left\\'][1]:\\n                    dfs(i,j-1)\\n\\n            if j+1<m:\\n                if grid[i][j] in d[\\'right\\'][0] and grid[i][j+1] in d[\\'right\\'][1]:\\n                    dfs(i,j+1)\\n\\n        dfs(0,0)\\n        return a[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool: \\n        n=len(grid)\\n        m=len(grid[0])\\n        a=[0]\\n        v=set() \\n         \\n        d={\\n            \\'down\\':[\\n                [2,3,4],[2,5,6]\\n            ],\\n            \\'right\\':[\\n                [1,4,6],[1,3,5]\\n            ],\\n            \\'up\\':[\\n                [2,5,6],[2,3,4]\\n            ],\\n            \\'left\\':[\\n                [1,3,5],[1,4,6]\\n            ]\\n        }   \\n\\n        def dfs(i,j):\\n            if (i,j) in v:\\n                return\\n            if i==n-1 and j==m-1:\\n                a[0]=1\\n                return\\n            v.add((i,j))\\n    \\n            if i-1>=0:\\n                if grid[i][j] in d[\\'up\\'][0] and grid[i-1][j] in d[\\'up\\'][1]:\\n                    dfs(i-1,j)\\n\\n            if i+1<n:\\n                if grid[i][j] in d[\\'down\\'][0] and grid[i+1][j] in d[\\'down\\'][1]:\\n                    dfs(i+1,j)\\n\\n            if j-1>=0:\\n                if grid[i][j] in d[\\'left\\'][0] and grid[i][j-1] in d[\\'left\\'][1]:\\n                    dfs(i,j-1)\\n\\n            if j+1<m:\\n                if grid[i][j] in d[\\'right\\'][0] and grid[i][j+1] in d[\\'right\\'][1]:\\n                    dfs(i,j+1)\\n\\n        dfs(0,0)\\n        return a[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016672,
                "title": "c-with-floodfill",
                "content": "# Intuition\\nuse floodfill and check current step and next step\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int iHeight;\\n    int iWidth;\\n    int bRet = false;\\n    void floodfill(vector<vector<int>>& grid, vector<vector<int>>& path, int i, int j, int pre_i, int pre_j)\\n    {\\n        if(i==iHeight-1 && j==iWidth-1) \\n        {\\n            bRet = true;\\n            return;\\n        }\\n        if(path[i][j] == 1 || bRet == true) return;\\n\\n        path[i][j]=1;\\n\\n        if(i-1>=0 && path[i-1][j] ==0 && (i-1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6)&&(grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4))\\n            floodfill(grid, path, i-1, j, i, j);\\n\\n        if(i+1<iHeight && path[i+1][j] ==0 && (i+1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4)&&(grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6))\\n            floodfill(grid, path, i+1, j, i, j);\\n\\n        if(j-1>=0 && path[i][j-1] ==0 && (j-1 !=pre_j) &&\\n(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5)&&(grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6))\\n            floodfill(grid, path, i, j-1, i, j);            \\n\\n        if(j+1<iWidth && path[i][j+1] ==0 && (j+1 !=pre_j) && \\n(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6)&&(grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5))\\n            floodfill(grid, path, i, j+1, i, j);            \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        iHeight = grid.size();\\n        iWidth = grid[0].size();\\n        vector<vector<int>> path(iHeight, vector<int>(iWidth, 0));\\n        floodfill(grid, path, 0, 0, -1, -1);\\n\\n        return bRet;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int iHeight;\\n    int iWidth;\\n    int bRet = false;\\n    void floodfill(vector<vector<int>>& grid, vector<vector<int>>& path, int i, int j, int pre_i, int pre_j)\\n    {\\n        if(i==iHeight-1 && j==iWidth-1) \\n        {\\n            bRet = true;\\n            return;\\n        }\\n        if(path[i][j] == 1 || bRet == true) return;\\n\\n        path[i][j]=1;\\n\\n        if(i-1>=0 && path[i-1][j] ==0 && (i-1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6)&&(grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4))\\n            floodfill(grid, path, i-1, j, i, j);\\n\\n        if(i+1<iHeight && path[i+1][j] ==0 && (i+1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4)&&(grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6))\\n            floodfill(grid, path, i+1, j, i, j);\\n\\n        if(j-1>=0 && path[i][j-1] ==0 && (j-1 !=pre_j) &&\\n(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5)&&(grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6))\\n            floodfill(grid, path, i, j-1, i, j);            \\n\\n        if(j+1<iWidth && path[i][j+1] ==0 && (j+1 !=pre_j) && \\n(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6)&&(grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5))\\n            floodfill(grid, path, i, j+1, i, j);            \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        iHeight = grid.size();\\n        iWidth = grid[0].size();\\n        vector<vector<int>> path(iHeight, vector<int>(iWidth, 0));\\n        floodfill(grid, path, 0, 0, -1, -1);\\n\\n        return bRet;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974103,
                "title": "python-dfs-1159ms-beat-90",
                "content": "Standard iterative DFS. \\nCode is pretty much self-explanatory.\\nFor each direction each cell can go, check if we can go to that direction.\\nIf we can go to that direction, and the cell in that direction is not yet visited, push it onto the stack.\\nThe hardest part is to write clean and easy-to-read code :)\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n\\n# Code\\n**Easy-to-understand version:**\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [\"LEFT\", \"RIGHT\"],\\n            2: [\"UP\", \"DOWN\"],\\n            3: [\"LEFT\", \"DOWN\"],\\n            4: [\"DOWN\", \"RIGHT\"],\\n            5: [\"LEFT\", \"UP\"],\\n            6: [\"UP\", \"RIGHT\"]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for direction in directions[curr_cell]:\\n                if direction == \"LEFT\":\\n                    i, j = curr_i, curr_j - 1\\n                    if j >= 0 and \"RIGHT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"RIGHT\":\\n                    i, j = curr_i, curr_j + 1\\n                    if j < n and \"LEFT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"UP\":\\n                    i, j = curr_i - 1, curr_j\\n                    if i >= 0 and \"DOWN\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"DOWN\":\\n                    i, j = curr_i + 1, curr_j\\n                    if i < m and \"UP\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n        return False\\n```\\n**Simplied Version:**\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        LEFT, RIGHT, UP, DOWN = (0, -1), (0, 1), (-1, 0), (1, 0)\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [LEFT, RIGHT],\\n            2: [UP, DOWN],\\n            3: [LEFT, DOWN],\\n            4: [DOWN, RIGHT],\\n            5: [LEFT, UP],\\n            6: [UP, RIGHT]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for di, dj in directions[curr_cell]:\\n                i, j = curr_i + di, curr_j + dj\\n                if 0 <= i and i < m and 0 <= j and j < n and (-di, -dj) in directions[grid[i][j]] and (i, j) not in visited:\\n                    stack.append((i, j, grid[i][j]))\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [\"LEFT\", \"RIGHT\"],\\n            2: [\"UP\", \"DOWN\"],\\n            3: [\"LEFT\", \"DOWN\"],\\n            4: [\"DOWN\", \"RIGHT\"],\\n            5: [\"LEFT\", \"UP\"],\\n            6: [\"UP\", \"RIGHT\"]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for direction in directions[curr_cell]:\\n                if direction == \"LEFT\":\\n                    i, j = curr_i, curr_j - 1\\n                    if j >= 0 and \"RIGHT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"RIGHT\":\\n                    i, j = curr_i, curr_j + 1\\n                    if j < n and \"LEFT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"UP\":\\n                    i, j = curr_i - 1, curr_j\\n                    if i >= 0 and \"DOWN\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"DOWN\":\\n                    i, j = curr_i + 1, curr_j\\n                    if i < m and \"UP\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n        return False\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        LEFT, RIGHT, UP, DOWN = (0, -1), (0, 1), (-1, 0), (1, 0)\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [LEFT, RIGHT],\\n            2: [UP, DOWN],\\n            3: [LEFT, DOWN],\\n            4: [DOWN, RIGHT],\\n            5: [LEFT, UP],\\n            6: [UP, RIGHT]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for di, dj in directions[curr_cell]:\\n                i, j = curr_i + di, curr_j + dj\\n                if 0 <= i and i < m and 0 <= j and j < n and (-di, -dj) in directions[grid[i][j]] and (i, j) not in visited:\\n                    stack.append((i, j, grid[i][j]))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972676,
                "title": "cleanest-and-most-intuitive-c-program-i-have-ever-written",
                "content": "# Intuition\\nSelf explanatory.\\n\\n# Approach\\nSelf explanatory.\\n\\n# Complexity\\n- Time complexity:\\nO(n**2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool valid(int i,int j, vector<vector<int >> &grid){\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1) return 0;\\n        return 1;\\n    }\\n\\n    void DFS(vector<vector<int>>& grid, int i, int j){\\n\\n        //cout<<i<<\" \"<<j<<endl;\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1 || grid[i][j]==-1) return;\\n\\n        else if(grid[i][j]==1){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==6 || grid[i][j-1] == 1)) DFS(grid, i, j-1);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==3 || grid[i][j+1]==5 || grid[i][j+1] == 1)) DFS(grid, i, j+1);\\n        }\\n\\n        else if(grid[i][j]==2){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==5 || grid[i+1][j]==6 || grid[i+1][j] == 2)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==3){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==4){\\n            grid[i][j] = -1;\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==5){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==1 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n        }\\n\\n        else if(grid[i][j]==6){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n        }\\n\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        DFS(grid, 0, 0);\\n        return grid[grid.size()-1][grid[0].size()-1] == -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool valid(int i,int j, vector<vector<int >> &grid){\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1) return 0;\\n        return 1;\\n    }\\n\\n    void DFS(vector<vector<int>>& grid, int i, int j){\\n\\n        //cout<<i<<\" \"<<j<<endl;\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1 || grid[i][j]==-1) return;\\n\\n        else if(grid[i][j]==1){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==6 || grid[i][j-1] == 1)) DFS(grid, i, j-1);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==3 || grid[i][j+1]==5 || grid[i][j+1] == 1)) DFS(grid, i, j+1);\\n        }\\n\\n        else if(grid[i][j]==2){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==5 || grid[i+1][j]==6 || grid[i+1][j] == 2)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==3){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==4){\\n            grid[i][j] = -1;\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==5){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==1 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n        }\\n\\n        else if(grid[i][j]==6){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n        }\\n\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        DFS(grid, 0, 0);\\n        return grid[grid.size()-1][grid[0].size()-1] == -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3953267,
                "title": "longest-bfs-ever-c-straightforward-if-else",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLiterally just went through every possibility that a path has to join with another path.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, pair<int,int>>> q;\\n        q.push({grid[0][0], {0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            if(val==1){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==2){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            else if(val==3){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==4){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1] = 1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2)){\\n                    vis[row+1][col] = 1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                \\n            }\\n            else if(val==5){\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==3 || grid[row-1][col]==4 || grid[row-1][col]==2)){\\n                    vis[row-1][col] = 1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==6 || grid[row][col-1]==4 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==6){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            \\n        }\\n        if(vis[m-1][n-1]==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, pair<int,int>>> q;\\n        q.push({grid[0][0], {0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            if(val==1){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==2){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            else if(val==3){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==4){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1] = 1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2)){\\n                    vis[row+1][col] = 1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                \\n            }\\n            else if(val==5){\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==3 || grid[row-1][col]==4 || grid[row-1][col]==2)){\\n                    vis[row-1][col] = 1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==6 || grid[row][col-1]==4 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==6){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            \\n        }\\n        if(vis[m-1][n-1]==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947025,
                "title": "python-bfs-with-complicated-next-state-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding a path through a maze can be done using the following schema for a Breadth-First Search (BFS):\\n1. Pick starting point and put in queue\\n2. While the queue is not empty, take current point\\n3. If current point equals stopping point, return True\\n4. Find successor(s) to current point and put in queue\\n5. If queue is empty, return False\\n\\nAmong these steps, number 4 -- finding successor points -- is the trickiest part:  We assume that a queue entry consists of *two* parts:  A point to move into, and a direction (N, W, S, E) to move\\ninto the point.  Given the point, we can look up its street configuration (1-6) and from that we can determine what the next point will be *and* what direction to move into it.  Then, that next point must be checked for validity:  Has it not been visited yet, and is it within the bounds of the ```grid```.\\n\\nThere\\'s one further wrinkle on step number 4, namely what to do about the ```start_point```:  We don\\'t really have a direction that we entered that point, so we look at the street configuration in ```start_point``` and check *both* of its entrances/exits for validity.  Generally, there will be 0, 1 or 2 successor points.  If it\\'s 0, then we\\'re done and return ```False```; otherwise, we push the successor(s) into the queue and start the BFS traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we encode the information about the problem like:  for each street configuration, what two directions does its two entrances/exits face.  Second, we look at the first point\\'s street configuration to determine the 0, 1, or 2 entrance/exit to push in the queue.\\n\\nThird, we enter the BFS loop following the schema in Intuition.  We pop the current square and entry direction from the queue, then see whether we\\'ve reach the ```stopping_point```.  If not, then determine which exit direction we\\'ll take, see if it\\'s valid, and if so, push it in the queue.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case, the path from the start point to the stopping point passes through every square in the grid, and each square must be pushed, popped, and processed.  Thus, the time complexity is proportional to the number of grid points, which is $$O(n*m)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIgnoring the input (```grid```), the only structure that may grow with the input is the ```queue```.  At worst (mainly in degenerate cases) the ```queue``` will have to hold $$O(n*m)$$ entries, hence this is the overall space complexity.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hasValidPath(self, grid: list[list[int]]) -> bool:\\n        nrows = len( grid ); ncols = len( grid[ 0 ] )\\n        # Directions:\\n        N = 0; W = 1; S = 2; E = 3\\n        dir_names = { N : \"N\", W : \"W\", S : \"S\", E : \"E\" }\\n        streets = { 1: (W, E), 2: (N, S), 3: (W, S), 4: (S, E), 5: (N, W),  6: (N, E)  }\\n        otherDirs = {N: S, W: E, S: N, E: W}\\n        self.moves = {N: (-1, 0), W: (0, -1), S: (1, 0), E: (0, 1)}\\n        visited = set()\\n\\n        # Do a breadth-first search, starting at grid square (0,0); this\\n        # requires a little extra work to figure out what the exit is,\\n        # based on the blockage to the North and West.\\n        start_square = (0, 0)\\n        stop_square = (len(grid) - 1, len(grid[0]) - 1 )\\n        if start_square == stop_square:\\n            return True\\n        visited.add(start_square)\\n        queue = []\\n        start_street = grid[0][0]\\n        if start_street == 5:  # Stuck in the corner!\\n            return False\\n        for street_port in streets[start_street]:\\n            dir_name = dir_names[ street_port ]\\n            if street_port == S:\\n                next_square = (1, 0)\\n                next_row, next_col = next_square\\n                if (0 <= next_row < nrows) and (0 <= next_col < ncols):\\n                    next_entrance = N\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n            elif street_port == E:\\n                next_square = (0, 1)\\n                next_row, next_col = next_square\\n                if ( 0 <= next_row < nrows ) and ( 0 <= next_col < ncols ):\\n                    next_entrance = W\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n        # OK, we\\'ve put one or two next square into the queue.  Now,\\n        # start going through the queue:\\n        while queue:\\n            curr_square, curr_entrance = queue.pop(0)\\n            if curr_square == stop_square:\\n                return True\\n            else:\\n                curr_row, curr_col = curr_square\\n                curr_street = grid[ curr_row ][ curr_col ]\\n                street_port1, street_port2 = streets[curr_street]\\n                if street_port1 == curr_entrance:\\n                    curr_exit = street_port2\\n                elif street_port2 == curr_entrance:\\n                    curr_exit = street_port1\\n                next_entrance = otherDirs[curr_exit]\\n                next_square = self.moveFromSquare(curr_square, curr_exit)\\n                next_row, next_col = next_square\\n                # See if \"next_square\" is OK to move into; if so, put it in the queue:\\n                if ( next_square not in visited ):\\n                    if ( 0 <= next_row < nrows ):\\n                        if ( 0 <= next_col < ncols ):\\n                            next_street = grid[next_row][next_col]\\n                            next_ports = streets[next_street]\\n                            if ( next_entrance in next_ports ):\\n                                queue.append( ( next_square, next_entrance ) )\\n                                visited.add( next_square )\\n        return False\\n    # Given \"curr_square\" and \"curr_exit\" direction from it, return\\n    # the (row, col) of the square to move to:\\n    def moveFromSquare(self, curr_square, curr_exit):\\n        d_row, d_col = self.moves[curr_exit]\\n        result = (curr_square[0] + d_row, curr_square[1] + d_col)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```grid```\n```start_point```\n```start_point```\n```False```\n```stopping_point```\n```grid```\n```queue```\n```queue```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hasValidPath(self, grid: list[list[int]]) -> bool:\\n        nrows = len( grid ); ncols = len( grid[ 0 ] )\\n        # Directions:\\n        N = 0; W = 1; S = 2; E = 3\\n        dir_names = { N : \"N\", W : \"W\", S : \"S\", E : \"E\" }\\n        streets = { 1: (W, E), 2: (N, S), 3: (W, S), 4: (S, E), 5: (N, W),  6: (N, E)  }\\n        otherDirs = {N: S, W: E, S: N, E: W}\\n        self.moves = {N: (-1, 0), W: (0, -1), S: (1, 0), E: (0, 1)}\\n        visited = set()\\n\\n        # Do a breadth-first search, starting at grid square (0,0); this\\n        # requires a little extra work to figure out what the exit is,\\n        # based on the blockage to the North and West.\\n        start_square = (0, 0)\\n        stop_square = (len(grid) - 1, len(grid[0]) - 1 )\\n        if start_square == stop_square:\\n            return True\\n        visited.add(start_square)\\n        queue = []\\n        start_street = grid[0][0]\\n        if start_street == 5:  # Stuck in the corner!\\n            return False\\n        for street_port in streets[start_street]:\\n            dir_name = dir_names[ street_port ]\\n            if street_port == S:\\n                next_square = (1, 0)\\n                next_row, next_col = next_square\\n                if (0 <= next_row < nrows) and (0 <= next_col < ncols):\\n                    next_entrance = N\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n            elif street_port == E:\\n                next_square = (0, 1)\\n                next_row, next_col = next_square\\n                if ( 0 <= next_row < nrows ) and ( 0 <= next_col < ncols ):\\n                    next_entrance = W\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n        # OK, we\\'ve put one or two next square into the queue.  Now,\\n        # start going through the queue:\\n        while queue:\\n            curr_square, curr_entrance = queue.pop(0)\\n            if curr_square == stop_square:\\n                return True\\n            else:\\n                curr_row, curr_col = curr_square\\n                curr_street = grid[ curr_row ][ curr_col ]\\n                street_port1, street_port2 = streets[curr_street]\\n                if street_port1 == curr_entrance:\\n                    curr_exit = street_port2\\n                elif street_port2 == curr_entrance:\\n                    curr_exit = street_port1\\n                next_entrance = otherDirs[curr_exit]\\n                next_square = self.moveFromSquare(curr_square, curr_exit)\\n                next_row, next_col = next_square\\n                # See if \"next_square\" is OK to move into; if so, put it in the queue:\\n                if ( next_square not in visited ):\\n                    if ( 0 <= next_row < nrows ):\\n                        if ( 0 <= next_col < ncols ):\\n                            next_street = grid[next_row][next_col]\\n                            next_ports = streets[next_street]\\n                            if ( next_entrance in next_ports ):\\n                                queue.append( ( next_square, next_entrance ) )\\n                                visited.add( next_square )\\n        return False\\n    # Given \"curr_square\" and \"curr_exit\" direction from it, return\\n    # the (row, col) of the square to move to:\\n    def moveFromSquare(self, curr_square, curr_exit):\\n        d_row, d_col = self.moves[curr_exit]\\n        result = (curr_square[0] + d_row, curr_square[1] + d_col)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936607,
                "title": "c-easy-clean-bfs-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool b=0;\\n     vector<vector<int>> w;\\n  void t(vector<vector<int>>& v,int i,int j,int m,int n)\\n        {\\n          if(i<0 || j<0 || i>=m || j>=n || w[i][j]) return ;\\n          if(i==v.size()-1 && j==v[0].size()-1)\\n          {\\n              b=1;\\n              return ;\\n          }   \\n          w[i][j]=1;\\n         if(v[i][j]==1 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         \\n         if(v[i][j]==1 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==6 || v[i][j-1]==1))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==2 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n         \\n         if(v[i][j]==2 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==4 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n\\n         if(v[i][j]==4 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==5 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==5 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==6 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==6 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         }\\n\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> h(m+1,vector<int> (n+1,0));\\n        w=h;\\n\\n        t(g,0,0,m,n);\\n\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool b=0;\\n     vector<vector<int>> w;\\n  void t(vector<vector<int>>& v,int i,int j,int m,int n)\\n        {\\n          if(i<0 || j<0 || i>=m || j>=n || w[i][j]) return ;\\n          if(i==v.size()-1 && j==v[0].size()-1)\\n          {\\n              b=1;\\n              return ;\\n          }   \\n          w[i][j]=1;\\n         if(v[i][j]==1 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         \\n         if(v[i][j]==1 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==6 || v[i][j-1]==1))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==2 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n         \\n         if(v[i][j]==2 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==4 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n\\n         if(v[i][j]==4 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==5 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==5 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==6 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==6 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         }\\n\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> h(m+1,vector<int> (n+1,0));\\n        w=h;\\n\\n        t(g,0,0,m,n);\\n\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935860,
                "title": "cpp-implementation-beats-98-memory-beats-95-time",
                "content": "## **``v[a][b][c]`` denotes that one can move from sheet ``a`` to sheet ``c`` by taking action ``b``.**\\n\\n**Conventions used for moves are as :**\\n1. ``left -> 0``.\\n2. ``right -> 1``.\\n3. ``up -> 2``.\\n4. ``down -> 3``.\\n\\nFor example,``v[1][0][4]``denotes one can move from ``sheet1`` to ``sheet4`` by taking ``left`` turn.\\n\\nThis pre definition helps us to determine the safe move from the current sheets to its adjacents, and we keep on doing ``BFS`` untill we reach at that sheet from where we can\\'t get safe path.\\n\\n\\nAt this node we\\'ll check whether it is bottom rightmost sheet or not.\\n\\nIf Yes, return``true``else return ``false``. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> v(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n        v[1][0][4]=1;\\n        v[1][0][6]=1;                        \\n        v[1][0][1]=1;                        // 0->left\\n                                             // 1->right\\n        v[1][1][1]=1;                        //2->up\\n        v[1][1][3]=1;                        //3->down\\n        v[1][1][5]=1;\\n\\n        v[2][2][2]=1;\\n        v[2][2][3]=1;\\n        v[2][2][4]=1;\\n\\n        v[2][3][2]=1;\\n        v[2][3][5]=1;\\n        v[2][3][6]=1;\\n\\n        v[3][0][1]=1;\\n        v[3][0][4]=1;\\n        v[3][0][6]=1;\\n\\n        v[3][3][2]=1;\\n        v[3][3][6]=1;\\n        v[3][3][5]=1;\\n\\n        v[4][3][2]=1;\\n        v[4][3][6]=1;\\n        v[4][3][5]=1;\\n\\n        v[4][1][1]=1;\\n        v[4][1][3]=1;\\n        v[4][1][5]=1;\\n\\n        v[5][0][1]=1;\\n        v[5][0][4]=1;\\n        v[5][0][6]=1;\\n\\n        v[5][2][2]=1;\\n        v[5][2][3]=1;\\n        v[5][2][4]=1;\\n\\n        v[6][2][2]=1;\\n        v[6][2][3]=1;\\n        v[6][2][4]=1;\\n\\n        v[6][1][1]=1;\\n        v[6][1][3]=1;\\n        v[6][1][5]=1;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        grid[0][0]=-grid[0][0];\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int sheet=-grid[x][y];\\n            if(x==m-1 && y==n-1)return true;\\n            if(y-1>=0){\\n                if(grid[x][y-1]>0 && v[sheet][0][grid[x][y-1]]){\\n                    q.push({x,y-1});\\n                    grid[x][y-1] = -grid[x][y-1];\\n                }\\n            }\\n            if(y+1<n){\\n                if(grid[x][y+1]>0 && v[sheet][1][grid[x][y+1]]){\\n                    q.push({x,y+1});\\n                    grid[x][y+1] = -grid[x][y+1];\\n                }\\n            }\\n            if(x-1>=0){\\n                if(grid[x-1][y]>0 && v[sheet][2][grid[x-1][y]]){\\n                    q.push({x-1,y});\\n                    grid[x-1][y] = -grid[x-1][y];\\n                }\\n            }\\n            if(x+1<m){\\n                if(grid[x+1][y]>0 && v[sheet][3][grid[x+1][y]]){\\n                    q.push({x+1,y});\\n                    grid[x+1][y] = -grid[x+1][y];\\n                }\\n            }\\n        }\\n    return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> v(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n        v[1][0][4]=1;\\n        v[1][0][6]=1;                        \\n        v[1][0][1]=1;                        // 0->left\\n                                             // 1->right\\n        v[1][1][1]=1;                        //2->up\\n        v[1][1][3]=1;                        //3->down\\n        v[1][1][5]=1;\\n\\n        v[2][2][2]=1;\\n        v[2][2][3]=1;\\n        v[2][2][4]=1;\\n\\n        v[2][3][2]=1;\\n        v[2][3][5]=1;\\n        v[2][3][6]=1;\\n\\n        v[3][0][1]=1;\\n        v[3][0][4]=1;\\n        v[3][0][6]=1;\\n\\n        v[3][3][2]=1;\\n        v[3][3][6]=1;\\n        v[3][3][5]=1;\\n\\n        v[4][3][2]=1;\\n        v[4][3][6]=1;\\n        v[4][3][5]=1;\\n\\n        v[4][1][1]=1;\\n        v[4][1][3]=1;\\n        v[4][1][5]=1;\\n\\n        v[5][0][1]=1;\\n        v[5][0][4]=1;\\n        v[5][0][6]=1;\\n\\n        v[5][2][2]=1;\\n        v[5][2][3]=1;\\n        v[5][2][4]=1;\\n\\n        v[6][2][2]=1;\\n        v[6][2][3]=1;\\n        v[6][2][4]=1;\\n\\n        v[6][1][1]=1;\\n        v[6][1][3]=1;\\n        v[6][1][5]=1;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        grid[0][0]=-grid[0][0];\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int sheet=-grid[x][y];\\n            if(x==m-1 && y==n-1)return true;\\n            if(y-1>=0){\\n                if(grid[x][y-1]>0 && v[sheet][0][grid[x][y-1]]){\\n                    q.push({x,y-1});\\n                    grid[x][y-1] = -grid[x][y-1];\\n                }\\n            }\\n            if(y+1<n){\\n                if(grid[x][y+1]>0 && v[sheet][1][grid[x][y+1]]){\\n                    q.push({x,y+1});\\n                    grid[x][y+1] = -grid[x][y+1];\\n                }\\n            }\\n            if(x-1>=0){\\n                if(grid[x-1][y]>0 && v[sheet][2][grid[x-1][y]]){\\n                    q.push({x-1,y});\\n                    grid[x-1][y] = -grid[x-1][y];\\n                }\\n            }\\n            if(x+1<m){\\n                if(grid[x+1][y]>0 && v[sheet][3][grid[x+1][y]]){\\n                    q.push({x+1,y});\\n                    grid[x+1][y] = -grid[x+1][y];\\n                }\\n            }\\n        }\\n    return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896427,
                "title": "c-beats-99-25-and-super-concise-solution-with-explanation",
                "content": "# Intuition\\nCheck arrival at current cell is possible or not and then continue the path in possible ways as per current cell\\'s alignment\\n# Approach\\n1. From previous cell we arrived at curren cell. We check if any path is possible from the directions we used to arrive at current cell from previous cell\\n2. Invalidate current cell as it is visited\\n3. Look out for valid path emerging out of current cell and pass on the **directions** used to arrive at next cell\\n# Complexity\\n- Time complexity:\\nDFS approach - O(m*n)\\n\\n- Space complexity:\\nOccupied by the variables in the recursive calls - O(m*n)\\nNo \\'visited\\' matrix required here saving lots of memory!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n, temp;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        int i=0, j=0;\\n        return helper(0, 0, 2, 2, grid);// passed 2 as it only matters if hdir and vdir are in {-1,0,1}\\n    }\\n    // hdir, vdir => direction in which the CURRENT CELL is APPROACHED FROM PREVIOUS CELL\\n    // if approached from top then vertical direction = -1\\n    // approached from bottom then vertical direction = 1\\n    // appproached from left then horizontal direction = 1\\n    // approached from right then horizontal direction = -1\\n    bool helper(int i, int j, int hdir, int vdir, vector<vector<int>>& grid){\\n        // if outliers then return false\\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0) return false;\\n        temp = grid[i][j];\\n        // check if the way currrent cell is approached, path is possible or not\\n        if((temp == 1 && (vdir==1 || vdir==-1)) // arriving from bottom or top is invalid\\n        || (temp == 2 && (hdir==-1 || hdir==1)) // arriving from right or left is invalid\\n        || (temp == 3 && (hdir==-1 || vdir==-1)) // arriving from right or up is invalid\\n        || (temp == 4 && (hdir==1 || vdir==-1)) // arriving from left or up is invalid\\n        || (temp == 5 && (hdir==-1 || vdir==1)) // arriving from right or down is invalid\\n        || (temp == 6 && (hdir==1 || vdir==1))) // arriving from left or down is invalid\\n            return false;\\n        // if approach is valid and we reached bottom right cell return true\\n        if(i==m-1 && j==n-1) return true;\\n        // assign 0 to already approached cell to mark it as VISITED\\n        grid[i][j] = 0;\\n        // as per current cell, try all possible paths with direction which is selected\\n        if(temp == 1) return helper(i, j+1, 1, 0, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 2) return helper(i-1, j, 0, 1, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 3) return helper(i, j-1, -1, 0, grid)|| helper(i+1, j, 0, -1, grid);\\n        if(temp == 4) return helper(i, j+1, 1, 0, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 5) return helper(i-1, j, 0, 1, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 6) return helper(i-1, j, 0, 1, grid) || helper(i, j+1, 1, 0, grid);\\n        // retain original value in recursion if no solution is found\\n        grid[i][j] = temp;\\n        // no solution so return false\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, temp;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        int i=0, j=0;\\n        return helper(0, 0, 2, 2, grid);// passed 2 as it only matters if hdir and vdir are in {-1,0,1}\\n    }\\n    // hdir, vdir => direction in which the CURRENT CELL is APPROACHED FROM PREVIOUS CELL\\n    // if approached from top then vertical direction = -1\\n    // approached from bottom then vertical direction = 1\\n    // appproached from left then horizontal direction = 1\\n    // approached from right then horizontal direction = -1\\n    bool helper(int i, int j, int hdir, int vdir, vector<vector<int>>& grid){\\n        // if outliers then return false\\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0) return false;\\n        temp = grid[i][j];\\n        // check if the way currrent cell is approached, path is possible or not\\n        if((temp == 1 && (vdir==1 || vdir==-1)) // arriving from bottom or top is invalid\\n        || (temp == 2 && (hdir==-1 || hdir==1)) // arriving from right or left is invalid\\n        || (temp == 3 && (hdir==-1 || vdir==-1)) // arriving from right or up is invalid\\n        || (temp == 4 && (hdir==1 || vdir==-1)) // arriving from left or up is invalid\\n        || (temp == 5 && (hdir==-1 || vdir==1)) // arriving from right or down is invalid\\n        || (temp == 6 && (hdir==1 || vdir==1))) // arriving from left or down is invalid\\n            return false;\\n        // if approach is valid and we reached bottom right cell return true\\n        if(i==m-1 && j==n-1) return true;\\n        // assign 0 to already approached cell to mark it as VISITED\\n        grid[i][j] = 0;\\n        // as per current cell, try all possible paths with direction which is selected\\n        if(temp == 1) return helper(i, j+1, 1, 0, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 2) return helper(i-1, j, 0, 1, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 3) return helper(i, j-1, -1, 0, grid)|| helper(i+1, j, 0, -1, grid);\\n        if(temp == 4) return helper(i, j+1, 1, 0, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 5) return helper(i-1, j, 0, 1, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 6) return helper(i-1, j, 0, 1, grid) || helper(i, j+1, 1, 0, grid);\\n        // retain original value in recursion if no solution is found\\n        grid[i][j] = temp;\\n        // no solution so return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893462,
                "title": "c-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=0 && y>=0 && x<n && y<m)\\n        return true;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n       map<int,vector<vector<int>>> dir;\\n       dir[1] = {{0,-1},{0,1}};\\n       dir[2] = {{-1,0},{1,0}};\\n       dir[3] = {{0,-1},{1,0}};\\n       dir[4] = {{0,1},{1,0}};\\n       dir[5] = {{-1,0},{0,-1}};\\n       dir[6] = {{-1,0},{0,1}};\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       queue<vector<int>> q;\\n       q.push({0,0});\\n       vector<vector<int>> vis(n,vector<int>(m,0));\\n       while(!q.empty())\\n       {\\n           int x = q.front()[0];\\n           int y = q.front()[1];\\n           q.pop();\\n           if(x==n-1 && y==m-1)\\n           return true;\\n           int val = grid[x][y];\\n           vis[x][y] = 1;\\n           for(int j=0;j<dir[val].size();j++)\\n           {\\n               int newx = x+dir[val][j][0];\\n               int newy = y+dir[val][j][1];\\n               if(isValid(newx,newy,n,m) && vis[newx][newy]==0)\\n               {\\n                   int flg = 0;\\n                   int tmp = grid[newx][newy];\\n                   for(int k=0;k<dir[tmp].size();k++)\\n                   {\\n                       if(newx+dir[tmp][k][0]==x && \\n                       newy+dir[tmp][k][1]==y)\\n                       flg = 1;\\n                   }\\n                   if(flg)\\n                   q.push({newx,newy});\\n               }\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=0 && y>=0 && x<n && y<m)\\n        return true;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n       map<int,vector<vector<int>>> dir;\\n       dir[1] = {{0,-1},{0,1}};\\n       dir[2] = {{-1,0},{1,0}};\\n       dir[3] = {{0,-1},{1,0}};\\n       dir[4] = {{0,1},{1,0}};\\n       dir[5] = {{-1,0},{0,-1}};\\n       dir[6] = {{-1,0},{0,1}};\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       queue<vector<int>> q;\\n       q.push({0,0});\\n       vector<vector<int>> vis(n,vector<int>(m,0));\\n       while(!q.empty())\\n       {\\n           int x = q.front()[0];\\n           int y = q.front()[1];\\n           q.pop();\\n           if(x==n-1 && y==m-1)\\n           return true;\\n           int val = grid[x][y];\\n           vis[x][y] = 1;\\n           for(int j=0;j<dir[val].size();j++)\\n           {\\n               int newx = x+dir[val][j][0];\\n               int newy = y+dir[val][j][1];\\n               if(isValid(newx,newy,n,m) && vis[newx][newy]==0)\\n               {\\n                   int flg = 0;\\n                   int tmp = grid[newx][newy];\\n                   for(int k=0;k<dir[tmp].size();k++)\\n                   {\\n                       if(newx+dir[tmp][k][0]==x && \\n                       newy+dir[tmp][k][1]==y)\\n                       flg = 1;\\n                   }\\n                   if(flg)\\n                   q.push({newx,newy});\\n               }\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882958,
                "title": "fast-and-easy-java-solution-using-union-find-with-explanation-beats-80-43",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA valid path exists if there is a path from the first cell to the last cell in the grid so using union find if both of them have the same parent then there is a valid path.\\nMoving right and down only should be enough to check if the path exists. No need to move left or up as this is redundant.\\n\\nTo have an edge between two adjacent cells we have few possibilities that you can observe easily from the drawings\\n\\nFor example:\\n* If a cell can connect to another on its right, check if the other edge can connect to the cell on its left and so on.\\n\\nand as stated above you need to check if the right and down only. \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make 2 simple function of union find and the parent array (global).\\n2. Parent array size is the number of cells in the grid as each cell is considered as a node in the graph.\\n3. Loop over the grid and check the possible connections (take care of your boundaries).\\n4. If two cells can be connected, union these two.\\n5. Each cell is identified by its number from 0 to n * m - 1 using (row_num of the cell) * (overall colums number) + (col_num of the cell).\\n6. Check if the first and last cell of the grid are connected (Have the same parent).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n# Code\\n```\\nclass Solution {\\n    // Every cell will be identified uniquely from 0 to n * m - 1\\n    // using i * (number of columns) + j;\\n    int[] parent;\\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        // parent size = number of cells in the grid\\n        parent = new int[n * m];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j < m - 1){\\n                    int next = grid[i][j + 1];\\n                    int curr = grid[i][j];\\n                    if((curr == 1 || curr == 4 || curr == 6) \\n                    && (next == 1 || next == 3 || next == 5)) \\n                        union(i * m + j, i * m + j + 1);\\n                }\\n                if(i < n - 1){\\n                    int next = grid[i + 1][j];\\n                    int curr = grid[i][j];\\n                    if((curr == 2 || curr == 3 || curr == 4) \\n                    && (next == 2 || next == 6 || next == 5))\\n                        union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        int first = find(0);\\n        int last = find((n - 1) * m + m - 1);\\n        return first == last;\\n    }\\n    \\n    public int find(int x){\\n        if(parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public boolean union(int x, int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp == yp) return false;\\n        parent[yp] = xp;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    // Every cell will be identified uniquely from 0 to n * m - 1\\n    // using i * (number of columns) + j;\\n    int[] parent;\\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        // parent size = number of cells in the grid\\n        parent = new int[n * m];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j < m - 1){\\n                    int next = grid[i][j + 1];\\n                    int curr = grid[i][j];\\n                    if((curr == 1 || curr == 4 || curr == 6) \\n                    && (next == 1 || next == 3 || next == 5)) \\n                        union(i * m + j, i * m + j + 1);\\n                }\\n                if(i < n - 1){\\n                    int next = grid[i + 1][j];\\n                    int curr = grid[i][j];\\n                    if((curr == 2 || curr == 3 || curr == 4) \\n                    && (next == 2 || next == 6 || next == 5))\\n                        union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        int first = find(0);\\n        int last = find((n - 1) * m + m - 1);\\n        return first == last;\\n    }\\n    \\n    public int find(int x){\\n        if(parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public boolean union(int x, int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp == yp) return false;\\n        parent[yp] = xp;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860845,
                "title": "bfs-c-96-faster-1391-check-if-there-is-a-valid-path-in-a-grid",
                "content": "# Intuition\\nThe problem can be efficiently solved using a Breadth-First Search (BFS) approach.\\n\\n# Approach\\n1. Start the BFS from the current Pipe.\\n2. Explore the neighboring Pipes that are connected through its open side.\\n3. If a neighboring Pipe has an open side, move to that Pipe.\\n4. Repeat steps 2 and 3 until you either reach the end Pipe or exhaust all possibilities.\\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of pipes in the input.\\n\\n- Space complexity: O(N) for the Queue used in the BFS algorithm.\\n\\nIf you find this helpful, please consider starring my GitHub repository:\\n[https://github.com/ZadeAbhishek/DSA-Dev](https://github.com/ZadeAbhishek/DSA-Dev)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> grid;\\n    queue<pair<int,int>> que;\\n    \\n    // check if the left side is present or not\\n    bool left(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 3 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the right side is present or not\\n    bool right(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 4 || curr == 6) return true;\\n        return false;\\n    }\\n\\n    // check if the top side is present or not\\n    bool top(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 6 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the bottom side is present or not\\n    bool bottom(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 3 || curr == 4) return true;\\n        return false;\\n    }\\n    \\n\\n    // check validity of coordinates\\n    bool isValid(int x, int y){\\n        if(x < 0 || y < 0 || x > grid.size()-1 || y > grid[0].size()-1) return false;\\n        return true;\\n    }\\n    \\n    // check if right side has left or not\\n    void pushLeft(int currX, int currY){\\n         if(isValid(currX,currY+1) && left(currX,currY+1) && grid[currX][currY+1] != 0){\\n                    que.push({currX,currY+1});\\n            }\\n            return;\\n    }\\n\\n    // check if left side have right or not\\n    void pushRight(int currX, int currY){\\n         if(isValid(currX,currY-1) && right(currX,currY-1) && grid[currX][currY-1] != 0){\\n                    que.push({currX,currY-1});\\n            }\\n            return;\\n    }\\n\\n    // check if bottom has top or not\\n    void pushTop(int currX, int currY){\\n         if(isValid(currX+1,currY) && top(currX+1,currY) && grid[currX+1][currY] != 0){\\n                    que.push({currX+1,currY});\\n            }\\n            return;\\n    }\\n\\n    // check if top has bottom or not\\n    void pushBottom(int currX, int currY){\\n         if(isValid(currX-1,currY) && bottom(currX-1,currY) && grid[currX-1][currY] != 0){\\n                    que.push({currX-1,currY});\\n        }\\n            return;\\n    }\\n\\n\\n\\n    bool traverse(int x, int y){\\n        \\n        // push starting coordinate in queue\\n        que.push({x,y}); \\n\\n        while(!que.empty()){\\n            \\n            // get current Coordinates\\n            auto currX = que.front().first;\\n            auto currY = que.front().second;\\n            que.pop();\\n\\n            // base case if we reached end return true\\n            if(currX == grid.size()-1 && currY == grid[0].size()-1) return true;\\n            \\n            // get current pipe/number of pipe\\n            int currPipe = grid[currX][currY];\\n\\n            // mark visited\\n            grid[currX][currY] = 0;\\n            \\n            /*\\n            Depend upon current pipe we will check its neighbour\\n            for example if currPipe is 1 we check right side of curr has\\n            left or not or left side of current has right or not\\n            */\\n            switch(currPipe){\\n                case 1:\\n                pushLeft(currX,currY); // check right has left or not\\n                pushRight(currX,currY); // check left has right or not\\n                break;\\n\\n                case 2:\\n                pushTop(currX,currY);  // check bottom has top or not\\n                pushBottom(currX,currY); // check top has bottom or not\\n                break;\\n\\n                case 3:\\n                pushTop(currX,currY);\\n                pushTop(currX,currY);\\n                break;\\n\\n                case 4:\\n                pushTop(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                case 5:\\n                pushBottom(currX,currY);\\n                pushRight(currX,currY);\\n                break;\\n\\n                case 6:\\n                pushBottom(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                default:\\n                break;\\n            \\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public:\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        grid = g;\\n        // pipes direction check\\n        return traverse(0,0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> grid;\\n    queue<pair<int,int>> que;\\n    \\n    // check if the left side is present or not\\n    bool left(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 3 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the right side is present or not\\n    bool right(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 4 || curr == 6) return true;\\n        return false;\\n    }\\n\\n    // check if the top side is present or not\\n    bool top(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 6 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the bottom side is present or not\\n    bool bottom(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 3 || curr == 4) return true;\\n        return false;\\n    }\\n    \\n\\n    // check validity of coordinates\\n    bool isValid(int x, int y){\\n        if(x < 0 || y < 0 || x > grid.size()-1 || y > grid[0].size()-1) return false;\\n        return true;\\n    }\\n    \\n    // check if right side has left or not\\n    void pushLeft(int currX, int currY){\\n         if(isValid(currX,currY+1) && left(currX,currY+1) && grid[currX][currY+1] != 0){\\n                    que.push({currX,currY+1});\\n            }\\n            return;\\n    }\\n\\n    // check if left side have right or not\\n    void pushRight(int currX, int currY){\\n         if(isValid(currX,currY-1) && right(currX,currY-1) && grid[currX][currY-1] != 0){\\n                    que.push({currX,currY-1});\\n            }\\n            return;\\n    }\\n\\n    // check if bottom has top or not\\n    void pushTop(int currX, int currY){\\n         if(isValid(currX+1,currY) && top(currX+1,currY) && grid[currX+1][currY] != 0){\\n                    que.push({currX+1,currY});\\n            }\\n            return;\\n    }\\n\\n    // check if top has bottom or not\\n    void pushBottom(int currX, int currY){\\n         if(isValid(currX-1,currY) && bottom(currX-1,currY) && grid[currX-1][currY] != 0){\\n                    que.push({currX-1,currY});\\n        }\\n            return;\\n    }\\n\\n\\n\\n    bool traverse(int x, int y){\\n        \\n        // push starting coordinate in queue\\n        que.push({x,y}); \\n\\n        while(!que.empty()){\\n            \\n            // get current Coordinates\\n            auto currX = que.front().first;\\n            auto currY = que.front().second;\\n            que.pop();\\n\\n            // base case if we reached end return true\\n            if(currX == grid.size()-1 && currY == grid[0].size()-1) return true;\\n            \\n            // get current pipe/number of pipe\\n            int currPipe = grid[currX][currY];\\n\\n            // mark visited\\n            grid[currX][currY] = 0;\\n            \\n            /*\\n            Depend upon current pipe we will check its neighbour\\n            for example if currPipe is 1 we check right side of curr has\\n            left or not or left side of current has right or not\\n            */\\n            switch(currPipe){\\n                case 1:\\n                pushLeft(currX,currY); // check right has left or not\\n                pushRight(currX,currY); // check left has right or not\\n                break;\\n\\n                case 2:\\n                pushTop(currX,currY);  // check bottom has top or not\\n                pushBottom(currX,currY); // check top has bottom or not\\n                break;\\n\\n                case 3:\\n                pushTop(currX,currY);\\n                pushTop(currX,currY);\\n                break;\\n\\n                case 4:\\n                pushTop(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                case 5:\\n                pushBottom(currX,currY);\\n                pushRight(currX,currY);\\n                break;\\n\\n                case 6:\\n                pushBottom(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                default:\\n                break;\\n            \\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public:\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        grid = g;\\n        // pipes direction check\\n        return traverse(0,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858258,
                "title": "easy-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis){\\n        vis[row][col] = 1;\\n        if(row==grid.size()-1 && col == grid[0].size()-1) return true;\\n        //case 1:\\n        if(grid[row][col]==1){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        // case 2:\\n        if(grid[row][col]==2){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 3:\\n        if(grid[row][col]==3){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 4:\\n        if(grid[row][col]==4){\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 5:\\n        if(grid[row][col]==5){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 6:\\n        if(grid[row][col]==6){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        return dfs(0,0,grid,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis){\\n        vis[row][col] = 1;\\n        if(row==grid.size()-1 && col == grid[0].size()-1) return true;\\n        //case 1:\\n        if(grid[row][col]==1){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        // case 2:\\n        if(grid[row][col]==2){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 3:\\n        if(grid[row][col]==3){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 4:\\n        if(grid[row][col]==4){\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 5:\\n        if(grid[row][col]==5){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 6:\\n        if(grid[row][col]==6){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        return dfs(0,0,grid,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807043,
                "title": "dfs-at-its-finest-faster-than-98-ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool help(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n    \\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n\\n        bool flag = false;\\n\\n        if(grid[i][j]==1){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==2){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==3){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==4){\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==5){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==6){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        vis[0][0]++;\\n        return help(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool help(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n    \\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n\\n        bool flag = false;\\n\\n        if(grid[i][j]==1){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==2){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==3){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==4){\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==5){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==6){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        vis[0][0]++;\\n        return help(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779660,
                "title": "very-scuffed-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\n        def backtrack(visited, location):\\n            visitedCopy = visited\\n            currR, currC = location[0], location[1]\\n            if location in visited:\\n                return False\\n            visited.add(location)\\n            if location == (len(grid)-1, len(grid[0])-1):\\n                return True\\n            \\n            if grid[currR][currC] == 1:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                \\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                \\n                return temp\\n\\n            elif grid[currR][currC] == 2:\\n                #up\\n                temp = False\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 3:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 4:\\n                temp = False\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                return temp\\n            elif grid[currR][currC] == 5:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            else:\\n                #right\\n                temp = False\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            visited.remove(location)\\n\\n        return backtrack(set(), (0,0))\\n                \\n\\n                \\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\n        def backtrack(visited, location):\\n            visitedCopy = visited\\n            currR, currC = location[0], location[1]\\n            if location in visited:\\n                return False\\n            visited.add(location)\\n            if location == (len(grid)-1, len(grid[0])-1):\\n                return True\\n            \\n            if grid[currR][currC] == 1:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                \\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                \\n                return temp\\n\\n            elif grid[currR][currC] == 2:\\n                #up\\n                temp = False\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 3:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 4:\\n                temp = False\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                return temp\\n            elif grid[currR][currC] == 5:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            else:\\n                #right\\n                temp = False\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            visited.remove(location)\\n\\n        return backtrack(set(), (0,0))\\n                \\n\\n                \\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777924,
                "title": "java-simple-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] a) {\\n        dirMap = new HashMap<>();\\n        dirMap.put(1, new int[][]{{0,-1},{0,1}});\\n        dirMap.put(2, new int[][]{{-1,0},{1,0}});\\n        dirMap.put(3, new int[][]{{0,-1},{1,0}});\\n        dirMap.put(4, new int[][]{{0,1},{1,0}});\\n        dirMap.put(5, new int[][]{{0,-1},{-1,0}});\\n        dirMap.put(6, new int[][]{{0,1},{-1,0}});\\n        visited = new HashSet<>();\\n        return dfs(a, 0, 0);\\n    }\\n    static Map<Integer,int[][]> dirMap;\\n    static Set<List<Integer>> visited;\\n    static boolean dfs(int[][] a, int i, int j){\\n        List<Integer> list =new ArrayList<>();\\n        list.add(i); list.add(j);\\n        if(i<0 || j<0 || i>a.length-1 || j>a[0].length-1 || visited.contains(list)) return false;\\n        visited.add(list);\\n        if(i==a.length-1 && j==a[0].length-1) return true;\\n        for(int[] dir: dirMap.get(a[i][j])){\\n            // Next index in matrix\\n            int row = i + dir[0];\\n            int col = j + dir[1];\\n            if(row>=0 && col>=0 && row<a.length && col<a[0].length){\\n                // Check if we come back to previous index  \\n                for(int[] ndir: dirMap.get(a[row][col])){\\n                    int r = row + ndir[0];\\n                    int c = col + ndir[1];\\n                    if(r==i && c==j) {\\n                        if(dfs(a, row, col)) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] a) {\\n        dirMap = new HashMap<>();\\n        dirMap.put(1, new int[][]{{0,-1},{0,1}});\\n        dirMap.put(2, new int[][]{{-1,0},{1,0}});\\n        dirMap.put(3, new int[][]{{0,-1},{1,0}});\\n        dirMap.put(4, new int[][]{{0,1},{1,0}});\\n        dirMap.put(5, new int[][]{{0,-1},{-1,0}});\\n        dirMap.put(6, new int[][]{{0,1},{-1,0}});\\n        visited = new HashSet<>();\\n        return dfs(a, 0, 0);\\n    }\\n    static Map<Integer,int[][]> dirMap;\\n    static Set<List<Integer>> visited;\\n    static boolean dfs(int[][] a, int i, int j){\\n        List<Integer> list =new ArrayList<>();\\n        list.add(i); list.add(j);\\n        if(i<0 || j<0 || i>a.length-1 || j>a[0].length-1 || visited.contains(list)) return false;\\n        visited.add(list);\\n        if(i==a.length-1 && j==a[0].length-1) return true;\\n        for(int[] dir: dirMap.get(a[i][j])){\\n            // Next index in matrix\\n            int row = i + dir[0];\\n            int col = j + dir[1];\\n            if(row>=0 && col>=0 && row<a.length && col<a[0].length){\\n                // Check if we come back to previous index  \\n                for(int[] ndir: dirMap.get(a[row][col])){\\n                    int r = row + ndir[0];\\n                    int c = col + ndir[1];\\n                    if(r==i && c==j) {\\n                        if(dfs(a, row, col)) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777311,
                "title": "java-dfs-solution-clearly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem states the starting point is (0,0).\\n- we should keep in mind that the next possible direction of the route should also have a entry point to enter.\\n- When we reach a point from the previous point we need to go in possible directions (here we have only two possible directions for values 1 to 6)\\n- At every dfs call we need to handle the visited points so that we dont encounter any loop or tle.\\n- Below approach make you understand better. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a HashMap of opposite routes so that we can check the incoming route  can lead to enter the present point or not. Like l maps to r and vice versa.\\n- Create another hashmap for mapping direction to its correspoding row col direction. Like l maps to {0,-1} and so on.\\n- Create a array of Pair class where we can easily find the two possible directions for every point (1 to 6).\\n- Now start the dfs from (0,0) by taking the input direction any from a and b.\\n- In dfs, first we check if any of (i,j) are not out of bounds or have been already visited. If so we return false immediately.\\n- then we take the route from the grid and checks where the entered d direction can enter into the present route by checking from the opposite direction map. If no direction leads to enter the present point we return false.\\n- If we can enter the present (i,j) point then we check for the destination (m-1,n-1). If equals we return true.\\n- Else we try to go to the next two possible routes.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(7(array of pair class) + dirs + map + (m*n)recursive stack)--->   overall it comes to O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Character,Character> map;\\n    HashMap<Character,int[]> dirs;\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        map=new HashMap<>();\\n        dirs=new HashMap<>();\\n        dirs.put(\\'l\\',new int[]{0,-1});dirs.put(\\'r\\',new int[]{0,1});dirs.put(\\'t\\',new int[]{-1,0});\\n        dirs.put(\\'b\\',new int[]{1,0});\\n        map.put(\\'l\\',\\'r\\');map.put(\\'r\\',\\'l\\');map.put(\\'t\\',\\'b\\');map.put(\\'b\\',\\'t\\');\\n        Pair[] arr=new Pair[7];\\n        arr[1]=new Pair(\\'l\\',\\'r\\');\\n        arr[2]=new Pair(\\'t\\',\\'b\\');\\n        arr[3]=new Pair(\\'l\\',\\'b\\');\\n        arr[4]=new Pair(\\'r\\',\\'b\\');\\n        arr[5]=new Pair(\\'t\\',\\'l\\');\\n        arr[6]=new Pair(\\'t\\',\\'r\\');\\n        return dfs(grid,0,0,m,n,arr,map.get(arr[grid[0][0]].a));\\n    }\\n    public boolean dfs(int[][] grid,int i,int j,int m,int n,Pair[] arr,char d){\\n        if(Math.min(i,j)<0 || i>=m || j>=n || grid[i][j]==0)return false;\\n        int idx=grid[i][j];\\n        if(map.get(arr[idx].a)!=d && map.get(arr[idx].b)!=d)return false;\\n        if(i==m-1 && j==n-1)return true;\\n        grid[i][j]=0;\\n        char a=arr[idx].a;\\n        char b=arr[idx].b;\\n        int[] x=dirs.get(a);\\n        int[] y=dirs.get(b);\\n        return dfs(grid,i+x[0],j+x[1],m,n,arr,a) || dfs(grid,i+y[0],j+y[1],m,n,arr,b);\\n    }\\n}\\nclass Pair{\\n    char a;\\n    char b;\\n    Pair(char a,char b){\\n        this.a=a;\\n        this.b=b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character,Character> map;\\n    HashMap<Character,int[]> dirs;\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        map=new HashMap<>();\\n        dirs=new HashMap<>();\\n        dirs.put(\\'l\\',new int[]{0,-1});dirs.put(\\'r\\',new int[]{0,1});dirs.put(\\'t\\',new int[]{-1,0});\\n        dirs.put(\\'b\\',new int[]{1,0});\\n        map.put(\\'l\\',\\'r\\');map.put(\\'r\\',\\'l\\');map.put(\\'t\\',\\'b\\');map.put(\\'b\\',\\'t\\');\\n        Pair[] arr=new Pair[7];\\n        arr[1]=new Pair(\\'l\\',\\'r\\');\\n        arr[2]=new Pair(\\'t\\',\\'b\\');\\n        arr[3]=new Pair(\\'l\\',\\'b\\');\\n        arr[4]=new Pair(\\'r\\',\\'b\\');\\n        arr[5]=new Pair(\\'t\\',\\'l\\');\\n        arr[6]=new Pair(\\'t\\',\\'r\\');\\n        return dfs(grid,0,0,m,n,arr,map.get(arr[grid[0][0]].a));\\n    }\\n    public boolean dfs(int[][] grid,int i,int j,int m,int n,Pair[] arr,char d){\\n        if(Math.min(i,j)<0 || i>=m || j>=n || grid[i][j]==0)return false;\\n        int idx=grid[i][j];\\n        if(map.get(arr[idx].a)!=d && map.get(arr[idx].b)!=d)return false;\\n        if(i==m-1 && j==n-1)return true;\\n        grid[i][j]=0;\\n        char a=arr[idx].a;\\n        char b=arr[idx].b;\\n        int[] x=dirs.get(a);\\n        int[] y=dirs.get(b);\\n        return dfs(grid,i+x[0],j+x[1],m,n,arr,a) || dfs(grid,i+y[0],j+y[1],m,n,arr,b);\\n    }\\n}\\nclass Pair{\\n    char a;\\n    char b;\\n    Pair(char a,char b){\\n        this.a=a;\\n        this.b=b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768958,
                "title": "straight-forward-solution-bfs",
                "content": "`you can go to next cell and check whether you can come back.`\\n\\n`{{0, -1}, {0, 1}}`: This indicates that from a cell of street type 1, you can move either left or right.\\netc...........\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> direct({\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{0, 1}, {-1, 0}}\\n        });\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<vector<int>>Q;\\n        Q.push({0,0});\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        while(!Q.empty()){\\n            vector<int>curr=Q.front();\\n            Q.pop();\\n            int row=curr[0];\\n            int col=curr[1];\\n            for(auto &d:direct[grid[row][col]-1]){\\n                int nr=row+d[0];\\n                int nc=col+d[1];\\n                if(nr<0 || nr>=m || nc<0 || nc>=n || visited[nr][nc]){\\n                    continue;\\n                }\\n                for(auto &dir:direct[grid[nr][nc]-1]){\\n                    if(nr+dir[0]==row && nc+dir[1]==col){\\n                        visited[nr][nc]=true;\\n                        Q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m-1][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> direct({\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{0, 1}, {-1, 0}}\\n        });\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<vector<int>>Q;\\n        Q.push({0,0});\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        while(!Q.empty()){\\n            vector<int>curr=Q.front();\\n            Q.pop();\\n            int row=curr[0];\\n            int col=curr[1];\\n            for(auto &d:direct[grid[row][col]-1]){\\n                int nr=row+d[0];\\n                int nc=col+d[1];\\n                if(nr<0 || nr>=m || nc<0 || nc>=n || visited[nr][nc]){\\n                    continue;\\n                }\\n                for(auto &dir:direct[grid[nr][nc]-1]){\\n                    if(nr+dir[0]==row && nc+dir[1]==col){\\n                        visited[nr][nc]=true;\\n                        Q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m-1][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766424,
                "title": "javascript-union-find-475ms",
                "content": "Main idea: \\n(1) figure out all the cases of two board connections. here we use \\'H\\': horizontal to represent LR directions, V: vertical to represent UD directions\\n(2) union find to connect matrix node values: (i * m + j), answer is to check connectivity of [0, 0] and [n-1, m-1] node values.\\n```\\n////////////////////////// Template /////////////////////////\\nfunction DJSet(n) {\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n        return true;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n//////////////////////////////////////////////////////////\\n\\nconst hasValidPath = (g) => {\\n    let se = new Set([\\n        \\'H11\\', \\'H13\\', \\'H41\\', \\'H15\\', \\'H61\\',\\n        \\'V22\\', \\'V32\\', \\'V42\\', \\'V25\\', \\'V26\\',\\n        \\'H43\\', \\'V35\\', \\'V36\\', \\'H63\\',\\n        \\'V45\\', \\'H45\\', \\'V46\\',\\n        \\'H65\\']); // connected cases, example, H13: horizontal 1 -> 3  V32: vertical 3 -> 2\\n    let n = g.length, m = g[0].length, ds = new DJSet(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let mark; // build 4 cases, if connected, union nodes value: i * m + j\\n            if (i + 1 < n) {\\n                mark = \\'V\\' + g[i][j] + g[i + 1][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i + 1) * m + j)\\n            }\\n            if (i - 1 >= 0) {\\n                mark = \\'V\\' + g[i - 1][j] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i - 1) * m + j)\\n            }\\n            if (j + 1 < m) {\\n                mark = \\'H\\' + g[i][j] + g[i][j + 1];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j + 1);\\n            }\\n            if (j - 1 >= 0) {\\n                mark = \\'H\\' + g[i][j - 1] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j - 1);\\n            }\\n        }\\n    }\\n    return ds.equiv(0, (n - 1) * m + m - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n////////////////////////// Template /////////////////////////\\nfunction DJSet(n) {\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n        return true;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n//////////////////////////////////////////////////////////\\n\\nconst hasValidPath = (g) => {\\n    let se = new Set([\\n        \\'H11\\', \\'H13\\', \\'H41\\', \\'H15\\', \\'H61\\',\\n        \\'V22\\', \\'V32\\', \\'V42\\', \\'V25\\', \\'V26\\',\\n        \\'H43\\', \\'V35\\', \\'V36\\', \\'H63\\',\\n        \\'V45\\', \\'H45\\', \\'V46\\',\\n        \\'H65\\']); // connected cases, example, H13: horizontal 1 -> 3  V32: vertical 3 -> 2\\n    let n = g.length, m = g[0].length, ds = new DJSet(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let mark; // build 4 cases, if connected, union nodes value: i * m + j\\n            if (i + 1 < n) {\\n                mark = \\'V\\' + g[i][j] + g[i + 1][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i + 1) * m + j)\\n            }\\n            if (i - 1 >= 0) {\\n                mark = \\'V\\' + g[i - 1][j] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i - 1) * m + j)\\n            }\\n            if (j + 1 < m) {\\n                mark = \\'H\\' + g[i][j] + g[i][j + 1];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j + 1);\\n            }\\n            if (j - 1 >= 0) {\\n                mark = \\'H\\' + g[i][j - 1] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j - 1);\\n            }\\n        }\\n    }\\n    return ds.equiv(0, (n - 1) * m + m - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765490,
                "title": "python-union-find-with-template-to-use-everwhere",
                "content": "```\\nclass UnionFind:     # union find template to use every where with amorized O(1) time and O(n) space complexity\\n    def __init__(self):\\n        self.root = dict()\\n        self.rank = defaultdict(int)\\n\\n    def find(self, x):\\n        self.check(x)         # check if the x exist in self root \\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x]) # path compression\\n        return self.root[x]\\n    \\n    def check(self, node):\\n        if not node in self.root:      # add node:node key to root dict if node does not exist in root\\n            self.root[node] = node\\n        return\\n        \\n       \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:   # optimizing union function using rank\\n                self.root[rootY] = rootX\\n                \\n            elif self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n\\nclass Solution:\\n    def check(self, row, col):\\n        return 0 <= col < self.m and 0 <= row < self.n \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.n = len(grid)\\n        self.m = len(grid[0])\\n        n = len(grid)\\n        m = len(grid[0])\\n        uf = UnionFind()\\n        for row in range(n):\\n            for col in range(m):\\n                st = grid[row][col]\\n                if st == 1:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n                elif st == 2:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                elif st == 3:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                elif st == 4:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n                elif st == 6:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n        \\n        return uf.find((0, 0)) == uf.find((n - 1, m - 1))\\n",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "class Solution:\\n    def check(self, row, col):\\n        return 0 <= col < self.m and 0 <= row < self.n \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.n = len(grid)\\n        self.m = len(grid[0])\\n        n = len(grid)\\n        m = len(grid[0])\\n        uf = UnionFind()\\n        for row in range(n):\\n            for col in range(m):\\n                st = grid[row][col]\\n                if st == 1:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}",
                "codeTag": "Java"
            },
            {
                "id": 3748749,
                "title": "the-simplest-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow the path\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to follow the street and eliminate each street u have ben in until u end up in the bottom right corner, nothing special just want it to be so simple. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool HasValidPath(int[][] grid) {\\n        Dictionary<int, string[]> streets = new Dictionary<int, string[]>();\\n        streets.Add(0, new string[] { \"nothin\", \"nothing\" });\\n        streets.Add(1, new string[] { \"left\", \"right\" });\\n        streets.Add(2, new string[] { \"up\", \"down\" });\\n        streets.Add(3, new string[] { \"left\", \"down\" });\\n        streets.Add(4, new string[] { \"right\", \"down\" });\\n        streets.Add(5, new string[] { \"left\", \"up\" });\\n        streets.Add(6, new string[] { \"right\", \"up\" });\\n\\n        int iPos = 0;\\n        int jPos = 0;\\n        int firstStreet = grid[0][0];\\n        int currentStreet = grid[0][0];\\n        bool canWalkToNextStreet = true;\\n        bool walked = false;\\n        for (int i = 0; i < 2; i++)\\n        {\\n            if (i == 1)//if went right and got stuck, just go back and go down instead of right\\n            {\\n                iPos = 0;\\n                jPos = 0;\\n                currentStreet = firstStreet;\\n                grid[0][0] = firstStreet;\\n                canWalkToNextStreet = true;\\n                walked = false;\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n            }\\n\\n            while (canWalkToNextStreet)\\n            {\\n                walked = false;\\n                if (iPos - 1 >= 0 && !walked)\\n                {\\n                    //checkUp\\n                    if (streets[grid[iPos][jPos]][0] == \"up\" || streets[grid[iPos][jPos]][1] == \"up\")\\n                    {\\n                        if (streets[grid[iPos - 1][jPos]][0] == \"down\" || streets[grid[iPos - 1][jPos]][1] == \"down\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos - 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos--;\\n                        }\\n                    }\\n                }\\n                if (jPos + 1 <= grid[iPos].Length - 1 && !walked)\\n                {\\n                    //checkRight\\n                    if (streets[grid[iPos][jPos]][0] == \"right\" || streets[grid[iPos][jPos]][1] == \"right\")\\n                    {\\n                        if (streets[grid[iPos][jPos + 1]][0] == \"left\" || streets[grid[iPos][jPos + 1]][1] == \"left\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos + 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos++;\\n                        }\\n                    }\\n                }\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (jPos - 1 >= 0 && !walked)\\n                {\\n                    //checkLeft\\n                    if (streets[grid[iPos][jPos]][0] == \"left\" || streets[grid[iPos][jPos]][1] == \"left\")\\n                    {\\n                        if (streets[grid[iPos][jPos - 1]][0] == \"right\" || streets[grid[iPos][jPos - 1]][1] == \"right\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos - 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos--;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n                if (iPos == grid.Length - 1 && jPos == grid[grid.Length - 1].Length - 1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasValidPath(int[][] grid) {\\n        Dictionary<int, string[]> streets = new Dictionary<int, string[]>();\\n        streets.Add(0, new string[] { \"nothin\", \"nothing\" });\\n        streets.Add(1, new string[] { \"left\", \"right\" });\\n        streets.Add(2, new string[] { \"up\", \"down\" });\\n        streets.Add(3, new string[] { \"left\", \"down\" });\\n        streets.Add(4, new string[] { \"right\", \"down\" });\\n        streets.Add(5, new string[] { \"left\", \"up\" });\\n        streets.Add(6, new string[] { \"right\", \"up\" });\\n\\n        int iPos = 0;\\n        int jPos = 0;\\n        int firstStreet = grid[0][0];\\n        int currentStreet = grid[0][0];\\n        bool canWalkToNextStreet = true;\\n        bool walked = false;\\n        for (int i = 0; i < 2; i++)\\n        {\\n            if (i == 1)//if went right and got stuck, just go back and go down instead of right\\n            {\\n                iPos = 0;\\n                jPos = 0;\\n                currentStreet = firstStreet;\\n                grid[0][0] = firstStreet;\\n                canWalkToNextStreet = true;\\n                walked = false;\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n            }\\n\\n            while (canWalkToNextStreet)\\n            {\\n                walked = false;\\n                if (iPos - 1 >= 0 && !walked)\\n                {\\n                    //checkUp\\n                    if (streets[grid[iPos][jPos]][0] == \"up\" || streets[grid[iPos][jPos]][1] == \"up\")\\n                    {\\n                        if (streets[grid[iPos - 1][jPos]][0] == \"down\" || streets[grid[iPos - 1][jPos]][1] == \"down\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos - 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos--;\\n                        }\\n                    }\\n                }\\n                if (jPos + 1 <= grid[iPos].Length - 1 && !walked)\\n                {\\n                    //checkRight\\n                    if (streets[grid[iPos][jPos]][0] == \"right\" || streets[grid[iPos][jPos]][1] == \"right\")\\n                    {\\n                        if (streets[grid[iPos][jPos + 1]][0] == \"left\" || streets[grid[iPos][jPos + 1]][1] == \"left\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos + 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos++;\\n                        }\\n                    }\\n                }\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (jPos - 1 >= 0 && !walked)\\n                {\\n                    //checkLeft\\n                    if (streets[grid[iPos][jPos]][0] == \"left\" || streets[grid[iPos][jPos]][1] == \"left\")\\n                    {\\n                        if (streets[grid[iPos][jPos - 1]][0] == \"right\" || streets[grid[iPos][jPos - 1]][1] == \"right\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos - 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos--;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n                if (iPos == grid.Length - 1 && jPos == grid[grid.Length - 1].Length - 1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743957,
                "title": "c-easy-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep All directions in 3D vector\\n2. In BFS, restrict moves as per street number given in matrix[i][j]\\n3. Keep a visited matrix also, to avoid revisiting same cells\\n3. Check if the cell which we are moving to can recieve our movement. \\n4. For e.g. we have 2 direction left or right in street 1, so street 1 tells us to move right suppose, but we have street 2 to the right, which cannot recieve our movement\\n\\n\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743956,
                "title": "c-easy-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep All directions in 3D vector\\n2. In BFS, restrict moves as per street number given in matrix[i][j]\\n3. Keep a visited matrix also, to avoid revisiting same cells\\n3. Check if the cell which we are moving to can recieve our movement. \\n4. For e.g. we have 2 direction left or right in street 1, so street 1 tells us to move right suppose, but we have street 2 to the right, which cannot recieve our movement\\n\\n\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726821,
                "title": "dfs-dp-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[m*n]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[m*n]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> dp;\\n    bool hasValidPathHelper(int i,int j,vector<vector<int>>& grid,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]){\\n            return false;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return true;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        visited[i][j]=true;\\n        if(grid[i][j]==1){\\n            bool possibleLeft=false,possibleRight=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleRight;\\n        }\\n        else if(grid[i][j]==2){\\n            bool possibleUp=false,possibleDown=false;\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleUp || possibleDown;\\n        }\\n        else if(grid[i][j]==3){\\n            bool possibleLeft=false,possibleDown=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleDown;\\n        }\\n        else if(grid[i][j]==4){\\n            bool possibleRight=false,possibleDown=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleDown;\\n        }\\n        else if(grid[i][j]==5){\\n            bool possibleLeft=false,possibleUp=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleUp;\\n        }\\n        else if(grid[i][j]==6){\\n            bool possibleRight=false,possibleUp=false;\\n            if(j+1<n && grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleUp;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        visited=vector<vector<bool>> (m,vector<bool> (n,0));\\n        dp=vector<vector<int>> (m,vector<int> (n,-1));\\n        return hasValidPathHelper(0,0,grid,m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> dp;\\n    bool hasValidPathHelper(int i,int j,vector<vector<int>>& grid,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]){\\n            return false;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return true;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        visited[i][j]=true;\\n        if(grid[i][j]==1){\\n            bool possibleLeft=false,possibleRight=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleRight;\\n        }\\n        else if(grid[i][j]==2){\\n            bool possibleUp=false,possibleDown=false;\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleUp || possibleDown;\\n        }\\n        else if(grid[i][j]==3){\\n            bool possibleLeft=false,possibleDown=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleDown;\\n        }\\n        else if(grid[i][j]==4){\\n            bool possibleRight=false,possibleDown=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleDown;\\n        }\\n        else if(grid[i][j]==5){\\n            bool possibleLeft=false,possibleUp=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleUp;\\n        }\\n        else if(grid[i][j]==6){\\n            bool possibleRight=false,possibleUp=false;\\n            if(j+1<n && grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleUp;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        visited=vector<vector<bool>> (m,vector<bool> (n,0));\\n        dp=vector<vector<int>> (m,vector<int> (n,-1));\\n        return hasValidPathHelper(0,0,grid,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723257,
                "title": "simple-c-dfs-with-explanation-notes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we can see, there are only cells with exactly 2 entrances / exits. Thus, there are at most 2 ways to reach the final cell from the starting cell. Let\\'s employ DFS \\uD83D\\uDE09\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDepending on the cell kind we have a limited corresponding set of possible directions to go from that cell (aka we only have a limited set of allowed exits from the cell).\\n\\n**E.g.:** From the cell \\'1\\' we can only go left or right.\\n\\n![image.png](https://assets.leetcode.com/users/images/d660f0e6-6167-48f6-92e9-1644f0eb47d1_1688573510.0240421.png)\\n\\n\\nMoreover, we can\\'t just arrive into **any** the neighboring cell `y` by following the exits from the current cell `x`, because `y`\\'s entrance should be aligned with the used `x`\\'s exit (aka we only have a limited set of allowed enters into the cell).\\n\\n**E.g.:** Going right from cell 4 we can come into cell 5, but we can\\'t come to cell 6.\\n\\n![image.png](https://assets.leetcode.com/users/images/ad8e9dce-ef25-4f19-ab28-145a2e4f0078_1688573856.7739303.png)\\n\\nAlso, during our traversal we can\\'t enter into the cycle from outside the cycle (because each cell kind has only to enters/exits both of which should already be used be the cycle neighbors). But we can start from the cell inside the cycle. So, remembering the visited cells may come handy in order not enter the infinite loop.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  \\nWorst time complexity example grid (and its traversal):\\n\\n![image.png](https://assets.leetcode.com/users/images/a5cfb716-6df5-4e41-9b39-c1c4e0ac132d_1688574424.0544958.png)\\n\\n# Code\\n```csharp\\npublic class Solution\\n{\\n\\tstatic readonly int[] Up = { -1, 0 };\\n\\tstatic readonly int[] Down = { 1, 0 };\\n\\tstatic readonly int[] Left = { 0, -1 };\\n\\tstatic readonly int[] Right = { 0, 1 };\\n\\n\\tstatic readonly int[] UpLandingZones = { 2, 3, 4 };\\n\\tstatic readonly int[] DownLandingZones = { 2, 5, 6 };\\n\\tstatic readonly int[] LeftLandingZones = { 1, 4, 6 };\\n\\tstatic readonly int[] RightLandingZones = { 1, 3, 5 };\\n\\n\\t// cellKind => [ (direction, validLandingCellKinds) ]\\n\\tstatic readonly (int[], int[])[][] Transitions = {\\n\\t\\tnull,\\n\\t\\tnew[]{ (Left, LeftLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Down, DownLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Right, RightLandingZones) },\\n\\t};\\n\\n\\tpublic bool HasValidPath(int[][] grid)\\n\\t{\\n\\t\\tint m = grid.Length, n = grid[0].Length;\\n\\t\\tvar visited = new bool[m, n];\\n\\n\\t\\treturn dfs(0, 0);\\n\\n\\t\\tbool dfs(int row, int col)\\n\\t\\t{\\n\\t\\t\\tif (row == m - 1 && col == n - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvisited[row, col] = true;\\n\\t\\t\\t\\n\\t\\t\\tforeach (var (dir, landingZones) in Transitions[grid[row][col]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar nextRow = row + dir[0];\\n\\t\\t\\t\\tvar nextCol = col + dir[1];\\n\\n\\t\\t\\t\\tif (0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n\\n\\t\\t\\t\\t\\t&& !visited[nextRow, nextCol]\\n\\t\\t\\t\\t\\t&& landingZones.Contains(grid[nextRow][nextCol]))\\n\\t\\t\\t\\t{\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (dfs(nextRow, nextCol))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n\\tstatic readonly int[] Up = { -1, 0 };\\n\\tstatic readonly int[] Down = { 1, 0 };\\n\\tstatic readonly int[] Left = { 0, -1 };\\n\\tstatic readonly int[] Right = { 0, 1 };\\n\\n\\tstatic readonly int[] UpLandingZones = { 2, 3, 4 };\\n\\tstatic readonly int[] DownLandingZones = { 2, 5, 6 };\\n\\tstatic readonly int[] LeftLandingZones = { 1, 4, 6 };\\n\\tstatic readonly int[] RightLandingZones = { 1, 3, 5 };\\n\\n\\t// cellKind => [ (direction, validLandingCellKinds) ]\\n\\tstatic readonly (int[], int[])[][] Transitions = {\\n\\t\\tnull,\\n\\t\\tnew[]{ (Left, LeftLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Down, DownLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Right, RightLandingZones) },\\n\\t};\\n\\n\\tpublic bool HasValidPath(int[][] grid)\\n\\t{\\n\\t\\tint m = grid.Length, n = grid[0].Length;\\n\\t\\tvar visited = new bool[m, n];\\n\\n\\t\\treturn dfs(0, 0);\\n\\n\\t\\tbool dfs(int row, int col)\\n\\t\\t{\\n\\t\\t\\tif (row == m - 1 && col == n - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvisited[row, col] = true;\\n\\t\\t\\t\\n\\t\\t\\tforeach (var (dir, landingZones) in Transitions[grid[row][col]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar nextRow = row + dir[0];\\n\\t\\t\\t\\tvar nextCol = col + dir[1];\\n\\n\\t\\t\\t\\tif (0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n\\n\\t\\t\\t\\t\\t&& !visited[nextRow, nextCol]\\n\\t\\t\\t\\t\\t&& landingZones.Contains(grid[nextRow][nextCol]))\\n\\t\\t\\t\\t{\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (dfs(nextRow, nextCol))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705359,
                "title": "easy-line-line-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        // 1->r3, l4, r5 l6\\n        // 2->u3, d5, d6, u4\\n        // 3 ->l1, d2, l4, d5, d6\\n        // 4->r1, r3, d2, d5, d6;\\n        // 5->l1, u2, u3, u4, l6\\n        // 6-> r1, u2, u3, u4, r5\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        queue<pair<int, int>> qq;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        vis[0][0]=1;\\n        qq.push({0, 0});\\n        while (!qq.empty())\\n        {\\n            int xx = qq.front().first;\\n            int yy = qq.front().second;\\n            if (xx == n - 1 && yy == m - 1)\\n            {\\n                return true;\\n            }\\n            qq.pop();\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nr = xx + drow[i];\\n                int nc = yy + dcol[i];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < m&&vis[nr][nc]==0)\\n                {\\n                    if (i == 0)\\n                    { // up\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4||grid[nr][nc]==2)\\n                            {    vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {\\n                                vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        // 1->r3, l4, r5 l6\\n                        // 2->u3, d5, d6, u4\\n                        // 3 ->l1, d2, l4, d5, d6\\n                        // 4->r1, r3, d2, d5, d6;\\n                        // 5->l1, u2, u3, u4, l6\\n                        // 6-> r1, u2, u3, u4, r5\\n                    }\\n                    else if (i == 1)\\n                    { // right\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 5||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {   \\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 1||grid[nr][nc]==5)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 1||grid[nr][nc]==3)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    else if (i == 2)\\n                    { // down\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        { // 1->r3, l4, r5 l6\\n                          // 2->u3, d5, d6, u4\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6||grid[nr][nc]==2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n\\n                            } // 3 ->l1, d2, l4, d5, d6\\n                              // 4->r1, r3, d2, d5, d6;\\n                              // 5->l1, u2, u3, u4, l6\\n                            // 6-> r1, u2, u3, u4, r5\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n\\n                    // 1->r3, l4, r5 l6\\n                    // 2->u3, d5, d6, u4\\n                    // 3 ->l1, d2, l4, d5, d6\\n                    // 4->r1, r3, d2, d5, d6;\\n                    // 5->l1, u2, u3, u4, l6\\n                    // 6-> r1, u2, u3, u4, r5\\n                    else if (i == 3)\\n                    { // left\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 6||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 1||grid[nr][nc]==6)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 1 || grid[nr][nc] == 6||grid[nr][nc]==4)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        // 1->r3, l4, r5 l6\\n        // 2->u3, d5, d6, u4\\n        // 3 ->l1, d2, l4, d5, d6\\n        // 4->r1, r3, d2, d5, d6;\\n        // 5->l1, u2, u3, u4, l6\\n        // 6-> r1, u2, u3, u4, r5\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        queue<pair<int, int>> qq;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        vis[0][0]=1;\\n        qq.push({0, 0});\\n        while (!qq.empty())\\n        {\\n            int xx = qq.front().first;\\n            int yy = qq.front().second;\\n            if (xx == n - 1 && yy == m - 1)\\n            {\\n                return true;\\n            }\\n            qq.pop();\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nr = xx + drow[i];\\n                int nc = yy + dcol[i];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < m&&vis[nr][nc]==0)\\n                {\\n                    if (i == 0)\\n                    { // up\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4||grid[nr][nc]==2)\\n                            {    vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {\\n                                vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        // 1->r3, l4, r5 l6\\n                        // 2->u3, d5, d6, u4\\n                        // 3 ->l1, d2, l4, d5, d6\\n                        // 4->r1, r3, d2, d5, d6;\\n                        // 5->l1, u2, u3, u4, l6\\n                        // 6-> r1, u2, u3, u4, r5\\n                    }\\n                    else if (i == 1)\\n                    { // right\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 5||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {   \\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 1||grid[nr][nc]==5)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 1||grid[nr][nc]==3)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    else if (i == 2)\\n                    { // down\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        { // 1->r3, l4, r5 l6\\n                          // 2->u3, d5, d6, u4\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6||grid[nr][nc]==2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n\\n                            } // 3 ->l1, d2, l4, d5, d6\\n                              // 4->r1, r3, d2, d5, d6;\\n                              // 5->l1, u2, u3, u4, l6\\n                            // 6-> r1, u2, u3, u4, r5\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n\\n                    // 1->r3, l4, r5 l6\\n                    // 2->u3, d5, d6, u4\\n                    // 3 ->l1, d2, l4, d5, d6\\n                    // 4->r1, r3, d2, d5, d6;\\n                    // 5->l1, u2, u3, u4, l6\\n                    // 6-> r1, u2, u3, u4, r5\\n                    else if (i == 3)\\n                    { // left\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 6||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 1||grid[nr][nc]==6)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 1 || grid[nr][nc] == 6||grid[nr][nc]==4)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703440,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar hasValidPath = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const connectMap = { left: \\'right\\', right: \\'left\\', upper: \\'lower\\', lower: \\'upper\\' };\\n    const moreMap = {\\n        left: { row: 0, col: -1 }, \\n        right: { row: 0, col: 1 },  \\n        upper: { row: -1, col: 0 }, \\n        lower: { row: 1, col: 0 }, \\n    };\\n    const streetMap = {\\n        1: [\\'left\\', \\'right\\'],\\n        2: [\\'upper\\', \\'lower\\'],\\n        3: [\\'left\\', \\'lower\\'],\\n        4: [\\'lower\\', \\'right\\'],\\n        5: [\\'left\\', \\'upper\\'],\\n        6: [\\'upper\\', \\'right\\'],\\n    };\\n    const isValidPath = (row, col, connect, visited = new Set()) => {\\n        if (row >= m || col >= n || row < 0 || col < 0) return false;\\n        if (visited.has(`${row}_${col}`)) return false;\\n        const street = streetMap[grid[row][col]];\\n        const startStreet = street.indexOf(connect);\\n        const isConnect = startStreet > -1;\\n        if (!isConnect) return false;\\n        if (row === m - 1 && col === n - 1) return true;\\n\\n        const endStreet = startStreet ? street[0] : street[1];\\n        const move = moreMap[endStreet];\\n        const nextConnect = connectMap[endStreet];\\n\\n        visited.add(`${row}_${col}`);\\n        return isValidPath(row + move.row, col + move.col, nextConnect, visited);\\n    };\\n    const [directionA, directionB] = streetMap[grid[0][0]];\\n\\n    return isValidPath(0, 0, directionA) || isValidPath(0, 0, directionB);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasValidPath = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const connectMap = { left: \\'right\\', right: \\'left\\', upper: \\'lower\\', lower: \\'upper\\' };\\n    const moreMap = {\\n        left: { row: 0, col: -1 }, \\n        right: { row: 0, col: 1 },  \\n        upper: { row: -1, col: 0 }, \\n        lower: { row: 1, col: 0 }, \\n    };\\n    const streetMap = {\\n        1: [\\'left\\', \\'right\\'],\\n        2: [\\'upper\\', \\'lower\\'],\\n        3: [\\'left\\', \\'lower\\'],\\n        4: [\\'lower\\', \\'right\\'],\\n        5: [\\'left\\', \\'upper\\'],\\n        6: [\\'upper\\', \\'right\\'],\\n    };\\n    const isValidPath = (row, col, connect, visited = new Set()) => {\\n        if (row >= m || col >= n || row < 0 || col < 0) return false;\\n        if (visited.has(`${row}_${col}`)) return false;\\n        const street = streetMap[grid[row][col]];\\n        const startStreet = street.indexOf(connect);\\n        const isConnect = startStreet > -1;\\n        if (!isConnect) return false;\\n        if (row === m - 1 && col === n - 1) return true;\\n\\n        const endStreet = startStreet ? street[0] : street[1];\\n        const move = moreMap[endStreet];\\n        const nextConnect = connectMap[endStreet];\\n\\n        visited.add(`${row}_${col}`);\\n        return isValidPath(row + move.row, col + move.col, nextConnect, visited);\\n    };\\n    const [directionA, directionB] = streetMap[grid[0][0]];\\n\\n    return isValidPath(0, 0, directionA) || isValidPath(0, 0, directionB);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683045,
                "title": "c-iterative",
                "content": "# Intuition\\nBecause there aren\\'t crossroads in this task we can move straingforward along the road there is a iterative solution.\\n\\n# Approach\\nFor easier reading I put position offsets, that depends on the road type in a vector `roads`.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nnamespace {\\nstruct V {\\n    int x{}, y{};\\n    bool operator==(const V& rhs) const {\\n        return rhs.x == x && rhs.y == y;\\n    }\\n    V operator+(const V& rhs) const {\\n        return V{x + rhs.x, y + rhs.y};\\n    }\\n};\\nconst vector<pair<V, V>> roads = {\\n    {{-1, 0}, {1, 0}},\\n    {{0, -1}, {0, 1}},\\n    {{-1, 0}, {0, 1}},\\n    {{1, 0}, {0, 1}},\\n    {{-1, 0}, {0, -1}},\\n    {{0, -1}, {1, 0}},\\n};\\n}\\n\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        if (grid.size() == 1 && grid[0].size() == 1)\\n            return true;\\n        const auto& t = roads[grid[0][0] - 1];\\n        return trackPath(grid, t.first) || trackPath(grid, t.second);\\n    }\\n\\nprivate:\\n    bool trackPath(vector<vector<int>>& grid, V c) {\\n        V p;  // previous position; start from (0, 0)\\n        while (c.x != grid[0].size() - 1 || c.y != grid.size() - 1) {\\n            // returned to the start - found a loop\\n            if (c.x == 0 && c.y == 0)\\n                return false;\\n            // moved from the field\\n            if (c.x < 0 || c.y < 0 || c.x >= grid[0].size() || c.y >= grid.size())\\n                return false;\\n\\n            const auto& t = roads[grid[c.y][c.x] - 1];\\n            if (p == c + t.first) {\\n                // from first to second\\n                p = exchange(c, c + t.second);\\n            } else if (p == c + t.second) {\\n                // from second to first\\n                p = exchange(c, c + t.first);\\n            } else {\\n                // meet incorrect road configuration\\n                return false;\\n            }\\n        }\\n\\n        const auto& t = roads[grid[c.y][c.x] - 1];\\n        return t.first + c == p || t.second + c == p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnamespace {\\nstruct V {\\n    int x{}, y{};\\n    bool operator==(const V& rhs) const {\\n        return rhs.x == x && rhs.y == y;\\n    }\\n    V operator+(const V& rhs) const {\\n        return V{x + rhs.x, y + rhs.y};\\n    }\\n};\\nconst vector<pair<V, V>> roads = {\\n    {{-1, 0}, {1, 0}},\\n    {{0, -1}, {0, 1}},\\n    {{-1, 0}, {0, 1}},\\n    {{1, 0}, {0, 1}},\\n    {{-1, 0}, {0, -1}},\\n    {{0, -1}, {1, 0}},\\n};\\n}\\n\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        if (grid.size() == 1 && grid[0].size() == 1)\\n            return true;\\n        const auto& t = roads[grid[0][0] - 1];\\n        return trackPath(grid, t.first) || trackPath(grid, t.second);\\n    }\\n\\nprivate:\\n    bool trackPath(vector<vector<int>>& grid, V c) {\\n        V p;  // previous position; start from (0, 0)\\n        while (c.x != grid[0].size() - 1 || c.y != grid.size() - 1) {\\n            // returned to the start - found a loop\\n            if (c.x == 0 && c.y == 0)\\n                return false;\\n            // moved from the field\\n            if (c.x < 0 || c.y < 0 || c.x >= grid[0].size() || c.y >= grid.size())\\n                return false;\\n\\n            const auto& t = roads[grid[c.y][c.x] - 1];\\n            if (p == c + t.first) {\\n                // from first to second\\n                p = exchange(c, c + t.second);\\n            } else if (p == c + t.second) {\\n                // from second to first\\n                p = exchange(c, c + t.first);\\n            } else {\\n                // meet incorrect road configuration\\n                return false;\\n            }\\n        }\\n\\n        const auto& t = roads[grid[c.y][c.x] - 1];\\n        return t.first + c == p || t.second + c == p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682239,
                "title": "very-brute-method-simple-implementation-of-basic-dfs-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,set<pair<int,int>>> m;\\n    int n,mm;\\n    bool dfs(vector<vector<int>>& v, int r, int c, vector<vector<int>>&vis){\\n        vis[r][c]=1;\\n        if(r==n-1 && c==mm-1) return true;\\n        // vector<int> temp=m[v[r][c]];\\n        for(auto i:m[v[r][c]]){\\n            int nr=r+i.first;\\n            int nc=c+i.second;\\n            if(nr>=0 && nc>=0 && nr<n && nc<mm && vis[nr][nc]==0 && m[v[nr][nc]].find({-1*i.first,-1*i.second})!=m[v[nr][nc]].end()){\\n                /* in this checking if current node has right than its child must have left and so on */\\n                if(dfs(v,nr,nc,vis)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m[1]={{0,-1},{0,1}};\\n        m[2]={{-1,0},{1,0}};\\n        m[3]={{0,-1},{1,0}};\\n        m[4]={{0,1},{1,0}};\\n        m[5]={{0,-1},{-1,0}};\\n        m[6]={{0,1},{-1,0}};\\n        n=grid.size();\\n        mm=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(mm,0));\\n        return dfs(grid,0,0,vis);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,set<pair<int,int>>> m;\\n    int n,mm;\\n    bool dfs(vector<vector<int>>& v, int r, int c, vector<vector<int>>&vis){\\n        vis[r][c]=1;\\n        if(r==n-1 && c==mm-1) return true;\\n        // vector<int> temp=m[v[r][c]];\\n        for(auto i:m[v[r][c]]){\\n            int nr=r+i.first;\\n            int nc=c+i.second;\\n            if(nr>=0 && nc>=0 && nr<n && nc<mm && vis[nr][nc]==0 && m[v[nr][nc]].find({-1*i.first,-1*i.second})!=m[v[nr][nc]].end()){\\n                /* in this checking if current node has right than its child must have left and so on */\\n                if(dfs(v,nr,nc,vis)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m[1]={{0,-1},{0,1}};\\n        m[2]={{-1,0},{1,0}};\\n        m[3]={{0,-1},{1,0}};\\n        m[4]={{0,1},{1,0}};\\n        m[5]={{0,-1},{-1,0}};\\n        m[6]={{0,1},{-1,0}};\\n        n=grid.size();\\n        mm=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(mm,0));\\n        return dfs(grid,0,0,vis);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676946,
                "title": "bfs-python-solution",
                "content": "# Approach\\nWe have taken entry and exit coordinates for each direction given in the question as shown below.\\n```\\ndirections={1:[(0,-1),(0,1)],\\n            2:[(1,0),(-1,0)],\\n            3:[(0,-1),(1,0)],\\n            4:[(0,1),(1,0)],\\n            5:[(0,-1),(-1,0)],\\n            6:[(0,1),(-1,0)]}\\n```\\nTo explain the above directions let me take an example.\\n![image.png](https://assets.leetcode.com/users/images/93eed343-f352-433a-bd89-8a6be083e0f8_1687605830.341373.png)\\n\\n```\\n1:[ Entrypoint->(0,-1),exitpoint->(0,1) ]\\n\\nlets say, street 1 grid position is (x,y)\\nyou can enter into steet-1 (x,y) from grid position (x,y-1) ie.,(x+0,y-1)\\nand to exit from street-1 (x,y) to (x,y+1) ie., (x+0,y+1)\\n```\\n**We can exit from one street and enter other street only when they are connected.**\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        rows,cols=len(grid),len(grid[0])\\n        directions={1:[(0,-1),(0,1)],2:[(1,0),(-1,0)],3:[(0,-1),(1,0)],\\n                    4:[(0,1),(1,0)],5:[(0,-1),(-1,0)],6:[(0,1),(-1,0)]}\\n        queue=deque()\\n        visit=set()\\n        queue.append((0,0))\\n        visit.add((0,0))\\n        while queue:\\n            x,y=queue.popleft()\\n            if x==rows-1 and y==cols-1:\\n                return True\\n            for dx,dy in directions[grid[x][y]]:\\n                newx=x+dx\\n                newy=y+dy\\n                if 0<=newx<rows and 0<=newy<cols and (newx,newy) not in visit:\\n                    #Checking whether two streets are connected or not\\n                    #If connected append (newx,newy) to the queue\\n                    if (-dx,-dy) in directions[grid[newx][newy]]:\\n                        queue.append((newx,newy))\\n                        visit.add((newx,newy))\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndirections={1:[(0,-1),(0,1)],\\n            2:[(1,0),(-1,0)],\\n            3:[(0,-1),(1,0)],\\n            4:[(0,1),(1,0)],\\n            5:[(0,-1),(-1,0)],\\n            6:[(0,1),(-1,0)]}\\n```\n```\\n1:[ Entrypoint->(0,-1),exitpoint->(0,1) ]\\n\\nlets say, street 1 grid position is (x,y)\\nyou can enter into steet-1 (x,y) from grid position (x,y-1) ie.,(x+0,y-1)\\nand to exit from street-1 (x,y) to (x,y+1) ie., (x+0,y+1)\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        rows,cols=len(grid),len(grid[0])\\n        directions={1:[(0,-1),(0,1)],2:[(1,0),(-1,0)],3:[(0,-1),(1,0)],\\n                    4:[(0,1),(1,0)],5:[(0,-1),(-1,0)],6:[(0,1),(-1,0)]}\\n        queue=deque()\\n        visit=set()\\n        queue.append((0,0))\\n        visit.add((0,0))\\n        while queue:\\n            x,y=queue.popleft()\\n            if x==rows-1 and y==cols-1:\\n                return True\\n            for dx,dy in directions[grid[x][y]]:\\n                newx=x+dx\\n                newy=y+dy\\n                if 0<=newx<rows and 0<=newy<cols and (newx,newy) not in visit:\\n                    #Checking whether two streets are connected or not\\n                    #If connected append (newx,newy) to the queue\\n                    if (-dx,-dy) in directions[grid[newx][newy]]:\\n                        queue.append((newx,newy))\\n                        visit.add((newx,newy))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669998,
                "title": "93-faster-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        def left(x,y, vis):\\n            if 0<= y and (x,y) not in vis and grid[x][y] in (1,4,6):\\n                return True\\n            return False\\n\\n        def right(x,y, vis):\\n            if y < n and (x, y) not in vis and grid[x][y] in (1,3,5):\\n                return True\\n            return False\\n\\n        def up(x,y, vis):\\n            if 0<= x and (x, y) not in vis and grid[x][y] in (3,4,2):\\n                return True\\n            return False\\n        \\n        def down(x,y, vis):\\n            if x < m and (x,y) not in vis and grid[x][y] in (5,6,2):\\n                return True\\n            return False\\n\\n\\n        def dfs(i, j, visit):\\n            if i == m -1 and j == n-1:\\n                return True\\n            \\n            visit.add((i,j))\\n            if grid[i][j] == 1:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 2:\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 3:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n            elif grid[i][j] ==4:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if down(i+1,j, visit) and dfs(i+1,j, visit):\\n                    return True\\n            elif grid[i][j] == 5:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n            elif grid[i][j] ==6:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if up(i-1, j , visit) and dfs(i-1, j, visit):\\n                    return True\\n            return False\\n            \\n        \\n\\n        return dfs(0,0, set())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        def left(x,y, vis):\\n            if 0<= y and (x,y) not in vis and grid[x][y] in (1,4,6):\\n                return True\\n            return False\\n\\n        def right(x,y, vis):\\n            if y < n and (x, y) not in vis and grid[x][y] in (1,3,5):\\n                return True\\n            return False\\n\\n        def up(x,y, vis):\\n            if 0<= x and (x, y) not in vis and grid[x][y] in (3,4,2):\\n                return True\\n            return False\\n        \\n        def down(x,y, vis):\\n            if x < m and (x,y) not in vis and grid[x][y] in (5,6,2):\\n                return True\\n            return False\\n\\n\\n        def dfs(i, j, visit):\\n            if i == m -1 and j == n-1:\\n                return True\\n            \\n            visit.add((i,j))\\n            if grid[i][j] == 1:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 2:\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 3:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n            elif grid[i][j] ==4:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if down(i+1,j, visit) and dfs(i+1,j, visit):\\n                    return True\\n            elif grid[i][j] == 5:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n            elif grid[i][j] ==6:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if up(i-1, j , visit) and dfs(i-1, j, visit):\\n                    return True\\n            return False\\n            \\n        \\n\\n        return dfs(0,0, set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652084,
                "title": "easy-solution-java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M,N;\\n    static int[][] dirs = {{-1,0},{0,-1},{1,0},{0,1}};\\n    static Map<Integer,int[][]> rulesMap = new HashMap<>();\\n    static {\\n        int[][] fs = {{0,-1,1,4,6},{0,1,1,3,5}};\\n        rulesMap.put(1, fs);\\n        fs = new int[][]{{-1,0,2,3,4},{1,0,2,5,6}};\\n        rulesMap.put(2,fs);\\n        fs = new int[][]{{0,-1,1,4,6},{1,0,2,5,6}};\\n        rulesMap.put(3,fs);\\n        fs = new int[][]{{1,0, 2,5,6}, {0,1,1,3,5}};\\n        rulesMap.put(4,fs);\\n        fs = new int[][]{{-1,0,2,3,4},{0,-1,1,4,6}};\\n        rulesMap.put(5,fs);\\n        fs = new int[][]{{-1,0,2,3,4}, {0,1,1,3,5}};\\n        rulesMap.put(6,fs);\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            if(curr[0]==M-1 && curr[1]==N-1)\\n            return true;\\n            for(int[] dir : dirs) {\\n                int x = dir[0]+curr[0];\\n                int y = dir[1]+curr[1];\\n                if(isValid(x,y) && !visited[x][y]) {\\n                    int rl = grid[curr[0]][curr[1]];\\n                    int[][] rules = rulesMap.get(rl);\\n                    boolean flag = false;\\n                    for(int[] rule : rules) {\\n                        if(dir[0]==rule[0] && dir[1]==rule[1]) {\\n                            for(int i=2; i<rule.length; i++) {\\n                                if(grid[x][y]==rule[i]) {\\n                                    q.add(new int[]{x,y});\\n                                    visited[x][y] = true;\\n                                    flag= true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(flag)\\n                        break;\\n                    }\\n                 }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean isValid(int i, int j) {\\n        if(i<0 || j<0 || i>=M || j>=N)\\n        return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int M,N;\\n    static int[][] dirs = {{-1,0},{0,-1},{1,0},{0,1}};\\n    static Map<Integer,int[][]> rulesMap = new HashMap<>();\\n    static {\\n        int[][] fs = {{0,-1,1,4,6},{0,1,1,3,5}};\\n        rulesMap.put(1, fs);\\n        fs = new int[][]{{-1,0,2,3,4},{1,0,2,5,6}};\\n        rulesMap.put(2,fs);\\n        fs = new int[][]{{0,-1,1,4,6},{1,0,2,5,6}};\\n        rulesMap.put(3,fs);\\n        fs = new int[][]{{1,0, 2,5,6}, {0,1,1,3,5}};\\n        rulesMap.put(4,fs);\\n        fs = new int[][]{{-1,0,2,3,4},{0,-1,1,4,6}};\\n        rulesMap.put(5,fs);\\n        fs = new int[][]{{-1,0,2,3,4}, {0,1,1,3,5}};\\n        rulesMap.put(6,fs);\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            if(curr[0]==M-1 && curr[1]==N-1)\\n            return true;\\n            for(int[] dir : dirs) {\\n                int x = dir[0]+curr[0];\\n                int y = dir[1]+curr[1];\\n                if(isValid(x,y) && !visited[x][y]) {\\n                    int rl = grid[curr[0]][curr[1]];\\n                    int[][] rules = rulesMap.get(rl);\\n                    boolean flag = false;\\n                    for(int[] rule : rules) {\\n                        if(dir[0]==rule[0] && dir[1]==rule[1]) {\\n                            for(int i=2; i<rule.length; i++) {\\n                                if(grid[x][y]==rule[i]) {\\n                                    q.add(new int[]{x,y});\\n                                    visited[x][y] = true;\\n                                    flag= true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(flag)\\n                        break;\\n                    }\\n                 }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean isValid(int i, int j) {\\n        if(i<0 || j<0 || i>=M || j>=N)\\n        return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644539,
                "title": "follow-the-route-until-you-can",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        ## edges bottom 0, left 1, top 2, right 3\\n        street_cons = [(-1, -1), (1, 3), (0, 2), (0, 1), (0, 3), (1, 2), (2, 3)]\\n        dirs = [(1, 0), (0, -1), (-1, 0), (0, 1)]\\n\\n        m, n = len(grid), len(grid[0])\\n        if m==1 and n==1:\\n            return True\\n\\n        def next_cell(pos, side):\\n            i, j = pos\\n            a, b = street_cons[grid[i][j]]\\n            if a == side:\\n                out = b\\n            elif b == side:\\n                out = a\\n            else:\\n                return  -1, -1\\n            \\n            di, dj = dirs[out]\\n            i, j = i+di, j+dj\\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) == (0, 0):\\n                return -1, -1\\n            return (i, j), (out + 2) % 4\\n\\n        \\n        for side in street_cons[grid[0][0]]:\\n            pos, side = next_cell((0, 0), side)\\n            while side != -1 and pos != (m-1, n-1):\\n                pos, side = next_cell(pos, side)\\n            if pos == (m-1, n-1) and (side in street_cons[grid[-1][-1]]):\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        ## edges bottom 0, left 1, top 2, right 3\\n        street_cons = [(-1, -1), (1, 3), (0, 2), (0, 1), (0, 3), (1, 2), (2, 3)]\\n        dirs = [(1, 0), (0, -1), (-1, 0), (0, 1)]\\n\\n        m, n = len(grid), len(grid[0])\\n        if m==1 and n==1:\\n            return True\\n\\n        def next_cell(pos, side):\\n            i, j = pos\\n            a, b = street_cons[grid[i][j]]\\n            if a == side:\\n                out = b\\n            elif b == side:\\n                out = a\\n            else:\\n                return  -1, -1\\n            \\n            di, dj = dirs[out]\\n            i, j = i+di, j+dj\\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) == (0, 0):\\n                return -1, -1\\n            return (i, j), (out + 2) % 4\\n\\n        \\n        for side in street_cons[grid[0][0]]:\\n            pos, side = next_cell((0, 0), side)\\n            while side != -1 and pos != (m-1, n-1):\\n                pos, side = next_cell(pos, side)\\n            if pos == (m-1, n-1) and (side in street_cons[grid[-1][-1]]):\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619631,
                "title": "c-dfs-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); \\n\\t\\tvis[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ \\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 or y<0 or x>=m or y>= n or vis[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ \\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvis[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); \\n\\t\\tvis[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ \\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 or y<0 or x>=m or y>= n or vis[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ \\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvis[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610090,
                "title": "1391-check-if-there-is-a-valid-path-in-a-grid",
                "content": "[Java Solution BFS](https://github.com/pratham1singh/Leetcode-Solutions-In-Java/commit/3f338a1cfe54e075b71c84fec86eaf6ca68f36ef)\\n```\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600116,
                "title": "c-solution-with-explanation-clean-code-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPath is to be finded . So BFS or DFS can be used to traverse the matrix.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple , we just have to apply bfs to matrix ,hard thing is know if we can go from one cell to another or not.\\n    I\\'m using map to store if it possible to go from one type to another and in which direction.\\n\\n---\\n\\n\\nmp[type,dir]={types we cann go };\\ndirections==> 0 - left, 1 - up, 2 - right, 3 - down\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n       queue<pair<int,pair<int,int>>>qt;//store {type,{row,col}}\\n       qt.push({grid[0][0],{0,0}});\\n       vector<vector<int>>visited(m,vector<int>(n,0));//visited arr\\n       visited[0][0]=1;\\n       int drow[]={0,-1,0,1};//all possible dirn 0->left (index)\\n       int dcol[]={-1,0,1,0};\\n        map<pair<int,int>,vector<int>>mp;//map to store valid path\\n       mp[{1,0}]={1,4,6};\\n       mp[{1,2}]={1,3,5};\\n       mp[{2,1}]={2,4,3};\\n       mp[{2,3}]={2,5,6};\\n       mp[{3,0}]={4,6,1};\\n       mp[{3,3}]={5,6,2};\\n       mp[{4,3}]={5,6,2};\\n       mp[{4,2}]={3,1,5};\\n       mp[{5,0}]={1,4,6};\\n       mp[{5,1}]={2,3,4};\\n       mp[{6,1}]={2,3,4};\\n       mp[{6,2}]={3,5,1};\\n         while(!qt.empty()){\\n             auto it=qt.front();\\n             qt.pop();\\n             int type=it.first;\\n             int r=it.second.first;\\n             int c=it.second.second;\\n             for(int i=0;i<4;i++){\\n                 int nrow=r+drow[i];\\n                 int ncol=c+dcol[i];\\n                 if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && visited[nrow][ncol]==0){\\n                     int newType=grid[nrow][ncol];\\n                     vector<int>can=mp[{type,i}];\\n                    //checking if we can go there or not\\n                     auto it=find(can.begin(),can.end(),newType);\\n                     if(it !=can.end()){\\n                         visited[nrow][ncol]=1;\\n                         qt.push({newType,{nrow,ncol}});\\n                     }\\n                 }\\n             }\\n        }\\n        return visited[m-1][n-1]==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n       queue<pair<int,pair<int,int>>>qt;//store {type,{row,col}}\\n       qt.push({grid[0][0],{0,0}});\\n       vector<vector<int>>visited(m,vector<int>(n,0));//visited arr\\n       visited[0][0]=1;\\n       int drow[]={0,-1,0,1};//all possible dirn 0->left (index)\\n       int dcol[]={-1,0,1,0};\\n        map<pair<int,int>,vector<int>>mp;//map to store valid path\\n       mp[{1,0}]={1,4,6};\\n       mp[{1,2}]={1,3,5};\\n       mp[{2,1}]={2,4,3};\\n       mp[{2,3}]={2,5,6};\\n       mp[{3,0}]={4,6,1};\\n       mp[{3,3}]={5,6,2};\\n       mp[{4,3}]={5,6,2};\\n       mp[{4,2}]={3,1,5};\\n       mp[{5,0}]={1,4,6};\\n       mp[{5,1}]={2,3,4};\\n       mp[{6,1}]={2,3,4};\\n       mp[{6,2}]={3,5,1};\\n         while(!qt.empty()){\\n             auto it=qt.front();\\n             qt.pop();\\n             int type=it.first;\\n             int r=it.second.first;\\n             int c=it.second.second;\\n             for(int i=0;i<4;i++){\\n                 int nrow=r+drow[i];\\n                 int ncol=c+dcol[i];\\n                 if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && visited[nrow][ncol]==0){\\n                     int newType=grid[nrow][ncol];\\n                     vector<int>can=mp[{type,i}];\\n                    //checking if we can go there or not\\n                     auto it=find(can.begin(),can.end(),newType);\\n                     if(it !=can.end()){\\n                         visited[nrow][ncol]=1;\\n                         qt.push({newType,{nrow,ncol}});\\n                     }\\n                 }\\n             }\\n        }\\n        return visited[m-1][n-1]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588071,
                "title": "simple-c-dfs-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple dfs solution\\n\\n![image.png](https://assets.leetcode.com/users/images/c51d0872-6b43-4763-894e-aa41dcd2431c_1685681344.537065.png)\\n\\nabove image is represented as\\n[2,4,3]\\n[6,5,2]\\n\\nabove grid is converted into 3*n X 3*m matrix\\n0 1 0  0 0 0  0 0 0 \\n0 1 0  0 1 1  1 1 0 \\n0 1 0  0 1 0  0 1 0 \\n0 1 0  0 1 0  0 1 0 \\n0 1 1  1 1 0  0 1 0 \\n0 0 0  0 0 0  0 1 0 \\n\\n2-> [[0 1 0],[0 1 0],[0 1 0]]\\n4-> [[0 0 0],[0 1 1],[0 1 0]]\\nand so on\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,bool &ans,vector<vector<int>>& mat)\\n    {\\n        if(i<0||j<0||i>=mat.size()||j>=mat[0].size()||mat[i][j]==0)\\n        {\\n            return ;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //check bottom right cell centre\\n        if(i==n-2&&j==m-2)\\n        {\\n            ans=1;\\n            return;\\n        }\\n        mat[i][j]=0;\\n        \\n        dfs(i+1,j,ans,mat);\\n        dfs(i,j+1,ans,mat);\\n        dfs(i-1,j,ans,mat);\\n        dfs(i,j-1,ans,mat);\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // each cell of grid is divided into 3*3 matrix\\n        vector<vector<int>> mat(3*n,vector<int>(3*m,0));\\n        \\n        //mat\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x1=i*3;\\n                int y1=j*3;\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                    mat[x1][y1+1]=1;\\n                }\\n                else if(grid[i][j]==3)\\n                {\\n                    mat[x1+1][y1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==4)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==5)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==6)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1+2]=1;\\n                }\\n            }\\n        }\\n        //print the matrix to check it is correct or not\\n//         for(int i=0;i<mat.size();i++)\\n//         {\\n//             for(int j=0;j<mat[0].size();j++)\\n//             {\\n//                 cout<<mat[i][j]<<\" \";\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n        bool ans=0;\\n        //dfs start from 1,1 because all street pass through centre\\n        if(mat[1][1]==1)dfs(1,1,ans,mat);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,bool &ans,vector<vector<int>>& mat)\\n    {\\n        if(i<0||j<0||i>=mat.size()||j>=mat[0].size()||mat[i][j]==0)\\n        {\\n            return ;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //check bottom right cell centre\\n        if(i==n-2&&j==m-2)\\n        {\\n            ans=1;\\n            return;\\n        }\\n        mat[i][j]=0;\\n        \\n        dfs(i+1,j,ans,mat);\\n        dfs(i,j+1,ans,mat);\\n        dfs(i-1,j,ans,mat);\\n        dfs(i,j-1,ans,mat);\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // each cell of grid is divided into 3*3 matrix\\n        vector<vector<int>> mat(3*n,vector<int>(3*m,0));\\n        \\n        //mat\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x1=i*3;\\n                int y1=j*3;\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                    mat[x1][y1+1]=1;\\n                }\\n                else if(grid[i][j]==3)\\n                {\\n                    mat[x1+1][y1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==4)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==5)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==6)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1+2]=1;\\n                }\\n            }\\n        }\\n        //print the matrix to check it is correct or not\\n//         for(int i=0;i<mat.size();i++)\\n//         {\\n//             for(int j=0;j<mat[0].size();j++)\\n//             {\\n//                 cout<<mat[i][j]<<\" \";\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n        bool ans=0;\\n        //dfs start from 1,1 because all street pass through centre\\n        if(mat[1][1]==1)dfs(1,1,ans,mat);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587576,
                "title": "10-line-simple-dfs-w-less-constants-defined-above",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            1: [(0,-1),(0,1)],\\n            2: [(-1,0),(1,0)],\\n            3: [(0,-1),(1,0)],\\n            4: [(0,1),(1,0)],\\n            5: [(0,-1),(-1,0)],\\n            6: [(0,1),(-1,0)]\\n        }\\n        visited = set()\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == (len(grid)-1, len(grid[0]) - 1):\\n                return True \\n            ret = False\\n            for r, c in directions[grid[i][j]]:\\n                row, col = i+r, j+c\\n                if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]):\\n                    continue \\n                if (row, col) in visited:\\n                    continue \\n                nexx = grid[row][col]\\n                if (-r, -c) in directions[nexx]:\\n                    ret = ret or dfs(row, col)\\n            return ret\\n        return dfs(0,0)\\n```\\n\\n# Inside the recursive dfs: [See above code]\\n- We start at current cell (i, j).\\n- We add current cell to visited set() so we don\\'t revisit it.\\n- If we have reached the last cell already, we return True.\\n- If not, we fetch the two directions we can move to from here on, that we have already defined in directions.\\n- We loop through those directions and move over if:\\n        1. next (row, col) is inbound  and\\n        2. inverse of (-r, -c) is in directions of grid[row][col], i.e it is possible to even get in that cell from the direction we are trying to get in, and\\n        3. (row, col) is not already visited \\n- Now we start at first cell and move to all possible cells following the current path, returning OR of result of all those paths. If we ever get to target cell, we return True.\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            1: [(0,-1),(0,1)],\\n            2: [(-1,0),(1,0)],\\n            3: [(0,-1),(1,0)],\\n            4: [(0,1),(1,0)],\\n            5: [(0,-1),(-1,0)],\\n            6: [(0,1),(-1,0)]\\n        }\\n        visited = set()\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == (len(grid)-1, len(grid[0]) - 1):\\n                return True \\n            ret = False\\n            for r, c in directions[grid[i][j]]:\\n                row, col = i+r, j+c\\n                if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]):\\n                    continue \\n                if (row, col) in visited:\\n                    continue \\n                nexx = grid[row][col]\\n                if (-r, -c) in directions[nexx]:\\n                    ret = ret or dfs(row, col)\\n            return ret\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546663,
                "title": "go-bfs",
                "content": "\\n# Code\\n```\\nfunc hasValidPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    up, down, left, right := [2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}\\n    directions := [][2]int{up, down, left, right}\\n    validNext := map[int]map[[2]int][]int{\\n        1: {left: {1, 4, 6}, right: {1, 3, 5}},\\n        2: {up: {2, 3, 4}, down: {2, 5, 6}},\\n        3: {left: {1, 4, 6}, down: {2, 5, 6}},\\n        4: {right: {1, 3, 5}, down: {2, 5, 6}},\\n        5: {left: {1, 4, 6}, up: {2, 3, 4}},\\n        6: {right: {1, 3, 5}, up: {2, 3, 4}},\\n    }\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n    visited[0][0] = 1\\n    queue := make([][2]int, 0, 10)\\n    queue = append(queue, [2]int{0, 0})\\n    for len(queue) > 0 {\\n        x, y := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        if x == m-1 && y == n-1 {\\n            return true\\n        }\\n        curr := grid[x][y]\\n        // fmt.Println(curr)\\n        for _, dir := range directions {\\n            dx, dy := x+dir[0], y+dir[1]\\n            if dx >= 0 && dx < m && dy >= 0 && dy < n && visited[dx][dy] == 0 {\\n                // fmt.Println(curr, dir)\\n                for _, next := range validNext[curr][dir] {\\n                    // fmt.Println(curr, next)\\n                    if next == grid[dx][dy] {\\n                        queue = append(queue, [2]int{dx, dy})\\n                        visited[dx][dy] = 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hasValidPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    up, down, left, right := [2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}\\n    directions := [][2]int{up, down, left, right}\\n    validNext := map[int]map[[2]int][]int{\\n        1: {left: {1, 4, 6}, right: {1, 3, 5}},\\n        2: {up: {2, 3, 4}, down: {2, 5, 6}},\\n        3: {left: {1, 4, 6}, down: {2, 5, 6}},\\n        4: {right: {1, 3, 5}, down: {2, 5, 6}},\\n        5: {left: {1, 4, 6}, up: {2, 3, 4}},\\n        6: {right: {1, 3, 5}, up: {2, 3, 4}},\\n    }\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n    visited[0][0] = 1\\n    queue := make([][2]int, 0, 10)\\n    queue = append(queue, [2]int{0, 0})\\n    for len(queue) > 0 {\\n        x, y := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        if x == m-1 && y == n-1 {\\n            return true\\n        }\\n        curr := grid[x][y]\\n        // fmt.Println(curr)\\n        for _, dir := range directions {\\n            dx, dy := x+dir[0], y+dir[1]\\n            if dx >= 0 && dx < m && dy >= 0 && dy < n && visited[dx][dy] == 0 {\\n                // fmt.Println(curr, dir)\\n                for _, next := range validNext[curr][dir] {\\n                    // fmt.Println(curr, next)\\n                    if next == grid[dx][dy] {\\n                        queue = append(queue, [2]int{dx, dy})\\n                        visited[dx][dy] = 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536100,
                "title": "painful-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npain\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> adj(n * m);\\n        vector<int> vis(n * m, 0);\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 2) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (i > 0 && (grid[i - 1][j] == 4 || grid[i - 1][j] == 6 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                }\\n                else if (grid[i][j] == 3) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 4) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 5) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 6 || grid[i][j - 1] == 4 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 6) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n            }\\n        }\\n        q.push(0);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if (k == n * m - 1) {\\n                return true;\\n            }\\n            for (int i = 0; i < adj[k].size(); ++i) {\\n                if (!vis[adj[k][i]]) {\\n                    vis[adj[k][i]] = 1;\\n                    q.push(adj[k][i]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> adj(n * m);\\n        vector<int> vis(n * m, 0);\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 2) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (i > 0 && (grid[i - 1][j] == 4 || grid[i - 1][j] == 6 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                }\\n                else if (grid[i][j] == 3) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 4) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 5) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 6 || grid[i][j - 1] == 4 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 6) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n            }\\n        }\\n        q.push(0);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if (k == n * m - 1) {\\n                return true;\\n            }\\n            for (int i = 0; i < adj[k].size(); ++i) {\\n                if (!vis[adj[k][i]]) {\\n                    vis[adj[k][i]] = 1;\\n                    q.push(adj[k][i]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440897,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410542,
                "title": "java-16ms-beats-95-dfs-and-clear-code",
                "content": "# Approach\\n1. Starting from cell [m][n] determine if you reach [0][0] if you walk on the road described/linked by each cell\\n2. Use 4 directions to travel: UP (1), RIGHT 2, DOWN 3 and LEFT 4.\\n3. Each cell/street has two modifiers, depending of the direction in which you ENTER this cell.\\n    - if you enter a cell 6 with a LEFT orientation, then your coords modifiers will be {-1, 0} (going up by 1 row)\\n    - if you enter a cell 6 with a DOWN orientation, then your coords modifiers will be {0, 1} (going left by 1 )\\n4. Declare an array of 6 such objects, each with two modifiers, based on direction\\n5. Pay special attention to edge case of [m][n]\\n    - if cell is 4. Return false immediately\\n    - if cell if 5, you could be stepping here from cell above or cell on the right, so you need to check both\\n6. Starting from cell [m][n] step each cell and see if you reach [0][0].\\nIf you get stuck in a cell (cell 2 cannot connect to cell 1) or step outside matrix, return false.\\n7. Use a recursive function to step each connected cell. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(6)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int UP = 1, RIGHT = 2, DOWN = 3, LEFT = 4;\\n    private static StreetConnection[] streets;\\n    public boolean hasValidPath(int[][] grid) {\\n        initializeStreets();\\n        int[] location = {grid.length -1, grid[0].length -1};\\n        int cellNo = grid[location[0]][location[1]];\\n        boolean canFinish;\\n        if (cellNo == 4) {\\n            canFinish = false;\\n        } else if (cellNo == 5) {\\n            int[] cloneLoc = {location[0], location[1]};\\n            canFinish = hasValidPath(RIGHT, location, grid) || hasValidPath(DOWN, cloneLoc, grid);\\n        } else {\\n            canFinish = hasValidPath(cellNo == 1 || cellNo == 6 ? LEFT : UP, location, grid);\\n        }\\n        return canFinish;\\n    }\\n\\n    private boolean hasValidPath(int direction, int[] location, int[][] grid) {\\n        if (location[0] == 0 && location[1] == 0) {\\n            return true;\\n        }\\n        if (location[0] < 0 || location[0] >= grid.length || location[1] < 0 || location[1] >= grid[0].length) {\\n            return false;\\n        }\\n        StreetConnection currentCell = streets[grid[location[0]][location[1]]];\\n        int newDirection = currentCell.getNewCoordsAndDirection(direction, location);\\n        if (newDirection != -1) {\\n            return hasValidPath(newDirection, location, grid);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    private void initializeStreets() {\\n        if (streets == null) {\\n            streets = new StreetConnection[]{null,\\n                new StreetConnection(RIGHT, new int[]{0, 1}, LEFT, new int[]{0, -1}),\\n                new StreetConnection(UP, new int[]{-1, 0}, DOWN, new int[]{1, 0}),\\n                new StreetConnection(RIGHT, new int[]{1, 0}, UP, new int[]{0, -1}),\\n                new StreetConnection(LEFT, new int[]{1, 0}, UP, new int[]{0, 1}),\\n                new StreetConnection(DOWN, new int[]{0, -1}, RIGHT, new int[]{-1, 0}),\\n                new StreetConnection(DOWN, new int[]{0, 1}, LEFT, new int[]{-1, 0})};\\n        }\\n    }\\n\\n    private static class StreetConnection {\\n        private int direction1, direction2;\\n        private int[] coefficient1, coefficient2;\\n\\n        public StreetConnection(int d1, int[] c1, int d2, int[] c2) {\\n            this.direction1 = d1;\\n            this.coefficient1 = c1;\\n            this.direction2 = d2;\\n            this.coefficient2 = c2;\\n        }\\n\\n        public int getNewCoordsAndDirection(int direction, int[] current) {\\n            int x = current[0];\\n            int y = current[1];\\n            if (direction == direction1) {\\n                current[0] += coefficient1[0];\\n                current[1] += coefficient1[1];\\n            } else if (direction == direction2) {\\n                current[0] += coefficient2[0];\\n                current[1] += coefficient2[1];\\n            } else {\\n                return -1;\\n            }\\n            return detectChangeOfDirection(x, y, current[0], current[1]);\\n        }\\n\\n        private int detectChangeOfDirection(int oldX, int oldY, int newX, int newY) {\\n            if (oldX == newX) {\\n                return oldY < newY ? RIGHT : LEFT;\\n            } else {\\n                return oldX < newX ? DOWN : UP;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int UP = 1, RIGHT = 2, DOWN = 3, LEFT = 4;\\n    private static StreetConnection[] streets;\\n    public boolean hasValidPath(int[][] grid) {\\n        initializeStreets();\\n        int[] location = {grid.length -1, grid[0].length -1};\\n        int cellNo = grid[location[0]][location[1]];\\n        boolean canFinish;\\n        if (cellNo == 4) {\\n            canFinish = false;\\n        } else if (cellNo == 5) {\\n            int[] cloneLoc = {location[0], location[1]};\\n            canFinish = hasValidPath(RIGHT, location, grid) || hasValidPath(DOWN, cloneLoc, grid);\\n        } else {\\n            canFinish = hasValidPath(cellNo == 1 || cellNo == 6 ? LEFT : UP, location, grid);\\n        }\\n        return canFinish;\\n    }\\n\\n    private boolean hasValidPath(int direction, int[] location, int[][] grid) {\\n        if (location[0] == 0 && location[1] == 0) {\\n            return true;\\n        }\\n        if (location[0] < 0 || location[0] >= grid.length || location[1] < 0 || location[1] >= grid[0].length) {\\n            return false;\\n        }\\n        StreetConnection currentCell = streets[grid[location[0]][location[1]]];\\n        int newDirection = currentCell.getNewCoordsAndDirection(direction, location);\\n        if (newDirection != -1) {\\n            return hasValidPath(newDirection, location, grid);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    private void initializeStreets() {\\n        if (streets == null) {\\n            streets = new StreetConnection[]{null,\\n                new StreetConnection(RIGHT, new int[]{0, 1}, LEFT, new int[]{0, -1}),\\n                new StreetConnection(UP, new int[]{-1, 0}, DOWN, new int[]{1, 0}),\\n                new StreetConnection(RIGHT, new int[]{1, 0}, UP, new int[]{0, -1}),\\n                new StreetConnection(LEFT, new int[]{1, 0}, UP, new int[]{0, 1}),\\n                new StreetConnection(DOWN, new int[]{0, -1}, RIGHT, new int[]{-1, 0}),\\n                new StreetConnection(DOWN, new int[]{0, 1}, LEFT, new int[]{-1, 0})};\\n        }\\n    }\\n\\n    private static class StreetConnection {\\n        private int direction1, direction2;\\n        private int[] coefficient1, coefficient2;\\n\\n        public StreetConnection(int d1, int[] c1, int d2, int[] c2) {\\n            this.direction1 = d1;\\n            this.coefficient1 = c1;\\n            this.direction2 = d2;\\n            this.coefficient2 = c2;\\n        }\\n\\n        public int getNewCoordsAndDirection(int direction, int[] current) {\\n            int x = current[0];\\n            int y = current[1];\\n            if (direction == direction1) {\\n                current[0] += coefficient1[0];\\n                current[1] += coefficient1[1];\\n            } else if (direction == direction2) {\\n                current[0] += coefficient2[0];\\n                current[1] += coefficient2[1];\\n            } else {\\n                return -1;\\n            }\\n            return detectChangeOfDirection(x, y, current[0], current[1]);\\n        }\\n\\n        private int detectChangeOfDirection(int oldX, int oldY, int newX, int newY) {\\n            if (oldX == newX) {\\n                return oldY < newY ? RIGHT : LEFT;\\n            } else {\\n                return oldX < newX ? DOWN : UP;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398931,
                "title": "bfs-for-my-own-reference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h=[[], [1,0,1,0], [0,1,0,1], [1,0,0,1], [0,0,1,1], [1,1,0,0], [0,1,1,0]]\\n        n, m, x, y = len(grid), len(grid[0]), 0, 0\\n        def isValid(new_x, new_y):\\n            return 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] > 0\\n        q = deque([(x, y)])\\n        while q:\\n            x, y = q.popleft()\\n            left, up, right, down = h[grid[x][y]]\\n            grid[x][y] = -grid[x][y]\\n            if left:\\n                new_x, new_y = x, y - 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 3, 5] and new in [1, 4, 6]:\\n                        q.append((new_x, new_y))\\n            if up:\\n                new_x, new_y = x - 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 5, 6] and new in [2, 3, 4]:\\n                        q.append((new_x, new_y))\\n            if right:\\n                new_x, new_y = x, y + 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 4, 6] and new in [1, 3, 5]:\\n                        q.append((new_x, new_y))\\n            if down:\\n                new_x, new_y = x + 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 3, 4] and new in [2, 5, 6]:\\n                        q.append((new_x, new_y))\\n        return grid[-1][-1] < 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h=[[], [1,0,1,0], [0,1,0,1], [1,0,0,1], [0,0,1,1], [1,1,0,0], [0,1,1,0]]\\n        n, m, x, y = len(grid), len(grid[0]), 0, 0\\n        def isValid(new_x, new_y):\\n            return 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] > 0\\n        q = deque([(x, y)])\\n        while q:\\n            x, y = q.popleft()\\n            left, up, right, down = h[grid[x][y]]\\n            grid[x][y] = -grid[x][y]\\n            if left:\\n                new_x, new_y = x, y - 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 3, 5] and new in [1, 4, 6]:\\n                        q.append((new_x, new_y))\\n            if up:\\n                new_x, new_y = x - 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 5, 6] and new in [2, 3, 4]:\\n                        q.append((new_x, new_y))\\n            if right:\\n                new_x, new_y = x, y + 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 4, 6] and new in [1, 3, 5]:\\n                        q.append((new_x, new_y))\\n            if down:\\n                new_x, new_y = x + 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 3, 4] and new in [2, 5, 6]:\\n                        q.append((new_x, new_y))\\n        return grid[-1][-1] < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395182,
                "title": "python-bfs-beats-97-44",
                "content": "# Intuition\\nBreadth-first search, try to go through all possible destinations\\n\\n# Approach\\ndirection is represented by int:\\n0: left\\n1: top\\n2: right\\n3: bottom\\nwe also hard-code all kinds of streets.\\n\\nfor each pos, we first try to see if the direction we enter it is valid. after that, we get the new position after it goes through this street.\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h, w = len(grid), len(grid[0])\\n        queue = [(0,0,i) for i in range(4)]\\n        visited = set()\\n        xs = [0, -1, 0, 1]\\n        ys = [-1, 0, 1, 0]\\n        streets = [(0, 2), (1, 3), (0, 3), (2, 3), (0, 1), (1, 2)]\\n        for p in queue:\\n            if p in visited:\\n                continue\\n            x, y, side = p\\n            if x < 0 or x >= h or y < 0 or y >= w:\\n                continue\\n            # print(p)\\n            visited.add(p)\\n            s_type = streets[grid[x][y]-1]\\n            if side not in s_type:\\n                continue\\n            if x == h-1 and y == w-1:\\n                return True\\n            d = sum(s_type) - side\\n            nx, ny = x + xs[d], y + ys[d]\\n            nside = (d + 2) % 4\\n            queue.append((nx, ny, nside))\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h, w = len(grid), len(grid[0])\\n        queue = [(0,0,i) for i in range(4)]\\n        visited = set()\\n        xs = [0, -1, 0, 1]\\n        ys = [-1, 0, 1, 0]\\n        streets = [(0, 2), (1, 3), (0, 3), (2, 3), (0, 1), (1, 2)]\\n        for p in queue:\\n            if p in visited:\\n                continue\\n            x, y, side = p\\n            if x < 0 or x >= h or y < 0 or y >= w:\\n                continue\\n            # print(p)\\n            visited.add(p)\\n            s_type = streets[grid[x][y]-1]\\n            if side not in s_type:\\n                continue\\n            if x == h-1 and y == w-1:\\n                return True\\n            d = sum(s_type) - side\\n            nx, ny = x + xs[d], y + ys[d]\\n            nside = (d + 2) % 4\\n            queue.append((nx, ny, nside))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358842,
                "title": "python-dfs-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ndfs(i, j) walk to the bottom-right cell from position(i, j),\\nAt position (0, 0), we have 2 paths to go at most.\\nAt the bottom-right cell, dfs return true\\nat the rest cells (i, j), we only has 1 path to go, and should check the next cell we go have `road`,\\ne.g., we go to right, and the right cell have road at its left side.\\nWhen passing throgh the cell, we destroy the cell, so we never go back.\\ntc is O(len(grid)*len(grid[0])), sc is O(road length) = O(len(grid)*len(grid[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        streets = [\\n            [0,0,1,1], [1,1,0,0],\\n            [0,1,1,0], [0,1,0,1],\\n            [1,0,1,0], [1,0,0,1],\\n        ] # [top, bottom, left, right], 1 is road\\n        numRow, numCol = len(grid), len(grid[0])\\n        if numRow == numCol == 1: return True\\n\\n        def dfs(i, j):\\n            if i == numRow - 1 and j == numCol - 1: return True\\n            if streets[grid[i][j]-1][0] and i-1 >= 0 and grid[i-1][j] != -1 and streets[grid[i-1][j]-1][1]:\\n                grid[i][j] = -1\\n                return dfs(i-1, j)\\n            elif streets[grid[i][j]-1][1] and i+1 < numRow and grid[i+1][j] != -1 and streets[grid[i+1][j]-1][0]:\\n                grid[i][j] = -1\\n                return dfs(i+1, j) \\n            elif streets[grid[i][j]-1][2] and j-1 >= 0 and grid[i][j-1] != -1 and streets[grid[i][j-1]-1][3]:\\n                grid[i][j] = -1\\n                return dfs(i, j-1) \\n            elif streets[grid[i][j]-1][3] and j+1 < numCol and grid[i][j+1] != -1 and streets[grid[i][j+1]-1][2]:\\n                grid[i][j] = -1\\n                return dfs(i, j+1)\\n            return False\\n        tmp = grid[0][0] - 1\\n        grid[0][0] = -1\\n        \\n        if (streets[tmp][1] and 1 < numRow and streets[grid[1][0]-1][0] and dfs(1, 0)) or (streets[tmp][3] and 1 < numCol and streets[grid[0][1]-1][2] and dfs(0, 1)): return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\ndfs(i, j) walk to the bottom-right cell from position(i, j),\\nAt position (0, 0), we have 2 paths to go at most.\\nAt the bottom-right cell, dfs return true\\nat the rest cells (i, j), we only has 1 path to go, and should check the next cell we go have `road`,\\ne.g., we go to right, and the right cell have road at its left side.\\nWhen passing throgh the cell, we destroy the cell, so we never go back.\\ntc is O(len(grid)*len(grid[0])), sc is O(road length) = O(len(grid)*len(grid[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        streets = [\\n            [0,0,1,1], [1,1,0,0],\\n            [0,1,1,0], [0,1,0,1],\\n            [1,0,1,0], [1,0,0,1],\\n        ] # [top, bottom, left, right], 1 is road\\n        numRow, numCol = len(grid), len(grid[0])\\n        if numRow == numCol == 1: return True\\n\\n        def dfs(i, j):\\n            if i == numRow - 1 and j == numCol - 1: return True\\n            if streets[grid[i][j]-1][0] and i-1 >= 0 and grid[i-1][j] != -1 and streets[grid[i-1][j]-1][1]:\\n                grid[i][j] = -1\\n                return dfs(i-1, j)\\n            elif streets[grid[i][j]-1][1] and i+1 < numRow and grid[i+1][j] != -1 and streets[grid[i+1][j]-1][0]:\\n                grid[i][j] = -1\\n                return dfs(i+1, j) \\n            elif streets[grid[i][j]-1][2] and j-1 >= 0 and grid[i][j-1] != -1 and streets[grid[i][j-1]-1][3]:\\n                grid[i][j] = -1\\n                return dfs(i, j-1) \\n            elif streets[grid[i][j]-1][3] and j+1 < numCol and grid[i][j+1] != -1 and streets[grid[i][j+1]-1][2]:\\n                grid[i][j] = -1\\n                return dfs(i, j+1)\\n            return False\\n        tmp = grid[0][0] - 1\\n        grid[0][0] = -1\\n        \\n        if (streets[tmp][1] and 1 < numRow and streets[grid[1][0]-1][0] and dfs(1, 0)) or (streets[tmp][3] and 1 < numCol and streets[grid[0][1]-1][2] and dfs(0, 1)): return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355896,
                "title": "c-simple-simulation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    enum { _N = 0, _E, _S, _W };\\n\\n    vector<vector<int>> grid;\\n\\n    bool check(int dir)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int rules[6][4] = {\\n            /* N   E   S   W */\\n            { -1, _E, -1, _W },\\n            { _N, -1, _S, -1 },\\n\\n            { _W, _S, -1, -1 },\\n            { _E, -1, -1, _S },\\n\\n            { -1, _N, _W, -1 },\\n            { -1, -1, _E, _N },\\n        };\\n\\n        int dx[] = { 0, 1, 0, -1 };\\n        int dy[] = { -1, 0, 1, 0 };\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        set<pair<int, int>> visited;\\n\\n        while (true)\\n        {\\n            if (x < 0 || x >= n || y < 0 || y >= m)\\n                return false;\\n\\n            if (visited.count({ x, y }))\\n                return false;\\n\\n            visited.insert({ x,y });\\n\\n            dir = rules[grid[y][x] - 1][dir];\\n\\n            if (dir == -1)\\n                return false;\\n\\n            if (x == n - 1 && y == m - 1)\\n                return true;\\n\\n            x += dx[dir];\\n            y += dy[dir];\\n        }\\n\\n        throw;\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n        this->grid = grid;\\n\\n        switch (grid[0][0])\\n        {\\n        case 1: return check(_E);\\n        case 2: return check(_S);\\n        case 3: return check(_E);\\n        case 4: return check(_N) || check(_W);\\n        case 5: return false;\\n        case 6: return check(_S);\\n        default: throw;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    enum { _N = 0, _E, _S, _W };\\n\\n    vector<vector<int>> grid;\\n\\n    bool check(int dir)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int rules[6][4] = {\\n            /* N   E   S   W */\\n            { -1, _E, -1, _W },\\n            { _N, -1, _S, -1 },\\n\\n            { _W, _S, -1, -1 },\\n            { _E, -1, -1, _S },\\n\\n            { -1, _N, _W, -1 },\\n            { -1, -1, _E, _N },\\n        };\\n\\n        int dx[] = { 0, 1, 0, -1 };\\n        int dy[] = { -1, 0, 1, 0 };\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        set<pair<int, int>> visited;\\n\\n        while (true)\\n        {\\n            if (x < 0 || x >= n || y < 0 || y >= m)\\n                return false;\\n\\n            if (visited.count({ x, y }))\\n                return false;\\n\\n            visited.insert({ x,y });\\n\\n            dir = rules[grid[y][x] - 1][dir];\\n\\n            if (dir == -1)\\n                return false;\\n\\n            if (x == n - 1 && y == m - 1)\\n                return true;\\n\\n            x += dx[dir];\\n            y += dy[dir];\\n        }\\n\\n        throw;\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n        this->grid = grid;\\n\\n        switch (grid[0][0])\\n        {\\n        case 1: return check(_E);\\n        case 2: return check(_S);\\n        case 3: return check(_E);\\n        case 4: return check(_N) || check(_W);\\n        case 5: return false;\\n        case 6: return check(_S);\\n        default: throw;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349178,
                "title": "largest-code-on-leetcode-i-think-so",
                "content": "# Complexity\\n- Time complexity:\\nO(N*m)\\n\\n- Space complexity:\\nO(N*m)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\n    bool fun(int x, int y, int xn, int yn, vector<vector<int>> &grid, int dirX, int dirY)\\n    {\\n        if (grid[x][y] == 1)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 2)\\n        {\\n            if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 6 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 3)\\n        {\\n            if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 4)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 5)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 6)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        queue<vector<int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n\\n        q.push({0, 0});\\n        vis[0][0] = 1;\\n\\n\\n        int dirX[4] = {1, 0, -1, 0};\\n        int dirY[4] = {0, 1, 0, -1};\\n\\n\\n        while (q.size())\\n        {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            q.pop();\\n\\n\\n            if (x == n - 1 && y == m - 1)\\n            {\\n                return true;\\n            }\\n\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int xn = x + dirX[k];\\n                int yn = y + dirY[k];\\n\\n\\n                if (xn >= 0 && yn >= 0 && xn < n && yn < m && vis[xn][yn] == 0)\\n                {\\n                    if (fun(x, y, xn, yn, grid, dirX[k], dirY[k]))\\n                    {\\n                        q.push({xn, yn});\\n                        vis[xn][yn] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\n    bool fun(int x, int y, int xn, int yn, vector<vector<int>> &grid, int dirX, int dirY)\\n    {\\n        if (grid[x][y] == 1)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 2)\\n        {\\n            if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 6 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 3)\\n        {\\n            if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 4)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 5)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 6)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        queue<vector<int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n\\n        q.push({0, 0});\\n        vis[0][0] = 1;\\n\\n\\n        int dirX[4] = {1, 0, -1, 0};\\n        int dirY[4] = {0, 1, 0, -1};\\n\\n\\n        while (q.size())\\n        {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            q.pop();\\n\\n\\n            if (x == n - 1 && y == m - 1)\\n            {\\n                return true;\\n            }\\n\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int xn = x + dirX[k];\\n                int yn = y + dirY[k];\\n\\n\\n                if (xn >= 0 && yn >= 0 && xn < n && yn < m && vis[xn][yn] == 0)\\n                {\\n                    if (fun(x, y, xn, yn, grid, dirX[k], dirY[k]))\\n                    {\\n                        q.push({xn, yn});\\n                        vis[xn][yn] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3344938,
                "title": "huh-better-not-write-this-in-interview",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Move{\\n    int[] valid;\\n    int row;\\n    int col;\\n    public Move(int[] valid, int row, int col){\\n        this.valid = valid;\\n        this.row = row;\\n        this.col = col;\\n    }\\n\\n    public String toString(){\\n        return (row + \" \" + col);\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n\\n        Move[][] dirs = new Move[7][2];\\n        dirs[1][0] = new Move(new int[]{4,6,1}, 0, -1);\\n        dirs[1][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[2][0] = new Move(new int[]{6,5,2}, 1, 0);\\n        dirs[2][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        dirs[3][0] = new Move(new int[]{1, 4, 6}, 0, -1);\\n        dirs[3][1] = new Move(new int[]{5, 6, 2}, 1, 0);\\n        \\n        dirs[4][0] = new Move(new int[]{6, 5, 2}, 1, 0);\\n        dirs[4][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[5][0] = new Move(new int[]{6,4,1}, 0, -1);\\n        dirs[5][1] = new Move(new int[]{3,4,2}, -1, 0);\\n\\n        dirs[6][0] = new Move(new int[]{3,5,1}, 0, 1);\\n        dirs[6][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        return helper(dirs, grid, 0, 0, new HashSet<Integer>(), new int[]{1,2,3,4,5,6});\\n\\n    }\\n\\n    private boolean helper(Move[][] dirs, int[][] grid, int r, int c,HashSet<Integer> visited, int[] valid_moves){\\n        if (r<0 || r>=grid.length || c<0 || c>=grid[0].length) return false;\\n\\n        int index = getIndex(r, c, grid);\\n        if (visited.contains(index)) return false;\\n\\n        boolean isValid = false;\\n        for(int valid_move : valid_moves){\\n            if (grid[r][c] == valid_move) {\\n                isValid = true;\\n                break;\\n            }\\n        }\\n        if (!isValid) return false;\\n\\n        if (r == grid.length-1 && c == grid[0].length -1) return true;\\n\\n        visited.add(index);\\n\\n        for(Move move : dirs[grid[r][c]]){\\n            int next_r = move.row;\\n            int next_c = move.col;\\n            int valid[] = move.valid;\\n            if (helper(dirs, grid, next_r + r, next_c + c, visited, valid)) return true;\\n        }\\n        visited.remove(index);\\n        return false;\\n\\n    }\\n\\n    private int getIndex(int r, int c, int[][] grid){\\n        return (r*grid[0].length + c);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Move{\\n    int[] valid;\\n    int row;\\n    int col;\\n    public Move(int[] valid, int row, int col){\\n        this.valid = valid;\\n        this.row = row;\\n        this.col = col;\\n    }\\n\\n    public String toString(){\\n        return (row + \" \" + col);\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n\\n        Move[][] dirs = new Move[7][2];\\n        dirs[1][0] = new Move(new int[]{4,6,1}, 0, -1);\\n        dirs[1][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[2][0] = new Move(new int[]{6,5,2}, 1, 0);\\n        dirs[2][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        dirs[3][0] = new Move(new int[]{1, 4, 6}, 0, -1);\\n        dirs[3][1] = new Move(new int[]{5, 6, 2}, 1, 0);\\n        \\n        dirs[4][0] = new Move(new int[]{6, 5, 2}, 1, 0);\\n        dirs[4][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[5][0] = new Move(new int[]{6,4,1}, 0, -1);\\n        dirs[5][1] = new Move(new int[]{3,4,2}, -1, 0);\\n\\n        dirs[6][0] = new Move(new int[]{3,5,1}, 0, 1);\\n        dirs[6][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        return helper(dirs, grid, 0, 0, new HashSet<Integer>(), new int[]{1,2,3,4,5,6});\\n\\n    }\\n\\n    private boolean helper(Move[][] dirs, int[][] grid, int r, int c,HashSet<Integer> visited, int[] valid_moves){\\n        if (r<0 || r>=grid.length || c<0 || c>=grid[0].length) return false;\\n\\n        int index = getIndex(r, c, grid);\\n        if (visited.contains(index)) return false;\\n\\n        boolean isValid = false;\\n        for(int valid_move : valid_moves){\\n            if (grid[r][c] == valid_move) {\\n                isValid = true;\\n                break;\\n            }\\n        }\\n        if (!isValid) return false;\\n\\n        if (r == grid.length-1 && c == grid[0].length -1) return true;\\n\\n        visited.add(index);\\n\\n        for(Move move : dirs[grid[r][c]]){\\n            int next_r = move.row;\\n            int next_c = move.col;\\n            int valid[] = move.valid;\\n            if (helper(dirs, grid, next_r + r, next_c + c, visited, valid)) return true;\\n        }\\n        visited.remove(index);\\n        return false;\\n\\n    }\\n\\n    private int getIndex(int r, int c, int[][] grid){\\n        return (r*grid[0].length + c);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338334,
                "title": "recursive-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int[] dr = new int[]{-1,1,0,0};\\n    int[] dc = new int[]{0,0,1,-1};\\n\\n\\n    public HashMap<Integer,List<String>> generatePathConfig() {\\n        HashMap<Integer,List<String>> pathConfig = new HashMap<>();\\n        List<String> path = new ArrayList<>();\\n        path.add(\"R\");\\n        path.add(\"L\");\\n        pathConfig.put(1,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"D\");\\n        path.add(\"U\");\\n        pathConfig.put(2,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"RD\");\\n        path.add(\"UL\");      \\n        pathConfig.put(3,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"LD\");\\n        path.add(\"UR\");\\n        pathConfig.put(4,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"RU\");\\n        path.add(\"DL\");\\n        pathConfig.put(5,new ArrayList<String>(path));\\n        path.clear();\\n\\n        \\n\\n        path.add(\"LU\");\\n        path.add(\"DR\");\\n        pathConfig.put(6,new ArrayList<String>(path));\\n        path.clear();\\n\\n        return pathConfig;\\n    }\\n\\n    public boolean isValid(int i, int j, int[][] grid) {\\n        return i>=0 && i < grid.length && j>=0 && j<grid[0].length;\\n    }\\n\\n    public boolean solve(int i, int j, String pathSoFar,int[][] grid,boolean[][] visited,HashMap<Integer,List<String>> pathConfig) {\\n        if (i == grid.length-1 && j == grid[0].length - 1) \\n        return true;\\n\\n        if (isValid(i,j,grid))\\n        visited[i][j] = true;\\n\\n        boolean answer = false;\\n        for (int k=0;k<4;k++) {\\n            int adjR = i + dr[k];\\n            int adjC = j + dc[k];\\n            if (isValid(adjR,adjC,grid) && !visited[adjR][adjC]) {\\n                int val = grid[adjR][adjC];\\n                List<String> pathsAvailable = pathConfig.get(val);\\n                for (String path: pathsAvailable) {\\n                    char lastChar = \\'#\\';\\n                    if (pathSoFar.length() > 0)\\n                    lastChar = pathSoFar.charAt(pathSoFar.length()-1);\\n                    if (lastChar == \\'#\\') {\\n                        answer |= solve(adjR,adjC,pathSoFar+path,grid,visited,pathConfig);\\n                    } else {\\n                        switch(lastChar) {\\n                            case \\'U\\':\\n                                if (adjR == i - 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'R\\':\\n                                if (adjR == i && adjC == j + 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'D\\':\\n                                if (adjR == i + 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'L\\':\\n                                if (adjR == i  && adjC == j - 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n\\n\\n    public boolean hasValidPath(int[][] grid) {\\n      boolean[][] visited = new boolean[grid.length][grid[0].length];\\n      HashMap<Integer,List<String>> pathConfig = generatePathConfig();\\n      return solve(0,-1,\"\",grid,visited,pathConfig);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] dr = new int[]{-1,1,0,0};\\n    int[] dc = new int[]{0,0,1,-1};\\n\\n\\n    public HashMap<Integer,List<String>> generatePathConfig() {\\n        HashMap<Integer,List<String>> pathConfig = new HashMap<>();\\n        List<String> path = new ArrayList<>();\\n        path.add(\"R\");\\n        path.add(\"L\");\\n        pathConfig.put(1,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"D\");\\n        path.add(\"U\");\\n        pathConfig.put(2,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"RD\");\\n        path.add(\"UL\");      \\n        pathConfig.put(3,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"LD\");\\n        path.add(\"UR\");\\n        pathConfig.put(4,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"RU\");\\n        path.add(\"DL\");\\n        pathConfig.put(5,new ArrayList<String>(path));\\n        path.clear();\\n\\n        \\n\\n        path.add(\"LU\");\\n        path.add(\"DR\");\\n        pathConfig.put(6,new ArrayList<String>(path));\\n        path.clear();\\n\\n        return pathConfig;\\n    }\\n\\n    public boolean isValid(int i, int j, int[][] grid) {\\n        return i>=0 && i < grid.length && j>=0 && j<grid[0].length;\\n    }\\n\\n    public boolean solve(int i, int j, String pathSoFar,int[][] grid,boolean[][] visited,HashMap<Integer,List<String>> pathConfig) {\\n        if (i == grid.length-1 && j == grid[0].length - 1) \\n        return true;\\n\\n        if (isValid(i,j,grid))\\n        visited[i][j] = true;\\n\\n        boolean answer = false;\\n        for (int k=0;k<4;k++) {\\n            int adjR = i + dr[k];\\n            int adjC = j + dc[k];\\n            if (isValid(adjR,adjC,grid) && !visited[adjR][adjC]) {\\n                int val = grid[adjR][adjC];\\n                List<String> pathsAvailable = pathConfig.get(val);\\n                for (String path: pathsAvailable) {\\n                    char lastChar = \\'#\\';\\n                    if (pathSoFar.length() > 0)\\n                    lastChar = pathSoFar.charAt(pathSoFar.length()-1);\\n                    if (lastChar == \\'#\\') {\\n                        answer |= solve(adjR,adjC,pathSoFar+path,grid,visited,pathConfig);\\n                    } else {\\n                        switch(lastChar) {\\n                            case \\'U\\':\\n                                if (adjR == i - 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'R\\':\\n                                if (adjR == i && adjC == j + 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'D\\':\\n                                if (adjR == i + 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'L\\':\\n                                if (adjR == i  && adjC == j - 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n\\n\\n    public boolean hasValidPath(int[][] grid) {\\n      boolean[][] visited = new boolean[grid.length][grid[0].length];\\n      HashMap<Integer,List<String>> pathConfig = generatePathConfig();\\n      return solve(0,-1,\"\",grid,visited,pathConfig);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334818,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<int>>& grid,vector<vector<int>>&vis,int i,int j){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or vis[i][j]==1){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        vis[i][j]=1;\\n        int a=grid[i][j];\\n        if(a==2){\\n    if(isvalid(i+1,j,n,m)){  // check right direction instead of down\\n        int a=grid[i+1][j];\\n        if(a==2 or a==5 or a==6){\\n            bool b=solve(grid,vis,i+1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n    if(isvalid(i-1,j,n,m)){  // check left direction instead of up\\n        int a=grid[i-1][j];\\n        if(a==2 or a==3 or a==4){\\n            bool b=solve(grid,vis,i-1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n}\\n\\n        if(a==1){\\n            if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==6 or a==4){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==3){\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==4){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==5){\\n             if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==3 or a==4){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==6){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==4 or a==3){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return solve(grid,vis,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<int>>& grid,vector<vector<int>>&vis,int i,int j){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or vis[i][j]==1){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        vis[i][j]=1;\\n        int a=grid[i][j];\\n        if(a==2){\\n    if(isvalid(i+1,j,n,m)){  // check right direction instead of down\\n        int a=grid[i+1][j];\\n        if(a==2 or a==5 or a==6){\\n            bool b=solve(grid,vis,i+1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n    if(isvalid(i-1,j,n,m)){  // check left direction instead of up\\n        int a=grid[i-1][j];\\n        if(a==2 or a==3 or a==4){\\n            bool b=solve(grid,vis,i-1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n}\\n\\n        if(a==1){\\n            if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==6 or a==4){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==3){\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==4){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==5){\\n             if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==3 or a==4){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==6){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==4 or a==3){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return solve(grid,vis,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220737,
                "title": "simple-solution-using-bfs-intuitive-solution",
                "content": "Observation:\\n\\n1  :  Can connect only to adj left and right.\\n2  :  Can connect only to adj up and down.\\n3  :  Can connect only to adj left and down.\\n4  :  Can connect only to adj down and right.\\n5  :  Can connect only to adj up and left.\\n6  :  Can connect only to adj right and up.\\n\\n\\nCode :\\n\\nclass Solution {\\n\\nprivate:\\n    bool isValid(int r, int c, int n, int m, vector<vector<int>> &vis){\\n        return r<n && c<m && r>=0 && c>=0 && !vis[r][c];\\n    }\\n\\t\\n    bool isSafe(int left, int rgt, int up, int down, int nr, int nc, int r, int c, vector<vector<int>>& grid){\\n    if(left == 1 && nc == c-1){\\n        return grid[nr][nc] == 1 || grid[nr][nc] == 4 || grid[nr][nc] == 6;\\n    }\\n    else if(rgt == 1 && nc == c+1){\\n        return grid[nr][nc] == 1 || grid[nr][nc] == 3 || grid[nr][nc] == 5;\\n    }\\n    else if(up == 1 && nr == r-1){\\n        return grid[nr][nc] == 2 || grid[nr][nc] == 3 || grid[nr][nc] == 4;\\n    }\\n    else if(down == 1 && nr == r+1){\\n        return grid[nr][nc] == 2 || grid[nr][nc] == 5 || grid[nr][nc] == 6;\\n    }\\n    return false;\\n}\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0)); \\n        queue<pair<int, pair<int, int>>> q;\\n        q.push({grid[0][0], {0, 0}});\\n        vis[0][0] = 1;\\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            \\n            if(row == n-1 && col == m-1) return true;\\n            \\n            int left = 0, rgt = 0, up = 0, down = 0;\\n            \\n            if(val == 1){\\n                left = rgt = 1;\\n            }\\n            else if(val == 2){\\n                up = down = 1;\\n            }\\n            else if(val == 3){\\n                left = down = 1;\\n            }\\n            else if(val == 4){\\n                rgt = down = 1;\\n            }\\n            else if(val == 5){\\n                left = up = 1;\\n            }\\n            else {\\n                up = rgt = 1;\\n            }\\n            \\n            for(int ind = 0; ind<4; ind++){\\n                int nr = row + dx[ind];\\n                int nc = col + dy[ind];\\n                \\n                if(isValid(nr, nc, n, m, vis)){\\n                    if(isSafe(left, rgt, up, down, nr, nc, row, col, grid)){ \\n                        q.push({grid[nr][nc], {nr, nc}});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\t\\n\\t\\n\\t\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\nprivate:\\n    bool isValid(int r, int c, int n, int m, vector<vector<int>> &vis){\\n        return r<n && c<m && r>=0 && c>=0 && !vis[r][c];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3177953,
                "title": "javascript-dfs-solution",
                "content": "This is a pretty standard DFS solution. The tricky part here is to figure where we come from and where we go next. This is solved by adding the opposite to `dirs` map. Every time we traverse to the next street, we check if streets[nextStreet] includes the direction we are coming from.\\n\\n```\\nconst hasValidPath = grid => {\\n    const streets = {\\n        1: [\\'l\\', \\'r\\'],\\n        2: [\\'u\\', \\'d\\'],\\n        3: [\\'l\\', \\'d\\'],\\n        4: [\\'d\\', \\'r\\'],\\n        5: [\\'l\\', \\'u\\'],\\n        6: [\\'u\\', \\'r\\']\\n    }\\n    \\n    const dirs = {\\n        u: [-1, 0, \\'d\\'],\\n        d: [1, 0, \\'u\\'],\\n        l: [0, -1, \\'r\\'],\\n        r: [0, 1, \\'l\\']\\n    }\\n    \\n    const m = grid.length\\n    const n = grid[0].length\\n    const visited = new Set()\\n    \\n    const dfs = (i, j) => {\\n        if (i === m - 1 && j === n - 1) return true\\n        if (i < 0 || i > m - 1) return false\\n        if (j < 0 || j > n - 1) return false\\n        const key = `${i}-${j}`\\n        if (visited.has(key)) return false\\n        visited.add(key)\\n        \\n        const street = grid[i][j]\\n        const paths = streets[street]\\n        for (const path of paths) {\\n            const [ni, nj, nFrom] = dirs[path]\\n            const nextI = i + ni\\n            const nextJ = j + nj\\n            const nextStreet = grid[nextI]?.[nextJ]\\n            \\n            if (streets[nextStreet]?.includes?.(nFrom)) {\\n                if (dfs(i + ni, j + nj)) return true\\n            }\\n        }\\n        return false\\n    }\\n    \\n    return dfs(0, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst hasValidPath = grid => {\\n    const streets = {\\n        1: [\\'l\\', \\'r\\'],\\n        2: [\\'u\\', \\'d\\'],\\n        3: [\\'l\\', \\'d\\'],\\n        4: [\\'d\\', \\'r\\'],\\n        5: [\\'l\\', \\'u\\'],\\n        6: [\\'u\\', \\'r\\']\\n    }\\n    \\n    const dirs = {\\n        u: [-1, 0, \\'d\\'],\\n        d: [1, 0, \\'u\\'],\\n        l: [0, -1, \\'r\\'],\\n        r: [0, 1, \\'l\\']\\n    }\\n    \\n    const m = grid.length\\n    const n = grid[0].length\\n    const visited = new Set()\\n    \\n    const dfs = (i, j) => {\\n        if (i === m - 1 && j === n - 1) return true\\n        if (i < 0 || i > m - 1) return false\\n        if (j < 0 || j > n - 1) return false\\n        const key = `${i}-${j}`\\n        if (visited.has(key)) return false\\n        visited.add(key)\\n        \\n        const street = grid[i][j]\\n        const paths = streets[street]\\n        for (const path of paths) {\\n            const [ni, nj, nFrom] = dirs[path]\\n            const nextI = i + ni\\n            const nextJ = j + nj\\n            const nextStreet = grid[nextI]?.[nextJ]\\n            \\n            if (streets[nextStreet]?.includes?.(nFrom)) {\\n                if (dfs(i + ni, j + nj)) return true\\n            }\\n        }\\n        return false\\n    }\\n    \\n    return dfs(0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174504,
                "title": "javascript-solution-bfs-matrix-time-space-o-n-m-with-explanation",
                "content": "# Intuition\\nBreadth First Search and Matrix Traversal.\\n\\n# Approach\\n\\nCheck neighbors\\nCheck if neighbor can reach your cell\\nMark as visited\\npush into queue\\n\\n# Complexity\\n- Time complexity:\\nO(n * m) for rows * columns\\n\\n- Space complexity:\\nO(n * m) for rows * columns for visited array\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n// Breadth-First-Search, Matrix Traversal\\n// Time and Space: O(m * n)...rows * columns\\nvar hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n// Breadth-First-Search, Matrix Traversal\\n// Time and Space: O(m * n)...rows * columns\\nvar hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173421,
                "title": "python-union-find-approach",
                "content": "# Intuition\\nWe can traverse the grid and connect cells on the right and on the bottom of the current: \\n1. If current cell is 1, 4 or 6 (has road on the right) then it could be connected to the right cell having road on the left (1, 3 or 5)\\n2. If current cell is 2, 3 or 4 (has road on the bottom) then it could be connected to the bottom cell having road on the left (2, 5 or 6)\\n\\nWe can connect cells using Union-Find, and then check whether top-left and bottom-right cells pertain to the same cluster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        p, rank = [[(i, j) for j in range(m)] for i in range(n)], [[1 for _ in range(m)] for _ in range(n)]\\n\\n        def get(i, j):\\n            while p[i][j] != (i, j):\\n                i, j = p[i][j]\\n            return i, j\\n\\n        def connect(i1, j1, i2, j2):\\n            i1, j1 = get(i1, j1)\\n            i2, j2 = get(i2, j2)\\n            if rank[i1][j1] >= rank[i2][j2]:\\n                p[i2][j2] = p[i1][j1]\\n                rank[i1][j1] += 1\\n            else:\\n                p[i1][j1] = p[i2][j2]\\n                rank[i2][j2] += 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] in [1, 4, 6] and j+1 < m and grid[i][j+1] in [1, 3, 5]:\\n                    connect(i, j, i, j+1)\\n                if grid[i][j] in [2, 3, 4] and i+1 < n and grid[i+1][j] in [2, 5, 6]:\\n                    connect(i, j, i+1, j)\\n\\n        return get(0, 0) == get(n-1, m-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        p, rank = [[(i, j) for j in range(m)] for i in range(n)], [[1 for _ in range(m)] for _ in range(n)]\\n\\n        def get(i, j):\\n            while p[i][j] != (i, j):\\n                i, j = p[i][j]\\n            return i, j\\n\\n        def connect(i1, j1, i2, j2):\\n            i1, j1 = get(i1, j1)\\n            i2, j2 = get(i2, j2)\\n            if rank[i1][j1] >= rank[i2][j2]:\\n                p[i2][j2] = p[i1][j1]\\n                rank[i1][j1] += 1\\n            else:\\n                p[i1][j1] = p[i2][j2]\\n                rank[i2][j2] += 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] in [1, 4, 6] and j+1 < m and grid[i][j+1] in [1, 3, 5]:\\n                    connect(i, j, i, j+1)\\n                if grid[i][j] in [2, 3, 4] and i+1 < n and grid[i+1][j] in [2, 5, 6]:\\n                    connect(i, j, i+1, j)\\n\\n        return get(0, 0) == get(n-1, m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137498,
                "title": "standard-union-find-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    int[] parent;\\n    int[] sz;\\n\\n    public bool HasValidPath(int[][] grid) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n\\n        if (n == 1 && m == 1) return true;\\n\\n        parent = new int[n * m];\\n        sz = new int[n * m];\\n\\n        for (var i = 0; i < n * m; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n        \\n        for (var i = 0; i < n; i++) {\\n            for (var j = 0; j < m; j++) {\\n                var road = grid[i][j];\\n\\n                // left\\n                if (j > 0 && (road == 1 || road == 3 || road == 5)) {\\n                    var road2 = grid[i][j - 1];\\n\\n                    if (road2 == 1 || road2 == 4 || road2 == 6) {\\n                        Union(i * m + j, i * m + j - 1);\\n                    }\\n                }\\n\\n                // up\\n                if (i > 0 && (road == 2 || road == 5 || road == 6)) {\\n                    var road2 = grid[i - 1][j];\\n\\n                    if (road2 == 2 || road2 == 3 || road2 == 4) {\\n                        Union(i * m + j, (i - 1) * m + j);\\n                    }\\n                }\\n\\n                // right\\n                if (j < m - 1 && (road == 1 || road == 4 || road == 6)) {\\n                    var road2 = grid[i][j + 1];\\n\\n                    if (road2 == 1 || road2 == 3 || road2 == 5) {\\n                        Union(i * m + j, i * m + j + 1);\\n                    }\\n                }\\n\\n                // down\\n                if (i < n - 1 && (road == 2 || road == 3 || road == 4)) {\\n                    var road2 = grid[i + 1][j];\\n\\n                    if (road2 == 2 || road2 == 5 || road2 == 6) {\\n                        Union(i * m + j, (i + 1) * m + j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return Find(0) == Find(n * m - 1);\\n    }\\n\\n    private int Find(int a) {\\n        while (a != parent[a]) {\\n            a = parent[a];\\n            parent[a] = parent[parent[a]];\\n        }\\n\\n        return a;\\n    }\\n\\n    private void Union(int a, int b) {\\n        var root_a = Find(a);\\n        var root_b = Find(b);\\n        if (root_a == root_b) return;\\n\\n        if (sz[root_a] < sz[root_b])  {\\n            parent[root_a] = root_b;\\n            sz[root_b] += sz[root_a];\\n        } else {\\n            parent[root_b] = root_a;\\n            sz[root_a] += sz[root_b];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] parent;\\n    int[] sz;\\n\\n    public bool HasValidPath(int[][] grid) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n\\n        if (n == 1 && m == 1) return true;\\n\\n        parent = new int[n * m];\\n        sz = new int[n * m];\\n\\n        for (var i = 0; i < n * m; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n        \\n        for (var i = 0; i < n; i++) {\\n            for (var j = 0; j < m; j++) {\\n                var road = grid[i][j];\\n\\n                // left\\n                if (j > 0 && (road == 1 || road == 3 || road == 5)) {\\n                    var road2 = grid[i][j - 1];\\n\\n                    if (road2 == 1 || road2 == 4 || road2 == 6) {\\n                        Union(i * m + j, i * m + j - 1);\\n                    }\\n                }\\n\\n                // up\\n                if (i > 0 && (road == 2 || road == 5 || road == 6)) {\\n                    var road2 = grid[i - 1][j];\\n\\n                    if (road2 == 2 || road2 == 3 || road2 == 4) {\\n                        Union(i * m + j, (i - 1) * m + j);\\n                    }\\n                }\\n\\n                // right\\n                if (j < m - 1 && (road == 1 || road == 4 || road == 6)) {\\n                    var road2 = grid[i][j + 1];\\n\\n                    if (road2 == 1 || road2 == 3 || road2 == 5) {\\n                        Union(i * m + j, i * m + j + 1);\\n                    }\\n                }\\n\\n                // down\\n                if (i < n - 1 && (road == 2 || road == 3 || road == 4)) {\\n                    var road2 = grid[i + 1][j];\\n\\n                    if (road2 == 2 || road2 == 5 || road2 == 6) {\\n                        Union(i * m + j, (i + 1) * m + j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return Find(0) == Find(n * m - 1);\\n    }\\n\\n    private int Find(int a) {\\n        while (a != parent[a]) {\\n            a = parent[a];\\n            parent[a] = parent[parent[a]];\\n        }\\n\\n        return a;\\n    }\\n\\n    private void Union(int a, int b) {\\n        var root_a = Find(a);\\n        var root_b = Find(b);\\n        if (root_a == root_b) return;\\n\\n        if (sz[root_a] < sz[root_b])  {\\n            parent[root_a] = root_b;\\n            sz[root_b] += sz[root_a];\\n        } else {\\n            parent[root_b] = root_a;\\n            sz[root_a] += sz[root_b];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136116,
                "title": "java-very-easy-to-understand-solution-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the curr ele can reach to its parent ele then move ahead,else stop there\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) m=grid.length n=grid[0].length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\n    public boolean helper(int row,int col,int prevr,int prevc,int[][] grid,int[][][] arr,boolean[][] visited){\\n        if(row<0||row==grid.length||col<0||col==grid[0].length){\\n            return false;\\n        }\\n        if(visited[row][col]){\\n            return false;\\n        }\\n        visited[row][col]=true;\\n        if(prevr!=-1&&prevc!=-1){\\n            int[][] check=arr[grid[row][col]-1];\\n            if(row+check[0][0]==prevr&&col+check[0][1]==prevc||row+check[1][0]==prevr&&col+check[1][1]==prevc){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    return true;\\n                }\\n                else{\\n                if(row+check[0][0]==prevr&&col+check[0][1]==prevc){\\n                   return helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n                }\\n                else{\\n                  return  helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited);\\n                }\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(row==grid.length-1&&col==grid[0].length-1){\\n                return true;\\n            }\\n            int[][] check=arr[grid[row][col]-1];\\n            return helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited)||helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n        }\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] arr={{{0,-1},{0,1}},\\n                        {{-1,0},{1,0}},\\n                        {{0,-1},{1,0}},\\n                        {{0,1},{1,0}},\\n                        {{-1,0},{0,-1}},\\n                        {{-1,0},{0,1}}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        return helper(0,0,-1,-1,grid,arr,visited);\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean helper(int row,int col,int prevr,int prevc,int[][] grid,int[][][] arr,boolean[][] visited){\\n        if(row<0||row==grid.length||col<0||col==grid[0].length){\\n            return false;\\n        }\\n        if(visited[row][col]){\\n            return false;\\n        }\\n        visited[row][col]=true;\\n        if(prevr!=-1&&prevc!=-1){\\n            int[][] check=arr[grid[row][col]-1];\\n            if(row+check[0][0]==prevr&&col+check[0][1]==prevc||row+check[1][0]==prevr&&col+check[1][1]==prevc){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    return true;\\n                }\\n                else{\\n                if(row+check[0][0]==prevr&&col+check[0][1]==prevc){\\n                   return helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n                }\\n                else{\\n                  return  helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited);\\n                }\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(row==grid.length-1&&col==grid[0].length-1){\\n                return true;\\n            }\\n            int[][] check=arr[grid[row][col]-1];\\n            return helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited)||helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n        }\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] arr={{{0,-1},{0,1}},\\n                        {{-1,0},{1,0}},\\n                        {{0,-1},{1,0}},\\n                        {{0,1},{1,0}},\\n                        {{-1,0},{0,-1}},\\n                        {{-1,0},{0,1}}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        return helper(0,0,-1,-1,grid,arr,visited);\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123173,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    bool good(int i, int j, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        int n = g.size(), m = g[0].size();\\n        if(i >= 0 && i < n && j >= 0 && j < m && !vis[i][j]) return true;\\n        return false;\\n    }\\n    bool dfs(int i, int j, int n, int m, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        if(i == n - 1 && j == m - 1) return true;\\n        vis[i][j] = 1;\\n\\n        if(g[i][j] == 1) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 4 || g[i][j - 1] == 6 || g[i][j - 1] == 1) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 2) {\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 5 || g[i + 1][j] == 6 || g[i + 1][j] == 2) \\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 3) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 4) {\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 1 || g[i][j + 1] == 3 || g[i][j + 1] == 5) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 5) {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n        }\\n        else {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        return dfs(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int i, int j, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        int n = g.size(), m = g[0].size();\\n        if(i >= 0 && i < n && j >= 0 && j < m && !vis[i][j]) return true;\\n        return false;\\n    }\\n    bool dfs(int i, int j, int n, int m, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        if(i == n - 1 && j == m - 1) return true;\\n        vis[i][j] = 1;\\n\\n        if(g[i][j] == 1) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 4 || g[i][j - 1] == 6 || g[i][j - 1] == 1) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 2) {\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 5 || g[i + 1][j] == 6 || g[i + 1][j] == 2) \\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 3) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 4) {\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 1 || g[i][j + 1] == 3 || g[i][j + 1] == 5) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 5) {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n        }\\n        else {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        return dfs(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091770,
                "title": "python-video-walkthrough-6-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/gnt9ym9IV-g)\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        up, down, left, right, grid[0][0], queue = {x: set([2,3,4]) for x in [2,5,6]}, {x: set([2,5,6]) for x in [2,3,4]}, {x: set([1,4,6]) for x in [1,3,5]}, {x: set([1,3,5]) for x in [1,4,6]}, -grid[0][0], deque([(0,0)])\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == len(grid) - 1 and j == len(grid[0]) -1: return True\\n            for k, l, d in filter(lambda a:  0 <= a[0] < len(grid) and 0 <= a[1] < len(grid[0]) and  -grid[i][j] in a[2] and grid[a[0]][a[1]] in a[2][-grid[i][j]] , [(i-1,j, up),(i+1,j, down),(i,j-1, left),(i,j+1, right)] ): grid[k][l], _ = -grid[k][l], queue.append((k,l))\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        up, down, left, right, grid[0][0], queue = {x: set([2,3,4]) for x in [2,5,6]}, {x: set([2,5,6]) for x in [2,3,4]}, {x: set([1,4,6]) for x in [1,3,5]}, {x: set([1,3,5]) for x in [1,4,6]}, -grid[0][0], deque([(0,0)])\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == len(grid) - 1 and j == len(grid[0]) -1: return True\\n            for k, l, d in filter(lambda a:  0 <= a[0] < len(grid) and 0 <= a[1] < len(grid[0]) and  -grid[i][j] in a[2] and grid[a[0]][a[1]] in a[2][-grid[i][j]] , [(i-1,j, up),(i+1,j, down),(i,j-1, left),(i,j+1, right)] ): grid[k][l], _ = -grid[k][l], queue.append((k,l))\\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566004,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1804771,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1573542,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 2022775,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1849547,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            }
        ]
    }
]